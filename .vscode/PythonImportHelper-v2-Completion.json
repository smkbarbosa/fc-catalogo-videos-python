[
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "src.__seedwork.domain.exceptions",
        "description": "src.__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "src.__seedwork.domain.exceptions",
        "description": "src.__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "__seedwork.domain.exceptions",
        "description": "__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "__seedwork.domain.exceptions",
        "description": "__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "__seedwork.domain.exceptions",
        "description": "__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "importPath": "__seedwork.domain.exceptions",
        "description": "__seedwork.domain.exceptions",
        "isExtraImport": true,
        "detail": "__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "importPath": "__seedwork.domain.value_objects",
        "description": "__seedwork.domain.value_objects",
        "isExtraImport": true,
        "detail": "__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "src.__seedwork.entities.entities",
        "description": "src.__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "src.__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "__seedwork.entities.entities",
        "description": "__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "__seedwork.entities.entities",
        "description": "__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "__seedwork.entities.entities",
        "description": "__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "__seedwork.entities.entities",
        "description": "__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "__seedwork.entities.entities",
        "description": "__seedwork.entities.entities",
        "isExtraImport": true,
        "detail": "__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "tzinfo",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "tzinfo",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "tzinfo",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsInt",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "isExtraImport": true,
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "Category",
        "importPath": "category.domain.entities",
        "description": "category.domain.entities",
        "isExtraImport": true,
        "detail": "category.domain.entities",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_VARARGS",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_VARKEYWORDS",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "ismethod",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isfunction",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "istraceback",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isframe",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "iscode",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getblock",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getfile",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getmodule",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getsourcefile",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "indentsize",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isbuiltin",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "iscode",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isframe",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isfunction",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "ismethod",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "ismodule",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "istraceback",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getmro",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_ITERABLE_COROUTINE",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "cleandoc",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "getcwd",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sep",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "match",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "intern",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "format_exception_only",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "UnsupportedOperation",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedIOBase",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "PurePath",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "PurePath",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "PurePosixPath",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "CodeType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "FrameType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "ModuleType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "CodeType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MethodType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GeneratorType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GetSetDescriptorType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "ClassMethodDescriptorType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "CoroutineType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GeneratorType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "ModuleType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "ref",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "WeakKeyDictionary",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "ReferenceType",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "ProxyType",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "CallableProxyType",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "attr",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "attr",
        "description": "attr",
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "pluggy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pluggy",
        "description": "pluggy",
        "detail": "pluggy",
        "documentation": {}
    },
    {
        "label": "HookspecMarker",
        "importPath": "pluggy",
        "description": "pluggy",
        "isExtraImport": true,
        "detail": "pluggy",
        "documentation": {}
    },
    {
        "label": "_pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest",
        "description": "_pytest",
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "outcomes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "outcomes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "outcomes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "timing",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "timing",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "fixtures",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "timing",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "timing",
        "importPath": "_pytest",
        "description": "_pytest",
        "isExtraImport": true,
        "detail": "_pytest",
        "documentation": {}
    },
    {
        "label": "findsource",
        "importPath": "_pytest._code.source",
        "description": "_pytest._code.source",
        "isExtraImport": true,
        "detail": "_pytest._code.source",
        "documentation": {}
    },
    {
        "label": "getrawcode",
        "importPath": "_pytest._code.source",
        "description": "_pytest._code.source",
        "isExtraImport": true,
        "detail": "_pytest._code.source",
        "documentation": {}
    },
    {
        "label": "getstatementrange_ast",
        "importPath": "_pytest._code.source",
        "description": "_pytest._code.source",
        "isExtraImport": true,
        "detail": "_pytest._code.source",
        "documentation": {}
    },
    {
        "label": "Source",
        "importPath": "_pytest._code.source",
        "description": "_pytest._code.source",
        "isExtraImport": true,
        "detail": "_pytest._code.source",
        "documentation": {}
    },
    {
        "label": "_pytest._io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "importPath": "_pytest._io",
        "description": "_pytest._io",
        "isExtraImport": true,
        "detail": "_pytest._io",
        "documentation": {}
    },
    {
        "label": "safeformat",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REPR_MAX_SIZE",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "_pformat_dispatch",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr_unlimited",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "importPath": "_pytest._io.saferepr",
        "description": "_pytest._io.saferepr",
        "isExtraImport": true,
        "detail": "_pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_func",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_getattr",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "_format_args",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "_PytestWrapper",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_func",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_method",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getfuncargnames",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getimfunc",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getlocation",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_generator",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "NOTSET",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_getattr",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "LEGACY_PATH",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "legacy_path",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "LEGACY_PATH",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "NOTSET",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "NotSetType",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "ascii_escaped",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_default_arg_names",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_func",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getimfunc",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getlocation",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_async_function",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_generator",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "LEGACY_PATH",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "NOTSET",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_getattr",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_isclass",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "STRING_TYPES",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "STRING_TYPES",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "getimfunc",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_async_function",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "_pytest.compat",
        "description": "_pytest.compat",
        "isExtraImport": true,
        "detail": "_pytest.compat",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_PERCENT_DEFAULT",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_TYPE_STR",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_TYPE_STR_CHOICE",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "YIELD_FIXTURE",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "WARNING_CMDLINE_PREPARSE_HOOK",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NODE_CTOR_FSPATH_ARG",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NOSE_SUPPORT",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "KEYWORD_MSG_ARG",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "INSTANCE_COLLECTOR",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NOSE_SUPPORT_METHOD",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "WARNS_NONE_ARG",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "importPath": "_pytest.deprecated",
        "description": "_pytest.deprecated",
        "isExtraImport": true,
        "detail": "_pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "fnmatch_ex",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "commonpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "fnmatch_ex",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "import_path",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "fnmatch_ex",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "visit",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "commonpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "copytree",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "make_numbered_dir",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "fnmatch_ex",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "import_path",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "ImportPathMismatchError",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "parts",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "visit",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "importPath": "_pytest.pathlib",
        "description": "_pytest.pathlib",
        "isExtraImport": true,
        "detail": "_pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tokenize",
        "description": "tokenize",
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "generate_tokens",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenError",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "bisect_right",
        "importPath": "bisect",
        "description": "bisect",
        "isExtraImport": true,
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "PrettyPrinter",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "reprlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "reprlib",
        "description": "reprlib",
        "detail": "reprlib",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "unicodedata",
        "description": "unicodedata",
        "isExtraImport": true,
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "with_statement",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EBADF",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ELOOP",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ENOENT",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ENOTDIR",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "_find_spec_from_path",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "find_spec",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "module_from_spec",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "posixpath",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "posixpath",
        "description": "posixpath",
        "detail": "posixpath",
        "documentation": {}
    },
    {
        "label": "sep",
        "importPath": "posixpath",
        "description": "posixpath",
        "isExtraImport": true,
        "detail": "posixpath",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "nullcontext",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stderr",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stderr",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "AbstractContextManager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "abspath",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "dirname",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "exists",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isabs",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isfile",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "islink",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "normpath",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "expanduser",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "expandvars",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isabs",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "sep",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "basename",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "exists",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "basename",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "splitext",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_ISDIR",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_ISLNK",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_ISREG",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "importlib.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.abc",
        "description": "importlib.abc",
        "detail": "importlib.abc",
        "documentation": {}
    },
    {
        "label": "importlib.machinery",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.machinery",
        "description": "importlib.machinery",
        "detail": "importlib.machinery",
        "documentation": {}
    },
    {
        "label": "EXTENSION_SUFFIXES",
        "importPath": "importlib.machinery",
        "description": "importlib.machinery",
        "isExtraImport": true,
        "detail": "importlib.machinery",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "filterfalse",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "marshal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "marshal",
        "description": "marshal",
        "detail": "marshal",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "_pytest._version",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest._version",
        "description": "_pytest._version",
        "detail": "_pytest._version",
        "documentation": {}
    },
    {
        "label": "version",
        "importPath": "_pytest._version",
        "description": "_pytest._version",
        "isExtraImport": true,
        "detail": "_pytest._version",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "_pytest.assertion",
        "description": "_pytest.assertion",
        "isExtraImport": true,
        "detail": "_pytest.assertion",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "_pytest.assertion",
        "description": "_pytest.assertion",
        "isExtraImport": true,
        "detail": "_pytest.assertion",
        "documentation": {}
    },
    {
        "label": "# noqa: F401\n    format_explanation",
        "importPath": "_pytest.assertion.util",
        "description": "_pytest.assertion.util",
        "isExtraImport": true,
        "detail": "_pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "running_on_ci",
        "importPath": "_pytest.assertion.util",
        "description": "_pytest.assertion.util",
        "isExtraImport": true,
        "detail": "_pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ConftestImportFailure",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "PytestPluginManager",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "_PluggyPlugin",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "PrintHelp",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "filename_arg",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "PytestPluginManager",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "_strtobool",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "create_terminal_writer",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "UsageError",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "directory_arg",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "PytestPluginManager",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "UsageError",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ConftestImportFailure",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "create_terminal_writer",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "_PluggyPlugin",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "PytestPluginManager",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "_PluggyPlugin",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "hookimpl",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "apply_warning_filters",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "parse_warning_filter",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "_pytest.config",
        "description": "_pytest.config",
        "isExtraImport": true,
        "detail": "_pytest.config",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "_pytest.main",
        "description": "_pytest.main",
        "isExtraImport": true,
        "detail": "_pytest.main",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "Stash",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "importPath": "_pytest.stash",
        "description": "_pytest.stash",
        "isExtraImport": true,
        "detail": "_pytest.stash",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "_check_path",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "File",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "_pytest.nodes",
        "description": "_pytest.nodes",
        "isExtraImport": true,
        "detail": "_pytest.nodes",
        "documentation": {}
    },
    {
        "label": "collections.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections.abc",
        "description": "collections.abc",
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sized",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "_pytest._code",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "getfslineno",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "getfslineno",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "Source",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "filter_traceback",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "getfslineno",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code",
        "description": "_pytest._code",
        "isExtraImport": true,
        "detail": "_pytest._code",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "gettext",
        "importPath": "gettext",
        "description": "gettext",
        "isExtraImport": true,
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "gettext",
        "importPath": "gettext",
        "description": "gettext",
        "isExtraImport": true,
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "UsageError",
        "importPath": "_pytest.config.exceptions",
        "description": "_pytest.config.exceptions",
        "isExtraImport": true,
        "detail": "_pytest.config.exceptions",
        "documentation": {}
    },
    {
        "label": "UsageError",
        "importPath": "_pytest.config.exceptions",
        "description": "_pytest.config.exceptions",
        "isExtraImport": true,
        "detail": "_pytest.config.exceptions",
        "documentation": {}
    },
    {
        "label": "iniconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "iniconfig",
        "description": "iniconfig",
        "detail": "iniconfig",
        "documentation": {}
    },
    {
        "label": "SectionWrapper",
        "importPath": "iniconfig",
        "description": "iniconfig",
        "isExtraImport": true,
        "detail": "iniconfig",
        "documentation": {}
    },
    {
        "label": "IniConfig",
        "importPath": "iniconfig",
        "description": "iniconfig",
        "isExtraImport": true,
        "detail": "iniconfig",
        "documentation": {}
    },
    {
        "label": "SectionWrapper",
        "importPath": "iniconfig",
        "description": "iniconfig",
        "isExtraImport": true,
        "detail": "iniconfig",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "OutcomeException",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "TEST_OUTCOME",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "importorskip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "Exit",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "OutcomeException",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "Skipped",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "TEST_OUTCOME",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "xfail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "xfail",
        "importPath": "_pytest.outcomes",
        "description": "_pytest.outcomes",
        "isExtraImport": true,
        "detail": "_pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "PytestUnknownMarkWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestDeprecationWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestRemovedIn8Warning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "UnformattedWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestCollectionWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestReturnNotNoneWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestUnhandledCoroutineWarning",
        "importPath": "_pytest.warning_types",
        "description": "_pytest.warning_types",
        "isExtraImport": true,
        "detail": "_pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "_pytest.config.argparsing",
        "description": "_pytest.config.argparsing",
        "isExtraImport": true,
        "detail": "_pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "SubRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureManager",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "getfixturemarker",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FuncFixtureInfo",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureDef",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "SubRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureDef",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "SubRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "importPath": "_pytest.fixtures",
        "description": "_pytest.fixtures",
        "isExtraImport": true,
        "detail": "_pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Package",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Function",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Class",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Function",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "_pytest.python",
        "description": "_pytest.python",
        "isExtraImport": true,
        "detail": "_pytest.python",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "BaseReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "BaseReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "BaseReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "importPath": "_pytest.reports",
        "description": "_pytest.reports",
        "isExtraImport": true,
        "detail": "_pytest.reports",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "py",
        "description": "py",
        "detail": "py",
        "documentation": {}
    },
    {
        "label": "bdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bdb",
        "description": "bdb",
        "detail": "bdb",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFileLocation",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "FormattedExcinfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFileLocation",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionChainRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprEntry",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprEntryNative",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFileLocation",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFuncArgs",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprLocals",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprTraceback",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionChainRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionRepr",
        "importPath": "_pytest._code.code",
        "description": "_pytest._code.code",
        "isExtraImport": true,
        "detail": "_pytest._code.code",
        "documentation": {}
    },
    {
        "label": "approx",
        "importPath": "_pytest.python_api",
        "description": "_pytest.python_api",
        "isExtraImport": true,
        "detail": "_pytest.python_api",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "pytest",
        "description": "pytest",
        "isExtraImport": true,
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "pytest",
        "description": "pytest",
        "isExtraImport": true,
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "UserDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "UserList",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "UserString",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Mark",
        "importPath": "_pytest.mark",
        "description": "_pytest.mark",
        "isExtraImport": true,
        "detail": "_pytest.mark",
        "documentation": {}
    },
    {
        "label": "ParameterSet",
        "importPath": "_pytest.mark",
        "description": "_pytest.mark",
        "isExtraImport": true,
        "detail": "_pytest.mark",
        "documentation": {}
    },
    {
        "label": "MARK_GEN",
        "importPath": "_pytest.mark",
        "description": "_pytest.mark",
        "isExtraImport": true,
        "detail": "_pytest.mark",
        "documentation": {}
    },
    {
        "label": "ParameterSet",
        "importPath": "_pytest.mark",
        "description": "_pytest.mark",
        "isExtraImport": true,
        "detail": "_pytest.mark",
        "documentation": {}
    },
    {
        "label": "MarkDecorator",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "Mark",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "MarkDecorator",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "NodeKeywords",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "get_unpacked_marks",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "Mark",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "MarkDecorator",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "normalize_mark_list",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "Mark",
        "importPath": "_pytest.mark.structures",
        "description": "_pytest.mark.structures",
        "isExtraImport": true,
        "detail": "_pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "HIGH_SCOPES",
        "importPath": "_pytest.scope",
        "description": "_pytest.scope",
        "isExtraImport": true,
        "detail": "_pytest.scope",
        "documentation": {}
    },
    {
        "label": "Scope",
        "importPath": "_pytest.scope",
        "description": "_pytest.scope",
        "isExtraImport": true,
        "detail": "_pytest.scope",
        "documentation": {}
    },
    {
        "label": "Scope",
        "importPath": "_pytest.scope",
        "description": "_pytest.scope",
        "isExtraImport": true,
        "detail": "_pytest.scope",
        "documentation": {}
    },
    {
        "label": "Scope",
        "importPath": "_pytest.scope",
        "description": "_pytest.scope",
        "isExtraImport": true,
        "detail": "_pytest.scope",
        "documentation": {}
    },
    {
        "label": "Scope",
        "importPath": "_pytest.scope",
        "description": "_pytest.scope",
        "isExtraImport": true,
        "detail": "_pytest.scope",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "importPath": "_pytest.terminal",
        "description": "_pytest.terminal",
        "isExtraImport": true,
        "detail": "_pytest.terminal",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "importPath": "_pytest.terminal",
        "description": "_pytest.terminal",
        "isExtraImport": true,
        "detail": "_pytest.terminal",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "importPath": "_pytest.terminal",
        "description": "_pytest.terminal",
        "isExtraImport": true,
        "detail": "_pytest.terminal",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "importPath": "_pytest.terminal",
        "description": "_pytest.terminal",
        "isExtraImport": true,
        "detail": "_pytest.terminal",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "importPath": "_pytest.terminal",
        "description": "_pytest.terminal",
        "isExtraImport": true,
        "detail": "_pytest.terminal",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "shlex",
        "description": "shlex",
        "isExtraImport": true,
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Cache",
        "importPath": "_pytest.cacheprovider",
        "description": "_pytest.cacheprovider",
        "isExtraImport": true,
        "detail": "_pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "MonkeyPatch",
        "importPath": "_pytest.monkeypatch",
        "description": "_pytest.monkeypatch",
        "isExtraImport": true,
        "detail": "_pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "MonkeyPatch",
        "importPath": "_pytest.monkeypatch",
        "description": "_pytest.monkeypatch",
        "isExtraImport": true,
        "detail": "_pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "MonkeyPatch",
        "importPath": "_pytest.monkeypatch",
        "description": "_pytest.monkeypatch",
        "isExtraImport": true,
        "detail": "_pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "HookRecorder",
        "importPath": "_pytest.pytester",
        "description": "_pytest.pytester",
        "isExtraImport": true,
        "detail": "_pytest.pytester",
        "documentation": {}
    },
    {
        "label": "Pytester",
        "importPath": "_pytest.pytester",
        "description": "_pytest.pytester",
        "isExtraImport": true,
        "detail": "_pytest.pytester",
        "documentation": {}
    },
    {
        "label": "RunResult",
        "importPath": "_pytest.pytester",
        "description": "_pytest.pytester",
        "isExtraImport": true,
        "detail": "_pytest.pytester",
        "documentation": {}
    },
    {
        "label": "TempPathFactory",
        "importPath": "_pytest.tmpdir",
        "description": "_pytest.tmpdir",
        "isExtraImport": true,
        "detail": "_pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "TempPathFactory",
        "importPath": "_pytest.tmpdir",
        "description": "_pytest.tmpdir",
        "isExtraImport": true,
        "detail": "_pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "CaptureManager",
        "importPath": "_pytest.capture",
        "description": "_pytest.capture",
        "isExtraImport": true,
        "detail": "_pytest.capture",
        "documentation": {}
    },
    {
        "label": "_get_multicapture",
        "importPath": "_pytest.capture",
        "description": "_pytest.capture",
        "isExtraImport": true,
        "detail": "_pytest.capture",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "reload",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "reload",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "collect_one_node",
        "importPath": "_pytest.runner",
        "description": "_pytest.runner",
        "isExtraImport": true,
        "detail": "_pytest.runner",
        "documentation": {}
    },
    {
        "label": "SetupState",
        "importPath": "_pytest.runner",
        "description": "_pytest.runner",
        "isExtraImport": true,
        "detail": "_pytest.runner",
        "documentation": {}
    },
    {
        "label": "CallInfo",
        "importPath": "_pytest.runner",
        "description": "_pytest.runner",
        "isExtraImport": true,
        "detail": "_pytest.runner",
        "documentation": {}
    },
    {
        "label": "CallInfo",
        "importPath": "_pytest.runner",
        "description": "_pytest.runner",
        "isExtraImport": true,
        "detail": "_pytest.runner",
        "documentation": {}
    },
    {
        "label": "TestCaseFunction",
        "importPath": "_pytest.unittest",
        "description": "_pytest.unittest",
        "isExtraImport": true,
        "detail": "_pytest.unittest",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "decimal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "decimal",
        "description": "decimal",
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Complex",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "wcswidth",
        "importPath": "_pytest._io.wcwidth",
        "description": "_pytest._io.wcwidth",
        "isExtraImport": true,
        "detail": "_pytest._io.wcwidth",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Lock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "perf_counter",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "astroid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid",
        "description": "astroid",
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "BoundMethod",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "modutils",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "raw_building",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "rebuilder",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "_cache",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "manager",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "raw_building",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "constraint",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "protocols",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "helpers",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "manager",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "transforms",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "Instance",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "arguments",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "TooManyLevelsError",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "bases",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "modutils",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "modutils",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "modutils",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "astroid",
        "description": "astroid",
        "isExtraImport": true,
        "detail": "astroid",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "bind_context_to_node",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "bind_context_to_node",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "bind_context_to_node",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "_invalidate_cache",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "importPath": "astroid.context",
        "description": "astroid.context",
        "isExtraImport": true,
        "detail": "astroid.context",
        "documentation": {}
    },
    {
        "label": "astroid.exceptions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidSyntaxError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidValueError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "DuplicateBasesError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InconsistentMroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "StatementMissing",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "TooManyLevelsError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidIndexError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidValueError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "ParentMissingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "ParentMissingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "StatementMissing",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NameInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidSyntaxError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "_NonDeducibleTypeHierarchy",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidIndexError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidValueError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NameInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "_NonDeducibleTypeHierarchy",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceOverwriteError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidImportError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "SuperError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidIndexError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDefault",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidError",
        "importPath": "astroid.exceptions",
        "description": "astroid.exceptions",
        "isExtraImport": true,
        "detail": "astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "importPath": "astroid.manager",
        "description": "astroid.manager",
        "isExtraImport": true,
        "detail": "astroid.manager",
        "documentation": {}
    },
    {
        "label": "AnnAssign",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Assign",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignName",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Call",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Unknown",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "FormattedValue",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignName",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Call",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Import",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Call",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Const",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "EvaluatedObject",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Assign",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignName",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Call",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Const",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "JoinedStr",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Subscript",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Const",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "# pylint: disable=redefined-builtin Ellipsis",
        "importPath": "astroid.nodes.node_classes",
        "description": "astroid.nodes.node_classes",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "AsyncFunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ComprehensionScope",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "DictComp",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "GeneratorExp",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "Lambda",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ListComp",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "LocalsDictNodeNG",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "SetComp",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "_is_metaclass",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "builtin_lookup",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "function_to_method",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "get_wrapping_class",
        "importPath": "astroid.nodes.scoped_nodes",
        "description": "astroid.nodes.scoped_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "astroid.builder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "_extract_single_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "_extract_single_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "_extract_single_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "_extract_single_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "_extract_single_node",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "astroid.builder",
        "description": "astroid.builder",
        "isExtraImport": true,
        "detail": "astroid.builder",
        "documentation": {}
    },
    {
        "label": "scoped_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "scoped_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "Arguments",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "Const",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "_base_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "_base_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "scoped_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "scoped_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "node_classes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "LocalsDictNodeNG",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "_base_nodes",
        "importPath": "astroid.nodes",
        "description": "astroid.nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "importPath": "astroid.brain.helpers",
        "description": "astroid.brain.helpers",
        "isExtraImport": true,
        "detail": "astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY311_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY311_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PYPY_7_3_11_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "_EMPTY_OBJECT_MARKER",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "BRAIN_MODULES_DIRECTORY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_JYTHON",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "_EMPTY_OBJECT_MARKER",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "astroid.const",
        "description": "astroid.const",
        "isExtraImport": true,
        "detail": "astroid.const",
        "documentation": {}
    },
    {
        "label": "_SimpleCData",
        "importPath": "_ctypes",
        "description": "_ctypes",
        "isExtraImport": true,
        "detail": "_ctypes",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "importPath": "astroid.inference_tip",
        "description": "astroid.inference_tip",
        "isExtraImport": true,
        "detail": "astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferBinaryOp",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "ConstFactoryResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferBinaryOp",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceErrorInfo",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceErrorInfo",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferFn",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferBinaryOp",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceErrorInfo",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceErrorInfo",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferFn",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "AstroidManagerBrain",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "ConstFactoryResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "importPath": "astroid.typing",
        "description": "astroid.typing",
        "isExtraImport": true,
        "detail": "astroid.typing",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "lazy_descriptor",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "lazy_import",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "importPath": "astroid.util",
        "description": "astroid.util",
        "isExtraImport": true,
        "detail": "astroid.util",
        "documentation": {}
    },
    {
        "label": "objectmodel",
        "importPath": "astroid.interpreter",
        "description": "astroid.interpreter",
        "isExtraImport": true,
        "detail": "astroid.interpreter",
        "documentation": {}
    },
    {
        "label": "dunder_lookup",
        "importPath": "astroid.interpreter",
        "description": "astroid.interpreter",
        "isExtraImport": true,
        "detail": "astroid.interpreter",
        "documentation": {}
    },
    {
        "label": "astroid.bases",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid.bases",
        "description": "astroid.bases",
        "detail": "astroid.bases",
        "documentation": {}
    },
    {
        "label": "BoundMethod",
        "importPath": "astroid.bases",
        "description": "astroid.bases",
        "isExtraImport": true,
        "detail": "astroid.bases",
        "documentation": {}
    },
    {
        "label": "Instance",
        "importPath": "astroid.bases",
        "description": "astroid.bases",
        "isExtraImport": true,
        "detail": "astroid.bases",
        "documentation": {}
    },
    {
        "label": "_infer_stmts",
        "importPath": "astroid.bases",
        "description": "astroid.bases",
        "isExtraImport": true,
        "detail": "astroid.bases",
        "documentation": {}
    },
    {
        "label": "Instance",
        "importPath": "astroid.bases",
        "description": "astroid.bases",
        "isExtraImport": true,
        "detail": "astroid.bases",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyword",
        "description": "keyword",
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "infer_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "looks_like_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "infer_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "looks_like_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "infer_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "looks_like_numpy_member",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "numpy_supports_type_hints",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "numpy_supports_type_hints",
        "importPath": "astroid.brain.brain_numpy_utils",
        "description": "astroid.brain.brain_numpy_utils",
        "isExtraImport": true,
        "detail": "astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "_io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_io",
        "description": "_io",
        "detail": "_io",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "copyreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copyreg",
        "description": "copyreg",
        "detail": "copyreg",
        "documentation": {}
    },
    {
        "label": "_dummy_thread",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_dummy_thread",
        "description": "_dummy_thread",
        "detail": "_dummy_thread",
        "documentation": {}
    },
    {
        "label": "http.cookiejar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.cookiejar",
        "description": "http.cookiejar",
        "detail": "http.cookiejar",
        "documentation": {}
    },
    {
        "label": "http.cookies",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.cookies",
        "description": "http.cookies",
        "detail": "http.cookies",
        "documentation": {}
    },
    {
        "label": "html.entities",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html.entities",
        "description": "html.entities",
        "detail": "html.entities",
        "documentation": {}
    },
    {
        "label": "html.parser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html.parser",
        "description": "html.parser",
        "detail": "html.parser",
        "documentation": {}
    },
    {
        "label": "http.client",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.client",
        "description": "http.client",
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "http.server",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.server",
        "description": "http.server",
        "detail": "http.server",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "PicklingError",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "_Pickler",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "Unpickler",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PROTOCOL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "HIGHEST_PROTOCOL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "PickleError",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "PicklingError",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "UnpicklingError",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "GLOBAL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PROTOCOL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "socketserver",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socketserver",
        "description": "socketserver",
        "detail": "socketserver",
        "documentation": {}
    },
    {
        "label": "_thread",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_thread",
        "description": "_thread",
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "LockType",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "xmlrpc.server",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xmlrpc.server",
        "description": "xmlrpc.server",
        "detail": "xmlrpc.server",
        "documentation": {}
    },
    {
        "label": "xmlrpc.client",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xmlrpc.client",
        "description": "xmlrpc.client",
        "detail": "xmlrpc.client",
        "documentation": {}
    },
    {
        "label": "urllib.robotparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.robotparser",
        "description": "urllib.robotparser",
        "detail": "urllib.robotparser",
        "documentation": {}
    },
    {
        "label": "email.mime.multipart",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "email.mime.nonmultipart",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.mime.nonmultipart",
        "description": "email.mime.nonmultipart",
        "detail": "email.mime.nonmultipart",
        "documentation": {}
    },
    {
        "label": "email.mime.text",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "email.mime.base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.mime.base",
        "description": "email.mime.base",
        "detail": "email.mime.base",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urllib.error",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.error",
        "description": "urllib.error",
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "tkinter.dialog",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.dialog",
        "description": "tkinter.dialog",
        "detail": "tkinter.dialog",
        "documentation": {}
    },
    {
        "label": "tkinter.filedialog",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.filedialog",
        "description": "tkinter.filedialog",
        "detail": "tkinter.filedialog",
        "documentation": {}
    },
    {
        "label": "tkinter.scrolledtext",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.scrolledtext",
        "description": "tkinter.scrolledtext",
        "detail": "tkinter.scrolledtext",
        "documentation": {}
    },
    {
        "label": "tkinter.simpledialog",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.simpledialog",
        "description": "tkinter.simpledialog",
        "detail": "tkinter.simpledialog",
        "documentation": {}
    },
    {
        "label": "tkinter.tix",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.tix",
        "description": "tkinter.tix",
        "detail": "tkinter.tix",
        "documentation": {}
    },
    {
        "label": "tkinter.ttk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.ttk",
        "description": "tkinter.ttk",
        "detail": "tkinter.ttk",
        "documentation": {}
    },
    {
        "label": "tkinter.constants",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.constants",
        "description": "tkinter.constants",
        "detail": "tkinter.constants",
        "documentation": {}
    },
    {
        "label": "tkinter.dnd",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.dnd",
        "description": "tkinter.dnd",
        "detail": "tkinter.dnd",
        "documentation": {}
    },
    {
        "label": "tkinter.colorchooser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.colorchooser",
        "description": "tkinter.colorchooser",
        "detail": "tkinter.colorchooser",
        "documentation": {}
    },
    {
        "label": "tkinter.commondialog",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.commondialog",
        "description": "tkinter.commondialog",
        "detail": "tkinter.commondialog",
        "documentation": {}
    },
    {
        "label": "tkinter.font",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.font",
        "description": "tkinter.font",
        "detail": "tkinter.font",
        "documentation": {}
    },
    {
        "label": "tkinter.messagebox",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter.messagebox",
        "description": "tkinter.messagebox",
        "detail": "tkinter.messagebox",
        "documentation": {}
    },
    {
        "label": "urllib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib",
        "description": "urllib",
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "zipimport",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipimport",
        "description": "zipimport",
        "detail": "zipimport",
        "documentation": {}
    },
    {
        "label": "EXT_LIB_DIRS",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "NoSourceFile",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "_cache_normalize_path_",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "file_info_from_modpath",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "get_source_file",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_module_name_part_of_extension_package_whitelist",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_python_source",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_standard_module",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "load_module_from_name",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "modpath_from_file",
        "importPath": "astroid.modutils",
        "description": "astroid.modutils",
        "isExtraImport": true,
        "detail": "astroid.modutils",
        "documentation": {}
    },
    {
        "label": "_NamespacePath",
        "importPath": "importlib._bootstrap_external",
        "description": "importlib._bootstrap_external",
        "isExtraImport": true,
        "detail": "importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_filter_stmts",
        "importPath": "astroid.filter_statements",
        "description": "astroid.filter_statements",
        "isExtraImport": true,
        "detail": "astroid.filter_statements",
        "documentation": {}
    },
    {
        "label": "builtin_lookup",
        "importPath": "astroid.nodes.scoped_nodes.utils",
        "description": "astroid.nodes.scoped_nodes.utils",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes.utils",
        "documentation": {}
    },
    {
        "label": "builtin_lookup",
        "importPath": "astroid.nodes.scoped_nodes.utils",
        "description": "astroid.nodes.scoped_nodes.utils",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes.utils",
        "documentation": {}
    },
    {
        "label": "lookup",
        "importPath": "astroid.interpreter.dunder_lookup",
        "description": "astroid.interpreter.dunder_lookup",
        "isExtraImport": true,
        "detail": "astroid.interpreter.dunder_lookup",
        "documentation": {}
    },
    {
        "label": "ClassModel",
        "importPath": "astroid.interpreter.objectmodel",
        "description": "astroid.interpreter.objectmodel",
        "isExtraImport": true,
        "detail": "astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "FunctionModel",
        "importPath": "astroid.interpreter.objectmodel",
        "description": "astroid.interpreter.objectmodel",
        "isExtraImport": true,
        "detail": "astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ModuleModel",
        "importPath": "astroid.interpreter.objectmodel",
        "description": "astroid.interpreter.objectmodel",
        "isExtraImport": true,
        "detail": "astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ComprehensionScope",
        "importPath": "astroid.nodes.scoped_nodes.mixin",
        "description": "astroid.nodes.scoped_nodes.mixin",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes.mixin",
        "documentation": {}
    },
    {
        "label": "LocalsDictNodeNG",
        "importPath": "astroid.nodes.scoped_nodes.mixin",
        "description": "astroid.nodes.scoped_nodes.mixin",
        "isExtraImport": true,
        "detail": "astroid.nodes.scoped_nodes.mixin",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "astroid.nodes.utils",
        "description": "astroid.nodes.utils",
        "isExtraImport": true,
        "detail": "astroid.nodes.utils",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "astroid.nodes.utils",
        "description": "astroid.nodes.utils",
        "isExtraImport": true,
        "detail": "astroid.nodes.utils",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "astroid.nodes.utils",
        "description": "astroid.nodes.utils",
        "isExtraImport": true,
        "detail": "astroid.nodes.utils",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes.node_ng",
        "description": "astroid.nodes.node_ng",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "importPath": "astroid.nodes.node_ng",
        "description": "astroid.nodes.node_ng",
        "isExtraImport": true,
        "detail": "astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "OP_PRECEDENCE",
        "importPath": "astroid.nodes.const",
        "description": "astroid.nodes.const",
        "isExtraImport": true,
        "detail": "astroid.nodes.const",
        "documentation": {}
    },
    {
        "label": "OP_PRECEDENCE",
        "importPath": "astroid.nodes.const",
        "description": "astroid.nodes.const",
        "isExtraImport": true,
        "detail": "astroid.nodes.const",
        "documentation": {}
    },
    {
        "label": "AsStringVisitor",
        "importPath": "astroid.nodes.as_string",
        "description": "astroid.nodes.as_string",
        "isExtraImport": true,
        "detail": "astroid.nodes.as_string",
        "documentation": {}
    },
    {
        "label": "ParserModule",
        "importPath": "astroid._ast",
        "description": "astroid._ast",
        "isExtraImport": true,
        "detail": "astroid._ast",
        "documentation": {}
    },
    {
        "label": "get_parser_module",
        "importPath": "astroid._ast",
        "description": "astroid._ast",
        "isExtraImport": true,
        "detail": "astroid._ast",
        "documentation": {}
    },
    {
        "label": "ParserModule",
        "importPath": "astroid._ast",
        "description": "astroid._ast",
        "isExtraImport": true,
        "detail": "astroid._ast",
        "documentation": {}
    },
    {
        "label": "get_parser_module",
        "importPath": "astroid._ast",
        "description": "astroid._ast",
        "isExtraImport": true,
        "detail": "astroid._ast",
        "documentation": {}
    },
    {
        "label": "parse_function_type_comment",
        "importPath": "astroid._ast",
        "description": "astroid._ast",
        "isExtraImport": true,
        "detail": "astroid._ast",
        "documentation": {}
    },
    {
        "label": "wrapt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wrapt",
        "description": "wrapt",
        "detail": "wrapt",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "attrgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "CACHE_MANAGER",
        "importPath": "astroid._cache",
        "description": "astroid._cache",
        "isExtraImport": true,
        "detail": "astroid._cache",
        "documentation": {}
    },
    {
        "label": "spec",
        "importPath": "astroid.interpreter._import",
        "description": "astroid.interpreter._import",
        "isExtraImport": true,
        "detail": "astroid.interpreter._import",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid.interpreter._import",
        "description": "astroid.interpreter._import",
        "isExtraImport": true,
        "detail": "astroid.interpreter._import",
        "documentation": {}
    },
    {
        "label": "spec",
        "importPath": "astroid.interpreter._import",
        "description": "astroid.interpreter._import",
        "isExtraImport": true,
        "detail": "astroid.interpreter._import",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "astroid.interpreter._import",
        "description": "astroid.interpreter._import",
        "isExtraImport": true,
        "detail": "astroid.interpreter._import",
        "documentation": {}
    },
    {
        "label": "TransformVisitor",
        "importPath": "astroid.transforms",
        "description": "astroid.transforms",
        "isExtraImport": true,
        "detail": "astroid.transforms",
        "documentation": {}
    },
    {
        "label": "AssignTypeNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "FilterStmtsBaseNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ImportNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "MultiLineBlockNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "MultiLineWithElseBlockNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "NoChildrenNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ParentAssignNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ImportNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ImportNode",
        "importPath": "astroid.nodes._base_nodes",
        "description": "astroid.nodes._base_nodes",
        "isExtraImport": true,
        "detail": "astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "token",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "token",
        "description": "token",
        "detail": "token",
        "documentation": {}
    },
    {
        "label": "lazy_object_proxy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lazy_object_proxy",
        "description": "lazy_object_proxy",
        "detail": "lazy_object_proxy",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "linecache",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "linecache",
        "description": "linecache",
        "detail": "linecache",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.converters",
        "description": "attr.converters",
        "isExtraImport": true,
        "detail": "attr.converters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.exceptions",
        "description": "attr.exceptions",
        "isExtraImport": true,
        "detail": "attr.exceptions",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.filters",
        "description": "attr.filters",
        "isExtraImport": true,
        "detail": "attr.filters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.setters",
        "description": "attr.setters",
        "isExtraImport": true,
        "detail": "attr.setters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.validators",
        "description": "attr.validators",
        "isExtraImport": true,
        "detail": "attr.validators",
        "documentation": {}
    },
    {
        "label": "dill",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dill",
        "description": "dill",
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "check",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "__diff",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "detect",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "load_types",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "extend",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "load_types",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "_dill",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "Pickler",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "Unpickler",
        "importPath": "dill",
        "description": "dill",
        "isExtraImport": true,
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "capture",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "dump",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "dump_source",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "dumpIO",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "dumpIO_source",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "load_source",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "loadIO",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "loadIO_source",
        "importPath": "dill.temp",
        "description": "dill.temp",
        "isExtraImport": true,
        "detail": "dill.temp",
        "documentation": {}
    },
    {
        "label": "baditems",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "badobjects",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "badtypes",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "errors",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "parent",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "at",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "globalvars",
        "importPath": "dill.detect",
        "description": "dill.detect",
        "isExtraImport": true,
        "detail": "dill.detect",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "OLD310",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "MAPPING_PROXY_TRICK",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "DictProxyType",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "_testcapsule",
        "importPath": "dill._dill",
        "description": "dill._dill",
        "isExtraImport": true,
        "detail": "dill._dill",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "stderr_handler",
        "importPath": "dill.logger",
        "description": "dill.logger",
        "isExtraImport": true,
        "detail": "dill.logger",
        "documentation": {}
    },
    {
        "label": "adapter",
        "importPath": "dill.logger",
        "description": "dill.logger",
        "isExtraImport": true,
        "detail": "dill.logger",
        "documentation": {}
    },
    {
        "label": "test_mixins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test_mixins",
        "description": "test_mixins",
        "detail": "test_mixins",
        "documentation": {}
    },
    {
        "label": "doctest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "doctest",
        "description": "doctest",
        "detail": "doctest",
        "documentation": {}
    },
    {
        "label": "failures",
        "importPath": "dill._objects",
        "description": "dill._objects",
        "isExtraImport": true,
        "detail": "dill._objects",
        "documentation": {}
    },
    {
        "label": "registered",
        "importPath": "dill._objects",
        "description": "dill._objects",
        "isExtraImport": true,
        "detail": "dill._objects",
        "documentation": {}
    },
    {
        "label": "succeeds",
        "importPath": "dill._objects",
        "description": "dill._objects",
        "isExtraImport": true,
        "detail": "dill._objects",
        "documentation": {}
    },
    {
        "label": "__main__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__main__",
        "description": "__main__",
        "detail": "__main__",
        "documentation": {}
    },
    {
        "label": "sax",
        "importPath": "xml",
        "description": "xml",
        "isExtraImport": true,
        "detail": "xml",
        "documentation": {}
    },
    {
        "label": "xml.dom.minidom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.dom.minidom",
        "description": "xml.dom.minidom",
        "detail": "xml.dom.minidom",
        "documentation": {}
    },
    {
        "label": "test_dictviews",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test_dictviews",
        "description": "test_dictviews",
        "detail": "test_dictviews",
        "documentation": {}
    },
    {
        "label": "calendar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "calendar",
        "description": "calendar",
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "Calendar",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "isleap",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "day_name",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "cmath",
        "description": "cmath",
        "isExtraImport": true,
        "detail": "cmath",
        "documentation": {}
    },
    {
        "label": "getsource",
        "importPath": "dill.source",
        "description": "dill.source",
        "isExtraImport": true,
        "detail": "dill.source",
        "documentation": {}
    },
    {
        "label": "getname",
        "importPath": "dill.source",
        "description": "dill.source",
        "isExtraImport": true,
        "detail": "dill.source",
        "documentation": {}
    },
    {
        "label": "_wrap",
        "importPath": "dill.source",
        "description": "dill.source",
        "isExtraImport": true,
        "detail": "dill.source",
        "documentation": {}
    },
    {
        "label": "likely_import",
        "importPath": "dill.source",
        "description": "dill.source",
        "isExtraImport": true,
        "detail": "dill.source",
        "documentation": {}
    },
    {
        "label": "getimportable",
        "importPath": "dill.source",
        "description": "dill.source",
        "isExtraImport": true,
        "detail": "dill.source",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "socket",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "_reduce_socket",
        "importPath": "multiprocessing.reduction",
        "description": "multiprocessing.reduction",
        "isExtraImport": true,
        "detail": "multiprocessing.reduction",
        "documentation": {}
    },
    {
        "label": "warnings;",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings;",
        "description": "warnings;",
        "detail": "warnings;",
        "documentation": {}
    },
    {
        "label": "dbm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dbm",
        "description": "dbm",
        "detail": "dbm",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "shelve",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shelve",
        "description": "shelve",
        "detail": "shelve",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "xdrlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xdrlib",
        "description": "xdrlib",
        "detail": "xdrlib",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "hmac",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac",
        "description": "hmac",
        "detail": "hmac",
        "documentation": {}
    },
    {
        "label": "logging.handlers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "importPath": "optparse",
        "description": "optparse",
        "isExtraImport": true,
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "fractions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fractions",
        "description": "fractions",
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "dis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dis",
        "description": "dis",
        "detail": "dis",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "sections",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "api",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "sections",
        "importPath": "isort",
        "description": "isort",
        "isExtraImport": true,
        "detail": "isort",
        "documentation": {}
    },
    {
        "label": "KNOWN_SECTION_MAPPING",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "isort.settings",
        "description": "isort.settings",
        "isExtraImport": true,
        "detail": "isort.settings",
        "documentation": {}
    },
    {
        "label": "exists_case_sensitive",
        "importPath": "isort.utils",
        "description": "isort.utils",
        "isExtraImport": true,
        "detail": "isort.utils",
        "documentation": {}
    },
    {
        "label": "exists_case_sensitive",
        "importPath": "isort.utils",
        "description": "isort.utils",
        "isExtraImport": true,
        "detail": "isort.utils",
        "documentation": {}
    },
    {
        "label": "isort.literal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "isort.literal",
        "description": "isort.literal",
        "detail": "isort.literal",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "unified_diff",
        "importPath": "difflib",
        "description": "difflib",
        "isExtraImport": true,
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "_normalize_line",
        "importPath": "isort.parse",
        "description": "isort.parse",
        "isExtraImport": true,
        "detail": "isort.parse",
        "documentation": {}
    },
    {
        "label": "_strip_syntax",
        "importPath": "isort.parse",
        "description": "isort.parse",
        "isExtraImport": true,
        "detail": "isort.parse",
        "documentation": {}
    },
    {
        "label": "skip_line",
        "importPath": "isort.parse",
        "description": "isort.parse",
        "isExtraImport": true,
        "detail": "isort.parse",
        "documentation": {}
    },
    {
        "label": "UnsupportedEncoding",
        "importPath": "isort.exceptions",
        "description": "isort.exceptions",
        "isExtraImport": true,
        "detail": "isort.exceptions",
        "documentation": {}
    },
    {
        "label": "AssignmentsFormatMismatch",
        "importPath": "isort.exceptions",
        "description": "isort.exceptions",
        "isExtraImport": true,
        "detail": "isort.exceptions",
        "documentation": {}
    },
    {
        "label": "LiteralParsingFailure",
        "importPath": "isort.exceptions",
        "description": "isort.exceptions",
        "isExtraImport": true,
        "detail": "isort.exceptions",
        "documentation": {}
    },
    {
        "label": "LiteralSortTypeMismatch",
        "importPath": "isort.exceptions",
        "description": "isort.exceptions",
        "isExtraImport": true,
        "detail": "isort.exceptions",
        "documentation": {}
    },
    {
        "label": "FileSkipped",
        "importPath": "isort.exceptions",
        "description": "isort.exceptions",
        "isExtraImport": true,
        "detail": "isort.exceptions",
        "documentation": {}
    },
    {
        "label": "format_simplified",
        "importPath": "isort.format",
        "description": "isort.format",
        "isExtraImport": true,
        "detail": "isort.format",
        "documentation": {}
    },
    {
        "label": "Linter",
        "importPath": "pylama.lint",
        "description": "pylama.lint",
        "isExtraImport": true,
        "detail": "pylama.lint",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "isort.comments",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "isort.comments",
        "description": "isort.comments",
        "detail": "isort.comments",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "lint",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "extensions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "reporters",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "extensions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "reporters",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "reporters",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "checkers",
        "importPath": "pylint",
        "description": "pylint",
        "isExtraImport": true,
        "detail": "pylint",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "DeprecatedMixin",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "base_checker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "table_lines_from_stats",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "DeprecatedMixin",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers",
        "description": "pylint.checkers",
        "isExtraImport": true,
        "detail": "pylint.checkers",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "importPath": "pylint.checkers.base.basic_checker",
        "description": "pylint.checkers.base.basic_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "importPath": "pylint.checkers.base.basic_checker",
        "description": "pylint.checkers.base.basic_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "importPath": "pylint.checkers.base.basic_checker",
        "description": "pylint.checkers.base.basic_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "importPath": "pylint.checkers.base.basic_checker",
        "description": "pylint.checkers.base.basic_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "importPath": "pylint.checkers.base.basic_checker",
        "description": "pylint.checkers.base.basic_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "KNOWN_NAME_TYPES",
        "importPath": "pylint.checkers.base.name_checker.naming_style",
        "description": "pylint.checkers.base.name_checker.naming_style",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "KNOWN_NAME_TYPES_WITH_STYLE",
        "importPath": "pylint.checkers.base.name_checker.naming_style",
        "description": "pylint.checkers.base.name_checker.naming_style",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "NAMING_STYLES",
        "importPath": "pylint.checkers.base.name_checker.naming_style",
        "description": "pylint.checkers.base.name_checker.naming_style",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "_create_naming_options",
        "importPath": "pylint.checkers.base.name_checker.naming_style",
        "description": "pylint.checkers.base.name_checker.naming_style",
        "isExtraImport": true,
        "detail": "pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "is_property_deleter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "infer_all",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_overload_stub",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_deleter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "PYMETHODS",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "class_is_abstract",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with_property",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_outer_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "has_known_bases",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_attr_private",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_attr_protected",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_builtin_object",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_comprehension",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_iterable",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter_or_deleter",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_frame_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "unimplemented_abstract_methods",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "uninferable_final_decorators",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "PYMETHODS",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SPECIAL_METHODS_PARAMS",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_function_body_ellipsis",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_frame_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_import_name",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "infer_all",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_enum",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_import_name",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_from_fallback_block",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_guarded_import_block",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_typing_guard",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_ignores_exception",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "infer_all",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "has_known_bases",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_frame_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with_property",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "has_known_bases",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_builtin_object",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_comprehension",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_hashable",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_inside_abstract_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_iterable",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_mapping",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_module_ignored",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_type_annotation_context",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_overload_stub",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_postponed_evaluation_enabled",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_super",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_ignores_exception",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_delitem",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_getitem",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_membership_test",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_setitem",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "uninferable_final_decorators",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "in_type_checking_block",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_postponed_evaluation_enabled",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "assigned_bool",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "returns_bool",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "PYMETHODS",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with_property",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_overload_stub",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_protocol_class",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "overrides_a_method",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_none",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_type",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "in_type_checking_block",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_type_annotation_context",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_postponed_evaluation_enabled",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with_property",
        "importPath": "pylint.checkers.utils",
        "description": "pylint.checkers.utils",
        "isExtraImport": true,
        "detail": "pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ExtraMessageOptions",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ReportsCallable",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ManagedMessage",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "DirectoryNamespaceDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ErrorDescriptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ModuleDescriptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ManagedMessage",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "FileItem",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "DirectoryNamespaceDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "FileItem",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ManagedMessage",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageLocationTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ModuleDescriptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageLocationTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageLocationTuple",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "ReportsCallable",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageTypesFullName",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageTypesFullName",
        "importPath": "pylint.typing",
        "description": "pylint.typing",
        "isExtraImport": true,
        "detail": "pylint.typing",
        "documentation": {}
    },
    {
        "label": "pylint.interfaces",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "IRawChecker",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "ITokenChecker",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "implements",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE_FAILURE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "importPath": "pylint.interfaces",
        "description": "pylint.interfaces",
        "isExtraImport": true,
        "detail": "pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "pylint.reporters.ureports",
        "description": "pylint.reporters.ureports",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "pylint.reporters.ureports",
        "description": "pylint.reporters.ureports",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "get_rst_section",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "get_rst_title",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "IsortDriver",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "diff_string",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "decoding_stream",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "merge_stats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "ASTWalker",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "FileState",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "_splitstrip",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "ASTWalker",
        "importPath": "pylint.utils",
        "description": "pylint.utils",
        "isExtraImport": true,
        "detail": "pylint.utils",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint.pylinter",
        "description": "pylint.lint.pylinter",
        "isExtraImport": true,
        "detail": "pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "MANAGER",
        "importPath": "pylint.lint.pylinter",
        "description": "pylint.lint.pylinter",
        "isExtraImport": true,
        "detail": "pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint.pylinter",
        "description": "pylint.lint.pylinter",
        "isExtraImport": true,
        "detail": "pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "_ArgumentsProvider",
        "importPath": "pylint.config.arguments_provider",
        "description": "pylint.config.arguments_provider",
        "isExtraImport": true,
        "detail": "pylint.config.arguments_provider",
        "documentation": {}
    },
    {
        "label": "_ArgumentsProvider",
        "importPath": "pylint.config.arguments_provider",
        "description": "pylint.config.arguments_provider",
        "isExtraImport": true,
        "detail": "pylint.config.arguments_provider",
        "documentation": {}
    },
    {
        "label": "_MSG_ORDER",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MAIN_CHECKER_NAME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "DUNDER_METHODS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "TYPING_NEVER",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "TYPING_NORETURN",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MAIN_CHECKER_NAME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PYLINT_HOME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "OLD_DEFAULT_PYLINT_HOME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "DUNDER_METHODS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "DUNDER_PROPERTIES",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "EXTRA_DUNDER_METHODS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "TYPING_NORETURN",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PYLINT_HOME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_CONFIDENCE",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_SCOPE_CONFIG",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_SCOPE_MODULE",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES_LONG",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MAIN_CHECKER_NAME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES_STATUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "full_version",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "_SCOPE_EXEMPT",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MAIN_CHECKER_NAME",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "INCOMPATIBLE_WITH_USELESS_SUPPRESSION",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_SCOPE_MODULE",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY_EXTS",
        "importPath": "pylint.constants",
        "description": "pylint.constants",
        "isExtraImport": true,
        "detail": "pylint.constants",
        "documentation": {}
    },
    {
        "label": "InvalidMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyReportError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "UnknownMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "DeletedMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "MessageBecameExtensionError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "UnknownMessageError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyReportError",
        "importPath": "pylint.exceptions",
        "description": "pylint.exceptions",
        "isExtraImport": true,
        "detail": "pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "MessageDefinition",
        "importPath": "pylint.message.message_definition",
        "description": "pylint.message.message_definition",
        "isExtraImport": true,
        "detail": "pylint.message.message_definition",
        "documentation": {}
    },
    {
        "label": "MessageDefinition",
        "importPath": "pylint.message.message_definition",
        "description": "pylint.message.message_definition",
        "isExtraImport": true,
        "detail": "pylint.message.message_definition",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers.base_checker",
        "description": "pylint.checkers.base_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base_checker",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "importPath": "pylint.checkers.base_checker",
        "description": "pylint.checkers.base_checker",
        "isExtraImport": true,
        "detail": "pylint.checkers.base_checker",
        "documentation": {}
    },
    {
        "label": "OPTION_PO",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "PragmaParserError",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "parse_pragma",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "OPTION_PO",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "InvalidPragmaError",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "UnRecognizedOptionError",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "parse_pragma",
        "importPath": "pylint.utils.pragma_parser",
        "description": "pylint.utils.pragma_parser",
        "isExtraImport": true,
        "detail": "pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "DotBackend",
        "importPath": "pylint.graph",
        "description": "pylint.graph",
        "isExtraImport": true,
        "detail": "pylint.graph",
        "documentation": {}
    },
    {
        "label": "get_cycles",
        "importPath": "pylint.graph",
        "description": "pylint.graph",
        "isExtraImport": true,
        "detail": "pylint.graph",
        "documentation": {}
    },
    {
        "label": "Paragraph",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "VerbatimText",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Paragraph",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "importPath": "pylint.reporters.ureports.nodes",
        "description": "pylint.reporters.ureports.nodes",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "importPath": "pylint.utils.linterstats",
        "description": "pylint.utils.linterstats",
        "isExtraImport": true,
        "detail": "pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "getopt",
        "importPath": "getopt",
        "description": "getopt",
        "isExtraImport": true,
        "detail": "getopt",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "astroid.helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid.helpers",
        "description": "astroid.helpers",
        "detail": "astroid.helpers",
        "documentation": {}
    },
    {
        "label": "pylint.lint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "Run",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "Run",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "Run",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "importPath": "pylint.lint",
        "description": "pylint.lint",
        "isExtraImport": true,
        "detail": "pylint.lint",
        "documentation": {}
    },
    {
        "label": "_string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_string",
        "description": "_string",
        "detail": "_string",
        "documentation": {}
    },
    {
        "label": "astroid.objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "astroid.objects",
        "description": "astroid.objects",
        "detail": "astroid.objects",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.config._pylint_config",
        "description": "pylint.config._pylint_config",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config",
        "documentation": {}
    },
    {
        "label": "_handle_pylint_config_commands",
        "importPath": "pylint.config._pylint_config",
        "description": "pylint.config._pylint_config",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config",
        "documentation": {}
    },
    {
        "label": "_register_generate_config_options",
        "importPath": "pylint.config._pylint_config",
        "description": "pylint.config._pylint_config",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config",
        "documentation": {}
    },
    {
        "label": "get_subparser_help",
        "importPath": "pylint.config._pylint_config.help_message",
        "description": "pylint.config._pylint_config.help_message",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config.help_message",
        "documentation": {}
    },
    {
        "label": "get_help",
        "importPath": "pylint.config._pylint_config.help_message",
        "description": "pylint.config._pylint_config.help_message",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config.help_message",
        "documentation": {}
    },
    {
        "label": "get_help",
        "importPath": "pylint.config._pylint_config.help_message",
        "description": "pylint.config._pylint_config.help_message",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config.help_message",
        "documentation": {}
    },
    {
        "label": "handle_generate_command",
        "importPath": "pylint.config._pylint_config.generate_command",
        "description": "pylint.config._pylint_config.generate_command",
        "isExtraImport": true,
        "detail": "pylint.config._pylint_config.generate_command",
        "documentation": {}
    },
    {
        "label": "_AccessParserAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_CallbackAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ExtendAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_CallbackAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_CallbackAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_CallbackAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_DisableAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_DoNothingAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_EnableAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ErrorsOnlyModeAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_FullDocumentationAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_GenerateConfigFileAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_GenerateRCFileAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListCheckGroupsAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListConfidenceLevelsAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListExtensionsAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListMessagesAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListMessagesEnabledAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_LongHelpAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_MessageHelpAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_OutputFormatAction",
        "importPath": "pylint.config.callback_actions",
        "description": "pylint.config.callback_actions",
        "isExtraImport": true,
        "detail": "pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_NewNamesAction",
        "importPath": "pylint.config.deprecation_actions",
        "description": "pylint.config.deprecation_actions",
        "isExtraImport": true,
        "detail": "pylint.config.deprecation_actions",
        "documentation": {}
    },
    {
        "label": "_OldNamesAction",
        "importPath": "pylint.config.deprecation_actions",
        "description": "pylint.config.deprecation_actions",
        "isExtraImport": true,
        "detail": "pylint.config.deprecation_actions",
        "documentation": {}
    },
    {
        "label": "tomlkit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tomlkit",
        "description": "tomlkit",
        "detail": "tomlkit",
        "documentation": {}
    },
    {
        "label": "_Argument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_CallableArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_ExtendArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreNewNamesArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreOldNamesArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreTrueArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_CallableArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_ExtendArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreNewNamesArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreOldNamesArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreTrueArgument",
        "importPath": "pylint.config.argument",
        "description": "pylint.config.argument",
        "isExtraImport": true,
        "detail": "pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "UnrecognizedArgumentAction",
        "importPath": "pylint.config.exceptions",
        "description": "pylint.config.exceptions",
        "isExtraImport": true,
        "detail": "pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "_UnrecognizedOptionError",
        "importPath": "pylint.config.exceptions",
        "description": "pylint.config.exceptions",
        "isExtraImport": true,
        "detail": "pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "_UnrecognizedOptionError",
        "importPath": "pylint.config.exceptions",
        "description": "pylint.config.exceptions",
        "isExtraImport": true,
        "detail": "pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "ArgumentPreprocessingError",
        "importPath": "pylint.config.exceptions",
        "description": "pylint.config.exceptions",
        "isExtraImport": true,
        "detail": "pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "ArgumentPreprocessingError",
        "importPath": "pylint.config.exceptions",
        "description": "pylint.config.exceptions",
        "isExtraImport": true,
        "detail": "pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "_HelpFormatter",
        "importPath": "pylint.config.help_formatter",
        "description": "pylint.config.help_formatter",
        "isExtraImport": true,
        "detail": "pylint.config.help_formatter",
        "documentation": {}
    },
    {
        "label": "Option",
        "importPath": "pylint.config.option",
        "description": "pylint.config.option",
        "isExtraImport": true,
        "detail": "pylint.config.option",
        "documentation": {}
    },
    {
        "label": "Option",
        "importPath": "pylint.config.option",
        "description": "pylint.config.option",
        "isExtraImport": true,
        "detail": "pylint.config.option",
        "documentation": {}
    },
    {
        "label": "Option",
        "importPath": "pylint.config.option",
        "description": "pylint.config.option",
        "isExtraImport": true,
        "detail": "pylint.config.option",
        "documentation": {}
    },
    {
        "label": "_validate",
        "importPath": "pylint.config.option",
        "description": "pylint.config.option",
        "isExtraImport": true,
        "detail": "pylint.config.option",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "importPath": "pylint.config.option_parser",
        "description": "pylint.config.option_parser",
        "isExtraImport": true,
        "detail": "pylint.config.option_parser",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "importPath": "pylint.config.option_parser",
        "description": "pylint.config.option_parser",
        "isExtraImport": true,
        "detail": "pylint.config.option_parser",
        "documentation": {}
    },
    {
        "label": "# type: ignore[attr-defined]\n    OptionsProviderMixIn",
        "importPath": "pylint.config.options_provider_mixin",
        "description": "pylint.config.options_provider_mixin",
        "isExtraImport": true,
        "detail": "pylint.config.options_provider_mixin",
        "documentation": {}
    },
    {
        "label": "# type: ignore[attr-defined]\n    OptionsProviderMixIn",
        "importPath": "pylint.config.options_provider_mixin",
        "description": "pylint.config.options_provider_mixin",
        "isExtraImport": true,
        "detail": "pylint.config.options_provider_mixin",
        "documentation": {}
    },
    {
        "label": "_convert_option_to_argument",
        "importPath": "pylint.config.utils",
        "description": "pylint.config.utils",
        "isExtraImport": true,
        "detail": "pylint.config.utils",
        "documentation": {}
    },
    {
        "label": "_parse_rich_type_value",
        "importPath": "pylint.config.utils",
        "description": "pylint.config.utils",
        "isExtraImport": true,
        "detail": "pylint.config.utils",
        "documentation": {}
    },
    {
        "label": "_parse_rich_type_value",
        "importPath": "pylint.config.utils",
        "description": "pylint.config.utils",
        "isExtraImport": true,
        "detail": "pylint.config.utils",
        "documentation": {}
    },
    {
        "label": "_preprocess_options",
        "importPath": "pylint.config.utils",
        "description": "pylint.config.utils",
        "isExtraImport": true,
        "detail": "pylint.config.utils",
        "documentation": {}
    },
    {
        "label": "_ArgumentsManager",
        "importPath": "pylint.config.arguments_manager",
        "description": "pylint.config.arguments_manager",
        "isExtraImport": true,
        "detail": "pylint.config.arguments_manager",
        "documentation": {}
    },
    {
        "label": "_ArgumentsManager",
        "importPath": "pylint.config.arguments_manager",
        "description": "pylint.config.arguments_manager",
        "isExtraImport": true,
        "detail": "pylint.config.arguments_manager",
        "documentation": {}
    },
    {
        "label": "_ArgumentsManager",
        "importPath": "pylint.config.arguments_manager",
        "description": "pylint.config.arguments_manager",
        "isExtraImport": true,
        "detail": "pylint.config.arguments_manager",
        "documentation": {}
    },
    {
        "label": "_ConfigurationFileParser",
        "importPath": "pylint.config.config_file_parser",
        "description": "pylint.config.config_file_parser",
        "isExtraImport": true,
        "detail": "pylint.config.config_file_parser",
        "documentation": {}
    },
    {
        "label": "OptionsManagerMixIn",
        "importPath": "pylint.config.option_manager_mixin",
        "description": "pylint.config.option_manager_mixin",
        "isExtraImport": true,
        "detail": "pylint.config.option_manager_mixin",
        "documentation": {}
    },
    {
        "label": "find_pylintrc",
        "importPath": "pylint.config.find_default_config_files",
        "description": "pylint.config.find_default_config_files",
        "isExtraImport": true,
        "detail": "pylint.config.find_default_config_files",
        "documentation": {}
    },
    {
        "label": "_check_docs_utils",
        "importPath": "pylint.extensions",
        "description": "pylint.extensions",
        "isExtraImport": true,
        "detail": "pylint.extensions",
        "documentation": {}
    },
    {
        "label": "Docstring",
        "importPath": "pylint.extensions._check_docs_utils",
        "description": "pylint.extensions._check_docs_utils",
        "isExtraImport": true,
        "detail": "pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "PathGraph",
        "importPath": "mccabe",
        "description": "mccabe",
        "isExtraImport": true,
        "detail": "mccabe",
        "documentation": {}
    },
    {
        "label": "PathGraphingAstVisitor",
        "importPath": "mccabe",
        "description": "mccabe",
        "isExtraImport": true,
        "detail": "mccabe",
        "documentation": {}
    },
    {
        "label": "_annotated_unpack_infer",
        "importPath": "pylint.checkers.exceptions",
        "description": "pylint.checkers.exceptions",
        "isExtraImport": true,
        "detail": "pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "MessageDefinition",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "MessageDefinition",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionStore",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message",
        "description": "pylint.message",
        "isExtraImport": true,
        "detail": "pylint.message",
        "documentation": {}
    },
    {
        "label": "_patch_sys_path",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "_is_relative_to",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "fix_import_path",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "get_fatal_error_message",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "prepare_crash_report",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "fix_import_path",
        "importPath": "pylint.lint.utils",
        "description": "pylint.lint.utils",
        "isExtraImport": true,
        "detail": "pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "_make_linter_options",
        "importPath": "pylint.lint.base_options",
        "description": "pylint.lint.base_options",
        "isExtraImport": true,
        "detail": "pylint.lint.base_options",
        "documentation": {}
    },
    {
        "label": "_make_run_options",
        "importPath": "pylint.lint.base_options",
        "description": "pylint.lint.base_options",
        "isExtraImport": true,
        "detail": "pylint.lint.base_options",
        "documentation": {}
    },
    {
        "label": "load_results",
        "importPath": "pylint.lint.caching",
        "description": "pylint.lint.caching",
        "isExtraImport": true,
        "detail": "pylint.lint.caching",
        "documentation": {}
    },
    {
        "label": "save_results",
        "importPath": "pylint.lint.caching",
        "description": "pylint.lint.caching",
        "isExtraImport": true,
        "detail": "pylint.lint.caching",
        "documentation": {}
    },
    {
        "label": "_is_ignored_file",
        "importPath": "pylint.lint.expand_modules",
        "description": "pylint.lint.expand_modules",
        "isExtraImport": true,
        "detail": "pylint.lint.expand_modules",
        "documentation": {}
    },
    {
        "label": "expand_modules",
        "importPath": "pylint.lint.expand_modules",
        "description": "pylint.lint.expand_modules",
        "isExtraImport": true,
        "detail": "pylint.lint.expand_modules",
        "documentation": {}
    },
    {
        "label": "get_python_path",
        "importPath": "pylint.lint.expand_modules",
        "description": "pylint.lint.expand_modules",
        "isExtraImport": true,
        "detail": "pylint.lint.expand_modules",
        "documentation": {}
    },
    {
        "label": "_MessageStateHandler",
        "importPath": "pylint.lint.message_state_handler",
        "description": "pylint.lint.message_state_handler",
        "isExtraImport": true,
        "detail": "pylint.lint.message_state_handler",
        "documentation": {}
    },
    {
        "label": "check_parallel",
        "importPath": "pylint.lint.parallel",
        "description": "pylint.lint.parallel",
        "isExtraImport": true,
        "detail": "pylint.lint.parallel",
        "documentation": {}
    },
    {
        "label": "report_messages_by_module_stats",
        "importPath": "pylint.lint.report_functions",
        "description": "pylint.lint.report_functions",
        "isExtraImport": true,
        "detail": "pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "report_messages_stats",
        "importPath": "pylint.lint.report_functions",
        "description": "pylint.lint.report_functions",
        "isExtraImport": true,
        "detail": "pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "report_total_messages_stats",
        "importPath": "pylint.lint.report_functions",
        "description": "pylint.lint.report_functions",
        "isExtraImport": true,
        "detail": "pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters.base_reporter",
        "description": "pylint.reporters.base_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "TextReporter",
        "importPath": "pylint.reporters.text",
        "description": "pylint.reporters.text",
        "isExtraImport": true,
        "detail": "pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "_config_initialization",
        "importPath": "pylint.config.config_initialization",
        "description": "pylint.config.config_initialization",
        "isExtraImport": true,
        "detail": "pylint.config.config_initialization",
        "documentation": {}
    },
    {
        "label": "_config_initialization",
        "importPath": "pylint.config.config_initialization",
        "description": "pylint.config.config_initialization",
        "isExtraImport": true,
        "detail": "pylint.config.config_initialization",
        "documentation": {}
    },
    {
        "label": "PYLINT_HOME",
        "importPath": "pylint.config",
        "description": "pylint.config",
        "isExtraImport": true,
        "detail": "pylint.config",
        "documentation": {}
    },
    {
        "label": "MessageIdStore",
        "importPath": "pylint.message.message_id_store",
        "description": "pylint.message.message_id_store",
        "isExtraImport": true,
        "detail": "pylint.message.message_id_store",
        "documentation": {}
    },
    {
        "label": "is_deleted_msgid",
        "importPath": "pylint.message._deleted_message_ids",
        "description": "pylint.message._deleted_message_ids",
        "isExtraImport": true,
        "detail": "pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_deleted_symbol",
        "importPath": "pylint.message._deleted_message_ids",
        "description": "pylint.message._deleted_message_ids",
        "isExtraImport": true,
        "detail": "pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_moved_msgid",
        "importPath": "pylint.message._deleted_message_ids",
        "description": "pylint.message._deleted_message_ids",
        "isExtraImport": true,
        "detail": "pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_moved_symbol",
        "importPath": "pylint.message._deleted_message_ids",
        "description": "pylint.message._deleted_message_ids",
        "isExtraImport": true,
        "detail": "pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "ClassDiagram",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "PackageDiagram",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "ClassDiagram",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "ClassEntity",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "DiagramEntity",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "PackageDiagram",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "PackageEntity",
        "importPath": "pylint.pyreverse.diagrams",
        "description": "pylint.pyreverse.diagrams",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "Linker",
        "importPath": "pylint.pyreverse.inspector",
        "description": "pylint.pyreverse.inspector",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "Project",
        "importPath": "pylint.pyreverse.inspector",
        "description": "pylint.pyreverse.inspector",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "Linker",
        "importPath": "pylint.pyreverse.inspector",
        "description": "pylint.pyreverse.inspector",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "project_from_files",
        "importPath": "pylint.pyreverse.inspector",
        "description": "pylint.pyreverse.inspector",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "LocalsVisitor",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "FilterMixIn",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "is_interface",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation_label",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "check_graphviz_availability",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "check_if_graphviz_supports_format",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "insert_default_options",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation_label",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation_label",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation_label",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "is_exception",
        "importPath": "pylint.pyreverse.utils",
        "description": "pylint.pyreverse.utils",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Layout",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Layout",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Layout",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "importPath": "pylint.pyreverse.printer",
        "description": "pylint.pyreverse.printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pylint.pyreverse",
        "description": "pylint.pyreverse",
        "isExtraImport": true,
        "detail": "pylint.pyreverse",
        "documentation": {}
    },
    {
        "label": "writer",
        "importPath": "pylint.pyreverse",
        "description": "pylint.pyreverse",
        "isExtraImport": true,
        "detail": "pylint.pyreverse",
        "documentation": {}
    },
    {
        "label": "DiadefsHandler",
        "importPath": "pylint.pyreverse.diadefslib",
        "description": "pylint.pyreverse.diadefslib",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.diadefslib",
        "documentation": {}
    },
    {
        "label": "DotPrinter",
        "importPath": "pylint.pyreverse.dot_printer",
        "description": "pylint.pyreverse.dot_printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.dot_printer",
        "documentation": {}
    },
    {
        "label": "HTMLMermaidJSPrinter",
        "importPath": "pylint.pyreverse.mermaidjs_printer",
        "description": "pylint.pyreverse.mermaidjs_printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.mermaidjs_printer",
        "documentation": {}
    },
    {
        "label": "MermaidJSPrinter",
        "importPath": "pylint.pyreverse.mermaidjs_printer",
        "description": "pylint.pyreverse.mermaidjs_printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.mermaidjs_printer",
        "documentation": {}
    },
    {
        "label": "PlantUmlPrinter",
        "importPath": "pylint.pyreverse.plantuml_printer",
        "description": "pylint.pyreverse.plantuml_printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.plantuml_printer",
        "documentation": {}
    },
    {
        "label": "VCGPrinter",
        "importPath": "pylint.pyreverse.vcg_printer",
        "description": "pylint.pyreverse.vcg_printer",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "get_printer_for_filetype",
        "importPath": "pylint.pyreverse.printer_factory",
        "description": "pylint.pyreverse.printer_factory",
        "isExtraImport": true,
        "detail": "pylint.pyreverse.printer_factory",
        "documentation": {}
    },
    {
        "label": "BaseWriter",
        "importPath": "pylint.reporters.ureports.base_writer",
        "description": "pylint.reporters.ureports.base_writer",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.base_writer",
        "documentation": {}
    },
    {
        "label": "BaseWriter",
        "importPath": "pylint.reporters.ureports.base_writer",
        "description": "pylint.reporters.ureports.base_writer",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.base_writer",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters",
        "description": "pylint.reporters",
        "isExtraImport": true,
        "detail": "pylint.reporters",
        "documentation": {}
    },
    {
        "label": "JSONReporter",
        "importPath": "pylint.reporters",
        "description": "pylint.reporters",
        "isExtraImport": true,
        "detail": "pylint.reporters",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "importPath": "pylint.reporters",
        "description": "pylint.reporters",
        "isExtraImport": true,
        "detail": "pylint.reporters",
        "documentation": {}
    },
    {
        "label": "TextWriter",
        "importPath": "pylint.reporters.ureports.text_writer",
        "description": "pylint.reporters.ureports.text_writer",
        "isExtraImport": true,
        "detail": "pylint.reporters.ureports.text_writer",
        "documentation": {}
    },
    {
        "label": "Git",
        "importPath": "git.cmd",
        "description": "git.cmd",
        "isExtraImport": true,
        "detail": "git.cmd",
        "documentation": {}
    },
    {
        "label": "Git",
        "importPath": "git.cmd",
        "description": "git.cmd",
        "isExtraImport": true,
        "detail": "git.cmd",
        "documentation": {}
    },
    {
        "label": "Repo",
        "importPath": "git.repo",
        "description": "git.repo",
        "isExtraImport": true,
        "detail": "git.repo",
        "documentation": {}
    },
    {
        "label": "Repo",
        "importPath": "git.repo",
        "description": "git.repo",
        "isExtraImport": true,
        "detail": "git.repo",
        "documentation": {}
    },
    {
        "label": "Repo",
        "importPath": "git.repo",
        "description": "git.repo",
        "isExtraImport": true,
        "detail": "git.repo",
        "documentation": {}
    },
    {
        "label": "PackageToLint",
        "importPath": "pylint.testutils._primer",
        "description": "pylint.testutils._primer",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer",
        "documentation": {}
    },
    {
        "label": "PackageToLint",
        "importPath": "pylint.testutils._primer",
        "description": "pylint.testutils._primer",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer",
        "documentation": {}
    },
    {
        "label": "PrimerCommand",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PackageData",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PackageMessages",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PrimerCommand",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PrimerCommand",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PackageData",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PackageMessages",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PrimerCommand",
        "importPath": "pylint.testutils._primer.primer_command",
        "description": "pylint.testutils._primer.primer_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "CompareCommand",
        "importPath": "pylint.testutils._primer.primer_compare_command",
        "description": "pylint.testutils._primer.primer_compare_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_compare_command",
        "documentation": {}
    },
    {
        "label": "PrepareCommand",
        "importPath": "pylint.testutils._primer.primer_prepare_command",
        "description": "pylint.testutils._primer.primer_prepare_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_prepare_command",
        "documentation": {}
    },
    {
        "label": "RunCommand",
        "importPath": "pylint.testutils._primer.primer_run_command",
        "description": "pylint.testutils._primer.primer_run_command",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.primer_run_command",
        "documentation": {}
    },
    {
        "label": "OldJsonExport",
        "importPath": "pylint.reporters.json_reporter",
        "description": "pylint.reporters.json_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "OldJsonExport",
        "importPath": "pylint.reporters.json_reporter",
        "description": "pylint.reporters.json_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "OldJsonExport",
        "importPath": "pylint.reporters.json_reporter",
        "description": "pylint.reporters.json_reporter",
        "isExtraImport": true,
        "detail": "pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "PackageToLint",
        "importPath": "pylint.testutils._primer.package_to_lint",
        "description": "pylint.testutils._primer.package_to_lint",
        "isExtraImport": true,
        "detail": "pylint.testutils._primer.package_to_lint",
        "documentation": {}
    },
    {
        "label": "FunctionalTestFile",
        "importPath": "pylint.testutils.functional.test_file",
        "description": "pylint.testutils.functional.test_file",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "FunctionalTestFile",
        "importPath": "pylint.testutils.functional.test_file",
        "description": "pylint.testutils.functional.test_file",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "# need to import from functional.test_file to avoid cyclic import\n    FunctionalTestFile",
        "importPath": "pylint.testutils.functional.test_file",
        "description": "pylint.testutils.functional.test_file",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "NoFileError",
        "importPath": "pylint.testutils.functional.test_file",
        "description": "pylint.testutils.functional.test_file",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "parse_python_version",
        "importPath": "pylint.testutils.functional.test_file",
        "description": "pylint.testutils.functional.test_file",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "LintModuleTest",
        "importPath": "pylint.testutils.lint_module_test",
        "description": "pylint.testutils.lint_module_test",
        "isExtraImport": true,
        "detail": "pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "MessageCounter",
        "importPath": "pylint.testutils.lint_module_test",
        "description": "pylint.testutils.lint_module_test",
        "isExtraImport": true,
        "detail": "pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "PYLINTRC",
        "importPath": "pylint.testutils.lint_module_test",
        "description": "pylint.testutils.lint_module_test",
        "isExtraImport": true,
        "detail": "pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "OutputLine",
        "importPath": "pylint.testutils.output_line",
        "description": "pylint.testutils.output_line",
        "isExtraImport": true,
        "detail": "pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "MessageTest",
        "importPath": "pylint.testutils.output_line",
        "description": "pylint.testutils.output_line",
        "isExtraImport": true,
        "detail": "pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "OutputLine",
        "importPath": "pylint.testutils.output_line",
        "description": "pylint.testutils.output_line",
        "isExtraImport": true,
        "detail": "pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "MessageTest",
        "importPath": "pylint.testutils.output_line",
        "description": "pylint.testutils.output_line",
        "isExtraImport": true,
        "detail": "pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "UNUSED_PARAM_SENTINEL",
        "importPath": "pylint.lint.run",
        "description": "pylint.lint.run",
        "isExtraImport": true,
        "detail": "pylint.lint.run",
        "documentation": {}
    },
    {
        "label": "linter",
        "importPath": "pylint.testutils.global_test_linter",
        "description": "pylint.testutils.global_test_linter",
        "isExtraImport": true,
        "detail": "pylint.testutils.global_test_linter",
        "documentation": {}
    },
    {
        "label": "UnittestLinter",
        "importPath": "pylint.testutils.unittest_linter",
        "description": "pylint.testutils.unittest_linter",
        "isExtraImport": true,
        "detail": "pylint.testutils.unittest_linter",
        "documentation": {}
    },
    {
        "label": "CheckerTestCase",
        "importPath": "pylint.testutils.checker_test_case",
        "description": "pylint.testutils.checker_test_case",
        "isExtraImport": true,
        "detail": "pylint.testutils.checker_test_case",
        "documentation": {}
    },
    {
        "label": "FunctionalTestFile",
        "importPath": "pylint.testutils.functional",
        "description": "pylint.testutils.functional",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional",
        "documentation": {}
    },
    {
        "label": "NoFileError",
        "importPath": "pylint.testutils.functional",
        "description": "pylint.testutils.functional",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional",
        "documentation": {}
    },
    {
        "label": "parse_python_version",
        "importPath": "pylint.testutils.functional",
        "description": "pylint.testutils.functional",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional",
        "documentation": {}
    },
    {
        "label": "SYS_VERS_STR",
        "importPath": "pylint.testutils.constants",
        "description": "pylint.testutils.constants",
        "isExtraImport": true,
        "detail": "pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "_EXPECTED_RE",
        "importPath": "pylint.testutils.constants",
        "description": "pylint.testutils.constants",
        "isExtraImport": true,
        "detail": "pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "_OPERATORS",
        "importPath": "pylint.testutils.constants",
        "description": "pylint.testutils.constants",
        "isExtraImport": true,
        "detail": "pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "UPDATE_OPTION",
        "importPath": "pylint.testutils.constants",
        "description": "pylint.testutils.constants",
        "isExtraImport": true,
        "detail": "pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "UPDATE_OPTION",
        "importPath": "pylint.testutils.constants",
        "description": "pylint.testutils.constants",
        "isExtraImport": true,
        "detail": "pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "GenericTestReporter",
        "importPath": "pylint.testutils.reporter_for_tests",
        "description": "pylint.testutils.reporter_for_tests",
        "isExtraImport": true,
        "detail": "pylint.testutils.reporter_for_tests",
        "documentation": {}
    },
    {
        "label": "FunctionalTestReporter",
        "importPath": "pylint.testutils.reporter_for_tests",
        "description": "pylint.testutils.reporter_for_tests",
        "isExtraImport": true,
        "detail": "pylint.testutils.reporter_for_tests",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message.message",
        "description": "pylint.message.message",
        "isExtraImport": true,
        "detail": "pylint.message.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "pylint.message.message",
        "description": "pylint.message.message",
        "isExtraImport": true,
        "detail": "pylint.message.message",
        "documentation": {}
    },
    {
        "label": "from functional.test_file to avoid cyclic import",
        "importPath": "pylint.testutils.functional.test_file import (  # need to",
        "description": "pylint.testutils.functional.test_file import (  # need to",
        "isExtraImport": true,
        "detail": "pylint.testutils.functional.test_file import (  # need to",
        "documentation": {}
    },
    {
        "label": "get_rst_section",
        "importPath": "pylint.utils.utils",
        "description": "pylint.utils.utils",
        "isExtraImport": true,
        "detail": "pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_rst_title",
        "importPath": "pylint.utils.utils",
        "description": "pylint.utils.utils",
        "isExtraImport": true,
        "detail": "pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "platformdirs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platformdirs",
        "description": "platformdirs",
        "detail": "platformdirs",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "pylint.__pkginfo__",
        "description": "pylint.__pkginfo__",
        "isExtraImport": true,
        "detail": "pylint.__pkginfo__",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "tomlkit._compat",
        "description": "tomlkit._compat",
        "isExtraImport": true,
        "detail": "tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "tomlkit._compat",
        "description": "tomlkit._compat",
        "isExtraImport": true,
        "detail": "tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "PY38",
        "importPath": "tomlkit._compat",
        "description": "tomlkit._compat",
        "isExtraImport": true,
        "detail": "tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "tomlkit._compat",
        "description": "tomlkit._compat",
        "isExtraImport": true,
        "detail": "tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "tomlkit._compat",
        "description": "tomlkit._compat",
        "isExtraImport": true,
        "detail": "tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "parse_rfc3339",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "merge_dicts",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "CONTROL_CHARS",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "escape_string",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "RFC_3339_LOOSE",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "_escaped",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "parse_rfc3339",
        "importPath": "tomlkit._utils",
        "description": "tomlkit._utils",
        "isExtraImport": true,
        "detail": "tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "tomlkit.container",
        "description": "tomlkit.container",
        "isExtraImport": true,
        "detail": "tomlkit.container",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "tomlkit.container",
        "description": "tomlkit.container",
        "isExtraImport": true,
        "detail": "tomlkit.container",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "tomlkit.container",
        "description": "tomlkit.container",
        "isExtraImport": true,
        "detail": "tomlkit.container",
        "documentation": {}
    },
    {
        "label": "UnexpectedCharError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "KeyAlreadyPresent",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "NonExistentKey",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "TOMLKitError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidStringError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyKeyError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyTableNameError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InternalParserError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidCharInStringError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidControlChar",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidDateError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidDateTimeError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidNumberError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidTimeError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUnicodeValueError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedCharError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedEofError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedCharError",
        "importPath": "tomlkit.exceptions",
        "description": "tomlkit.exceptions",
        "isExtraImport": true,
        "detail": "tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "AoT",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Bool",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "DottedKey",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "InlineTable",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Key",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "SingleKey",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "StringType",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Time",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Trivia",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Whitespace",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "AoT",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Key",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Null",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "SingleKey",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Trivia",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Whitespace",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "_CustomDict",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "AoT",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Bool",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "BoolType",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "InlineTable",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Key",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "KeyType",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Null",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "SingleKey",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "StringType",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Time",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Trivia",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Whitespace",
        "importPath": "tomlkit.items",
        "description": "tomlkit.items",
        "isExtraImport": true,
        "detail": "tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "tomlkit.parser",
        "description": "tomlkit.parser",
        "isExtraImport": true,
        "detail": "tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "TOMLDocument",
        "importPath": "tomlkit.toml_document",
        "description": "tomlkit.toml_document",
        "isExtraImport": true,
        "detail": "tomlkit.toml_document",
        "documentation": {}
    },
    {
        "label": "TOMLDocument",
        "importPath": "tomlkit.toml_document",
        "description": "tomlkit.toml_document",
        "isExtraImport": true,
        "detail": "tomlkit.toml_document",
        "documentation": {}
    },
    {
        "label": "TOMLDocument",
        "importPath": "tomlkit.toml_document",
        "description": "tomlkit.toml_document",
        "isExtraImport": true,
        "detail": "tomlkit.toml_document",
        "documentation": {}
    },
    {
        "label": "Source",
        "importPath": "tomlkit.source",
        "description": "tomlkit.source",
        "isExtraImport": true,
        "detail": "tomlkit.source",
        "documentation": {}
    },
    {
        "label": "TOMLChar",
        "importPath": "tomlkit.toml_char",
        "description": "tomlkit.toml_char",
        "isExtraImport": true,
        "detail": "tomlkit.toml_char",
        "documentation": {}
    },
    {
        "label": "TOMLChar",
        "importPath": "tomlkit.toml_char",
        "description": "tomlkit.toml_char",
        "isExtraImport": true,
        "detail": "tomlkit.toml_char",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "tomlkit.api",
        "description": "tomlkit.api",
        "isExtraImport": true,
        "detail": "tomlkit.api",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "pycodestyle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pycodestyle",
        "description": "pycodestyle",
        "detail": "pycodestyle",
        "documentation": {}
    },
    {
        "label": "STARTSWITH_INDENT_STATEMENT_REGEX",
        "importPath": "pycodestyle",
        "description": "pycodestyle",
        "isExtraImport": true,
        "detail": "pycodestyle",
        "documentation": {}
    },
    {
        "label": "_pytest._py.error",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest._py.error",
        "description": "_pytest._py.error",
        "detail": "_pytest._py.error",
        "documentation": {}
    },
    {
        "label": "_pytest._py.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pytest._py.path",
        "description": "_pytest._py.path",
        "detail": "_pytest._py.path",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "kind": 6,
        "importPath": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "description": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "peekOfCode": "class ValueObject(ABC):\n    def __str__(self) -> str:\n        fields_name = [f.name for f in fields(self)]\n        return str(getattr(self, fields_name[0])) \\\n                   if len(fields_name) == 1 \\\n                   else json.dumps({field_name: getattr(self, field_name) for field_name in fields_name})\n@dataclass(frozen=True)\nclass UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())",
        "detail": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "kind": 6,
        "importPath": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "description": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "peekOfCode": "class UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())\n                    )\n    def __post_init__(self):\n        id_value = str(self.id) if isinstance(self.id, uuid.UUID) else self.id\n        object.__setattr__(self, 'id', id_value)\n        self.__validate()\n    def __validate(self):\n        try:",
        "detail": ".history.src.__seedwork.domain.value_objects_20230222185318",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "kind": 6,
        "importPath": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "description": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "peekOfCode": "class ValueObject(ABC):\n    def __str__(self) -> str:\n        fields_name = [f.name for f in fields(self)]\n        return str(getattr(self, fields_name[0])) \\\n                   if len(fields_name) == 1 \\\n                   else json.dumps({field_name: getattr(self, field_name) for field_name in fields_name})\n@dataclass(frozen=True)\nclass UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())",
        "detail": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "kind": 6,
        "importPath": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "description": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "peekOfCode": "class UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())\n                    )\n    def __post_init__(self):\n        id_value = str(self.id) if isinstance(self.id, uuid.UUID) else self.id\n        object.__setattr__(self, 'id', id_value)\n        self.__validate()\n    def __validate(self):\n        try:",
        "detail": ".history.src.__seedwork.domain.value_objects_20230223120800",
        "documentation": {}
    },
    {
        "label": "Entity",
        "kind": 6,
        "importPath": ".history.src.__seedwork.entities.entities_20230222182350",
        "description": ".history.src.__seedwork.entities.entities_20230222182350",
        "peekOfCode": "class Entity(ABC):\n    unique_entity_id: UniqueEntityId = field(default_factory=lambda: UniqueEntityId())\n    @property\n    def id(self):\n        return str(self.unique_entity_id)\n    def to_dict(self):\n        entity_dict = asdict(self)\n        entity_dict.pop('unique_entity_id')\n        entity_dict['id'] = self.id\n        return entity_dict",
        "detail": ".history.src.__seedwork.entities.entities_20230222182350",
        "documentation": {}
    },
    {
        "label": "Entity",
        "kind": 6,
        "importPath": ".history.src.__seedwork.entities.entities_20230223120807",
        "description": ".history.src.__seedwork.entities.entities_20230223120807",
        "peekOfCode": "class Entity(ABC):\n    unique_entity_id: UniqueEntityId = field(default_factory=lambda: UniqueEntityId())\n    @property\n    def id(self):\n        return str(self.unique_entity_id)\n    def to_dict(self):\n        entity_dict = asdict(self)\n        entity_dict.pop('unique_entity_id')\n        entity_dict['id'] = self.id\n        return entity_dict",
        "detail": ".history.src.__seedwork.entities.entities_20230223120807",
        "documentation": {}
    },
    {
        "label": "StubEntity",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "peekOfCode": "class StubEntity(Entity):\n    prop1: str\n    prop2: str\nclass TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "documentation": {}
    },
    {
        "label": "TestEntityUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "peekOfCode": "class TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')\n        self.assertEqual(entity.prop1, 'some id')\n        self.assertEqual(entity.prop2, 'some prop')\n        self.assertIsInstance(entity.unique_entity_id, UniqueEntityId)",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230222185806",
        "documentation": {}
    },
    {
        "label": "StubEntity",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "peekOfCode": "class StubEntity(Entity):\n    prop1: str\n    prop2: str\nclass TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "documentation": {}
    },
    {
        "label": "TestEntityUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "peekOfCode": "class TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')\n        self.assertEqual(entity.prop1, 'some id')\n        self.assertEqual(entity.prop2, 'some prop')\n        self.assertIsInstance(entity.unique_entity_id, UniqueEntityId)",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120447",
        "documentation": {}
    },
    {
        "label": "StubEntity",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "peekOfCode": "class StubEntity(Entity):\n    prop1: str\n    prop2: str\nclass TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "documentation": {}
    },
    {
        "label": "TestEntityUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "peekOfCode": "class TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')\n        self.assertEqual(entity.prop1, 'some id')\n        self.assertEqual(entity.prop2, 'some prop')\n        self.assertIsInstance(entity.unique_entity_id, UniqueEntityId)",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_entities_20230223120451",
        "documentation": {}
    },
    {
        "label": "StubOneProp",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "peekOfCode": "class StubOneProp(ValueObject):\n    prop: str\n@dataclass(frozen=True)\nclass StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "documentation": {}
    },
    {
        "label": "StubTwoProp",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "peekOfCode": "class StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "documentation": {}
    },
    {
        "label": "TestValueObjectUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "peekOfCode": "class TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')\n        self.assertEqual(value_object.prop, 'some value')\n        value_object2 = StubTwoProp(prop1='some value', prop2='some value 2')\n        self.assertEqual(value_object2.prop1, 'some value')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "documentation": {}
    },
    {
        "label": "TestUniqueEntityIdUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "peekOfCode": "class TestUniqueEntityIdUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_throw_exception_when_uuid_is_invalid(self):\n        with patch.object(\n            UniqueEntityId,\n            '_UniqueEntityId__validate',\n            autospec=True,\n            side_effect=UniqueEntityId._UniqueEntityId__validate\n        ) as mock_validate:",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230222185038",
        "documentation": {}
    },
    {
        "label": "StubOneProp",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "peekOfCode": "class StubOneProp(ValueObject):\n    prop: str\n@dataclass(frozen=True)\nclass StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "documentation": {}
    },
    {
        "label": "StubTwoProp",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "peekOfCode": "class StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "documentation": {}
    },
    {
        "label": "TestValueObjectUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "peekOfCode": "class TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')\n        self.assertEqual(value_object.prop, 'some value')\n        value_object2 = StubTwoProp(prop1='some value', prop2='some value 2')\n        self.assertEqual(value_object2.prop1, 'some value')",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "documentation": {}
    },
    {
        "label": "TestUniqueEntityIdUnit",
        "kind": 6,
        "importPath": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "description": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "peekOfCode": "class TestUniqueEntityIdUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_throw_exception_when_uuid_is_invalid(self):\n        with patch.object(\n            UniqueEntityId,\n            '_UniqueEntityId__validate',\n            autospec=True,\n            side_effect=UniqueEntityId._UniqueEntityId__validate\n        ) as mock_validate:",
        "detail": ".history.src.__seedwork.tests.unit.domain.test_unit_value_object_20230223120511",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220112307",
        "description": ".history.src.category.domain.entities_20230220112307",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name",
        "detail": ".history.src.category.domain.entities_20230220112307",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113734",
        "description": ".history.src.category.domain.entities_20230220113734",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name",
        "detail": ".history.src.category.domain.entities_20230220113734",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113738",
        "description": ".history.src.category.domain.entities_20230220113738",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name",
        "detail": ".history.src.category.domain.entities_20230220113738",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113739",
        "description": ".history.src.category.domain.entities_20230220113739",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name",
        "detail": ".history.src.category.domain.entities_20230220113739",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113744",
        "description": ".history.src.category.domain.entities_20230220113744",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name\n# create -",
        "detail": ".history.src.category.domain.entities_20230220113744",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113804",
        "description": ".history.src.category.domain.entities_20230220113804",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name\n        self.descr",
        "detail": ".history.src.category.domain.entities_20230220113804",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113816",
        "description": ".history.src.category.domain.entities_20230220113816",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active =",
        "detail": ".history.src.category.domain.entities_20230220113816",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113821",
        "description": ".history.src.category.domain.entities_20230220113821",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.",
        "detail": ".history.src.category.domain.entities_20230220113821",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113828",
        "description": ".history.src.category.domain.entities_20230220113828",
        "peekOfCode": "class Category:\n    def __init__(self, name, description, is_active, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113828",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113837",
        "description": ".history.src.category.domain.entities_20230220113837",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description, is_active, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113837",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113841",
        "description": ".history.src.category.domain.entities_20230220113841",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113841",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113844",
        "description": ".history.src.category.domain.entities_20230220113844",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active:bool , created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113844",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113848",
        "description": ".history.src.category.domain.entities_20230220113848",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active:bool, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113848",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113851",
        "description": ".history.src.category.domain.entities_20230220113851",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113851",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113856",
        "description": ".history.src.category.domain.entities_20230220113856",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113856",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113906",
        "description": ".history.src.category.domain.entities_20230220113906",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113906",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113912",
        "description": ".history.src.category.domain.entities_20230220113912",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113912",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220113914",
        "description": ".history.src.category.domain.entities_20230220113914",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220113914",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220115612",
        "description": ".history.src.category.domain.entities_20230220115612",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220115612",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134229",
        "description": ".history.src.category.domain.entities_20230220134229",
        "peekOfCode": "class Category:\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134229",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134236",
        "description": ".history.src.category.domain.entities_20230220134236",
        "peekOfCode": "class Category:\n    name: str\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134236",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134242",
        "description": ".history.src.category.domain.entities_20230220134242",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134242",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134247",
        "description": ".history.src.category.domain.entities_20230220134247",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134247",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134250",
        "description": ".history.src.category.domain.entities_20230220134250",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    create\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134250",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134253",
        "description": ".history.src.category.domain.entities_20230220134253",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134253",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134512",
        "description": ".history.src.category.domain.entities_20230220134512",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134512",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134516",
        "description": ".history.src.category.domain.entities_20230220134516",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134516",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134518",
        "description": ".history.src.category.domain.entities_20230220134518",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134518",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134531",
        "description": ".history.src.category.domain.entities_20230220134531",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime\n    def __init__(self, name: str, description: str, is_active: bool, created_at: datetime) -> None:\n        self.name = name\n        self.description = description\n        self.is_active = is_active\n        self.created_at = created_at",
        "detail": ".history.src.category.domain.entities_20230220134531",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134539",
        "description": ".history.src.category.domain.entities_20230220134539",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134539",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134541",
        "description": ".history.src.category.domain.entities_20230220134541",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134541",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134645",
        "description": ".history.src.category.domain.entities_20230220134645",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134645",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134648",
        "description": ".history.src.category.domain.entities_20230220134648",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134648",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134649",
        "description": ".history.src.category.domain.entities_20230220134649",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134649",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134707",
        "description": ".history.src.category.domain.entities_20230220134707",
        "peekOfCode": "class Category:\n    name: str\n    description: str\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134707",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134842",
        "description": ".history.src.category.domain.entities_20230220134842",
        "peekOfCode": "class Category:\n    name: str\n    description: str = no\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134842",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134845",
        "description": ".history.src.category.domain.entities_20230220134845",
        "peekOfCode": "class Category:\n    name: str\n    description: str = None\n    is_active: bool\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134845",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134849",
        "description": ".history.src.category.domain.entities_20230220134849",
        "peekOfCode": "class Category:\n    name: str\n    description: str = None\n    is_active: bool = True\n    created_at: datetime",
        "detail": ".history.src.category.domain.entities_20230220134849",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134855",
        "description": ".history.src.category.domain.entities_20230220134855",
        "peekOfCode": "class Category:\n    name: str\n    description: str = None\n    is_active: bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134855",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134912",
        "description": ".history.src.category.domain.entities_20230220134912",
        "peekOfCode": "class Category:\n    name: str\n    description: Optionalstr = None\n    is_active: bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134912",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134914",
        "description": ".history.src.category.domain.entities_20230220134914",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str = None\n    is_active: bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134914",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134916",
        "description": ".history.src.category.domain.entities_20230220134916",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134916",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134928",
        "description": ".history.src.category.domain.entities_20230220134928",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134928",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134941",
        "description": ".history.src.category.domain.entities_20230220134941",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optionalbool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134941",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134943",
        "description": ".history.src.category.domain.entities_20230220134943",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134943",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134946",
        "description": ".history.src.category.domain.entities_20230220134946",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134946",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134951",
        "description": ".history.src.category.domain.entities_20230220134951",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optidatetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134951",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134952",
        "description": ".history.src.category.domain.entities_20230220134952",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optionaldatetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134952",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134954",
        "description": ".history.src.category.domain.entities_20230220134954",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134954",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220134957",
        "description": ".history.src.category.domain.entities_20230220134957",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220134957",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220135111",
        "description": ".history.src.category.domain.entities_20230220135111",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = fielddatetime.now()",
        "detail": ".history.src.category.domain.entities_20230220135111",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220135115",
        "description": ".history.src.category.domain.entities_20230220135115",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factorydatetime.now()",
        "detail": ".history.src.category.domain.entities_20230220135115",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220135119",
        "description": ".history.src.category.domain.entities_20230220135119",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now()",
        "detail": ".history.src.category.domain.entities_20230220135119",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220135122",
        "description": ".history.src.category.domain.entities_20230220135122",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())",
        "detail": ".history.src.category.domain.entities_20230220135122",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220135129",
        "description": ".history.src.category.domain.entities_20230220135129",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())",
        "detail": ".history.src.category.domain.entities_20230220135129",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141849",
        "description": ".history.src.category.domain.entities_20230220141849",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    #",
        "detail": ".history.src.category.domain.entities_20230220141849",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141854",
        "description": ".history.src.category.domain.entities_20230220141854",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes",
        "detail": ".history.src.category.domain.entities_20230220141854",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141856",
        "description": ".history.src.category.domain.entities_20230220141856",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # -",
        "detail": ".history.src.category.domain.entities_20230220141856",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141859",
        "description": ".history.src.category.domain.entities_20230220141859",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade",
        "detail": ".history.src.category.domain.entities_20230220141859",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141901",
        "description": ".history.src.category.domain.entities_20230220141901",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # -",
        "detail": ".history.src.category.domain.entities_20230220141901",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141905",
        "description": ".history.src.category.domain.entities_20230220141905",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração",
        "detail": ".history.src.category.domain.entities_20230220141905",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141909",
        "description": ".history.src.category.domain.entities_20230220141909",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    -$ç",
        "detail": ".history.src.category.domain.entities_20230220141909",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141922",
        "description": ".history.src.category.domain.entities_20230220141922",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração",
        "detail": ".history.src.category.domain.entities_20230220141922",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141924",
        "description": ".history.src.category.domain.entities_20230220141924",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # -",
        "detail": ".history.src.category.domain.entities_20230220141924",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220141958",
        "description": ".history.src.category.domain.entities_20230220141958",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # -b2",
        "detail": ".history.src.category.domain.entities_20230220141958",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220142001",
        "description": ".history.src.category.domain.entities_20230220142001",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # -e2e",
        "detail": ".history.src.category.domain.entities_20230220142001",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230220142003",
        "description": ".history.src.category.domain.entities_20230220142003",
        "peekOfCode": "class Category:\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # - e2e",
        "detail": ".history.src.category.domain.entities_20230220142003",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.domain.entities_20230223120528",
        "description": ".history.src.category.domain.entities_20230223120528",
        "peekOfCode": "class Category(Entity):\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # - e2e",
        "detail": ".history.src.category.domain.entities_20230223120528",
        "documentation": {}
    },
    {
        "label": "Tes",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114600",
        "description": ".history.src.category.tests.domain.__init___20230220114600",
        "peekOfCode": "class Test",
        "detail": ".history.src.category.tests.domain.__init___20230220114600",
        "documentation": {}
    },
    {
        "label": "TestCategor",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114603",
        "description": ".history.src.category.tests.domain.__init___20230220114603",
        "peekOfCode": "class TestCategory",
        "detail": ".history.src.category.tests.domain.__init___20230220114603",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114605",
        "description": ".history.src.category.tests.domain.__init___20230220114605",
        "peekOfCode": "class TestCategory()",
        "detail": ".history.src.category.tests.domain.__init___20230220114605",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114611",
        "description": ".history.src.category.tests.domain.__init___20230220114611",
        "peekOfCode": "class TestCategory(unit)",
        "detail": ".history.src.category.tests.domain.__init___20230220114611",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114612",
        "description": ".history.src.category.tests.domain.__init___20230220114612",
        "peekOfCode": "class TestCategory(unitT)",
        "detail": ".history.src.category.tests.domain.__init___20230220114612",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114615",
        "description": ".history.src.category.tests.domain.__init___20230220114615",
        "peekOfCode": "class TestCategory(unittest.)",
        "detail": ".history.src.category.tests.domain.__init___20230220114615",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114619",
        "description": ".history.src.category.tests.domain.__init___20230220114619",
        "peekOfCode": "class TestCategory(unittest.TestCase)",
        "detail": ".history.src.category.tests.domain.__init___20230220114619",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.__init___20230220114621",
        "description": ".history.src.category.tests.domain.__init___20230220114621",
        "peekOfCode": "class TestCategory(unittest.TestCase):",
        "detail": ".history.src.category.tests.domain.__init___20230220114621",
        "documentation": {}
    },
    {
        "label": "Tes",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114848",
        "description": ".history.src.category.tests.domain.test_entities_20230220114848",
        "peekOfCode": "class Test",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114848",
        "documentation": {}
    },
    {
        "label": "TestCate",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114851",
        "description": ".history.src.category.tests.domain.test_entities_20230220114851",
        "peekOfCode": "class TestCateg",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114851",
        "documentation": {}
    },
    {
        "label": "TestCategor",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114853",
        "description": ".history.src.category.tests.domain.test_entities_20230220114853",
        "peekOfCode": "class TestCategory",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114853",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114902",
        "description": ".history.src.category.tests.domain.test_entities_20230220114902",
        "peekOfCode": "class TestCategory(unittest.)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114902",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114903",
        "description": ".history.src.category.tests.domain.test_entities_20230220114903",
        "peekOfCode": "class TestCategory(unittest.T)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114903",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114905",
        "description": ".history.src.category.tests.domain.test_entities_20230220114905",
        "peekOfCode": "class TestCategory(unittest.Tes)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114905",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114907",
        "description": ".history.src.category.tests.domain.test_entities_20230220114907",
        "peekOfCode": "class TestCategory(unittest.Testcase)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114907",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114912",
        "description": ".history.src.category.tests.domain.test_entities_20230220114912",
        "peekOfCode": "class TestCategory(unittest.TestCase)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114912",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114915",
        "description": ".history.src.category.tests.domain.test_entities_20230220114915",
        "peekOfCode": "class TestCategory(unittest.TestCase):",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114915",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114928",
        "description": ".history.src.category.tests.domain.test_entities_20230220114928",
        "peekOfCode": "class TestCategory(unittest.TestCase):",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114928",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114931",
        "description": ".history.src.category.tests.domain.test_entities_20230220114931",
        "peekOfCode": "class TestCategory(unittest.TestCase):",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114931",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114934",
        "description": ".history.src.category.tests.domain.test_entities_20230220114934",
        "peekOfCode": "class TestCategory(unittest.TestCase):",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114934",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114943",
        "description": ".history.src.category.tests.domain.test_entities_20230220114943",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114943",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114946",
        "description": ".history.src.category.tests.domain.test_entities_20230220114946",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114946",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220114949",
        "description": ".history.src.category.tests.domain.test_entities_20230220114949",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category",
        "detail": ".history.src.category.tests.domain.test_entities_20230220114949",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115011",
        "description": ".history.src.category.tests.domain.test_entities_20230220115011",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115011",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115047",
        "description": ".history.src.category.tests.domain.test_entities_20230220115047",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115047",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115053",
        "description": ".history.src.category.tests.domain.test_entities_20230220115053",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', )",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115053",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115058",
        "description": ".history.src.category.tests.domain.test_entities_20230220115058",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115058",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115100",
        "description": ".history.src.category.tests.domain.test_entities_20230220115100",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115100",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115105",
        "description": ".history.src.category.tests.domain.test_entities_20230220115105",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115105",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115111",
        "description": ".history.src.category.tests.domain.test_entities_20230220115111",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        assert",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115111",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115117",
        "description": ".history.src.category.tests.domain.test_entities_20230220115117",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        self.assser",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115117",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115120",
        "description": ".history.src.category.tests.domain.test_entities_20230220115120",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115120",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115124",
        "description": ".history.src.category.tests.domain.test_entities_20230220115124",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115124",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115126",
        "description": ".history.src.category.tests.domain.test_entities_20230220115126",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115126",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115129",
        "description": ".history.src.category.tests.domain.test_entities_20230220115129",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115129",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115134",
        "description": ".history.src.category.tests.domain.test_entities_20230220115134",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115134",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115208",
        "description": ".history.src.category.tests.domain.test_entities_20230220115208",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    dpyest_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115208",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115209",
        "description": ".history.src.category.tests.domain.test_entities_20230220115209",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115209",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115311",
        "description": ".history.src.category.tests.domain.test_entities_20230220115311",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115311",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115324",
        "description": ".history.src.category.tests.domain.test_entities_20230220115324",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115324",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115329",
        "description": ".history.src.category.tests.domain.test_entities_20230220115329",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual()",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115329",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115332",
        "description": ".history.src.category.tests.domain.test_entities_20230220115332",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115332",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115336",
        "description": ".history.src.category.tests.domain.test_entities_20230220115336",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.name)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115336",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115340",
        "description": ".history.src.category.tests.domain.test_entities_20230220115340",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115340",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115344",
        "description": ".history.src.category.tests.domain.test_entities_20230220115344",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115344",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115349",
        "description": ".history.src.category.tests.domain.test_entities_20230220115349",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.asser",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115349",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115352",
        "description": ".history.src.category.tests.domain.test_entities_20230220115352",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual()",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115352",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115354",
        "description": ".history.src.category.tests.domain.test_entities_20230220115354",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(categor)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115354",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115357",
        "description": ".history.src.category.tests.domain.test_entities_20230220115357",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(category.)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115357",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115359",
        "description": ".history.src.category.tests.domain.test_entities_20230220115359",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(category.is_active)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115359",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115403",
        "description": ".history.src.category.tests.domain.test_entities_20230220115403",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115403",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115413",
        "description": ".history.src.category.tests.domain.test_entities_20230220115413",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance()",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115413",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115415",
        "description": ".history.src.category.tests.domain.test_entities_20230220115415",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.asserEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(datetime)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115415",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115427",
        "description": ".history.src.category.tests.domain.test_entities_20230220115427",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(datetime)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115427",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115437",
        "description": ".history.src.category.tests.domain.test_entities_20230220115437",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(categorydatetime)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115437",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.domain.test_entities_20230220115440",
        "description": ".history.src.category.tests.domain.test_entities_20230220115440",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.domain.test_entities_20230220115440",
        "documentation": {}
    },
    {
        "label": "TestCategory",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220115439",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220115439",
        "peekOfCode": "class TestCategory(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220115439",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220142846",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220142846",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220142846",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143245",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143245",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    #\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143245",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143248",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143248",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143248",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143253",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143253",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    # Act\n    #\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143253",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143255",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143255",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143255",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143301",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143301",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = \n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143301",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143303",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143303",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143303",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143314",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143314",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'Movie', 'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143314",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143318",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143318",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {name: 'Movie', 'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143318",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143322",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143322",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {name: 'Movie',  ''some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143322",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143323",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143323",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {name: 'Movie',  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143323",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143328",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143328",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'name: 'Movie',  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143328",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143331",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143331",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'name': 'Movie',  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143331",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143336",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143336",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'name': 'Movie', description:  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143336",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143340",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143340",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'name': 'Movie', 'description':  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143340",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143346",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143346",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {'name': 'Movie', \n    'description':  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143346",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143348",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143348",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {\n        'name': 'Movie', \n    'description':  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143348",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143351",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143351",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {\n        'name': 'Movie', \n        'description':  'some description', True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143351",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143357",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143357",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    # Arrange\n    data = {\n        'name': 'Movie', \n        'description':  'some description', \n        '': True, datetime.now()}\n    # Act\n    # Assert\n    def test_constructor(self):",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143357",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143408",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143408",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    #triple AAA\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143408",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143410",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143410",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category('Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143410",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143417",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143417",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            'Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143417",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143420",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143420",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143420",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143422",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143422",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', descr'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143422",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143426",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143426",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', description'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143426",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143427",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143427",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', description:'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143427",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143429",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143429",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', description= 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143429",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143430",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143430",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', description = 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143430",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143436",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143436",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143436",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143443",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143443",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active: True, datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143443",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143446",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143446",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active: True, \n            datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143446",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143500",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143500",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active: True, \n            created_atdatetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143500",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143502",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143502",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active: True, \n            created_at= datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143502",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143503",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143503",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active= True, \n            created_at= datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143503",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143504",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143504",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active= True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143504",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143506",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143506",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143506",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143702",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143702",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143702",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143709",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143709",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self)\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143709",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143712",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143712",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        pass\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143712",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143728",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143728",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        pass\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143728",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143731",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143731",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        pass\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143731",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143734",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143734",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        pass\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143734",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143739",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143739",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        pass\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143739",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143749",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143749",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143749",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143752",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143752",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143752",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143755",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143755",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass)\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143755",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143801",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143801",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())\n        self.assertEqual(category.name, 'Movie')",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220143801",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145139",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145139",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = \n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145139",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145143",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145143",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Ca\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145143",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145146",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145146",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145146",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145153",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145153",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        category = Category(\n            name='Movie', \n            description = 'some description', \n            is_active = True, \n            created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145153",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145156",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145156",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        # category = Category(\n        #     name='Movie', \n        #     description = 'some description', \n        #     is_active = True, \n        #     created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145156",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145206",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145206",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        # category = Category(\n        #     name='Movie', \n        #     description = 'some description', \n        #     is_active = True, \n        #     created_at = datetime.now())",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145206",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145208",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145208",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        # category = Category(",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145208",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145215",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145215",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        # category = Category(",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145215",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145247",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145247",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        # category = Category(",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145247",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145301",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145301",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, 'some description')\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        # category = Category(",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145301",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145629",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145629",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        # category = Category(",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145629",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145718",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145718",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145718",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145723",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145723",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145723",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145736",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145736",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145736",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145747",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145747",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145747",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145751",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145751",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145751",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145755",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145755",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145755",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145759",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145759",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145759",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145804",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145804",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145804",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145809",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145809",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145809",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145814",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145814",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145814",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145923",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145923",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145923",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145927",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145927",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145927",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145933",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145933",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145933",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145949",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145949",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145949",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145958",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145958",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220145958",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150021",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150021",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150021",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150041",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150041",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150041",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150048",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150048",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150048",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150049",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150049",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150049",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150052",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150052",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150052",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150053",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150053",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150053",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150057",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150057",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150057",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150058",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150058",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150058",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150101",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150101",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150101",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150104",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150104",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150104",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150108",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150108",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150108",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150109",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150109",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150109",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150111",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150111",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150111",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150115",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150115",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150115",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150121",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150121",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150121",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150128",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150128",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150128",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150444",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150444",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150444",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150448",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150448",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150448",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150452",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150452",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150452",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150457",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150457",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150457",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150502",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150502",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150502",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150505",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150505",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150505",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150518",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150518",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150518",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150523",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150523",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150523",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150529",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150529",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150529",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150537",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150537",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150537",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150539",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150539",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150539",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150556",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150556",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230220150556",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": ".history.src.category.tests.unit.domain.test_unit_entities_20230223120725",
        "description": ".history.src.category.tests.unit.domain.test_unit_entities_20230223120725",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": ".history.src.category.tests.unit.domain.test_unit_entities_20230223120725",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111714",
        "description": ".history.src.category.entities_20230220111714",
        "peekOfCode": "class Category:",
        "detail": ".history.src.category.entities_20230220111714",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111719",
        "description": ".history.src.category.entities_20230220111719",
        "peekOfCode": "class Category:\n    def __init__",
        "detail": ".history.src.category.entities_20230220111719",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111721",
        "description": ".history.src.category.entities_20230220111721",
        "peekOfCode": "class Category:\n    def __init__(sef)",
        "detail": ".history.src.category.entities_20230220111721",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111724",
        "description": ".history.src.category.entities_20230220111724",
        "peekOfCode": "class Category:\n    def __init__(self, name)",
        "detail": ".history.src.category.entities_20230220111724",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111727",
        "description": ".history.src.category.entities_20230220111727",
        "peekOfCode": "class Category:\n    def __init__(self, name) ->",
        "detail": ".history.src.category.entities_20230220111727",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111729",
        "description": ".history.src.category.entities_20230220111729",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:",
        "detail": ".history.src.category.entities_20230220111729",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111733",
        "description": ".history.src.category.entities_20230220111733",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name",
        "detail": ".history.src.category.entities_20230220111733",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111742",
        "description": ".history.src.category.entities_20230220111742",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name",
        "detail": ".history.src.category.entities_20230220111742",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111828",
        "description": ".history.src.category.entities_20230220111828",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name",
        "detail": ".history.src.category.entities_20230220111828",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111831",
        "description": ".history.src.category.entities_20230220111831",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name\nprint",
        "detail": ".history.src.category.entities_20230220111831",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111837",
        "description": ".history.src.category.entities_20230220111837",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name\nprint(vars(Category))",
        "detail": ".history.src.category.entities_20230220111837",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111839",
        "description": ".history.src.category.entities_20230220111839",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name\nprint(vars(Category('')))",
        "detail": ".history.src.category.entities_20230220111839",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220111841",
        "description": ".history.src.category.entities_20230220111841",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name\nprint(vars(Category('Movie')))",
        "detail": ".history.src.category.entities_20230220111841",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": ".history.src.category.entities_20230220112308",
        "description": ".history.src.category.entities_20230220112308",
        "peekOfCode": "class Category:\n    def __init__(self, name) -> None:\n        self.name = name",
        "detail": ".history.src.category.entities_20230220112308",
        "documentation": {}
    },
    {
        "label": "Code",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class Code:\n    \"\"\"Wrapper around Python code objects.\"\"\"\n    __slots__ = (\"raw\",)\n    def __init__(self, obj: CodeType) -> None:\n        self.raw = obj\n    @classmethod\n    def from_function(cls, obj: object) -> \"Code\":\n        return cls(getrawcode(obj))\n    def __eq__(self, other):\n        return self.raw == other.raw",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "Frame",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class Frame:\n    \"\"\"Wrapper around a Python frame holding f_locals and f_globals\n    in which expressions can be evaluated.\"\"\"\n    __slots__ = (\"raw\",)\n    def __init__(self, frame: FrameType) -> None:\n        self.raw = frame\n    @property\n    def lineno(self) -> int:\n        return self.raw.f_lineno - 1\n    @property",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TracebackEntry",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class TracebackEntry:\n    \"\"\"A single entry in a Traceback.\"\"\"\n    __slots__ = (\"_rawentry\", \"_excinfo\", \"_repr_style\")\n    def __init__(\n        self,\n        rawentry: TracebackType,\n        excinfo: Optional[\"ReferenceType[ExceptionInfo[BaseException]]\"] = None,\n    ) -> None:\n        self._rawentry = rawentry\n        self._excinfo = excinfo",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "Traceback",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class Traceback(List[TracebackEntry]):\n    \"\"\"Traceback objects encapsulate and offer higher level access to Traceback entries.\"\"\"\n    def __init__(\n        self,\n        tb: Union[TracebackType, Iterable[TracebackEntry]],\n        excinfo: Optional[\"ReferenceType[ExceptionInfo[BaseException]]\"] = None,\n    ) -> None:\n        \"\"\"Initialize from given python traceback object and ExceptionInfo.\"\"\"\n        self._excinfo = excinfo\n        if isinstance(tb, TracebackType):",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ExceptionInfo(Generic[E]):\n    \"\"\"Wraps sys.exc_info() objects and offers help for navigating the traceback.\"\"\"\n    _assert_start_repr: ClassVar = \"AssertionError('assert \"\n    _excinfo: Optional[Tuple[Type[\"E\"], \"E\", TracebackType]]\n    _striptext: str\n    _traceback: Optional[Traceback]\n    def __init__(\n        self,\n        excinfo: Optional[Tuple[Type[\"E\"], \"E\", TracebackType]],\n        striptext: str = \"\",",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "FormattedExcinfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class FormattedExcinfo:\n    \"\"\"Presenting information about failing Functions and Generators.\"\"\"\n    # for traceback entries\n    flow_marker: ClassVar = \">\"\n    fail_marker: ClassVar = \"E\"\n    showlocals: bool = False\n    style: \"_TracebackStyle\" = \"long\"\n    abspath: bool = True\n    tbfilter: bool = True\n    funcargs: bool = False",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "TerminalRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class TerminalRepr:\n    def __str__(self) -> str:\n        # FYI this is called from pytest-xdist's serialization of exception\n        # information.\n        io = StringIO()\n        tw = TerminalWriter(file=io)\n        self.toterminal(tw)\n        return io.getvalue().strip()\n    def __repr__(self) -> str:\n        return f\"<{self.__class__} instance at {id(self):0x}>\"",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ExceptionRepr(TerminalRepr):\n    # Provided by subclasses.\n    reprcrash: Optional[\"ReprFileLocation\"]\n    reprtraceback: \"ReprTraceback\"\n    def __attrs_post_init__(self) -> None:\n        self.sections: List[Tuple[str, str, str]] = []\n    def addsection(self, name: str, content: str, sep: str = \"-\") -> None:\n        self.sections.append((name, content, sep))\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for name, content, sep in self.sections:",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ExceptionChainRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ExceptionChainRepr(ExceptionRepr):\n    chain: Sequence[Tuple[\"ReprTraceback\", Optional[\"ReprFileLocation\"], Optional[str]]]\n    def __attrs_post_init__(self) -> None:\n        super().__attrs_post_init__()\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain.\n        self.reprtraceback = self.chain[-1][0]\n        self.reprcrash = self.chain[-1][1]\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for element in self.chain:",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprExceptionInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprExceptionInfo(ExceptionRepr):\n    reprtraceback: \"ReprTraceback\"\n    reprcrash: \"ReprFileLocation\"\n    def toterminal(self, tw: TerminalWriter) -> None:\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)\n@attr.s(eq=False, auto_attribs=True)\nclass ReprTraceback(TerminalRepr):\n    reprentries: Sequence[Union[\"ReprEntry\", \"ReprEntryNative\"]]\n    extraline: Optional[str]",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprTraceback",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprTraceback(TerminalRepr):\n    reprentries: Sequence[Union[\"ReprEntry\", \"ReprEntryNative\"]]\n    extraline: Optional[str]\n    style: \"_TracebackStyle\"\n    entrysep: ClassVar = \"_ \"\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # The entries might have different styles.\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprTracebackNative",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines: Sequence[str]) -> None:\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None\n@attr.s(eq=False, auto_attribs=True)\nclass ReprEntryNative(TerminalRepr):\n    lines: Sequence[str]\n    style: ClassVar[\"_TracebackStyle\"] = \"native\"\n    def toterminal(self, tw: TerminalWriter) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprEntryNative",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprEntryNative(TerminalRepr):\n    lines: Sequence[str]\n    style: ClassVar[\"_TracebackStyle\"] = \"native\"\n    def toterminal(self, tw: TerminalWriter) -> None:\n        tw.write(\"\".join(self.lines))\n@attr.s(eq=False, auto_attribs=True)\nclass ReprEntry(TerminalRepr):\n    lines: Sequence[str]\n    reprfuncargs: Optional[\"ReprFuncArgs\"]\n    reprlocals: Optional[\"ReprLocals\"]",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprEntry",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprEntry(TerminalRepr):\n    lines: Sequence[str]\n    reprfuncargs: Optional[\"ReprFuncArgs\"]\n    reprlocals: Optional[\"ReprLocals\"]\n    reprfileloc: Optional[\"ReprFileLocation\"]\n    style: \"_TracebackStyle\"\n    def _write_entry_lines(self, tw: TerminalWriter) -> None:\n        \"\"\"Write the source code portions of a list of traceback entries with syntax highlighting.\n        Usually entries are lines like these:\n            \"     x = 1\"",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFileLocation",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprFileLocation(TerminalRepr):\n    path: str = attr.ib(converter=str)\n    lineno: int\n    message: str\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # Filename and lineno output for each entry, using an output format\n        # that most editors understand.\n        msg = self.message\n        i = msg.find(\"\\n\")\n        if i != -1:",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprLocals",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprLocals(TerminalRepr):\n    lines: Sequence[str]\n    def toterminal(self, tw: TerminalWriter, indent=\"\") -> None:\n        for line in self.lines:\n            tw.line(indent + line)\n@attr.s(eq=False, auto_attribs=True)\nclass ReprFuncArgs(TerminalRepr):\n    args: Sequence[Tuple[str, object]]\n    def toterminal(self, tw: TerminalWriter) -> None:\n        if self.args:",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "ReprFuncArgs",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "class ReprFuncArgs(TerminalRepr):\n    args: Sequence[Tuple[str, object]]\n    def toterminal(self, tw: TerminalWriter) -> None:\n        if self.args:\n            linesofar = \"\"\n            for name, value in self.args:\n                ns = f\"{name} = {value}\"\n                if len(ns) + len(linesofar) + 2 > tw.fullwidth:\n                    if linesofar:\n                        tw.line(linesofar)",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "getfslineno",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "def getfslineno(obj: object) -> Tuple[Union[str, Path], int]:\n    \"\"\"Return source location (path, lineno) for the given object.\n    If the source cannot be determined return (\"\", -1).\n    The line number is 0-based.\n    \"\"\"\n    # xxx let decorators etc specify a sane ordering\n    # NOTE: this used to be done in _pytest.compat.getfslineno, initially added\n    #       in 6ec13a2b9.  It (\"place_as\") appears to be something very custom.\n    obj = get_real_func(obj)\n    if hasattr(obj, \"place_as\"):",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "filter_traceback",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "def filter_traceback(entry: TracebackEntry) -> bool:\n    \"\"\"Return True if a TracebackEntry instance should be included in tracebacks.\n    We hide traceback entries of:\n    * dynamically generated code (no code to show up for it);\n    * internal traceback from pytest or its internal libraries, py and pluggy.\n    \"\"\"\n    # entry.path might sometimes return a str object when the entry\n    # points to dynamically generated code.\n    # See https://bitbucket.org/pytest-dev/py/issues/71.\n    raw_filename = entry.frame.code.raw.co_filename",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "E",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "E = TypeVar(\"E\", bound=BaseException, covariant=True)\n@final\n@attr.s(repr=False, init=False, auto_attribs=True)\nclass ExceptionInfo(Generic[E]):\n    \"\"\"Wraps sys.exc_info() objects and offers help for navigating the traceback.\"\"\"\n    _assert_start_repr: ClassVar = \"AssertionError('assert \"\n    _excinfo: Optional[Tuple[Type[\"E\"], \"E\", TracebackType]]\n    _striptext: str\n    _traceback: Optional[Traceback]\n    def __init__(",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "_PLUGGY_DIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "_PLUGGY_DIR = Path(pluggy.__file__.rstrip(\"oc\"))\n# pluggy is either a package or a single module depending on the version\nif _PLUGGY_DIR.name == \"__init__.py\":\n    _PLUGGY_DIR = _PLUGGY_DIR.parent\n_PYTEST_DIR = Path(_pytest.__file__).parent\ndef filter_traceback(entry: TracebackEntry) -> bool:\n    \"\"\"Return True if a TracebackEntry instance should be included in tracebacks.\n    We hide traceback entries of:\n    * dynamically generated code (no code to show up for it);\n    * internal traceback from pytest or its internal libraries, py and pluggy.",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "_PYTEST_DIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._code.code",
        "description": "__pypackages__.3.10.lib._pytest._code.code",
        "peekOfCode": "_PYTEST_DIR = Path(_pytest.__file__).parent\ndef filter_traceback(entry: TracebackEntry) -> bool:\n    \"\"\"Return True if a TracebackEntry instance should be included in tracebacks.\n    We hide traceback entries of:\n    * dynamically generated code (no code to show up for it);\n    * internal traceback from pytest or its internal libraries, py and pluggy.\n    \"\"\"\n    # entry.path might sometimes return a str object when the entry\n    # points to dynamically generated code.\n    # See https://bitbucket.org/pytest-dev/py/issues/71.",
        "detail": "__pypackages__.3.10.lib._pytest._code.code",
        "documentation": {}
    },
    {
        "label": "Source",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "class Source:\n    \"\"\"An immutable object holding a source code fragment.\n    When using Source(...), the source lines are deindented.\n    \"\"\"\n    def __init__(self, obj: object = None) -> None:\n        if not obj:\n            self.lines: List[str] = []\n        elif isinstance(obj, Source):\n            self.lines = obj.lines\n        elif isinstance(obj, (tuple, list)):",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "findsource",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "def findsource(obj) -> Tuple[Optional[Source], int]:\n    try:\n        sourcelines, lineno = inspect.findsource(obj)\n    except Exception:\n        return None, -1\n    source = Source()\n    source.lines = [line.rstrip() for line in sourcelines]\n    return source, lineno\ndef getrawcode(obj: object, trycall: bool = True) -> types.CodeType:\n    \"\"\"Return code object for given function.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "getrawcode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "def getrawcode(obj: object, trycall: bool = True) -> types.CodeType:\n    \"\"\"Return code object for given function.\"\"\"\n    try:\n        return obj.__code__  # type: ignore[attr-defined,no-any-return]\n    except AttributeError:\n        pass\n    if trycall:\n        call = getattr(obj, \"__call__\", None)\n        if call and not isinstance(obj, type):\n            return getrawcode(call, trycall=False)",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "deindent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "def deindent(lines: Iterable[str]) -> List[str]:\n    return textwrap.dedent(\"\\n\".join(lines)).splitlines()\ndef get_statement_startend2(lineno: int, node: ast.AST) -> Tuple[int, Optional[int]]:\n    # Flatten all statements and except handlers into one lineno-list.\n    # AST's line numbers start indexing at 1.\n    values: List[int] = []\n    for x in ast.walk(node):\n        if isinstance(x, (ast.stmt, ast.ExceptHandler)):\n            # Before Python 3.8, the lineno of a decorated class or function pointed at the decorator.\n            # Since Python 3.8, the lineno points to the class/def, so need to include the decorators.",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "get_statement_startend2",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "def get_statement_startend2(lineno: int, node: ast.AST) -> Tuple[int, Optional[int]]:\n    # Flatten all statements and except handlers into one lineno-list.\n    # AST's line numbers start indexing at 1.\n    values: List[int] = []\n    for x in ast.walk(node):\n        if isinstance(x, (ast.stmt, ast.ExceptHandler)):\n            # Before Python 3.8, the lineno of a decorated class or function pointed at the decorator.\n            # Since Python 3.8, the lineno points to the class/def, so need to include the decorators.\n            if isinstance(x, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):\n                for d in x.decorator_list:",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "getstatementrange_ast",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._code.source",
        "description": "__pypackages__.3.10.lib._pytest._code.source",
        "peekOfCode": "def getstatementrange_ast(\n    lineno: int,\n    source: Source,\n    assertion: bool = False,\n    astnode: Optional[ast.AST] = None,\n) -> Tuple[ast.AST, int, int]:\n    if astnode is None:\n        content = str(source)\n        # See #4260:\n        # Don't produce duplicate warnings when compiling source to find AST.",
        "detail": "__pypackages__.3.10.lib._pytest._code.source",
        "documentation": {}
    },
    {
        "label": "SafeRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "class SafeRepr(reprlib.Repr):\n    \"\"\"\n    repr.Repr that limits the resulting size of repr() and includes\n    information on exceptions raised during the call.\n    \"\"\"\n    def __init__(self, maxsize: Optional[int], use_ascii: bool = False) -> None:\n        \"\"\"\n        :param maxsize:\n            If not None, will truncate the resulting repr to that specific size, using ellipsis\n            somewhere in the middle to hide the extra text.",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "AlwaysDispatchingPrettyPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "class AlwaysDispatchingPrettyPrinter(pprint.PrettyPrinter):\n    \"\"\"PrettyPrinter that always dispatches (regardless of width).\"\"\"\n    def _format(\n        self,\n        object: object,\n        stream: IO[str],\n        indent: int,\n        allowance: int,\n        context: Dict[int, Any],\n        level: int,",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "safeformat",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "def safeformat(obj: object) -> str:\n    \"\"\"Return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)\n# Maximum size of overall repr of objects to display during assertion errors.",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "def saferepr(\n    obj: object, maxsize: Optional[int] = DEFAULT_REPR_MAX_SIZE, use_ascii: bool = False\n) -> str:\n    \"\"\"Return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.\n    This function is a wrapper around the Repr/reprlib functionality of the\n    stdlib.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "saferepr_unlimited",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "def saferepr_unlimited(obj: object, use_ascii: bool = True) -> str:\n    \"\"\"Return an unlimited-size safe repr-string for the given object.\n    As with saferepr, failing __repr__ functions of user instances\n    will be represented with a short exception info.\n    This function is a wrapper around simple repr.\n    Note: a cleaner solution would be to alter ``saferepr``this way\n    when maxsize=None, but that might affect some other code.\n    \"\"\"\n    try:\n        if use_ascii:",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REPR_MAX_SIZE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "description": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "peekOfCode": "DEFAULT_REPR_MAX_SIZE = 240\ndef saferepr(\n    obj: object, maxsize: Optional[int] = DEFAULT_REPR_MAX_SIZE, use_ascii: bool = False\n) -> str:\n    \"\"\"Return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.\n    This function is a wrapper around the Repr/reprlib functionality of the\n    stdlib.",
        "detail": "__pypackages__.3.10.lib._pytest._io.saferepr",
        "documentation": {}
    },
    {
        "label": "TerminalWriter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "description": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "peekOfCode": "class TerminalWriter:\n    _esctable = dict(\n        black=30,\n        red=31,\n        green=32,\n        yellow=33,\n        blue=34,\n        purple=35,\n        cyan=36,\n        white=37,",
        "detail": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "documentation": {}
    },
    {
        "label": "get_terminal_width",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "description": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "peekOfCode": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n    return width\ndef should_do_markup(file: TextIO) -> bool:\n    if os.environ.get(\"PY_COLORS\") == \"1\":\n        return True\n    if os.environ.get(\"PY_COLORS\") == \"0\":",
        "detail": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "documentation": {}
    },
    {
        "label": "should_do_markup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "description": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "peekOfCode": "def should_do_markup(file: TextIO) -> bool:\n    if os.environ.get(\"PY_COLORS\") == \"1\":\n        return True\n    if os.environ.get(\"PY_COLORS\") == \"0\":\n        return False\n    if \"NO_COLOR\" in os.environ:\n        return False\n    if \"FORCE_COLOR\" in os.environ:\n        return True\n    return (",
        "detail": "__pypackages__.3.10.lib._pytest._io.terminalwriter",
        "documentation": {}
    },
    {
        "label": "wcwidth",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "description": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "peekOfCode": "def wcwidth(c: str) -> int:\n    \"\"\"Determine how many columns are needed to display a character in a terminal.\n    Returns -1 if the character is not printable.\n    Returns 0, 1 or 2 for other characters.\n    \"\"\"\n    o = ord(c)\n    # ASCII fast path.\n    if 0x20 <= o < 0x07F:\n        return 1\n    # Some Cf/Zp/Zl characters which should be zero-width.",
        "detail": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "documentation": {}
    },
    {
        "label": "wcswidth",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "description": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "peekOfCode": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc",
        "detail": "__pypackages__.3.10.lib._pytest._io.wcwidth",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "class Error(EnvironmentError):\n    def __repr__(self) -> str:\n        return \"{}.{} {!r}: {} \".format(\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self.__class__.__doc__,\n            \" \".join(map(str, self.args)),\n            # repr(self.args)\n        )\n    def __str__(self) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "ErrorMaker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "class ErrorMaker:\n    \"\"\"lazily provides Exception classes for each possible POSIX errno\n    (as defined per the 'errno' module).  All such instances\n    subclass EnvironmentError.\n    \"\"\"\n    _errno2class: dict[int, type[Error]] = {}\n    def __getattr__(self, name: str) -> type[Error]:\n        if name[0] == \"_\":\n            raise AttributeError(name)\n        eno = getattr(errno, name)",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "R = TypeVar(\"R\")\nclass Error(EnvironmentError):\n    def __repr__(self) -> str:\n        return \"{}.{} {!r}: {} \".format(\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self.__class__.__doc__,\n            \" \".join(map(str, self.args)),\n            # repr(self.args)\n        )",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "_winerrnomap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "_winerrnomap = {\n    2: errno.ENOENT,\n    3: errno.ENOENT,\n    17: errno.EEXIST,\n    18: errno.EXDEV,\n    13: errno.EBUSY,  # empty cd drive, but ENOMEDIUM seems unavailiable\n    22: errno.ENOTDIR,\n    20: errno.ENOTDIR,\n    267: errno.ENOTDIR,\n    5: errno.EACCES,  # anything better?",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "_error_maker",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "_error_maker = ErrorMaker()\nchecked_call = _error_maker.checked_call\ndef __getattr__(attr: str) -> type[Error]:\n    return getattr(_error_maker, attr)  # type: ignore[no-any-return]",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "checked_call",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.error",
        "description": "__pypackages__.3.10.lib._pytest._py.error",
        "peekOfCode": "checked_call = _error_maker.checked_call\ndef __getattr__(attr: str) -> type[Error]:\n    return getattr(_error_maker, attr)  # type: ignore[no-any-return]",
        "detail": "__pypackages__.3.10.lib._pytest._py.error",
        "documentation": {}
    },
    {
        "label": "Checkers",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class Checkers:\n    _depend_on_existence = \"exists\", \"link\", \"dir\", \"file\"\n    def __init__(self, path):\n        self.path = path\n    def dotfile(self):\n        return self.path.basename.startswith(\".\")\n    def ext(self, arg):\n        if not arg.startswith(\".\"):\n            arg = \".\" + arg\n        return self.path.ext == arg",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "NeverRaised",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class NeverRaised(Exception):\n    pass\nclass Visitor:\n    def __init__(self, fil, rec, ignore, bf, sort):\n        if isinstance(fil, str):\n            fil = FNMatcher(fil)\n        if isinstance(rec, str):\n            self.rec: Callable[[LocalPath], bool] = FNMatcher(rec)\n        elif not hasattr(rec, \"__call__\") and rec:\n            self.rec = lambda path: True",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class Visitor:\n    def __init__(self, fil, rec, ignore, bf, sort):\n        if isinstance(fil, str):\n            fil = FNMatcher(fil)\n        if isinstance(rec, str):\n            self.rec: Callable[[LocalPath], bool] = FNMatcher(rec)\n        elif not hasattr(rec, \"__call__\") and rec:\n            self.rec = lambda path: True\n        else:\n            self.rec = rec",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "FNMatcher",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class FNMatcher:\n    def __init__(self, pattern):\n        self.pattern = pattern\n    def __call__(self, path):\n        pattern = self.pattern\n        if (\n            pattern.find(path.sep) == -1\n            and iswin32\n            and pattern.find(posixpath.sep) != -1\n        ):",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "Stat",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class Stat:\n    if TYPE_CHECKING:\n        @property\n        def size(self) -> int:\n            ...\n        @property\n        def mtime(self) -> float:\n            ...\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self._osstatresult, \"st_\" + name)",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "LocalPath",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "class LocalPath:\n    \"\"\"Object oriented interface to os.path and other local filesystem\n    related information.\n    \"\"\"\n    class ImportMismatchError(ImportError):\n        \"\"\"raised on pyimport() if there is a mismatch of __file__'s\"\"\"\n    sep = os.sep\n    def __init__(self, path=None, expanduser=False):\n        \"\"\"Initialize and return a local Path instance.\n        Path can be relative to the current directory.",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "map_as_list",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def map_as_list(func, iter):\n    return list(map(func, iter))\nclass Stat:\n    if TYPE_CHECKING:\n        @property\n        def size(self) -> int:\n            ...\n        @property\n        def mtime(self) -> float:\n            ...",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "getuserid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def getuserid(user):\n    import pwd\n    if not isinstance(user, int):\n        user = pwd.getpwnam(user)[2]\n    return user\ndef getgroupid(group):\n    import grp\n    if not isinstance(group, int):\n        group = grp.getgrnam(group)[2]\n    return group",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "getgroupid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def getgroupid(group):\n    import grp\n    if not isinstance(group, int):\n        group = grp.getgrnam(group)[2]\n    return group\nclass LocalPath:\n    \"\"\"Object oriented interface to os.path and other local filesystem\n    related information.\n    \"\"\"\n    class ImportMismatchError(ImportError):",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "copymode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def copymode(src, dest):\n    \"\"\"Copy permission from src to dst.\"\"\"\n    import shutil\n    shutil.copymode(src, dest)\ndef copystat(src, dest):\n    \"\"\"Copy permission,  last modification time,\n    last access time, and flags from src to dst.\"\"\"\n    import shutil\n    shutil.copystat(str(src), str(dest))\ndef copychunked(src, dest):",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "copystat",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def copystat(src, dest):\n    \"\"\"Copy permission,  last modification time,\n    last access time, and flags from src to dst.\"\"\"\n    import shutil\n    shutil.copystat(str(src), str(dest))\ndef copychunked(src, dest):\n    chunksize = 524288  # half a meg of bytes\n    fsrc = src.open(\"rb\")\n    try:\n        fdest = dest.open(\"wb\")",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "copychunked",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def copychunked(src, dest):\n    chunksize = 524288  # half a meg of bytes\n    fsrc = src.open(\"rb\")\n    try:\n        fdest = dest.open(\"wb\")\n        try:\n            while 1:\n                buf = fsrc.read(chunksize)\n                if not buf:\n                    break",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "isimportable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "def isimportable(name):\n    if name and (name[0].isalpha() or name[0] == \"_\"):\n        name = name.replace(\"_\", \"\")\n        return not name or name.isalnum()\nlocal = LocalPath",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "iswin32",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "iswin32 = sys.platform == \"win32\" or (getattr(os, \"_name\", False) == \"nt\")\nclass Checkers:\n    _depend_on_existence = \"exists\", \"link\", \"dir\", \"file\"\n    def __init__(self, path):\n        self.path = path\n    def dotfile(self):\n        return self.path.basename.startswith(\".\")\n    def ext(self, arg):\n        if not arg.startswith(\".\"):\n            arg = \".\" + arg",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "local",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._py.path",
        "description": "__pypackages__.3.10.lib._pytest._py.path",
        "peekOfCode": "local = LocalPath",
        "detail": "__pypackages__.3.10.lib._pytest._py.path",
        "documentation": {}
    },
    {
        "label": "AssertionRewritingHook",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session: Optional[Session] = None\n        self._rewritten_names: Dict[str, Path] = {}",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "AssertionRewriter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "rewrite_asserts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "def rewrite_asserts(\n    mod: ast.Module,\n    source: bytes,\n    module_path: Optional[str] = None,\n    config: Optional[Config] = None,\n) -> None:\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)\ndef _saferepr(obj: object) -> str:\n    r\"\"\"Get a safe repr of an object for assertion error messages.",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "traverse_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "def traverse_node(node: ast.AST) -> Iterator[ast.AST]:\n    \"\"\"Recursively yield node and all its children in depth-first order.\"\"\"\n    yield node\n    for child in ast.iter_child_nodes(node):\n        yield from traverse_node(child)\n@functools.lru_cache(maxsize=1)\ndef _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n    ret: Dict[int, str] = {}\n    depth = 0",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "try_makedirs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "def try_makedirs(cache_dir: Path) -> bool:\n    \"\"\"Attempt to create the given directory and sub-directories exist.\n    Returns True if successful or if it already exists.\n    \"\"\"\n    try:\n        os.makedirs(cache_dir, exist_ok=True)\n    except (FileNotFoundError, NotADirectoryError, FileExistsError):\n        # One of the path components was not a directory:\n        # - we're in a zip file\n        # - it is a file",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "get_cache_dir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "def get_cache_dir(file_path: Path) -> Path:\n    \"\"\"Return the cache directory to write .pyc files for the given .py file path.\"\"\"\n    if sys.version_info >= (3, 8) and sys.pycache_prefix:\n        # given:\n        #   prefix = '/tmp/pycs'\n        #   path = '/home/user/proj/test_app.py'\n        # we want:\n        #   '/tmp/pycs/home/user/proj'\n        return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])\n    else:",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "assertstate_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "assertstate_key = StashKey[\"AssertionState\"]()\n# pytest caches rewritten pycs in pycache dirs\nPYTEST_TAG = f\"{sys.implementation.cache_tag}-pytest-{version}\"\nPYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\nPYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\nclass AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "PYTEST_TAG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "PYTEST_TAG = f\"{sys.implementation.cache_tag}-pytest-{version}\"\nPYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\nPYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\nclass AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "PYC_EXT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "PYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\nPYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\nclass AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "PYC_TAIL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "PYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\nclass AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session: Optional[Session] = None",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "UNARY_MAP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "UNARY_MAP = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\nBINOP_MAP = {\n    ast.BitOr: \"|\",\n    ast.BitXor: \"^\",\n    ast.BitAnd: \"&\",\n    ast.LShift: \"<<\",\n    ast.RShift: \">>\",\n    ast.Add: \"+\",\n    ast.Sub: \"-\",\n    ast.Mult: \"*\",",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "BINOP_MAP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "description": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "peekOfCode": "BINOP_MAP = {\n    ast.BitOr: \"|\",\n    ast.BitXor: \"^\",\n    ast.BitAnd: \"&\",\n    ast.LShift: \"<<\",\n    ast.RShift: \">>\",\n    ast.Add: \"+\",\n    ast.Sub: \"-\",\n    ast.Mult: \"*\",\n    ast.Div: \"/\",",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.rewrite",
        "documentation": {}
    },
    {
        "label": "truncate_if_required",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "description": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "peekOfCode": "def truncate_if_required(\n    explanation: List[str], item: Item, max_length: Optional[int] = None\n) -> List[str]:\n    \"\"\"Truncate this assertion explanation if the given test item is eligible.\"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation\ndef _should_truncate_item(item: Item) -> bool:\n    \"\"\"Whether or not this test item is eligible for truncation.\"\"\"\n    verbose = item.config.option.verbose",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_LINES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "description": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "peekOfCode": "DEFAULT_MAX_LINES = 8\nDEFAULT_MAX_CHARS = 8 * 80\nUSAGE_MSG = \"use '-vv' to show\"\ndef truncate_if_required(\n    explanation: List[str], item: Item, max_length: Optional[int] = None\n) -> List[str]:\n    \"\"\"Truncate this assertion explanation if the given test item is eligible.\"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "description": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "peekOfCode": "DEFAULT_MAX_CHARS = 8 * 80\nUSAGE_MSG = \"use '-vv' to show\"\ndef truncate_if_required(\n    explanation: List[str], item: Item, max_length: Optional[int] = None\n) -> List[str]:\n    \"\"\"Truncate this assertion explanation if the given test item is eligible.\"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation\ndef _should_truncate_item(item: Item) -> bool:",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "documentation": {}
    },
    {
        "label": "USAGE_MSG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "description": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "peekOfCode": "USAGE_MSG = \"use '-vv' to show\"\ndef truncate_if_required(\n    explanation: List[str], item: Item, max_length: Optional[int] = None\n) -> List[str]:\n    \"\"\"Truncate this assertion explanation if the given test item is eligible.\"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation\ndef _should_truncate_item(item: Item) -> bool:\n    \"\"\"Whether or not this test item is eligible for truncation.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.truncate",
        "documentation": {}
    },
    {
        "label": "format_explanation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def format_explanation(explanation: str) -> str:\n    r\"\"\"Format an explanation.\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "issequence",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def issequence(x: Any) -> bool:\n    return isinstance(x, collections.abc.Sequence) and not isinstance(x, str)\ndef istext(x: Any) -> bool:\n    return isinstance(x, str)\ndef isdict(x: Any) -> bool:\n    return isinstance(x, dict)\ndef isset(x: Any) -> bool:\n    return isinstance(x, (set, frozenset))\ndef isnamedtuple(obj: Any) -> bool:\n    return isinstance(obj, tuple) and getattr(obj, \"_fields\", None) is not None",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "istext",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def istext(x: Any) -> bool:\n    return isinstance(x, str)\ndef isdict(x: Any) -> bool:\n    return isinstance(x, dict)\ndef isset(x: Any) -> bool:\n    return isinstance(x, (set, frozenset))\ndef isnamedtuple(obj: Any) -> bool:\n    return isinstance(obj, tuple) and getattr(obj, \"_fields\", None) is not None\ndef isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isdict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isdict(x: Any) -> bool:\n    return isinstance(x, dict)\ndef isset(x: Any) -> bool:\n    return isinstance(x, (set, frozenset))\ndef isnamedtuple(obj: Any) -> bool:\n    return isinstance(obj, tuple) and getattr(obj, \"_fields\", None) is not None\ndef isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None\ndef isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isset",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isset(x: Any) -> bool:\n    return isinstance(x, (set, frozenset))\ndef isnamedtuple(obj: Any) -> bool:\n    return isinstance(obj, tuple) and getattr(obj, \"_fields\", None) is not None\ndef isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None\ndef isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None\ndef isiterable(obj: Any) -> bool:\n    try:",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isnamedtuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isnamedtuple(obj: Any) -> bool:\n    return isinstance(obj, tuple) and getattr(obj, \"_fields\", None) is not None\ndef isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None\ndef isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None\ndef isiterable(obj: Any) -> bool:\n    try:\n        iter(obj)\n        return not istext(obj)",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isdatacls",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None\ndef isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None\ndef isiterable(obj: Any) -> bool:\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isattrs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None\ndef isiterable(obj: Any) -> bool:\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False\ndef has_default_eq(\n    obj: object,",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "isiterable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def isiterable(obj: Any) -> bool:\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False\ndef has_default_eq(\n    obj: object,\n) -> bool:\n    \"\"\"Check if an instance of an object contains the default eq",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "has_default_eq",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def has_default_eq(\n    obj: object,\n) -> bool:\n    \"\"\"Check if an instance of an object contains the default eq\n    First, we check if the object's __eq__ attribute has __code__,\n    if so, we check the equally of the method code filename (__code__.co_filename)\n    to the default one generated by the dataclass and attr module\n    for dataclasses the default co_filename is <string>, for attrs class, the __eq__ should contain \"attrs eq generated\"\n    \"\"\"\n    # inspired from https://github.com/willmcgugan/rich/blob/07d51ffc1aee6f16bd2e5a25b4e82850fb9ed778/rich/pretty.py#L68",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "assertrepr_compare",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def assertrepr_compare(\n    config, op: str, left: Any, right: Any, use_ascii: bool = False\n) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands.\"\"\"\n    verbose = config.getoption(\"verbose\")\n    # Strings which normalize equal are often hard to distinguish when printed; use ascii() to make this easier.\n    # See issue #3246.\n    use_ascii = (\n        isinstance(left, str)\n        and isinstance(right, str)",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "running_on_ci",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.assertion.util",
        "description": "__pypackages__.3.10.lib._pytest.assertion.util",
        "peekOfCode": "def running_on_ci() -> bool:\n    \"\"\"Check if we're currently running on a CI system.\"\"\"\n    env_vars = [\"CI\", \"BUILD_NUMBER\"]\n    return any(var in os.environ for var in env_vars)",
        "detail": "__pypackages__.3.10.lib._pytest.assertion.util",
        "documentation": {}
    },
    {
        "label": "Parser",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class Parser:\n    \"\"\"Parser for command line arguments and ini-file values.\n    :ivar extra_info: Dict of generic param -> value to display in case\n        there's an error processing the command line arguments.\n    \"\"\"\n    prog: Optional[str] = None\n    def __init__(\n        self,\n        usage: Optional[str] = None,\n        processopt: Optional[Callable[[\"Argument\"], None]] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "ArgumentError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class ArgumentError(Exception):\n    \"\"\"Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\"\"\"\n    def __init__(self, msg: str, option: Union[\"Argument\", str]) -> None:\n        self.msg = msg\n        self.option_id = str(option)\n    def __str__(self) -> str:\n        if self.option_id:\n            return f\"option {self.option_id}: {self.msg}\"\n        else:",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "Argument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class Argument:\n    \"\"\"Class that mimics the necessary behaviour of optparse.Option.\n    It's currently a least effort implementation and ignoring choices\n    and integer prefixes.\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n    def __init__(self, *names: str, **attrs: Any) -> None:\n        \"\"\"Store params in private vars for use in add_argument.\"\"\"\n        self._attrs = attrs",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "OptionGroup",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class OptionGroup:\n    \"\"\"A group of options shown in its own section.\"\"\"\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        parser: Optional[Parser] = None,\n        *,\n        _ispytest: bool = False,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "MyOptionParser",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class MyOptionParser(argparse.ArgumentParser):\n    def __init__(\n        self,\n        parser: Parser,\n        extra_info: Optional[Dict[str, Any]] = None,\n        prog: Optional[str] = None,\n    ) -> None:\n        self._parser = parser\n        super().__init__(\n            prog=prog,",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "DropShorterLongHelpFormatter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "class DropShorterLongHelpFormatter(argparse.HelpFormatter):\n    \"\"\"Shorten help for long options that differ only in extra hyphens.\n    - Collapse **long** options that are the same except for extra hyphens.\n    - Shortcut if there are only two options and one of them is a short one.\n    - Cache result on the action object as this is called at least 2 times.\n    \"\"\"\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        # Use more accurate terminal width.\n        if \"width\" not in kwargs:\n            kwargs[\"width\"] = _pytest._io.get_terminal_width()",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "FILE_OR_DIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "description": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "peekOfCode": "FILE_OR_DIR = \"file_or_dir\"\n@final\nclass Parser:\n    \"\"\"Parser for command line arguments and ini-file values.\n    :ivar extra_info: Dict of generic param -> value to display in case\n        there's an error processing the command line arguments.\n    \"\"\"\n    prog: Optional[str] = None\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib._pytest.config.argparsing",
        "documentation": {}
    },
    {
        "label": "PathAwareHookProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.compat",
        "description": "__pypackages__.3.10.lib._pytest.config.compat",
        "peekOfCode": "class PathAwareHookProxy:\n    \"\"\"\n    this helper wraps around hook callers\n    until pluggy supports fixingcalls, this one will do\n    it currently doesn't return full hook caller proxies for fixed hooks,\n    this may have to be changed later depending on bugs\n    \"\"\"\n    def __init__(self, hook_caller):\n        self.__hook_caller = hook_caller\n    def __dir__(self):",
        "detail": "__pypackages__.3.10.lib._pytest.config.compat",
        "documentation": {}
    },
    {
        "label": "imply_paths_hooks",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.config.compat",
        "description": "__pypackages__.3.10.lib._pytest.config.compat",
        "peekOfCode": "imply_paths_hooks = {\n    \"pytest_ignore_collect\": (\"collection_path\", \"path\"),\n    \"pytest_collect_file\": (\"file_path\", \"path\"),\n    \"pytest_pycollect_makemodule\": (\"module_path\", \"path\"),\n    \"pytest_report_header\": (\"start_path\", \"startdir\"),\n    \"pytest_report_collectionfinish\": (\"start_path\", \"startdir\"),\n}\nclass PathAwareHookProxy:\n    \"\"\"\n    this helper wraps around hook callers",
        "detail": "__pypackages__.3.10.lib._pytest.config.compat",
        "documentation": {}
    },
    {
        "label": "UsageError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "description": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "peekOfCode": "class UsageError(Exception):\n    \"\"\"Error in pytest usage or invocation.\"\"\"\nclass PrintHelp(Exception):\n    \"\"\"Raised when pytest should print its help to skip the rest of the\n    argument parsing and validation.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "documentation": {}
    },
    {
        "label": "PrintHelp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "description": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "peekOfCode": "class PrintHelp(Exception):\n    \"\"\"Raised when pytest should print its help to skip the rest of the\n    argument parsing and validation.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.config.exceptions",
        "documentation": {}
    },
    {
        "label": "load_config_dict_from_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def load_config_dict_from_file(\n    filepath: Path,\n) -> Optional[Dict[str, Union[str, List[str]]]]:\n    \"\"\"Load pytest configuration from the given file path, if supported.\n    Return None if the file does not contain valid pytest configuration.\n    \"\"\"\n    # Configuration from ini files are obtained from the [pytest] section, if present.\n    if filepath.suffix == \".ini\":\n        iniconfig = _parse_ini_config(filepath)\n        if \"pytest\" in iniconfig:",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "locate_config",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def locate_config(\n    args: Iterable[Path],\n) -> Tuple[Optional[Path], Optional[Path], Dict[str, Union[str, List[str]]]]:\n    \"\"\"Search in the list of arguments for a valid ini-file for pytest,\n    and return a tuple of (rootdir, inifile, cfg-dict).\"\"\"\n    config_names = [\n        \"pytest.ini\",\n        \".pytest.ini\",\n        \"pyproject.toml\",\n        \"tox.ini\",",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "get_common_ancestor",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def get_common_ancestor(paths: Iterable[Path]) -> Path:\n    common_ancestor: Optional[Path] = None\n    for path in paths:\n        if not path.exists():\n            continue\n        if common_ancestor is None:\n            common_ancestor = path\n        else:\n            if common_ancestor in path.parents or path == common_ancestor:\n                continue",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "get_dirs_from_args",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def get_dirs_from_args(args: Iterable[str]) -> List[Path]:\n    def is_option(x: str) -> bool:\n        return x.startswith(\"-\")\n    def get_file_part_from_node_id(x: str) -> str:\n        return x.split(\"::\")[0]\n    def get_dir_from_path(path: Path) -> Path:\n        if path.is_dir():\n            return path\n        return path.parent\n    def safe_exists(path: Path) -> bool:",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "determine_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def determine_setup(\n    inifile: Optional[str],\n    args: Sequence[str],\n    rootdir_cmd_arg: Optional[str] = None,\n    config: Optional[\"Config\"] = None,\n) -> Tuple[Path, Optional[Path], Dict[str, Union[str, List[str]]]]:\n    rootdir = None\n    dirs = get_dirs_from_args(args)\n    if inifile:\n        inipath_ = absolutepath(inifile)",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "is_fs_root",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "def is_fs_root(p: Path) -> bool:\n    r\"\"\"\n    Return True if the given path is pointing to the root of the\n    file system (\"/\" on Unix and \"C:\\\\\" on Windows for example).\n    \"\"\"\n    return os.path.splitdrive(str(p))[1] == os.sep",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "CFG_PYTEST_SECTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "description": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "peekOfCode": "CFG_PYTEST_SECTION = \"[pytest] section in {filename} files is no longer supported, change to [tool:pytest] instead.\"\ndef determine_setup(\n    inifile: Optional[str],\n    args: Sequence[str],\n    rootdir_cmd_arg: Optional[str] = None,\n    config: Optional[\"Config\"] = None,\n) -> Tuple[Path, Optional[Path], Dict[str, Union[str, List[str]]]]:\n    rootdir = None\n    dirs = get_dirs_from_args(args)\n    if inifile:",
        "detail": "__pypackages__.3.10.lib._pytest.config.findpaths",
        "documentation": {}
    },
    {
        "label": "TokenType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class TokenType(enum.Enum):\n    LPAREN = \"left parenthesis\"\n    RPAREN = \"right parenthesis\"\n    OR = \"or\"\n    AND = \"and\"\n    NOT = \"not\"\n    IDENT = \"identifier\"\n    EOF = \"end of input\"\n@attr.s(frozen=True, slots=True, auto_attribs=True)\nclass Token:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class Token:\n    type: TokenType\n    value: str\n    pos: int\nclass ParseError(Exception):\n    \"\"\"The expression contains invalid syntax.\n    :param column: The column in the line where the error occurred (1-based).\n    :param message: A description of the error.\n    \"\"\"\n    def __init__(self, column: int, message: str) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class ParseError(Exception):\n    \"\"\"The expression contains invalid syntax.\n    :param column: The column in the line where the error occurred (1-based).\n    :param message: A description of the error.\n    \"\"\"\n    def __init__(self, column: int, message: str) -> None:\n        self.column = column\n        self.message = message\n    def __str__(self) -> str:\n        return f\"at column {self.column}: {self.message}\"",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "Scanner",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class Scanner:\n    __slots__ = (\"tokens\", \"current\")\n    def __init__(self, input: str) -> None:\n        self.tokens = self.lex(input)\n        self.current = next(self.tokens)\n    def lex(self, input: str) -> Iterator[Token]:\n        pos = 0\n        while pos < len(input):\n            if input[pos] in (\" \", \"\\t\"):\n                pos += 1",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "MatcherAdapter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class MatcherAdapter(Mapping[str, bool]):\n    \"\"\"Adapts a matcher function to a locals mapping as required by eval().\"\"\"\n    def __init__(self, matcher: Callable[[str], bool]) -> None:\n        self.matcher = matcher\n    def __getitem__(self, key: str) -> bool:\n        return self.matcher(key[len(IDENT_PREFIX) :])\n    def __iter__(self) -> Iterator[str]:\n        raise NotImplementedError()\n    def __len__(self) -> int:\n        raise NotImplementedError()",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "class Expression:\n    \"\"\"A compiled match expression as used by -k and -m.\n    The expression can be evaluated against different matchers.\n    \"\"\"\n    __slots__ = (\"code\",)\n    def __init__(self, code: types.CodeType) -> None:\n        self.code = code\n    @classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "expression",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "def expression(s: Scanner) -> ast.Expression:\n    if s.accept(TokenType.EOF):\n        ret: ast.expr = ast.NameConstant(False)\n    else:\n        ret = expr(s)\n        s.accept(TokenType.EOF, reject=True)\n    return ast.fix_missing_locations(ast.Expression(ret))\ndef expr(s: Scanner) -> ast.expr:\n    ret = and_expr(s)\n    while s.accept(TokenType.OR):",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "expr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "def expr(s: Scanner) -> ast.expr:\n    ret = and_expr(s)\n    while s.accept(TokenType.OR):\n        rhs = and_expr(s)\n        ret = ast.BoolOp(ast.Or(), [ret, rhs])\n    return ret\ndef and_expr(s: Scanner) -> ast.expr:\n    ret = not_expr(s)\n    while s.accept(TokenType.AND):\n        rhs = not_expr(s)",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "and_expr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "def and_expr(s: Scanner) -> ast.expr:\n    ret = not_expr(s)\n    while s.accept(TokenType.AND):\n        rhs = not_expr(s)\n        ret = ast.BoolOp(ast.And(), [ret, rhs])\n    return ret\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "not_expr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "def not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        return ast.Name(IDENT_PREFIX + ident.value, ast.Load())",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "__all__ = [\n    \"Expression\",\n    \"ParseError\",\n]\nclass TokenType(enum.Enum):\n    LPAREN = \"left parenthesis\"\n    RPAREN = \"right parenthesis\"\n    OR = \"or\"\n    AND = \"and\"\n    NOT = \"not\"",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "IDENT_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.expression",
        "description": "__pypackages__.3.10.lib._pytest.mark.expression",
        "peekOfCode": "IDENT_PREFIX = \"$\"\ndef expression(s: Scanner) -> ast.Expression:\n    if s.accept(TokenType.EOF):\n        ret: ast.expr = ast.NameConstant(False)\n    else:\n        ret = expr(s)\n        s.accept(TokenType.EOF, reject=True)\n    return ast.fix_missing_locations(ast.Expression(ret))\ndef expr(s: Scanner) -> ast.expr:\n    ret = and_expr(s)",
        "detail": "__pypackages__.3.10.lib._pytest.mark.expression",
        "documentation": {}
    },
    {
        "label": "ParameterSet",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "class ParameterSet(NamedTuple):\n    values: Sequence[Union[object, NotSetType]]\n    marks: Collection[Union[\"MarkDecorator\", \"Mark\"]]\n    id: Optional[str]\n    @classmethod\n    def param(\n        cls,\n        *values: object,\n        marks: Union[\"MarkDecorator\", Collection[Union[\"MarkDecorator\", \"Mark\"]]] = (),\n        id: Optional[str] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "Mark",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "class Mark:\n    #: Name of the mark.\n    name: str\n    #: Positional arguments of the mark decorator.\n    args: Tuple[Any, ...]\n    #: Keyword arguments of the mark decorator.\n    kwargs: Mapping[str, Any]\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from: Optional[\"Mark\"] = attr.ib(default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "MarkDecorator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "class MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n    ``MarkDecorators`` are created with ``pytest.mark``::\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n    and can then be applied as decorators to test functions::\n        @mark2\n        def test_function():\n            pass\n    When a ``MarkDecorator`` is called, it does the following:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "MarkGenerator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n    Example::\n         import pytest\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "NodeKeywords",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "class NodeKeywords(MutableMapping[str, Any]):\n    __slots__ = (\"node\", \"parent\", \"_markers\")\n    def __init__(self, node: \"Node\") -> None:\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n    def __getitem__(self, key: str) -> Any:\n        try:\n            return self._markers[key]\n        except KeyError:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "istestfunc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "def istestfunc(func) -> bool:\n    return callable(func) and getattr(func, \"__name__\", \"<lambda>\") != \"<lambda>\"\ndef get_empty_parameterset_mark(\n    config: Config, argnames: Sequence[str], func\n) -> \"MarkDecorator\":\n    from ..nodes import Collector\n    fs, lineno = getfslineno(func)\n    reason = \"got empty parameter set %r, function %s at %s:%d\" % (\n        argnames,\n        func.__name__,",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "get_empty_parameterset_mark",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "def get_empty_parameterset_mark(\n    config: Config, argnames: Sequence[str], func\n) -> \"MarkDecorator\":\n    from ..nodes import Collector\n    fs, lineno = getfslineno(func)\n    reason = \"got empty parameter set %r, function %s at %s:%d\" % (\n        argnames,\n        func.__name__,\n        fs,\n        lineno,",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "get_unpacked_marks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "def get_unpacked_marks(\n    obj: Union[object, type],\n    *,\n    consider_mro: bool = True,\n) -> List[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    If obj is a class and consider_mro is true, return marks applied to\n    this class and all of its super-classes in MRO order. If consider_mro\n    is false, only return marks applied directly to this class.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "normalize_mark_list",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "def normalize_mark_list(\n    mark_list: Iterable[Union[Mark, MarkDecorator]]\n) -> Iterable[Mark]:\n    \"\"\"\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    \"\"\"\n    for mark in mark_list:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "store_mark",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = [*get_unpacked_marks(obj, consider_mro=False), mark]\n# Typing for builtin pytest marks. This is cheating; it gives builtin marks\n# special privilege, and breaks modularity. But practicality beats purity...",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "EMPTY_PARAMETERSET_OPTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "EMPTY_PARAMETERSET_OPTION = \"empty_parameter_set_mark\"\ndef istestfunc(func) -> bool:\n    return callable(func) and getattr(func, \"__name__\", \"<lambda>\") != \"<lambda>\"\ndef get_empty_parameterset_mark(\n    config: Config, argnames: Sequence[str], func\n) -> \"MarkDecorator\":\n    from ..nodes import Collector\n    fs, lineno = getfslineno(func)\n    reason = \"got empty parameter set %r, function %s at %s:%d\" % (\n        argnames,",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "Markable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "Markable = TypeVar(\"Markable\", bound=Union[Callable[..., object], type])\n@attr.s(init=False, auto_attribs=True)\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n    ``MarkDecorators`` are created with ``pytest.mark``::\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n    and can then be applied as decorators to test functions::\n        @mark2\n        def test_function():",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "MARK_GEN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.mark.structures",
        "description": "__pypackages__.3.10.lib._pytest.mark.structures",
        "peekOfCode": "MARK_GEN = MarkGenerator(_ispytest=True)\n@final\nclass NodeKeywords(MutableMapping[str, Any]):\n    __slots__ = (\"node\", \"parent\", \"_markers\")\n    def __init__(self, node: \"Node\") -> None:\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n    def __getitem__(self, key: str) -> Any:\n        try:",
        "detail": "__pypackages__.3.10.lib._pytest.mark.structures",
        "documentation": {}
    },
    {
        "label": "FastFilesCompleter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest._argcomplete",
        "description": "__pypackages__.3.10.lib._pytest._argcomplete",
        "peekOfCode": "class FastFilesCompleter:\n    \"\"\"Fast file completer class.\"\"\"\n    def __init__(self, directories: bool = True) -> None:\n        self.directories = directories\n    def __call__(self, prefix: str, **kwargs: Any) -> List[str]:\n        # Only called on non option completions.\n        if os.path.sep in prefix[1:]:\n            prefix_dir = len(os.path.dirname(prefix) + os.path.sep)\n        else:\n            prefix_dir = 0",
        "detail": "__pypackages__.3.10.lib._pytest._argcomplete",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._version",
        "description": "__pypackages__.3.10.lib._pytest._version",
        "peekOfCode": "__version__ = version = '7.2.1'\n__version_tuple__ = version_tuple = (7, 2, 1)",
        "detail": "__pypackages__.3.10.lib._pytest._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest._version",
        "description": "__pypackages__.3.10.lib._pytest._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (7, 2, 1)",
        "detail": "__pypackages__.3.10.lib._pytest._version",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "class Cache:\n    _cachedir: Path = attr.ib(repr=False)\n    _config: Config = attr.ib(repr=False)\n    # Sub-directory under cache-dir for directories created by `mkdir()`.\n    _CACHE_PREFIX_DIRS = \"d\"\n    # Sub-directory under cache-dir for values created by `set()`.\n    _CACHE_PREFIX_VALUES = \"v\"\n    def __init__(\n        self, cachedir: Path, config: Config, *, _ispytest: bool = False\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "LFPluginCollWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "class LFPluginCollWrapper:\n    def __init__(self, lfplugin: \"LFPlugin\") -> None:\n        self.lfplugin = lfplugin\n        self._collected_at_least_one_failure = False\n    @hookimpl(hookwrapper=True)\n    def pytest_make_collect_report(self, collector: nodes.Collector):\n        if isinstance(collector, Session):\n            out = yield\n            res: CollectReport = out.get_result()\n            # Sort any lf-paths to the beginning.",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "LFPluginCollSkipfiles",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "class LFPluginCollSkipfiles:\n    def __init__(self, lfplugin: \"LFPlugin\") -> None:\n        self.lfplugin = lfplugin\n    @hookimpl\n    def pytest_make_collect_report(\n        self, collector: nodes.Collector\n    ) -> Optional[CollectReport]:\n        # Packages are Modules, but _last_failed_paths only contains\n        # test-bearing paths and doesn't try to include the paths of their\n        # packages, so don't filter them.",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "LFPlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "class LFPlugin:\n    \"\"\"Plugin which implements the --lf (run last-failing) option.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        active_keys = \"lf\", \"failedfirst\"\n        self.active = any(config.getoption(key) for key in active_keys)\n        assert config.cache\n        self.lastfailed: Dict[str, bool] = config.cache.get(\"cache/lastfailed\", {})\n        self._previously_failed_count: Optional[int] = None\n        self._report_status: Optional[str] = None",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "NFPlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "class NFPlugin:\n    \"\"\"Plugin which implements the --nf (run new-first) option.\"\"\"\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.active = config.option.newfirst\n        assert config.cache is not None\n        self.cached_nodeids = set(config.cache.get(\"cache/nodeids\", []))\n    @hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection_modifyitems(\n        self, items: List[nodes.Item]",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--lf\",\n        \"--last-failed\",\n        action=\"store_true\",\n        dest=\"lf\",\n        help=\"Rerun only the tests that failed \"\n        \"at the last run (or all if none failed)\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    if config.option.cacheshow:\n        from _pytest.main import wrap_session\n        return wrap_session(config, cacheshow)\n    return None\n@hookimpl(tryfirst=True)\ndef pytest_configure(config: Config) -> None:\n    config.cache = Cache.for_config(config, _ispytest=True)\n    config.pluginmanager.register(LFPlugin(config), \"lfplugin\")\n    config.pluginmanager.register(NFPlugin(config), \"nfplugin\")",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    config.cache = Cache.for_config(config, _ispytest=True)\n    config.pluginmanager.register(LFPlugin(config), \"lfplugin\")\n    config.pluginmanager.register(NFPlugin(config), \"nfplugin\")\n@fixture\ndef cache(request: FixtureRequest) -> Cache:\n    \"\"\"Return a cache object that can persist state between testing sessions.\n    cache.get(key, default)\n    cache.set(key, value)\n    Keys must be ``/`` separated strings, where the first part is usually the",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def cache(request: FixtureRequest) -> Cache:\n    \"\"\"Return a cache object that can persist state between testing sessions.\n    cache.get(key, default)\n    cache.set(key, value)\n    Keys must be ``/`` separated strings, where the first part is usually the\n    name of your plugin or application to avoid clashes with other cache users.\n    Values can be any object handled by the json stdlib module.\n    \"\"\"\n    assert request.config.cache is not None\n    return request.config.cache",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "pytest_report_header",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def pytest_report_header(config: Config) -> Optional[str]:\n    \"\"\"Display cachedir with --cache-show and if non-default.\"\"\"\n    if config.option.verbose > 0 or config.getini(\"cache_dir\") != \".pytest_cache\":\n        assert config.cache is not None\n        cachedir = config.cache._cachedir\n        # TODO: evaluate generating upward relative paths\n        # starting with .., ../.. if sensible\n        try:\n            displaypath = cachedir.relative_to(config.rootpath)\n        except ValueError:",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "cacheshow",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "def cacheshow(config: Config, session: Session) -> int:\n    from pprint import pformat\n    assert config.cache is not None\n    tw = TerminalWriter()\n    tw.line(\"cachedir: \" + str(config.cache._cachedir))\n    if not config.cache._cachedir.is_dir():\n        tw.line(\"cache is empty\")\n        return 0\n    glob = config.option.cacheshow[0]\n    if glob is None:",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "README_CONTENT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "README_CONTENT = \"\"\"\\\n# pytest cache directory #\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n**Do not** commit this to version control.\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\n\"\"\"\nCACHEDIR_TAG_CONTENT = b\"\"\"\\\nSignature: 8a477f597d28d172789f06886806bc55\n# This file is a cache directory tag created by pytest.",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "CACHEDIR_TAG_CONTENT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "description": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "peekOfCode": "CACHEDIR_TAG_CONTENT = b\"\"\"\\\nSignature: 8a477f597d28d172789f06886806bc55\n# This file is a cache directory tag created by pytest.\n# For information about cache directory tags, see:\n#\thttps://bford.info/cachedir/spec.html\n\"\"\"\n@final\n@attr.s(init=False, auto_attribs=True)\nclass Cache:\n    _cachedir: Path = attr.ib(repr=False)",
        "detail": "__pypackages__.3.10.lib._pytest.cacheprovider",
        "documentation": {}
    },
    {
        "label": "EncodedFile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class EncodedFile(io.TextIOWrapper):\n    __slots__ = ()\n    @property\n    def name(self) -> str:\n        # Ensure that file.name is a string. Workaround for a Python bug\n        # fixed in >=3.7.4: https://bugs.python.org/issue36015\n        return repr(self.buffer)\n    @property\n    def mode(self) -> str:\n        # TextIOWrapper doesn't expose a mode, but at least some of our",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "CaptureIO",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class CaptureIO(io.TextIOWrapper):\n    def __init__(self) -> None:\n        super().__init__(io.BytesIO(), encoding=\"UTF-8\", newline=\"\", write_through=True)\n    def getvalue(self) -> str:\n        assert isinstance(self.buffer, io.BytesIO)\n        return self.buffer.getvalue().decode(\"UTF-8\")\nclass TeeCaptureIO(CaptureIO):\n    def __init__(self, other: TextIO) -> None:\n        self._other = other\n        super().__init__()",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "TeeCaptureIO",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class TeeCaptureIO(CaptureIO):\n    def __init__(self, other: TextIO) -> None:\n        self._other = other\n        super().__init__()\n    def write(self, s: str) -> int:\n        super().write(s)\n        return self._other.write(s)\nclass DontReadFromInput:\n    encoding = None\n    def read(self, *args):",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "DontReadFromInput",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class DontReadFromInput:\n    encoding = None\n    def read(self, *args):\n        raise OSError(\n            \"pytest: reading from stdin while output is captured!  Consider using `-s`.\"\n        )\n    readline = read\n    readlines = read\n    __next__ = read\n    def __iter__(self):",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "NoCapture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class NoCapture:\n    EMPTY_BUFFER = None\n    __init__ = start = done = suspend = resume = lambda *args: None\nclass SysCaptureBinary:\n    EMPTY_BUFFER = b\"\"\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "SysCaptureBinary",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class SysCaptureBinary:\n    EMPTY_BUFFER = b\"\"\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "SysCapture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n    def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "FDCaptureBinary",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given OS-level file descriptor.\n    snap() produces `bytes`.\n    \"\"\"\n    EMPTY_BUFFER = b\"\"\n    def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n        try:\n            os.fstat(targetfd)\n        except OSError:",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "FDCapture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given OS-level file descriptor.\n    snap() produces text.\n    \"\"\"\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "CaptureResult",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class CaptureResult(Generic[AnyStr]):\n    \"\"\"The result of :method:`CaptureFixture.readouterr`.\"\"\"\n    __slots__ = (\"out\", \"err\")\n    def __init__(self, out: AnyStr, err: AnyStr) -> None:\n        self.out: AnyStr = out\n        self.err: AnyStr = err\n    def __len__(self) -> int:\n        return 2\n    def __iter__(self) -> Iterator[AnyStr]:\n        return iter((self.out, self.err))",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "MultiCapture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class MultiCapture(Generic[AnyStr]):\n    _state = None\n    _in_suspended = False\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out,",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "CaptureManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class CaptureManager:\n    \"\"\"The capture plugin.\n    Manages that the appropriate capture method is enabled/disabled during\n    collection and each test phase (setup, call, teardown). After each of\n    those points, the captured output is obtained and attached to the\n    collection/runtest report.\n    There are two levels of capture:\n    * global: enabled by default and can be suppressed by the ``-s``\n      option. This is always enabled/disabled during collection and each test\n      phase.",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "CaptureFixture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "class CaptureFixture(Generic[AnyStr]):\n    \"\"\"Object returned by the :fixture:`capsys`, :fixture:`capsysbinary`,\n    :fixture:`capfd` and :fixture:`capfdbinary` fixtures.\"\"\"\n    def __init__(\n        self, captureclass, request: SubRequest, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n        self.captureclass = captureclass\n        self.request = request\n        self._capture: Optional[MultiCapture[AnyStr]] = None",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--capture\",\n        action=\"store\",\n        default=\"fd\",\n        metavar=\"method\",\n        choices=[\"fd\", \"sys\", \"no\", \"tee-sys\"],\n        help=\"Per-test capturing method: one of fd|sys|no|tee-sys\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "pytest_load_initial_conftests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def pytest_load_initial_conftests(early_config: Config):\n    ns = early_config.known_args_namespace\n    if ns.capture == \"fd\":\n        _windowsconsoleio_workaround(sys.stdout)\n    _colorama_workaround()\n    pluginmanager = early_config.pluginmanager\n    capman = CaptureManager(ns.capture)\n    pluginmanager.register(capman, \"capturemanager\")\n    # Make sure that capturemanager is properly reset at final shutdown.\n    early_config.add_cleanup(capman.stop_global_capturing)",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "capsys",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def capsys(request: SubRequest) -> Generator[CaptureFixture[str], None, None]:\n    r\"\"\"Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.\n    The captured output is made available via ``capsys.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``text`` objects.\n    Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.\n    Example:\n    .. code-block:: python\n        def test_output(capsys):\n            print(\"hello\")",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "capsysbinary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def capsysbinary(request: SubRequest) -> Generator[CaptureFixture[bytes], None, None]:\n    r\"\"\"Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.\n    The captured output is made available via ``capsysbinary.readouterr()``\n    method calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``bytes`` objects.\n    Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.\n    Example:\n    .. code-block:: python\n        def test_output(capsysbinary):\n            print(\"hello\")",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "capfd",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def capfd(request: SubRequest) -> Generator[CaptureFixture[str], None, None]:\n    r\"\"\"Enable text capturing of writes to file descriptors ``1`` and ``2``.\n    The captured output is made available via ``capfd.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``text`` objects.\n    Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.\n    Example:\n    .. code-block:: python\n        def test_system_echo(capfd):\n            os.system('echo \"hello\"')",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "capfdbinary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "def capfdbinary(request: SubRequest) -> Generator[CaptureFixture[bytes], None, None]:\n    r\"\"\"Enable bytes capturing of writes to file descriptors ``1`` and ``2``.\n    The captured output is made available via ``capfd.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``byte`` objects.\n    Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.\n    Example:\n    .. code-block:: python\n        def test_system_echo(capfdbinary):\n            os.system('echo \"hello\"')",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "patchsysdict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.capture",
        "description": "__pypackages__.3.10.lib._pytest.capture",
        "peekOfCode": "patchsysdict = {0: \"stdin\", 1: \"stdout\", 2: \"stderr\"}\nclass NoCapture:\n    EMPTY_BUFFER = None\n    __init__ = start = done = suspend = resume = lambda *args: None\nclass SysCaptureBinary:\n    EMPTY_BUFFER = b\"\"\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name",
        "detail": "__pypackages__.3.10.lib._pytest.capture",
        "documentation": {}
    },
    {
        "label": "NotSetType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "class NotSetType(enum.Enum):\n    token = 0\nNOTSET: \"Final\" = NotSetType.token  # noqa: E305\n# fmt: on\nif sys.version_info >= (3, 8):\n    import importlib.metadata\n    importlib_metadata = importlib.metadata\nelse:\n    import importlib_metadata as importlib_metadata  # noqa: F401\ndef _format_args(func: Callable[..., Any]) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "_PytestWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "class _PytestWrapper:\n    \"\"\"Dummy wrapper around a function object for internal use only.\n    Used to correctly unwrap the underlying function object when we are\n    creating fixtures, because we wrap the function object ourselves with a\n    decorator to issue warnings when the fixture function is called directly.\n    \"\"\"\n    obj = attr.ib()\ndef get_real_func(obj):\n    \"\"\"Get the real function object of the (possibly) wrapped object by\n    functools.wraps or functools.partial.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "legacy_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def legacy_path(path: Union[str, \"os.PathLike[str]\"]) -> LEGACY_PATH:\n    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"\n    return LEGACY_PATH(path)\n# fmt: off\n# Singleton type for NOTSET, as described in:\n# https://www.python.org/dev/peps/pep-0484/#support-for-singleton-types-in-unions\nclass NotSetType(enum.Enum):\n    token = 0\nNOTSET: \"Final\" = NotSetType.token  # noqa: E305\n# fmt: on",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_generator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def is_generator(func: object) -> bool:\n    genfunc = inspect.isgeneratorfunction(func)\n    return genfunc and not iscoroutinefunction(func)\ndef iscoroutinefunction(func: object) -> bool:\n    \"\"\"Return True if func is a coroutine function (a function defined with async\n    def syntax, and doesn't contain yield), or a function decorated with\n    @asyncio.coroutine.\n    Note: copied and modified from Python 3.5's builtin couroutines.py to avoid\n    importing asyncio directly, which in turns also initializes the \"logging\"\n    module as a side-effect (see issue #8).",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "iscoroutinefunction",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def iscoroutinefunction(func: object) -> bool:\n    \"\"\"Return True if func is a coroutine function (a function defined with async\n    def syntax, and doesn't contain yield), or a function decorated with\n    @asyncio.coroutine.\n    Note: copied and modified from Python 3.5's builtin couroutines.py to avoid\n    importing asyncio directly, which in turns also initializes the \"logging\"\n    module as a side-effect (see issue #8).\n    \"\"\"\n    return inspect.iscoroutinefunction(func) or getattr(func, \"_is_coroutine\", False)\ndef is_async_function(func: object) -> bool:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "is_async_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def is_async_function(func: object) -> bool:\n    \"\"\"Return True if the given function seems to be an async function or\n    an async generator.\"\"\"\n    return iscoroutinefunction(func) or inspect.isasyncgenfunction(func)\ndef getlocation(function, curdir: Optional[str] = None) -> str:\n    function = get_real_func(function)\n    fn = Path(inspect.getfile(function))\n    lineno = function.__code__.co_firstlineno\n    if curdir is not None:\n        try:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "getlocation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def getlocation(function, curdir: Optional[str] = None) -> str:\n    function = get_real_func(function)\n    fn = Path(inspect.getfile(function))\n    lineno = function.__code__.co_firstlineno\n    if curdir is not None:\n        try:\n            relfn = fn.relative_to(curdir)\n        except ValueError:\n            pass\n        else:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "num_mock_patch_args",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def num_mock_patch_args(function) -> int:\n    \"\"\"Return number of arguments used up by mock arguments (if any).\"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n    mock_sentinel = getattr(sys.modules.get(\"mock\"), \"DEFAULT\", object())\n    ut_mock_sentinel = getattr(sys.modules.get(\"unittest.mock\"), \"DEFAULT\", object())\n    return len(\n        [\n            p",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "getfuncargnames",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def getfuncargnames(\n    function: Callable[..., Any],\n    *,\n    name: str = \"\",\n    is_method: bool = False,\n    cls: Optional[type] = None,\n) -> Tuple[str, ...]:\n    \"\"\"Return the names of a function's mandatory arguments.\n    Should return the names of all function arguments that:\n    * Aren't bound to an instance or type as in instance or class methods.",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_default_arg_names",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def get_default_arg_names(function: Callable[..., Any]) -> Tuple[str, ...]:\n    # Note: this code intentionally mirrors the code at the beginning of\n    # getfuncargnames, to get the arguments which were excluded from its result\n    # because they had default values.\n    return tuple(\n        p.name\n        for p in signature(function).parameters.values()\n        if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n        and p.default is not Parameter.empty\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "ascii_escaped",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def ascii_escaped(val: Union[bytes, str]) -> str:\n    r\"\"\"If val is pure ASCII, return it as an str, otherwise, escape\n    bytes objects into a sequence of escaped bytes:\n    b'\\xc3\\xb4\\xc5\\xd6' -> r'\\xc3\\xb4\\xc5\\xd6'\n    and escapes unicode objects into a sequence of escaped unicode\n    ids, e.g.:\n    r'4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'\n    Note:\n       The obvious \"v.decode('unicode-escape')\" will return\n       valid UTF-8 unicode if it finds them in bytes, but we",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_func",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def get_real_func(obj):\n    \"\"\"Get the real function object of the (possibly) wrapped object by\n    functools.wraps or functools.partial.\"\"\"\n    start_obj = obj\n    for i in range(100):\n        # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function\n        # to trigger a warning if it gets called directly instead of by pytest: we don't\n        # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)\n        new_obj = getattr(obj, \"__pytest_wrapped__\", None)\n        if isinstance(new_obj, _PytestWrapper):",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "get_real_method",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def get_real_method(obj, holder):\n    \"\"\"Attempt to obtain the real function object that might be wrapping\n    ``obj``, while at the same time returning a bound method to ``holder`` if\n    the original object was a bound method.\"\"\"\n    try:\n        is_method = hasattr(obj, \"__func__\")\n        obj = get_real_func(obj)\n    except Exception:  # pragma: no cover\n        return obj\n    if is_method and hasattr(obj, \"__get__\") and callable(obj.__get__):",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "getimfunc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def getimfunc(func):\n    try:\n        return func.__func__\n    except AttributeError:\n        return func\ndef safe_getattr(object: Any, name: str, default: Any) -> Any:\n    \"\"\"Like getattr but return default upon any Exception or any OutcomeException.\n    Attribute access can potentially fail for 'evil' Python objects.\n    See issue #214.\n    It catches OutcomeException because of #2490 (issue #580), new outcomes",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_getattr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def safe_getattr(object: Any, name: str, default: Any) -> Any:\n    \"\"\"Like getattr but return default upon any Exception or any OutcomeException.\n    Attribute access can potentially fail for 'evil' Python objects.\n    See issue #214.\n    It catches OutcomeException because of #2490 (issue #580), new outcomes\n    are derived from BaseException instead of Exception (for more details\n    check #2707).\n    \"\"\"\n    from _pytest.outcomes import TEST_OUTCOME\n    try:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "safe_isclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def safe_isclass(obj: object) -> bool:\n    \"\"\"Ignore any exception via isinstance on Python 3.\"\"\"\n    try:\n        return inspect.isclass(obj)\n    except Exception:\n        return False\nif TYPE_CHECKING:\n    if sys.version_info >= (3, 8):\n        from typing import final as final\n    else:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "def assert_never(value: NoReturn) -> NoReturn:\n    assert False, f\"Unhandled value: {value} ({type(value).__name__})\"",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n#: constant to prepare valuing pylib path replacements/lazy proxies later on\n#  intended for removal in pytest 8.0 or 9.0\n# fmt: off\n# intentional space to create a fake difference for the verification\nLEGACY_PATH = py.path. local\n# fmt: on\ndef legacy_path(path: Union[str, \"os.PathLike[str]\"]) -> LEGACY_PATH:\n    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "_S",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "_S = TypeVar(\"_S\")\n#: constant to prepare valuing pylib path replacements/lazy proxies later on\n#  intended for removal in pytest 8.0 or 9.0\n# fmt: off\n# intentional space to create a fake difference for the verification\nLEGACY_PATH = py.path. local\n# fmt: on\ndef legacy_path(path: Union[str, \"os.PathLike[str]\"]) -> LEGACY_PATH:\n    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"\n    return LEGACY_PATH(path)",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "LEGACY_PATH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "LEGACY_PATH = py.path. local\n# fmt: on\ndef legacy_path(path: Union[str, \"os.PathLike[str]\"]) -> LEGACY_PATH:\n    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"\n    return LEGACY_PATH(path)\n# fmt: off\n# Singleton type for NOTSET, as described in:\n# https://www.python.org/dev/peps/pep-0484/#support-for-singleton-types-in-unions\nclass NotSetType(enum.Enum):\n    token = 0",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "_non_printable_ascii_translate_table",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "_non_printable_ascii_translate_table = {\n    i: f\"\\\\x{i:02x}\" for i in range(128) if i not in range(32, 127)\n}\n_non_printable_ascii_translate_table.update(\n    {ord(\"\\t\"): \"\\\\t\", ord(\"\\r\"): \"\\\\r\", ord(\"\\n\"): \"\\\\n\"}\n)\ndef _translate_non_printable(s: str) -> str:\n    return s.translate(_non_printable_ascii_translate_table)\nSTRING_TYPES = bytes, str\ndef _bytes_to_ascii(val: bytes) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "STRING_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.compat",
        "description": "__pypackages__.3.10.lib._pytest.compat",
        "peekOfCode": "STRING_TYPES = bytes, str\ndef _bytes_to_ascii(val: bytes) -> str:\n    return val.decode(\"ascii\", \"backslashreplace\")\ndef ascii_escaped(val: Union[bytes, str]) -> str:\n    r\"\"\"If val is pure ASCII, return it as an str, otherwise, escape\n    bytes objects into a sequence of escaped bytes:\n    b'\\xc3\\xb4\\xc5\\xd6' -> r'\\xc3\\xb4\\xc5\\xd6'\n    and escapes unicode objects into a sequence of escaped unicode\n    ids, e.g.:\n    r'4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'",
        "detail": "__pypackages__.3.10.lib._pytest.compat",
        "documentation": {}
    },
    {
        "label": "pytestPDB",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "class pytestPDB:\n    \"\"\"Pseudo PDB that defers to the real pdb.\"\"\"\n    _pluginmanager: Optional[PytestPluginManager] = None\n    _config: Optional[Config] = None\n    _saved: List[\n        Tuple[Callable[..., None], Optional[PytestPluginManager], Optional[Config]]\n    ] = []\n    _recursive_debug = 0\n    _wrapped_pdb_cls: Optional[Tuple[Type[Any], Type[Any]]] = None\n    @classmethod",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "PdbInvoke",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "class PdbInvoke:\n    def pytest_exception_interact(\n        self, node: Node, call: \"CallInfo[Any]\", report: BaseReport\n    ) -> None:\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "PdbTrace",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "class PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_call(self, pyfuncitem) -> Generator[None, None, None]:\n        wrap_pytest_function_for_tracing(pyfuncitem)\n        yield\ndef wrap_pytest_function_for_tracing(pyfuncitem):\n    \"\"\"Change the Python function object of the given Function item by a\n    wrapper which actually enters pdb before calling the python function\n    itself, effectively leaving the user in the pdb prompt in the first\n    statement of the function.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"Start the interactive Python debugger on errors or KeyboardInterrupt\",\n    )\n    group._addoption(\n        \"--pdbcls\",",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    import pdb\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "wrap_pytest_function_for_tracing",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "def wrap_pytest_function_for_tracing(pyfuncitem):\n    \"\"\"Change the Python function object of the given Function item by a\n    wrapper which actually enters pdb before calling the python function\n    itself, effectively leaving the user in the pdb prompt in the first\n    statement of the function.\"\"\"\n    _pdb = pytestPDB._init_pdb(\"runcall\")\n    testfunction = pyfuncitem.obj\n    # we can't just return `partial(pdb.runcall, testfunction)` because (on\n    # python < 3.7.4) runcall's first param is `func`, which means we'd get\n    # an exception if one of the kwargs to testfunction was called `func`.",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "maybe_wrap_pytest_function_for_tracing",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "def maybe_wrap_pytest_function_for_tracing(pyfuncitem):\n    \"\"\"Wrap the given pytestfunct item for tracing support if --trace was given in\n    the command line.\"\"\"\n    if pyfuncitem.config.getvalue(\"trace\"):\n        wrap_pytest_function_for_tracing(pyfuncitem)\ndef _enter_pdb(\n    node: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport\n) -> BaseReport:\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "post_mortem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.debugging",
        "description": "__pypackages__.3.10.lib._pytest.debugging",
        "peekOfCode": "def post_mortem(t: types.TracebackType) -> None:\n    p = pytestPDB._init_pdb(\"post_mortem\")\n    p.reset()\n    p.interaction(None, t)\n    if p.quitting:\n        outcomes.exit(\"Quitting debugger\")",
        "detail": "__pypackages__.3.10.lib._pytest.debugging",
        "documentation": {}
    },
    {
        "label": "check_ispytest",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "def check_ispytest(ispytest: bool) -> None:\n    if not ispytest:\n        warn(PRIVATE, stacklevel=3)",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "DEPRECATED_EXTERNAL_PLUGINS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "DEPRECATED_EXTERNAL_PLUGINS = {\n    \"pytest_catchlog\",\n    \"pytest_capturelog\",\n    \"pytest_faulthandler\",\n}\nNOSE_SUPPORT = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"Support for nose tests is deprecated and will be removed in a future release.\\n\"\n    \"{nodeid} is using nose method: `{method}` ({stage})\\n\"\n    \"See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose\",",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NOSE_SUPPORT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "NOSE_SUPPORT = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"Support for nose tests is deprecated and will be removed in a future release.\\n\"\n    \"{nodeid} is using nose method: `{method}` ({stage})\\n\"\n    \"See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose\",\n)\nNOSE_SUPPORT_METHOD = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"Support for nose tests is deprecated and will be removed in a future release.\\n\"\n    \"{nodeid} is using nose-specific method: `{method}(self)`\\n\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NOSE_SUPPORT_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "NOSE_SUPPORT_METHOD = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"Support for nose tests is deprecated and will be removed in a future release.\\n\"\n    \"{nodeid} is using nose-specific method: `{method}(self)`\\n\"\n    \"To remove this warning, rename it to `{method}_method(self)`\\n\"\n    \"See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose\",\n)\n# This can be* removed pytest 8, but it's harmless and common, so no rush to remove.\n# * If you're in the future: \"could have been\".\nYIELD_FIXTURE = PytestDeprecationWarning(",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "YIELD_FIXTURE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "YIELD_FIXTURE = PytestDeprecationWarning(\n    \"@pytest.yield_fixture is deprecated.\\n\"\n    \"Use @pytest.fixture instead; they are the same.\"\n)\nWARNING_CMDLINE_PREPARSE_HOOK = PytestRemovedIn8Warning(\n    \"The pytest_cmdline_preparse hook is deprecated and will be removed in a future release. \\n\"\n    \"Please use pytest_load_initial_conftests hook instead.\"\n)\nFSCOLLECTOR_GETHOOKPROXY_ISINITPATH = PytestRemovedIn8Warning(\n    \"The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; \"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "WARNING_CMDLINE_PREPARSE_HOOK",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "WARNING_CMDLINE_PREPARSE_HOOK = PytestRemovedIn8Warning(\n    \"The pytest_cmdline_preparse hook is deprecated and will be removed in a future release. \\n\"\n    \"Please use pytest_load_initial_conftests hook instead.\"\n)\nFSCOLLECTOR_GETHOOKPROXY_ISINITPATH = PytestRemovedIn8Warning(\n    \"The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; \"\n    \"use self.session.gethookproxy() and self.session.isinitpath() instead. \"\n)\nSTRICT_OPTION = PytestRemovedIn8Warning(\n    \"The --strict option is deprecated, use --strict-markers instead.\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH = PytestRemovedIn8Warning(\n    \"The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; \"\n    \"use self.session.gethookproxy() and self.session.isinitpath() instead. \"\n)\nSTRICT_OPTION = PytestRemovedIn8Warning(\n    \"The --strict option is deprecated, use --strict-markers instead.\"\n)\n# This deprecation is never really meant to be removed.\nPRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\nARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "STRICT_OPTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "STRICT_OPTION = PytestRemovedIn8Warning(\n    \"The --strict option is deprecated, use --strict-markers instead.\"\n)\n# This deprecation is never really meant to be removed.\nPRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\nARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(\n    'pytest now uses argparse. \"%default\" should be changed to \"%(default)s\"',\n)\nARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n    PytestRemovedIn8Warning,",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "PRIVATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "PRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\nARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(\n    'pytest now uses argparse. \"%default\" should be changed to \"%(default)s\"',\n)\nARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"`type` argument to addoption() is the string {typ!r}.\"\n    \" For choices this is optional and can be omitted, \"\n    \" but when supplied should be a type (for example `str` or `int`).\"\n    \" (options: {names})\",",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_PERCENT_DEFAULT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "ARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(\n    'pytest now uses argparse. \"%default\" should be changed to \"%(default)s\"',\n)\nARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"`type` argument to addoption() is the string {typ!r}.\"\n    \" For choices this is optional and can be omitted, \"\n    \" but when supplied should be a type (for example `str` or `int`).\"\n    \" (options: {names})\",\n)",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_TYPE_STR_CHOICE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "ARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"`type` argument to addoption() is the string {typ!r}.\"\n    \" For choices this is optional and can be omitted, \"\n    \" but when supplied should be a type (for example `str` or `int`).\"\n    \" (options: {names})\",\n)\nARGUMENT_TYPE_STR = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"`type` argument to addoption() is the string {typ!r}, \"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_TYPE_STR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "ARGUMENT_TYPE_STR = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"`type` argument to addoption() is the string {typ!r}, \"\n    \" but when supplied should be a type (for example `str` or `int`).\"\n    \" (options: {names})\",\n)\nHOOK_LEGACY_PATH_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"The ({pylib_path_arg}: py.path.local) argument is deprecated, please use ({pathlib_path_arg}: pathlib.Path)\\n\"\n    \"see https://docs.pytest.org/en/latest/deprecations.html\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "HOOK_LEGACY_PATH_ARG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "HOOK_LEGACY_PATH_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"The ({pylib_path_arg}: py.path.local) argument is deprecated, please use ({pathlib_path_arg}: pathlib.Path)\\n\"\n    \"see https://docs.pytest.org/en/latest/deprecations.html\"\n    \"#py-path-local-arguments-for-hooks-replaced-with-pathlib-path\",\n)\nNODE_CTOR_FSPATH_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"The (fspath: py.path.local) argument to {node_type_name} is deprecated. \"\n    \"Please use the (path: pathlib.Path) argument instead.\\n\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "NODE_CTOR_FSPATH_ARG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "NODE_CTOR_FSPATH_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"The (fspath: py.path.local) argument to {node_type_name} is deprecated. \"\n    \"Please use the (path: pathlib.Path) argument instead.\\n\"\n    \"See https://docs.pytest.org/en/latest/deprecations.html\"\n    \"#fspath-argument-for-node-constructors-replaced-with-pathlib-path\",\n)\nWARNS_NONE_ARG = PytestRemovedIn8Warning(\n    \"Passing None has been deprecated.\\n\"\n    \"See https://docs.pytest.org/en/latest/how-to/capture-warnings.html\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "WARNS_NONE_ARG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "WARNS_NONE_ARG = PytestRemovedIn8Warning(\n    \"Passing None has been deprecated.\\n\"\n    \"See https://docs.pytest.org/en/latest/how-to/capture-warnings.html\"\n    \"#additional-use-cases-of-warnings-in-tests\"\n    \" for alternatives in common use cases.\"\n)\nKEYWORD_MSG_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"pytest.{func}(msg=...) is now deprecated, use pytest.{func}(reason=...) instead\",\n)",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "KEYWORD_MSG_ARG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "KEYWORD_MSG_ARG = UnformattedWarning(\n    PytestRemovedIn8Warning,\n    \"pytest.{func}(msg=...) is now deprecated, use pytest.{func}(reason=...) instead\",\n)\nINSTANCE_COLLECTOR = PytestRemovedIn8Warning(\n    \"The pytest.Instance collector type is deprecated and is no longer used. \"\n    \"See https://docs.pytest.org/en/latest/deprecations.html#the-pytest-instance-collector\",\n)\nHOOK_LEGACY_MARKING = UnformattedWarning(\n    PytestDeprecationWarning,",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "INSTANCE_COLLECTOR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "INSTANCE_COLLECTOR = PytestRemovedIn8Warning(\n    \"The pytest.Instance collector type is deprecated and is no longer used. \"\n    \"See https://docs.pytest.org/en/latest/deprecations.html#the-pytest-instance-collector\",\n)\nHOOK_LEGACY_MARKING = UnformattedWarning(\n    PytestDeprecationWarning,\n    \"The hook{type} {fullname} uses old-style configuration options (marks or attributes).\\n\"\n    \"Please use the pytest.hook{type}({hook_opts}) decorator instead\\n\"\n    \" to configure the hooks.\\n\"\n    \" See https://docs.pytest.org/en/latest/deprecations.html\"",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "HOOK_LEGACY_MARKING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.deprecated",
        "description": "__pypackages__.3.10.lib._pytest.deprecated",
        "peekOfCode": "HOOK_LEGACY_MARKING = UnformattedWarning(\n    PytestDeprecationWarning,\n    \"The hook{type} {fullname} uses old-style configuration options (marks or attributes).\\n\"\n    \"Please use the pytest.hook{type}({hook_opts}) decorator instead\\n\"\n    \" to configure the hooks.\\n\"\n    \" See https://docs.pytest.org/en/latest/deprecations.html\"\n    \"#configuring-hook-specs-impls-using-markers\",\n)\n# You want to make some `__init__` or function \"private\".\n#",
        "detail": "__pypackages__.3.10.lib._pytest.deprecated",
        "documentation": {}
    },
    {
        "label": "ReprFailDoctest",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "class ReprFailDoctest(TerminalRepr):\n    def __init__(\n        self, reprlocation_lines: Sequence[Tuple[ReprFileLocation, Sequence[str]]]\n    ) -> None:\n        self.reprlocation_lines = reprlocation_lines\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for reprlocation, lines in self.reprlocation_lines:\n            for line in lines:\n                tw.line(line)\n            reprlocation.toterminal(tw)",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "MultipleDoctestFailures",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "class MultipleDoctestFailures(Exception):\n    def __init__(self, failures: Sequence[\"doctest.DocTestFailure\"]) -> None:\n        super().__init__()\n        self.failures = failures\ndef _init_runner_class() -> Type[\"doctest.DocTestRunner\"]:\n    import doctest\n    class PytestDoctestRunner(doctest.DebugRunner):\n        \"\"\"Runner to collect failures.\n        Note that the out variable in this case is a list instead of a\n        stdout-like object.",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DoctestItem",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "class DoctestItem(Item):\n    def __init__(\n        self,\n        name: str,\n        parent: \"Union[DoctestTextfile, DoctestModule]\",\n        runner: Optional[\"doctest.DocTestRunner\"] = None,\n        dtest: Optional[\"doctest.DocTest\"] = None,\n    ) -> None:\n        super().__init__(name, parent)\n        self.runner = runner",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DoctestTextfile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "class DoctestTextfile(Module):\n    obj = None\n    def collect(self) -> Iterable[DoctestItem]:\n        import doctest\n        # Inspired by doctest.testfile; ideally we would use it directly,\n        # but it doesn't support passing a custom checker.\n        encoding = self.config.getini(\"doctest_encoding\")\n        text = self.path.read_text(encoding)\n        filename = str(self.path)\n        name = self.path.name",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DoctestModule",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "class DoctestModule(Module):\n    def collect(self) -> Iterable[DoctestItem]:\n        import doctest\n        class MockAwareDocTestFinder(doctest.DocTestFinder):\n            \"\"\"A hackish doctest finder that overrides stdlib internals to fix a stdlib bug.\n            https://github.com/pytest-dev/pytest/issues/3456\n            https://bugs.python.org/issue25532\n            \"\"\"\n            def _find_lineno(self, obj, source_lines):\n                \"\"\"Doctest code does not take into account `@property`, this",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"doctest_optionflags\",\n        \"Option flags for doctests\",\n        type=\"args\",\n        default=[\"ELLIPSIS\"],\n    )\n    parser.addini(\n        \"doctest_encoding\", \"Encoding used for doctest files\", default=\"utf-8\"\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "def pytest_unconfigure() -> None:\n    global RUNNER_CLASS\n    RUNNER_CLASS = None\ndef pytest_collect_file(\n    file_path: Path,\n    parent: Collector,\n) -> Optional[Union[\"DoctestModule\", \"DoctestTextfile\"]]:\n    config = parent.config\n    if file_path.suffix == \".py\":\n        if config.option.doctestmodules and not any(",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "pytest_collect_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "def pytest_collect_file(\n    file_path: Path,\n    parent: Collector,\n) -> Optional[Union[\"DoctestModule\", \"DoctestTextfile\"]]:\n    config = parent.config\n    if file_path.suffix == \".py\":\n        if config.option.doctestmodules and not any(\n            (_is_setup_py(file_path), _is_main_py(file_path))\n        ):\n            mod: DoctestModule = DoctestModule.from_parent(parent, path=file_path)",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "get_optionflags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "def get_optionflags(parent):\n    optionflags_str = parent.config.getini(\"doctest_optionflags\")\n    flag_lookup_table = _get_flag_lookup()\n    flag_acc = 0\n    for flag in optionflags_str:\n        flag_acc |= flag_lookup_table[flag]\n    return flag_acc\ndef _get_continue_on_failure(config):\n    continue_on_failure = config.getvalue(\"doctest_continue_on_failure\")\n    if continue_on_failure:",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "doctest_namespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "def doctest_namespace() -> Dict[str, Any]:\n    \"\"\"Fixture that returns a :py:class:`dict` that will be injected into the\n    namespace of doctests.\n    Usually this fixture is used in conjunction with another ``autouse`` fixture:\n    .. code-block:: python\n        @pytest.fixture(autouse=True)\n        def add_np(doctest_namespace):\n            doctest_namespace[\"np\"] = numpy\n    For more details: :ref:`doctest_namespace`.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICE_NONE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICE_NONE = \"none\"\nDOCTEST_REPORT_CHOICE_CDIFF = \"cdiff\"\nDOCTEST_REPORT_CHOICE_NDIFF = \"ndiff\"\nDOCTEST_REPORT_CHOICE_UDIFF = \"udiff\"\nDOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICE_CDIFF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICE_CDIFF = \"cdiff\"\nDOCTEST_REPORT_CHOICE_NDIFF = \"ndiff\"\nDOCTEST_REPORT_CHOICE_UDIFF = \"udiff\"\nDOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICE_NDIFF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICE_NDIFF = \"ndiff\"\nDOCTEST_REPORT_CHOICE_UDIFF = \"udiff\"\nDOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,\n)",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICE_UDIFF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICE_UDIFF = \"udiff\"\nDOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,\n)\n# Lazy definition of runner class",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,\n)\n# Lazy definition of runner class\nRUNNER_CLASS = None",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "DOCTEST_REPORT_CHOICES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "DOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,\n)\n# Lazy definition of runner class\nRUNNER_CLASS = None\n# Lazy definition of output checker class",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "RUNNER_CLASS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.doctest",
        "description": "__pypackages__.3.10.lib._pytest.doctest",
        "peekOfCode": "RUNNER_CLASS = None\n# Lazy definition of output checker class\nCHECKER_CLASS: Optional[Type[\"doctest.OutputChecker\"]] = None\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"doctest_optionflags\",\n        \"Option flags for doctests\",\n        type=\"args\",\n        default=[\"ELLIPSIS\"],\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.doctest",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    help = (\n        \"Dump the traceback of all threads if a test takes \"\n        \"more than TIMEOUT seconds to finish\"\n    )\n    parser.addini(\"faulthandler_timeout\", help, default=0.0)\ndef pytest_configure(config: Config) -> None:\n    import faulthandler\n    stderr_fd_copy = os.dup(get_stderr_fileno())\n    config.stash[fault_handler_stderr_key] = open(stderr_fd_copy, \"w\")",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    import faulthandler\n    stderr_fd_copy = os.dup(get_stderr_fileno())\n    config.stash[fault_handler_stderr_key] = open(stderr_fd_copy, \"w\")\n    config.stash[fault_handler_originally_enabled_key] = faulthandler.is_enabled()\n    faulthandler.enable(file=config.stash[fault_handler_stderr_key])\ndef pytest_unconfigure(config: Config) -> None:\n    import faulthandler\n    faulthandler.disable()\n    # Close the dup file installed during pytest_configure.",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_unconfigure(config: Config) -> None:\n    import faulthandler\n    faulthandler.disable()\n    # Close the dup file installed during pytest_configure.\n    if fault_handler_stderr_key in config.stash:\n        config.stash[fault_handler_stderr_key].close()\n        del config.stash[fault_handler_stderr_key]\n    if config.stash.get(fault_handler_originally_enabled_key, False):\n        # Re-enable the faulthandler if it was originally enabled.\n        faulthandler.enable(file=get_stderr_fileno())",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "get_stderr_fileno",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def get_stderr_fileno() -> int:\n    try:\n        fileno = sys.stderr.fileno()\n        # The Twisted Logger will return an invalid file descriptor since it is not backed\n        # by an FD. So, let's also forward this to the same code path as with pytest-xdist.\n        if fileno == -1:\n            raise AttributeError()\n        return fileno\n    except (AttributeError, io.UnsupportedOperation):\n        # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "get_timeout_config_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def get_timeout_config_value(config: Config) -> float:\n    return float(config.getini(\"faulthandler_timeout\") or 0.0)\n@pytest.hookimpl(hookwrapper=True, trylast=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    timeout = get_timeout_config_value(item.config)\n    stderr = item.config.stash[fault_handler_stderr_key]\n    if timeout > 0 and stderr is not None:\n        import faulthandler\n        faulthandler.dump_traceback_later(timeout, file=stderr)\n        try:",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    timeout = get_timeout_config_value(item.config)\n    stderr = item.config.stash[fault_handler_stderr_key]\n    if timeout > 0 and stderr is not None:\n        import faulthandler\n        faulthandler.dump_traceback_later(timeout, file=stderr)\n        try:\n            yield\n        finally:\n            faulthandler.cancel_dump_traceback_later()",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "pytest_enter_pdb",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_enter_pdb() -> None:\n    \"\"\"Cancel any traceback dumping due to timeout before entering pdb.\"\"\"\n    import faulthandler\n    faulthandler.cancel_dump_traceback_later()\n@pytest.hookimpl(tryfirst=True)\ndef pytest_exception_interact() -> None:\n    \"\"\"Cancel any traceback dumping due to an interactive exception being\n    raised.\"\"\"\n    import faulthandler\n    faulthandler.cancel_dump_traceback_later()",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "pytest_exception_interact",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "def pytest_exception_interact() -> None:\n    \"\"\"Cancel any traceback dumping due to an interactive exception being\n    raised.\"\"\"\n    import faulthandler\n    faulthandler.cancel_dump_traceback_later()",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "fault_handler_stderr_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "fault_handler_stderr_key = StashKey[TextIO]()\nfault_handler_originally_enabled_key = StashKey[bool]()\ndef pytest_addoption(parser: Parser) -> None:\n    help = (\n        \"Dump the traceback of all threads if a test takes \"\n        \"more than TIMEOUT seconds to finish\"\n    )\n    parser.addini(\"faulthandler_timeout\", help, default=0.0)\ndef pytest_configure(config: Config) -> None:\n    import faulthandler",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "fault_handler_originally_enabled_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.faulthandler",
        "description": "__pypackages__.3.10.lib._pytest.faulthandler",
        "peekOfCode": "fault_handler_originally_enabled_key = StashKey[bool]()\ndef pytest_addoption(parser: Parser) -> None:\n    help = (\n        \"Dump the traceback of all threads if a test takes \"\n        \"more than TIMEOUT seconds to finish\"\n    )\n    parser.addini(\"faulthandler_timeout\", help, default=0.0)\ndef pytest_configure(config: Config) -> None:\n    import faulthandler\n    stderr_fd_copy = os.dup(get_stderr_fileno())",
        "detail": "__pypackages__.3.10.lib._pytest.faulthandler",
        "documentation": {}
    },
    {
        "label": "PseudoFixtureDef",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class PseudoFixtureDef(Generic[FixtureValue]):\n    cached_result: \"_FixtureCachedResult[FixtureValue]\"\n    _scope: Scope\ndef pytest_sessionstart(session: \"Session\") -> None:\n    session._fixturemanager = FixtureManager(session)\ndef get_scope_package(node, fixturedef: \"FixtureDef[object]\"):\n    import pytest\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"{}/{}\".format(fixturedef.baseid, \"__init__.py\")",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FuncFixtureInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FuncFixtureInfo:\n    # Original function argument names.\n    argnames: Tuple[str, ...]\n    # Argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames: Tuple[str, ...]\n    names_closure: List[str]\n    name2fixturedefs: Dict[str, Sequence[\"FixtureDef[Any]\"]]\n    def prune_dependency_tree(self) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureRequest",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureRequest:\n    \"\"\"A request for a fixture from a test or fixture function.\n    A request object gives access to the requesting test context and has\n    an optional ``param`` attribute in case the fixture is parametrized\n    indirectly.\n    \"\"\"\n    def __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pyfuncitem = pyfuncitem\n        #: Fixture for which this request is being performed.",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "SubRequest",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class SubRequest(FixtureRequest):\n    \"\"\"A sub request for handling getting a fixture from a test function/fixture.\"\"\"\n    def __init__(\n        self,\n        request: \"FixtureRequest\",\n        scope: Scope,\n        param: Any,\n        param_index: int,\n        fixturedef: \"FixtureDef[object]\",\n        *,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureLookupError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureLookupError(LookupError):\n    \"\"\"Could not return a requested fixture (missing or invalid).\"\"\"\n    def __init__(\n        self, argname: Optional[str], request: FixtureRequest, msg: Optional[str] = None\n    ) -> None:\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n    def formatrepr(self) -> \"FixtureLookupErrorRepr\":",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureLookupErrorRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(\n        self,\n        filename: Union[str, \"os.PathLike[str]\"],\n        firstlineno: int,\n        tblines: Sequence[str],\n        errorstring: str,\n        argname: Optional[str],\n    ) -> None:\n        self.tblines = tblines",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureDef",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureDef(Generic[FixtureValue]):\n    \"\"\"A container for a fixture definition.\"\"\"\n    def __init__(\n        self,\n        fixturemanager: \"FixtureManager\",\n        baseid: Optional[str],\n        argname: str,\n        func: \"_FixtureFunc[FixtureValue]\",\n        scope: Union[Scope, \"_ScopeName\", Callable[[str, Config], \"_ScopeName\"], None],\n        params: Optional[Sequence[object]],",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureFunctionMarker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureFunctionMarker:\n    scope: \"Union[_ScopeName, Callable[[str, Config], _ScopeName]]\"\n    params: Optional[Tuple[object, ...]] = attr.ib(converter=_params_converter)\n    autouse: bool = False\n    ids: Optional[\n        Union[Tuple[Optional[object], ...], Callable[[Any], Optional[object]]]\n    ] = attr.ib(\n        default=None,\n        converter=_ensure_immutable_ids,\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "class FixtureManager:\n    \"\"\"pytest fixture definitions and information is stored and managed\n    from this class.\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def pytest_sessionstart(session: \"Session\") -> None:\n    session._fixturemanager = FixtureManager(session)\ndef get_scope_package(node, fixturedef: \"FixtureDef[object]\"):\n    import pytest\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"{}/{}\".format(fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "get_scope_package",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def get_scope_package(node, fixturedef: \"FixtureDef[object]\"):\n    import pytest\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"{}/{}\".format(fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "get_scope_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def get_scope_node(\n    node: nodes.Node, scope: Scope\n) -> Optional[Union[nodes.Item, nodes.Collector]]:\n    import _pytest.python\n    if scope is Scope.Function:\n        return node.getparent(nodes.Item)\n    elif scope is Scope.Class:\n        return node.getparent(_pytest.python.Class)\n    elif scope is Scope.Module:\n        return node.getparent(_pytest.python.Module)",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "add_funcarg_pseudo_fixture_def",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def add_funcarg_pseudo_fixture_def(\n    collector: nodes.Collector, metafunc: \"Metafunc\", fixturemanager: \"FixtureManager\"\n) -> None:\n    # This function will transform all collected calls to functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "getfixturemarker",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def getfixturemarker(obj: object) -> Optional[\"FixtureFunctionMarker\"]:\n    \"\"\"Return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    return cast(\n        Optional[FixtureFunctionMarker],\n        safe_getattr(obj, \"_pytestfixturefunction\", None),\n    )\n# Parametrized fixture key, helper alias for code below.\n_Key = Tuple[object, ...]\ndef get_parametrized_fixture_keys(item: nodes.Item, scope: Scope) -> Iterator[_Key]:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "get_parametrized_fixture_keys",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def get_parametrized_fixture_keys(item: nodes.Item, scope: Scope) -> Iterator[_Key]:\n    \"\"\"Return list of keys for all parametrized arguments which match\n    the specified scope.\"\"\"\n    assert scope is not Scope.Function\n    try:\n        callspec = item.callspec  # type: ignore[attr-defined]\n    except AttributeError:\n        pass\n    else:\n        cs: CallSpec2 = callspec",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "reorder_items",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:\n    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[_Key, None]]] = {}\n    items_by_argkey: Dict[Scope, Dict[_Key, Deque[nodes.Item]]] = {}\n    for scope in HIGH_SCOPES:\n        d: Dict[nodes.Item, Dict[_Key, None]] = {}\n        argkeys_cache[scope] = d\n        item_d: Dict[_Key, Deque[nodes.Item]] = defaultdict(deque)\n        items_by_argkey[scope] = item_d\n        for item in items:\n            keys = dict.fromkeys(get_parametrized_fixture_keys(item, scope), None)",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fix_cache_order",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def fix_cache_order(\n    item: nodes.Item,\n    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[_Key, None]]],\n    items_by_argkey: Dict[Scope, Dict[_Key, \"Deque[nodes.Item]\"]],\n) -> None:\n    for scope in HIGH_SCOPES:\n        for key in argkeys_cache[scope].get(item, []):\n            items_by_argkey[scope][key].appendleft(item)\ndef reorder_items_atscope(\n    items: Dict[nodes.Item, None],",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "reorder_items_atscope",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def reorder_items_atscope(\n    items: Dict[nodes.Item, None],\n    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[_Key, None]]],\n    items_by_argkey: Dict[Scope, Dict[_Key, \"Deque[nodes.Item]\"]],\n    scope: Scope,\n) -> Dict[nodes.Item, None]:\n    if scope is Scope.Function or len(items) < 3:\n        return items\n    ignore: Set[Optional[_Key]] = set()\n    items_deque = deque(items)",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "get_direct_param_fixture_func",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def get_direct_param_fixture_func(request: \"FixtureRequest\") -> Any:\n    return request.param\n@attr.s(slots=True, auto_attribs=True)\nclass FuncFixtureInfo:\n    # Original function argument names.\n    argnames: Tuple[str, ...]\n    # Argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames: Tuple[str, ...]",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fail_fixturefunc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def fail_fixturefunc(fixturefunc, msg: str) -> NoReturn:\n    fs, lineno = getfslineno(fixturefunc)\n    location = f\"{fs}:{lineno + 1}\"\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)\ndef call_fixture_func(\n    fixturefunc: \"_FixtureFunc[FixtureValue]\", request: FixtureRequest, kwargs\n) -> FixtureValue:\n    if is_generator(fixturefunc):\n        fixturefunc = cast(",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "call_fixture_func",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def call_fixture_func(\n    fixturefunc: \"_FixtureFunc[FixtureValue]\", request: FixtureRequest, kwargs\n) -> FixtureValue:\n    if is_generator(fixturefunc):\n        fixturefunc = cast(\n            Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n        )\n        generator = fixturefunc(**kwargs)\n        try:\n            fixture_result = next(generator)",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "resolve_fixture_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def resolve_fixture_function(\n    fixturedef: FixtureDef[FixtureValue], request: FixtureRequest\n) -> \"_FixtureFunc[FixtureValue]\":\n    \"\"\"Get the actual callable that can be called to obtain the fixture\n    value, dealing with unittest-specific instances and bound methods.\"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # Bind the unbound method to the TestCase instance.\n            fixturefunc = fixturedef.func.__get__(request.instance)  # type: ignore[union-attr]",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def pytest_fixture_setup(\n    fixturedef: FixtureDef[FixtureValue], request: SubRequest\n) -> FixtureValue:\n    \"\"\"Execution of fixture setup.\"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        assert fixdef.cached_result is not None\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request._scope, fixdef._scope)",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "wrap_function_to_error_out_if_called_directly",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def wrap_function_to_error_out_if_called_directly(\n    function: FixtureFunction,\n    fixture_marker: \"FixtureFunctionMarker\",\n) -> FixtureFunction:\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\"\"\"\n    message = (\n        'Fixture \"{name}\" called directly. Fixtures are not meant to be called directly,\\n'\n        \"but are created automatically when test functions request them as parameters.\\n\"\n        \"See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and\\n\"",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def fixture(\n    fixture_function: FixtureFunction,\n    *,\n    scope: \"Union[_ScopeName, Callable[[str, Config], _ScopeName]]\" = ...,\n    params: Optional[Iterable[object]] = ...,\n    autouse: bool = ...,\n    ids: Optional[\n        Union[Sequence[Optional[object]], Callable[[Any], Optional[object]]]\n    ] = ...,\n    name: Optional[str] = ...,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def fixture(  # noqa: F811\n    fixture_function: None = ...,\n    *,\n    scope: \"Union[_ScopeName, Callable[[str, Config], _ScopeName]]\" = ...,\n    params: Optional[Iterable[object]] = ...,\n    autouse: bool = ...,\n    ids: Optional[\n        Union[Sequence[Optional[object]], Callable[[Any], Optional[object]]]\n    ] = ...,\n    name: Optional[str] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "fixture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def fixture(  # noqa: F811\n    fixture_function: Optional[FixtureFunction] = None,\n    *,\n    scope: \"Union[_ScopeName, Callable[[str, Config], _ScopeName]]\" = \"function\",\n    params: Optional[Iterable[object]] = None,\n    autouse: bool = False,\n    ids: Optional[\n        Union[Sequence[Optional[object]], Callable[[Any], Optional[object]]]\n    ] = None,\n    name: Optional[str] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "yield_fixture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def yield_fixture(\n    fixture_function=None,\n    *args,\n    scope=\"function\",\n    params=None,\n    autouse=False,\n    ids=None,\n    name=None,\n):\n    \"\"\"(Return a) decorator to mark a yield-fixture factory function.",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "pytestconfig",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def pytestconfig(request: FixtureRequest) -> Config:\n    \"\"\"Session-scoped fixture that returns the session's :class:`pytest.Config`\n    object.\n    Example::\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n    \"\"\"\n    return request.config\ndef pytest_addoption(parser: Parser) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"usefixtures\",\n        type=\"args\",\n        default=[],\n        help=\"List of default fixtures to be used with this project\",\n    )\nclass FixtureManager:\n    \"\"\"pytest fixture definitions and information is stored and managed\n    from this class.",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureValue",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "FixtureValue = TypeVar(\"FixtureValue\")\n# The type of the fixture function (type variable).\nFixtureFunction = TypeVar(\"FixtureFunction\", bound=Callable[..., object])\n# The type of a fixture function (type alias generic in fixture value).\n_FixtureFunc = Union[\n    Callable[..., FixtureValue], Callable[..., Generator[FixtureValue, None, None]]\n]\n# The type of FixtureDef.cached_result (type alias generic in fixture value).\n_FixtureCachedResult = Union[\n    Tuple[",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "FixtureFunction",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "FixtureFunction = TypeVar(\"FixtureFunction\", bound=Callable[..., object])\n# The type of a fixture function (type alias generic in fixture value).\n_FixtureFunc = Union[\n    Callable[..., FixtureValue], Callable[..., Generator[FixtureValue, None, None]]\n]\n# The type of FixtureDef.cached_result (type alias generic in fixture value).\n_FixtureCachedResult = Union[\n    Tuple[\n        # The result.\n        FixtureValue,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "_FixtureFunc",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "_FixtureFunc = Union[\n    Callable[..., FixtureValue], Callable[..., Generator[FixtureValue, None, None]]\n]\n# The type of FixtureDef.cached_result (type alias generic in fixture value).\n_FixtureCachedResult = Union[\n    Tuple[\n        # The result.\n        FixtureValue,\n        # Cache key.\n        object,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "_FixtureCachedResult",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "_FixtureCachedResult = Union[\n    Tuple[\n        # The result.\n        FixtureValue,\n        # Cache key.\n        object,\n        None,\n    ],\n    Tuple[\n        None,",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "name2pseudofixturedef_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "name2pseudofixturedef_key = StashKey[Dict[str, \"FixtureDef[Any]\"]]()\ndef add_funcarg_pseudo_fixture_def(\n    collector: nodes.Collector, metafunc: \"Metafunc\", fixturemanager: \"FixtureManager\"\n) -> None:\n    # This function will transform all collected calls to functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "_Key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.fixtures",
        "description": "__pypackages__.3.10.lib._pytest.fixtures",
        "peekOfCode": "_Key = Tuple[object, ...]\ndef get_parametrized_fixture_keys(item: nodes.Item, scope: Scope) -> Iterator[_Key]:\n    \"\"\"Return list of keys for all parametrized arguments which match\n    the specified scope.\"\"\"\n    assert scope is not Scope.Function\n    try:\n        callspec = item.callspec  # type: ignore[attr-defined]\n    except AttributeError:\n        pass\n    else:",
        "detail": "__pypackages__.3.10.lib._pytest.fixtures",
        "documentation": {}
    },
    {
        "label": "freeze_includes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.freeze_support",
        "description": "__pypackages__.3.10.lib._pytest.freeze_support",
        "peekOfCode": "def freeze_includes() -> List[str]:\n    \"\"\"Return a list of module names used by pytest that should be\n    included by cx_freeze.\"\"\"\n    import _pytest\n    result = list(_iter_all_modules(_pytest))\n    return result\ndef _iter_all_modules(\n    package: Union[str, types.ModuleType],\n    prefix: str = \"\",\n) -> Iterator[str]:",
        "detail": "__pypackages__.3.10.lib._pytest.freeze_support",
        "documentation": {}
    },
    {
        "label": "HelpAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "class HelpAction(Action):\n    \"\"\"An argparse Action that will raise an exception in order to skip the\n    rest of the argument parsing when --help is passed.\n    This prevents argparse from quitting due to missing required arguments\n    when any are defined, for example by ``pytest_addoption``.\n    This is similar to the way that the builtin argparse --help option is\n    implemented by raising SystemExit.\n    \"\"\"\n    def __init__(self, option_strings, dest=None, default=False, help=None):\n        super().__init__(",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--version\",\n        \"-V\",\n        action=\"count\",\n        default=0,\n        dest=\"version\",\n        help=\"Display pytest version and information about plugins. \"\n        \"When given twice, also display information about plugins.\",",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def pytest_cmdline_parse():\n    outcome = yield\n    config: Config = outcome.get_result()\n    if config.option.debug:\n        # --debug | --debug <file.log> was provided.\n        path = config.option.debug\n        debugfile = open(path, \"w\")\n        debugfile.write(\n            \"versions pytest-%s, \"\n            \"python-%s\\ncwd=%s\\nargs=%s\\n\\n\"",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "showversion",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def showversion(config: Config) -> None:\n    if config.option.version > 1:\n        sys.stdout.write(\n            \"This is pytest version {}, imported from {}\\n\".format(\n                pytest.__version__, pytest.__file__\n            )\n        )\n        plugininfo = getpluginversioninfo(config)\n        if plugininfo:\n            for line in plugininfo:",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    if config.option.version > 0:\n        showversion(config)\n        return 0\n    elif config.option.help:\n        config._do_configure()\n        showhelp(config)\n        config._ensure_unconfigure()\n        return 0\n    return None",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "showhelp",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def showhelp(config: Config) -> None:\n    import textwrap\n    reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n    tw = reporter._tw\n    tw.write(config._parser.optparser.format_help())\n    tw.line()\n    tw.line(\n        \"[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:\"\n    )\n    tw.line()",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "getpluginversioninfo",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def getpluginversioninfo(config: Config) -> List[str]:\n    lines = []\n    plugininfo = config.pluginmanager.list_plugin_distinfo()\n    if plugininfo:\n        lines.append(\"setuptools registered plugins:\")\n        for plugin, dist in plugininfo:\n            loc = getattr(plugin, \"__file__\", repr(plugin))\n            content = f\"{dist.project_name}-{dist.version} at {loc}\"\n            lines.append(\"  \" + content)\n    return lines",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "pytest_report_header",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "def pytest_report_header(config: Config) -> List[str]:\n    lines = []\n    if config.option.debug or config.option.traceconfig:\n        lines.append(f\"using: pytest-{pytest.__version__}\")\n        verinfo = getpluginversioninfo(config)\n        if verinfo:\n            lines.extend(verinfo)\n    if config.option.traceconfig:\n        lines.append(\"active plugins:\")\n        items = config.pluginmanager.list_name_plugin()",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "conftest_options",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.helpconfig",
        "description": "__pypackages__.3.10.lib._pytest.helpconfig",
        "peekOfCode": "conftest_options = [(\"pytest_plugins\", \"list of plugin names to load\")]\ndef getpluginversioninfo(config: Config) -> List[str]:\n    lines = []\n    plugininfo = config.pluginmanager.list_plugin_distinfo()\n    if plugininfo:\n        lines.append(\"setuptools registered plugins:\")\n        for plugin, dist in plugininfo:\n            loc = getattr(plugin, \"__file__\", repr(plugin))\n            content = f\"{dist.project_name}-{dist.version} at {loc}\"\n            lines.append(\"  \" + content)",
        "detail": "__pypackages__.3.10.lib._pytest.helpconfig",
        "documentation": {}
    },
    {
        "label": "pytest_addhooks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_addhooks(pluginmanager: \"PytestPluginManager\") -> None:\n    \"\"\"Called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n    :param pytest.PytestPluginManager pluginmanager: The pytest plugin manager.\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n@hookspec(historic=True)\ndef pytest_plugin_registered(\n    plugin: \"_PluggyPlugin\", manager: \"PytestPluginManager\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_plugin_registered",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_plugin_registered(\n    plugin: \"_PluggyPlugin\", manager: \"PytestPluginManager\"\n) -> None:\n    \"\"\"A new pytest plugin got registered.\n    :param plugin: The plugin module or instance.\n    :param pytest.PytestPluginManager manager: pytest plugin manager.\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n@hookspec(historic=True)",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_addoption(parser: \"Parser\", pluginmanager: \"PytestPluginManager\") -> None:\n    \"\"\"Register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n    .. note::\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n    :param pytest.Parser parser:\n        To add command line options, call\n        :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_configure(config: \"Config\") -> None:\n    \"\"\"Allow plugins and conftest files to perform initial configuration.\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n    After that, the hook is called for other conftest files as they are\n    imported.\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    :param pytest.Config config: The pytest config object.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_cmdline_parse(\n    pluginmanager: \"PytestPluginManager\", args: List[str]\n) -> Optional[\"Config\"]:\n    \"\"\"Return an initialized :class:`~pytest.Config`, parsing the specified args.\n    Stops at first non-None result, see :ref:`firstresult`.\n    .. note::\n        This hook will only be called for plugin classes passed to the\n        ``plugins`` arg when using `pytest.main`_ to perform an in-process\n        test run.\n    :param pluginmanager: The pytest plugin manager.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_preparse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_cmdline_preparse(config: \"Config\", args: List[str]) -> None:\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :hook:`pytest_load_initial_conftests` instead.\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n    :param config: The pytest config object.\n    :param args: Arguments passed on the command line.\n    \"\"\"\n@hookspec(firstresult=True)",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_cmdline_main(config: \"Config\") -> Optional[Union[\"ExitCode\", int]]:\n    \"\"\"Called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param config: The pytest config object.\n    :returns: The exit code.\n    \"\"\"\ndef pytest_load_initial_conftests(\n    early_config: \"Config\", parser: \"Parser\", args: List[str]\n) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_load_initial_conftests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_load_initial_conftests(\n    early_config: \"Config\", parser: \"Parser\", args: List[str]\n) -> None:\n    \"\"\"Called to implement the loading of initial conftest files ahead\n    of command line option parsing.\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n    :param early_config: The pytest config object.\n    :param args: Arguments passed on the command line.\n    :param parser: To add command line options.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collection",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collection(session: \"Session\") -> Optional[object]:\n    \"\"\"Perform the collection phase for the given session.\n    Stops at first non-None result, see :ref:`firstresult`.\n    The return value is not used, but only stops further processing.\n    The default collection phase is this (see individual hooks for full details):\n    1. Starting from ``session`` as the initial collector:\n      1. ``pytest_collectstart(collector)``\n      2. ``report = pytest_make_collect_report(collector)``\n      3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred\n      4. For each collected node:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collection_modifyitems",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collection_modifyitems(\n    session: \"Session\", config: \"Config\", items: List[\"Item\"]\n) -> None:\n    \"\"\"Called after collection has been performed. May filter or re-order\n    the items in-place.\n    :param session: The pytest session object.\n    :param config: The pytest config object.\n    :param items: List of item objects.\n    \"\"\"\ndef pytest_collection_finish(session: \"Session\") -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collection_finish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collection_finish(session: \"Session\") -> None:\n    \"\"\"Called after collection has been performed and modified.\n    :param session: The pytest session object.\n    \"\"\"\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(\n    collection_path: Path, path: \"LEGACY_PATH\", config: \"Config\"\n) -> Optional[bool]:\n    \"\"\"Return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_ignore_collect",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_ignore_collect(\n    collection_path: Path, path: \"LEGACY_PATH\", config: \"Config\"\n) -> Optional[bool]:\n    \"\"\"Return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param collection_path: The path to analyze.\n    :param path: The path to analyze (deprecated).\n    :param config: The pytest config object.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collect_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collect_file(\n    file_path: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n) -> \"Optional[Collector]\":\n    \"\"\"Create a :class:`~pytest.Collector` for the given path, or None if not relevant.\n    The new node needs to have the specified ``parent`` as a parent.\n    :param file_path: The path to analyze.\n    :param path: The path to collect (deprecated).\n    .. versionchanged:: 7.0.0\n        The ``file_path`` parameter was added as a :class:`pathlib.Path`\n        equivalent of the ``path`` parameter. The ``path`` parameter",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collectstart",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collectstart(collector: \"Collector\") -> None:\n    \"\"\"Collector starts collecting.\n    :param collector:\n        The collector.\n    \"\"\"\ndef pytest_itemcollected(item: \"Item\") -> None:\n    \"\"\"We just collected a test item.\n    :param item:\n        The item.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_itemcollected",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_itemcollected(item: \"Item\") -> None:\n    \"\"\"We just collected a test item.\n    :param item:\n        The item.\n    \"\"\"\ndef pytest_collectreport(report: \"CollectReport\") -> None:\n    \"\"\"Collector finished collecting.\n    :param report:\n        The collect report.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_collectreport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_collectreport(report: \"CollectReport\") -> None:\n    \"\"\"Collector finished collecting.\n    :param report:\n        The collect report.\n    \"\"\"\ndef pytest_deselected(items: Sequence[\"Item\"]) -> None:\n    \"\"\"Called for deselected test items, e.g. by keyword.\n    May be called multiple times.\n    :param items:\n        The items.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_deselected",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_deselected(items: Sequence[\"Item\"]) -> None:\n    \"\"\"Called for deselected test items, e.g. by keyword.\n    May be called multiple times.\n    :param items:\n        The items.\n    \"\"\"\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector: \"Collector\") -> \"Optional[CollectReport]\":\n    \"\"\"Perform :func:`collector.collect() <pytest.Collector.collect>` and return\n    a :class:`~pytest.CollectReport`.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_make_collect_report",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_make_collect_report(collector: \"Collector\") -> \"Optional[CollectReport]\":\n    \"\"\"Perform :func:`collector.collect() <pytest.Collector.collect>` and return\n    a :class:`~pytest.CollectReport`.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param collector:\n        The collector.\n    \"\"\"\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_pycollect_makemodule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_pycollect_makemodule(\n    module_path: Path, path: \"LEGACY_PATH\", parent\n) -> Optional[\"Module\"]:\n    \"\"\"Return a :class:`pytest.Module` collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The :hook:`pytest_collect_file` hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param module_path: The path of the module to collect.\n    :param path: The path of the module to collect (deprecated).",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_pycollect_makeitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_pycollect_makeitem(\n    collector: Union[\"Module\", \"Class\"], name: str, obj: object\n) -> Union[None, \"Item\", \"Collector\", List[Union[\"Item\", \"Collector\"]]]:\n    \"\"\"Return a custom item/collector for a Python object in a module, or None.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param collector:\n        The module/class collector.\n    :param name:\n        The name of the object in the module/class.\n    :param obj:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_pyfunc_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    \"\"\"Call underlying test function.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param pyfuncitem:\n        The function item.\n    \"\"\"\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    \"\"\"Generate (multiple) parametrized calls to a test function.\n    :param metafunc:\n        The :class:`~pytest.Metafunc` helper for the test function.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    \"\"\"Generate (multiple) parametrized calls to a test function.\n    :param metafunc:\n        The :class:`~pytest.Metafunc` helper for the test function.\n    \"\"\"\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(\n    config: \"Config\", val: object, argname: str\n) -> Optional[str]:\n    \"\"\"Return a user-friendly string representation of the given ``val``",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_make_parametrize_id",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_make_parametrize_id(\n    config: \"Config\", val: object, argname: str\n) -> Optional[str]:\n    \"\"\"Return a user-friendly string representation of the given ``val``\n    that will be used by @pytest.mark.parametrize calls, or None if the hook\n    doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n    Stops at first non-None result, see :ref:`firstresult`.\n    :param config: The pytest config object.\n    :param val: The parametrized value.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtestloop",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtestloop(session: \"Session\") -> Optional[object]:\n    \"\"\"Perform the main runtest loop (after collection finished).\n    The default hook implementation performs the runtest protocol for all items\n    collected in the session (``session.items``), unless the collection failed\n    or the ``collectonly`` pytest option is set.\n    If at any point :py:func:`pytest.exit` is called, the loop is\n    terminated immediately.\n    If at any point ``session.shouldfail`` or ``session.shouldstop`` are set, the\n    loop is terminated after the runtest protocol for the current item is finished.\n    :param session: The pytest session object.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_protocol(\n    item: \"Item\", nextitem: \"Optional[Item]\"\n) -> Optional[object]:\n    \"\"\"Perform the runtest protocol for a single test item.\n    The default runtest protocol is this (see individual hooks for full details):\n    - ``pytest_runtest_logstart(nodeid, location)``\n    - Setup phase:\n        - ``call = pytest_runtest_setup(item)`` (wrapped in ``CallInfo(when=\"setup\")``)\n        - ``report = pytest_runtest_makereport(item, call)``\n        - ``pytest_runtest_logreport(report)``",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_logstart",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_logstart(\n    nodeid: str, location: Tuple[str, Optional[int], str]\n) -> None:\n    \"\"\"Called at the start of running the runtest protocol for a single item.\n    See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n    :param nodeid: Full node ID of the item.\n    :param location: A tuple of ``(filename, lineno, testname)``.\n    \"\"\"\ndef pytest_runtest_logfinish(\n    nodeid: str, location: Tuple[str, Optional[int], str]",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_logfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_logfinish(\n    nodeid: str, location: Tuple[str, Optional[int], str]\n) -> None:\n    \"\"\"Called at the end of running the runtest protocol for a single item.\n    See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n    :param nodeid: Full node ID of the item.\n    :param location: A tuple of ``(filename, lineno, testname)``.\n    \"\"\"\ndef pytest_runtest_setup(item: \"Item\") -> None:\n    \"\"\"Called to perform the setup phase for a test item.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_setup(item: \"Item\") -> None:\n    \"\"\"Called to perform the setup phase for a test item.\n    The default implementation runs ``setup()`` on ``item`` and all of its\n    parents (which haven't been setup yet). This includes obtaining the\n    values of fixtures required by the item (which haven't been obtained\n    yet).\n    :param item:\n        The item.\n    \"\"\"\ndef pytest_runtest_call(item: \"Item\") -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_call(item: \"Item\") -> None:\n    \"\"\"Called to run the test for test item (the call phase).\n    The default implementation calls ``item.runtest()``.\n    :param item:\n        The item.\n    \"\"\"\ndef pytest_runtest_teardown(item: \"Item\", nextitem: Optional[\"Item\"]) -> None:\n    \"\"\"Called to perform the teardown phase for a test item.\n    The default implementation runs the finalizers and calls ``teardown()``\n    on ``item`` and all of its parents (which need to be torn down). This",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_teardown",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_teardown(item: \"Item\", nextitem: Optional[\"Item\"]) -> None:\n    \"\"\"Called to perform the teardown phase for a test item.\n    The default implementation runs the finalizers and calls ``teardown()``\n    on ``item`` and all of its parents (which need to be torn down). This\n    includes running the teardown phase of fixtures required by the item (if\n    they go out of scope).\n    :param item:\n        The item.\n    :param nextitem:\n        The scheduled-to-be-next test item (None if no further test item is",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_makereport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_makereport(\n    item: \"Item\", call: \"CallInfo[None]\"\n) -> Optional[\"TestReport\"]:\n    \"\"\"Called to create a :class:`~pytest.TestReport` for each of\n    the setup, call and teardown runtest phases of a test item.\n    See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n    :param item: The item.\n    :param call: The :class:`~pytest.CallInfo` for the phase.\n    Stops at first non-None result, see :ref:`firstresult`.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_logreport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_runtest_logreport(report: \"TestReport\") -> None:\n    \"\"\"Process the :class:`~pytest.TestReport` produced for each\n    of the setup, call and teardown runtest phases of an item.\n    See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n    \"\"\"\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(\n    config: \"Config\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> Optional[Dict[str, Any]]:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_report_to_serializable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_report_to_serializable(\n    config: \"Config\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> Optional[Dict[str, Any]]:\n    \"\"\"Serialize the given report object into a data structure suitable for\n    sending over the wire, e.g. converted to JSON.\n    :param config: The pytest config object.\n    :param report: The report.\n    \"\"\"\n@hookspec(firstresult=True)",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_report_from_serializable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_report_from_serializable(\n    config: \"Config\",\n    data: Dict[str, Any],\n) -> Optional[Union[\"CollectReport\", \"TestReport\"]]:\n    \"\"\"Restore a report object previously serialized with\n    :hook:`pytest_report_to_serializable`.\n    :param config: The pytest config object.\n    \"\"\"\n# -------------------------------------------------------------------------\n# Fixture related hooks",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_fixture_setup(\n    fixturedef: \"FixtureDef[Any]\", request: \"SubRequest\"\n) -> Optional[object]:\n    \"\"\"Perform fixture setup execution.\n    :param fixturdef:\n        The fixture definition object.\n    :param request:\n        The fixture request object.\n    :returns:\n        The return value of the call to the fixture function.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_post_finalizer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_fixture_post_finalizer(\n    fixturedef: \"FixtureDef[Any]\", request: \"SubRequest\"\n) -> None:\n    \"\"\"Called after fixture teardown, but before the cache is cleared, so\n    the fixture result ``fixturedef.cached_result`` is still available (not\n    ``None``).\n    :param fixturdef:\n        The fixture definition object.\n    :param request:\n        The fixture request object.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_sessionstart(session: \"Session\") -> None:\n    \"\"\"Called after the ``Session`` object has been created and before performing collection\n    and entering the run test loop.\n    :param session: The pytest session object.\n    \"\"\"\ndef pytest_sessionfinish(\n    session: \"Session\",\n    exitstatus: Union[int, \"ExitCode\"],\n) -> None:\n    \"\"\"Called after whole test run finished, right before returning the exit status to the system.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_sessionfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_sessionfinish(\n    session: \"Session\",\n    exitstatus: Union[int, \"ExitCode\"],\n) -> None:\n    \"\"\"Called after whole test run finished, right before returning the exit status to the system.\n    :param session: The pytest session object.\n    :param exitstatus: The status which pytest will return to the system.\n    \"\"\"\ndef pytest_unconfigure(config: \"Config\") -> None:\n    \"\"\"Called before test process is exited.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_unconfigure(config: \"Config\") -> None:\n    \"\"\"Called before test process is exited.\n    :param config: The pytest config object.\n    \"\"\"\n# -------------------------------------------------------------------------\n# hooks for customizing the assert methods\n# -------------------------------------------------------------------------\ndef pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_assertrepr_compare",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:\n    \"\"\"Return explanation for comparisons in failing assert expressions.\n    Return None for no custom explanation, otherwise return a list\n    of strings. The strings will be joined by newlines but any newlines\n    *in* a string will be escaped. Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n    :param config: The pytest config object.\n    :param op: The operator, e.g. `\"==\"`, `\"!=\"`, `\"not in\"`.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_assertion_pass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n    \"\"\"Called whenever an assertion passes.\n    .. versionadded:: 5.0\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n    .. code-block:: ini",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_report_header",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_report_header(\n    config: \"Config\", start_path: Path, startdir: \"LEGACY_PATH\"\n) -> Union[str, List[str]]:\n    \"\"\"Return a string or list of strings to be displayed as header info for terminal reporting.\n    :param config: The pytest config object.\n    :param start_path: The starting dir.\n    :param startdir: The starting dir (deprecated).\n    .. note::\n        Lines returned by a plugin are displayed before those of plugins which\n        ran before it.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_report_collectionfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_report_collectionfinish(\n    config: \"Config\",\n    start_path: Path,\n    startdir: \"LEGACY_PATH\",\n    items: Sequence[\"Item\"],\n) -> Union[str, List[str]]:\n    \"\"\"Return a string or list of strings to be displayed after collection\n    has finished successfully.\n    These strings will be displayed after the standard \"collected X items\" message.\n    .. versionadded:: 3.2",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_report_teststatus",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_report_teststatus(\n    report: Union[\"CollectReport\", \"TestReport\"], config: \"Config\"\n) -> Tuple[str, str, Union[str, Mapping[str, bool]]]:\n    \"\"\"Return result-category, shortletter and verbose word for status\n    reporting.\n    The result-category is a category in which to count the result, for\n    example \"passed\", \"skipped\", \"error\" or the empty string.\n    The shortletter is shown as testing progresses, for example \".\", \"s\",\n    \"E\" or the empty string.\n    The verbose word is shown as testing progresses in verbose mode, for",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_terminal_summary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_terminal_summary(\n    terminalreporter: \"TerminalReporter\",\n    exitstatus: \"ExitCode\",\n    config: \"Config\",\n) -> None:\n    \"\"\"Add a section to terminal summary reporting.\n    :param terminalreporter: The internal terminal reporter object.\n    :param exitstatus: The exit status that will be reported back to the OS.\n    :param config: The pytest config object.\n    .. versionadded:: 4.2",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_warning_recorded",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_warning_recorded(\n    warning_message: \"warnings.WarningMessage\",\n    when: \"Literal['config', 'collect', 'runtest']\",\n    nodeid: str,\n    location: Optional[Tuple[str, int, str]],\n) -> None:\n    \"\"\"Process a warning captured by the internal pytest warnings plugin.\n    :param warning_message:\n        The captured warning. This is the same object produced by :py:func:`warnings.catch_warnings`, and contains\n        the same attributes as the parameters of :py:func:`warnings.showwarning`.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_markeval_namespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_markeval_namespace(config: \"Config\") -> Dict[str, Any]:\n    \"\"\"Called when constructing the globals dictionary used for\n    evaluating string conditions in xfail/skipif markers.\n    This is useful when the condition for a marker requires\n    objects that are expensive or impossible to obtain during\n    collection time, which is required by normal boolean\n    conditions.\n    .. versionadded:: 6.2\n    :param config: The pytest config object.\n    :returns: A dictionary of additional globals to add.",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_internalerror",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_internalerror(\n    excrepr: \"ExceptionRepr\",\n    excinfo: \"ExceptionInfo[BaseException]\",\n) -> Optional[bool]:\n    \"\"\"Called for internal errors.\n    Return True to suppress the fallback handling of printing an\n    INTERNALERROR message directly to sys.stderr.\n    :param excrepr: The exception repr object.\n    :param excinfo: The exception info.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_keyboard_interrupt",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_keyboard_interrupt(\n    excinfo: \"ExceptionInfo[Union[KeyboardInterrupt, Exit]]\",\n) -> None:\n    \"\"\"Called for keyboard interrupt.\n    :param excinfo: The exception info.\n    \"\"\"\ndef pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_exception_interact",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> None:\n    \"\"\"Called when an exception was raised which can potentially be\n    interactively handled.\n    May be called during collection (see :hook:`pytest_make_collect_report`),\n    in which case ``report`` is a :class:`CollectReport`.\n    May be called during runtest of an item (see :hook:`pytest_runtest_protocol`),",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_enter_pdb",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_enter_pdb(config: \"Config\", pdb: \"pdb.Pdb\") -> None:\n    \"\"\"Called upon pdb.set_trace().\n    Can be used by plugins to take special action just before the python\n    debugger enters interactive mode.\n    :param config: The pytest config object.\n    :param pdb: The Pdb instance.\n    \"\"\"\ndef pytest_leave_pdb(config: \"Config\", pdb: \"pdb.Pdb\") -> None:\n    \"\"\"Called when leaving pdb (e.g. with continue after pdb.set_trace()).\n    Can be used by plugins to take special action just after the python",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "pytest_leave_pdb",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "def pytest_leave_pdb(config: \"Config\", pdb: \"pdb.Pdb\") -> None:\n    \"\"\"Called when leaving pdb (e.g. with continue after pdb.set_trace()).\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n    :param config: The pytest config object.\n    :param pdb: The Pdb instance.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "hookspec",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.hookspec",
        "description": "__pypackages__.3.10.lib._pytest.hookspec",
        "peekOfCode": "hookspec = HookspecMarker(\"pytest\")\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager: \"PytestPluginManager\") -> None:\n    \"\"\"Called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n    :param pytest.PytestPluginManager pluginmanager: The pytest plugin manager.\n    .. note::",
        "detail": "__pypackages__.3.10.lib._pytest.hookspec",
        "documentation": {}
    },
    {
        "label": "_NodeReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "class _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:\n        self.id = nodeid\n        self.xml = xml\n        self.add_stats = self.xml.add_stats\n        self.family = self.xml.family\n        self.duration = 0.0\n        self.properties: List[Tuple[str, str]] = []\n        self.nodes: List[ET.Element] = []\n        self.attrs: Dict[str, str] = {}",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "LogXML",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix: Optional[str],\n        suite_name: str = \"pytest\",\n        logging: str = \"no\",\n        report_duration: str = \"total\",\n        family=\"xunit1\",\n        log_passing_tests: bool = True,",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "bin_xml_escape",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def bin_xml_escape(arg: object) -> str:\n    r\"\"\"Visually escape invalid XML characters.\n    For example, transforms\n        'hello\\aworld\\b'\n    into\n        'hello#x07world#x08'\n    Note that the #xABs are *not* XML escapes - missing the ampersand &#xAB.\n    The idea is to escape visually for the user rather than for XML itself.\n    \"\"\"\n    def repl(matchobj: Match[str]) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "merge_family",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def merge_family(left, right) -> None:\n    result = {}\n    for kl, vl in left.items():\n        for kr, vr in right.items():\n            if not isinstance(vl, list):\n                raise TypeError(type(vl))\n            result[kl] = vl + vr\n    left.update(result)\nfamilies = {}\nfamilies[\"_base\"] = {\"testcase\": [\"classname\", \"name\"]}",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "record_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def record_property(request: FixtureRequest) -> Callable[[str, object], None]:\n    \"\"\"Add extra properties to the calling test.\n    User properties become part of the test report and are available to the\n    configured reporters, like JUnit XML.\n    The fixture is callable with ``name, value``. The value is automatically\n    XML-encoded.\n    Example::\n        def test_function(record_property):\n            record_property(\"example_key\", 1)\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "record_xml_attribute",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def record_xml_attribute(request: FixtureRequest) -> Callable[[str, object], None]:\n    \"\"\"Add extra xml attributes to the tag for the calling test.\n    The fixture is callable with ``name, value``. The value is\n    automatically XML-encoded.\n    \"\"\"\n    from _pytest.warning_types import PytestExperimentalApiWarning\n    request.node.warn(\n        PytestExperimentalApiWarning(\"record_xml_attribute is an experimental feature\")\n    )\n    _warn_incompatibility_with_xunit2(request, \"record_xml_attribute\")",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "record_testsuite_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def record_testsuite_property(request: FixtureRequest) -> Callable[[str, object], None]:\n    \"\"\"Record a new ``<property>`` tag as child of the root ``<testsuite>``.\n    This is suitable to writing global information regarding the entire test\n    suite, and is compatible with ``xunit2`` JUnit family.\n    This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:\n    .. code-block:: python\n        def test_foo(record_testsuite_property):\n            record_testsuite_property(\"ARCH\", \"PPC\")\n            record_testsuite_property(\"STORAGE_TYPE\", \"CEPH\")\n    :param name:",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"terminal reporting\")\n    group.addoption(\n        \"--junitxml\",\n        \"--junit-xml\",\n        action=\"store\",\n        dest=\"xmlpath\",\n        metavar=\"path\",\n        type=functools.partial(filename_arg, optname=\"--junitxml\"),\n        default=None,",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    xmlpath = config.option.xmlpath\n    # Prevent opening xmllog on worker nodes (xdist).\n    if xmlpath and not hasattr(config, \"workerinput\"):\n        junit_family = config.getini(\"junit_family\")\n        config.stash[xml_key] = LogXML(\n            xmlpath,\n            config.option.junitprefix,\n            config.getini(\"junit_suite_name\"),\n            config.getini(\"junit_logging\"),",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def pytest_unconfigure(config: Config) -> None:\n    xml = config.stash.get(xml_key, None)\n    if xml:\n        del config.stash[xml_key]\n        config.pluginmanager.unregister(xml)\ndef mangle_test_address(address: str) -> List[str]:\n    path, possible_open_bracket, params = address.partition(\"[\")\n    names = path.split(\"::\")\n    # Convert file path to dotted path.\n    names[0] = names[0].replace(nodes.SEP, \".\")",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "mangle_test_address",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "def mangle_test_address(address: str) -> List[str]:\n    path, possible_open_bracket, params = address.partition(\"[\")\n    names = path.split(\"::\")\n    # Convert file path to dotted path.\n    names[0] = names[0].replace(nodes.SEP, \".\")\n    names[0] = re.sub(r\"\\.py$\", \"\", names[0])\n    # Put any params back.\n    names[-1] += possible_open_bracket + params\n    return names\nclass LogXML:",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "xml_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "xml_key = StashKey[\"LogXML\"]()\ndef bin_xml_escape(arg: object) -> str:\n    r\"\"\"Visually escape invalid XML characters.\n    For example, transforms\n        'hello\\aworld\\b'\n    into\n        'hello#x07world#x08'\n    Note that the #xABs are *not* XML escapes - missing the ampersand &#xAB.\n    The idea is to escape visually for the user rather than for XML itself.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "families",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "families = {}\nfamilies[\"_base\"] = {\"testcase\": [\"classname\", \"name\"]}\nfamilies[\"_base_legacy\"] = {\"testcase\": [\"file\", \"line\", \"url\"]}\n# xUnit 1.x inherits legacy attributes.\nfamilies[\"xunit1\"] = families[\"_base\"].copy()\nmerge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n# xUnit 2.x uses strict base attributes.\nfamilies[\"xunit2\"] = families[\"_base\"]\nclass _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "families[\"_base\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "families[\"_base\"] = {\"testcase\": [\"classname\", \"name\"]}\nfamilies[\"_base_legacy\"] = {\"testcase\": [\"file\", \"line\", \"url\"]}\n# xUnit 1.x inherits legacy attributes.\nfamilies[\"xunit1\"] = families[\"_base\"].copy()\nmerge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n# xUnit 2.x uses strict base attributes.\nfamilies[\"xunit2\"] = families[\"_base\"]\nclass _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:\n        self.id = nodeid",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "families[\"_base_legacy\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "families[\"_base_legacy\"] = {\"testcase\": [\"file\", \"line\", \"url\"]}\n# xUnit 1.x inherits legacy attributes.\nfamilies[\"xunit1\"] = families[\"_base\"].copy()\nmerge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n# xUnit 2.x uses strict base attributes.\nfamilies[\"xunit2\"] = families[\"_base\"]\nclass _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:\n        self.id = nodeid\n        self.xml = xml",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "families[\"xunit1\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "families[\"xunit1\"] = families[\"_base\"].copy()\nmerge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n# xUnit 2.x uses strict base attributes.\nfamilies[\"xunit2\"] = families[\"_base\"]\nclass _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:\n        self.id = nodeid\n        self.xml = xml\n        self.add_stats = self.xml.add_stats\n        self.family = self.xml.family",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "families[\"xunit2\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.junitxml",
        "description": "__pypackages__.3.10.lib._pytest.junitxml",
        "peekOfCode": "families[\"xunit2\"] = families[\"_base\"]\nclass _NodeReporter:\n    def __init__(self, nodeid: Union[str, TestReport], xml: \"LogXML\") -> None:\n        self.id = nodeid\n        self.xml = xml\n        self.add_stats = self.xml.add_stats\n        self.family = self.xml.family\n        self.duration = 0.0\n        self.properties: List[Tuple[str, str]] = []\n        self.nodes: List[ET.Element] = []",
        "detail": "__pypackages__.3.10.lib._pytest.junitxml",
        "documentation": {}
    },
    {
        "label": "Testdir",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "class Testdir:\n    \"\"\"\n    Similar to :class:`Pytester`, but this class works with legacy legacy_path objects instead.\n    All methods just forward to an internal :class:`Pytester` instance, converting results\n    to `legacy_path` objects as necessary.\n    \"\"\"\n    __test__ = False\n    CLOSE_STDIN: \"Final\" = Pytester.CLOSE_STDIN\n    TimeoutExpired: \"Final\" = Pytester.TimeoutExpired\n    def __init__(self, pytester: Pytester, *, _ispytest: bool = False) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "LegacyTestdirPlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "class LegacyTestdirPlugin:\n    @staticmethod\n    @fixture\n    def testdir(pytester: Pytester) -> Testdir:\n        \"\"\"\n        Identical to :fixture:`pytester`, and provides an instance whose methods return\n        legacy ``LEGACY_PATH`` objects instead when applicable.\n        New code should avoid using :fixture:`testdir` in favor of :fixture:`pytester`.\n        \"\"\"\n        return Testdir(pytester, _ispytest=True)",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "TempdirFactory",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "class TempdirFactory:\n    \"\"\"Backward compatibility wrapper that implements :class:`py.path.local`\n    for :class:`TempPathFactory`.\n    .. note::\n        These days, it is preferred to use ``tmp_path_factory``.\n        :ref:`About the tmpdir and tmpdir_factory fixtures<tmpdir and tmpdir_factory>`.\n    \"\"\"\n    _tmppath_factory: TempPathFactory\n    def __init__(\n        self, tmppath_factory: TempPathFactory, *, _ispytest: bool = False",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "LegacyTmpdirPlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "class LegacyTmpdirPlugin:\n    @staticmethod\n    @fixture(scope=\"session\")\n    def tmpdir_factory(request: FixtureRequest) -> TempdirFactory:\n        \"\"\"Return a :class:`pytest.TempdirFactory` instance for the test session.\"\"\"\n        # Set dynamically by pytest_configure().\n        return request.config._tmpdirhandler  # type: ignore\n    @staticmethod\n    @fixture\n    def tmpdir(tmp_path: Path) -> LEGACY_PATH:",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Cache_makedir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Cache_makedir(self: Cache, name: str) -> LEGACY_PATH:\n    \"\"\"Return a directory path object with the given name.\n    Same as :func:`mkdir`, but returns a legacy py path instance.\n    \"\"\"\n    return legacy_path(self.mkdir(name))\ndef FixtureRequest_fspath(self: FixtureRequest) -> LEGACY_PATH:\n    \"\"\"(deprecated) The file system path of the test module which collected this test.\"\"\"\n    return legacy_path(self.path)\ndef TerminalReporter_startdir(self: TerminalReporter) -> LEGACY_PATH:\n    \"\"\"The directory from which pytest was invoked.",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "FixtureRequest_fspath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def FixtureRequest_fspath(self: FixtureRequest) -> LEGACY_PATH:\n    \"\"\"(deprecated) The file system path of the test module which collected this test.\"\"\"\n    return legacy_path(self.path)\ndef TerminalReporter_startdir(self: TerminalReporter) -> LEGACY_PATH:\n    \"\"\"The directory from which pytest was invoked.\n    Prefer to use ``startpath`` which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH\n    \"\"\"\n    return legacy_path(self.startpath)\ndef Config_invocation_dir(self: Config) -> LEGACY_PATH:",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "TerminalReporter_startdir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def TerminalReporter_startdir(self: TerminalReporter) -> LEGACY_PATH:\n    \"\"\"The directory from which pytest was invoked.\n    Prefer to use ``startpath`` which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH\n    \"\"\"\n    return legacy_path(self.startpath)\ndef Config_invocation_dir(self: Config) -> LEGACY_PATH:\n    \"\"\"The directory from which pytest was invoked.\n    Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n    which is a :class:`pathlib.Path`.",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Config_invocation_dir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Config_invocation_dir(self: Config) -> LEGACY_PATH:\n    \"\"\"The directory from which pytest was invoked.\n    Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n    which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH\n    \"\"\"\n    return legacy_path(str(self.invocation_params.dir))\ndef Config_rootdir(self: Config) -> LEGACY_PATH:\n    \"\"\"The path to the :ref:`rootdir <rootdir>`.\n    Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Config_rootdir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Config_rootdir(self: Config) -> LEGACY_PATH:\n    \"\"\"The path to the :ref:`rootdir <rootdir>`.\n    Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH\n    \"\"\"\n    return legacy_path(str(self.rootpath))\ndef Config_inifile(self: Config) -> Optional[LEGACY_PATH]:\n    \"\"\"The path to the :ref:`configfile <configfiles>`.\n    Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n    :type: Optional[LEGACY_PATH]",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Config_inifile",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Config_inifile(self: Config) -> Optional[LEGACY_PATH]:\n    \"\"\"The path to the :ref:`configfile <configfiles>`.\n    Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n    :type: Optional[LEGACY_PATH]\n    \"\"\"\n    return legacy_path(str(self.inipath)) if self.inipath else None\ndef Session_stardir(self: Session) -> LEGACY_PATH:\n    \"\"\"The path from which pytest was invoked.\n    Prefer to use ``startpath`` which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Session_stardir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Session_stardir(self: Session) -> LEGACY_PATH:\n    \"\"\"The path from which pytest was invoked.\n    Prefer to use ``startpath`` which is a :class:`pathlib.Path`.\n    :type: LEGACY_PATH\n    \"\"\"\n    return legacy_path(self.startpath)\ndef Config__getini_unknown_type(\n    self, name: str, type: str, value: Union[str, List[str]]\n):\n    if type == \"pathlist\":",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Config__getini_unknown_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Config__getini_unknown_type(\n    self, name: str, type: str, value: Union[str, List[str]]\n):\n    if type == \"pathlist\":\n        # TODO: This assert is probably not valid in all cases.\n        assert self.inipath is not None\n        dp = self.inipath.parent\n        input_values = shlex.split(value) if isinstance(value, str) else value\n        return [legacy_path(str(dp / x)) for x in input_values]\n    else:",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Node_fspath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Node_fspath(self: Node) -> LEGACY_PATH:\n    \"\"\"(deprecated) returns a legacy_path copy of self.path\"\"\"\n    return legacy_path(self.path)\ndef Node_fspath_set(self: Node, value: LEGACY_PATH) -> None:\n    self.path = Path(value)\n@hookimpl(tryfirst=True)\ndef pytest_load_initial_conftests(early_config: Config) -> None:\n    \"\"\"Monkeypatch legacy path attributes in several classes, as early as possible.\"\"\"\n    mp = MonkeyPatch()\n    early_config.add_cleanup(mp.undo)",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "Node_fspath_set",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def Node_fspath_set(self: Node, value: LEGACY_PATH) -> None:\n    self.path = Path(value)\n@hookimpl(tryfirst=True)\ndef pytest_load_initial_conftests(early_config: Config) -> None:\n    \"\"\"Monkeypatch legacy path attributes in several classes, as early as possible.\"\"\"\n    mp = MonkeyPatch()\n    early_config.add_cleanup(mp.undo)\n    # Add Cache.makedir().\n    mp.setattr(Cache, \"makedir\", Cache_makedir, raising=False)\n    # Add FixtureRequest.fspath property.",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "pytest_load_initial_conftests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def pytest_load_initial_conftests(early_config: Config) -> None:\n    \"\"\"Monkeypatch legacy path attributes in several classes, as early as possible.\"\"\"\n    mp = MonkeyPatch()\n    early_config.add_cleanup(mp.undo)\n    # Add Cache.makedir().\n    mp.setattr(Cache, \"makedir\", Cache_makedir, raising=False)\n    # Add FixtureRequest.fspath property.\n    mp.setattr(FixtureRequest, \"fspath\", property(FixtureRequest_fspath), raising=False)\n    # Add TerminalReporter.startdir property.\n    mp.setattr(",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    \"\"\"Installs the LegacyTmpdirPlugin if the ``tmpdir`` plugin is also installed.\"\"\"\n    if config.pluginmanager.has_plugin(\"tmpdir\"):\n        mp = MonkeyPatch()\n        config.add_cleanup(mp.undo)\n        # Create TmpdirFactory and attach it to the config object.\n        #\n        # This is to comply with existing plugins which expect the handler to be\n        # available at pytest_configure time, but ideally should be moved entirely\n        # to the tmpdir_factory session fixture.",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "pytest_plugin_registered",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.legacypath",
        "description": "__pypackages__.3.10.lib._pytest.legacypath",
        "peekOfCode": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")",
        "detail": "__pypackages__.3.10.lib._pytest.legacypath",
        "documentation": {}
    },
    {
        "label": "ColoredLevelFormatter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"\n    LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "PercentStyleMultiline",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class PercentStyleMultiline(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n    def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:\n        super().__init__(fmt)\n        self._auto_indent = self._get_auto_indent(auto_indent)\n    @staticmethod\n    def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "catching_logs",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class catching_logs:\n    \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n    __slots__ = (\"handler\", \"level\", \"orig_level\")\n    def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:\n        self.handler = handler\n        self.level = level\n    def __enter__(self):\n        root_logger = logging.getLogger()\n        if self.level is not None:\n            self.handler.setLevel(self.level)",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "LogCaptureHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class LogCaptureHandler(logging_StreamHandler):\n    \"\"\"A logging handler that stores log records and the log text.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Create a new log handler.\"\"\"\n        super().__init__(StringIO())\n        self.records: List[logging.LogRecord] = []\n    def emit(self, record: logging.LogRecord) -> None:\n        \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n        self.records.append(record)\n        super().emit(record)",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "LogCaptureFixture",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n    def __init__(self, item: nodes.Node, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._item = item\n        self._initial_handler_level: Optional[int] = None\n        # Dict of log name -> log level.\n        self._initial_logger_levels: Dict[Optional[str], int] = {}\n    def _finalize(self) -> None:\n        \"\"\"Finalize the fixture.",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "LoggingPlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class LoggingPlugin:\n    \"\"\"Attaches to the logging module and captures log messages for each test.\"\"\"\n    def __init__(self, config: Config) -> None:\n        \"\"\"Create a new plugin to capture log messages.\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n        # Report logging.\n        self.formatter = self._create_formatter(",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "_FileHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class _FileHandler(logging.FileHandler):\n    \"\"\"A logging FileHandler with pytest tweaks.\"\"\"\n    def handleError(self, record: logging.LogRecord) -> None:\n        # Handled by LogCaptureHandler.\n        pass\nclass _LiveLoggingStreamHandler(logging_StreamHandler):\n    \"\"\"A logging StreamHandler used by the live logging feature: it will\n    write a newline before the first log message in each test.\n    During live logging we must also explicitly disable stdout/stderr\n    capturing otherwise it will get captured and won't appear in the",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "_LiveLoggingStreamHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class _LiveLoggingStreamHandler(logging_StreamHandler):\n    \"\"\"A logging StreamHandler used by the live logging feature: it will\n    write a newline before the first log message in each test.\n    During live logging we must also explicitly disable stdout/stderr\n    capturing otherwise it will get captured and won't appear in the\n    terminal.\n    \"\"\"\n    # Officially stream needs to be a IO[str], but TerminalReporter\n    # isn't. So force it.\n    stream: TerminalReporter = None  # type: ignore",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "_LiveLoggingNullHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "class _LiveLoggingNullHandler(logging.NullHandler):\n    \"\"\"A logging handler used when live logging is disabled.\"\"\"\n    def reset(self) -> None:\n        pass\n    def set_when(self, when: str) -> None:\n        pass\n    def handleError(self, record: logging.LogRecord) -> None:\n        # Handled by LogCaptureHandler.\n        pass",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "get_option_ini",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "def get_option_ini(config: Config, *names: str):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\ndef pytest_addoption(parser: Parser) -> None:\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"Default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n    add_option_ini(\n        \"--log-level\",",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "caplog",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n    Captured logs are available through the following properties/methods::\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node, _ispytest=True)",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "get_log_level_for_setting",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\n    for setting_name in setting_names:\n        log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return None\n    if isinstance(log_level, str):",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\nclass LoggingPlugin:\n    \"\"\"Attaches to the logging module and captures log messages for each test.\"\"\"\n    def __init__(self, config: Config) -> None:\n        \"\"\"Create a new plugin to capture log messages.\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOG_FORMAT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n_ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\ncaplog_handler_key = StashKey[\"LogCaptureHandler\"]()\ncaplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\ndef _remove_ansi_escape_sequences(text: str) -> str:\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOG_DATE_FORMAT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n_ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\ncaplog_handler_key = StashKey[\"LogCaptureHandler\"]()\ncaplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\ndef _remove_ansi_escape_sequences(text: str) -> str:\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"\n    LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "_ANSI_ESCAPE_SEQ",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "_ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\ncaplog_handler_key = StashKey[\"LogCaptureHandler\"]()\ncaplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\ndef _remove_ansi_escape_sequences(text: str) -> str:\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"\n    LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n        logging.CRITICAL: {\"red\"},",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "caplog_handler_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "caplog_handler_key = StashKey[\"LogCaptureHandler\"]()\ncaplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\ndef _remove_ansi_escape_sequences(text: str) -> str:\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"\n    LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "caplog_records_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "caplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\ndef _remove_ansi_escape_sequences(text: str) -> str:\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n    log format passed to __init__.\"\"\"\n    LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "_HandlerType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.logging",
        "description": "__pypackages__.3.10.lib._pytest.logging",
        "peekOfCode": "_HandlerType = TypeVar(\"_HandlerType\", bound=logging.Handler)\n# Not using @contextmanager for performance reasons.\nclass catching_logs:\n    \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n    __slots__ = (\"handler\", \"level\", \"orig_level\")\n    def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:\n        self.handler = handler\n        self.level = level\n    def __enter__(self):\n        root_logger = logging.getLogger()",
        "detail": "__pypackages__.3.10.lib._pytest.logging",
        "documentation": {}
    },
    {
        "label": "FSHookProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "class FSHookProxy:\n    def __init__(self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "Interrupted",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "class Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n    __module__ = \"builtins\"  # For py3.\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n@attr.s(slots=True, auto_attribs=True)\nclass _bestrelpath_cache(Dict[Path, str]):\n    path: Path\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "Failed",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "class Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n@attr.s(slots=True, auto_attribs=True)\nclass _bestrelpath_cache(Dict[Path, str]):\n    path: Path\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n@final",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "_bestrelpath_cache",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "class _bestrelpath_cache(Dict[Path, str]):\n    path: Path\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "Session",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n    def __init__(self, config: Config) -> None:\n        super().__init__(",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "validate_basetemp",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "wrap_session",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program.\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_collection",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n    if session.config.option.collectonly:\n        return True",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_runtestloop",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n    if session.config.option.collectonly:\n        return True\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_ignore_collect",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_ignore_collect(collection_path: Path, config: Config) -> Optional[bool]:\n    ignore_paths = config._getconftest_pathlist(\n        \"collect_ignore\", path=collection_path.parent, rootpath=config.rootpath\n    )\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend(absolutepath(x) for x in excludeopt)\n    if collection_path in ignore_paths:\n        return True",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "pytest_collection_modifyitems",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def pytest_collection_modifyitems(items: List[nodes.Item], config: Config) -> None:\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "search_pypath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "resolve_collection_argument",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.main",
        "description": "__pypackages__.3.10.lib._pytest.main",
        "peekOfCode": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n    This function ensures the path exists, and returns a tuple:\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n    When as_pypath is True, expects that the command-line argument actually contains",
        "detail": "__pypackages__.3.10.lib._pytest.main",
        "documentation": {}
    },
    {
        "label": "Notset",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "class Notset:\n    def __repr__(self) -> str:\n        return \"<notset>\"\nnotset = Notset()\n@final\nclass MonkeyPatch:\n    \"\"\"Helper to conveniently monkeypatch attributes/items/environment\n    variables/syspath.\n    Returned by the :fixture:`monkeypatch` fixture.\n    .. versionchanged:: 6.2",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "MonkeyPatch",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "class MonkeyPatch:\n    \"\"\"Helper to conveniently monkeypatch attributes/items/environment\n    variables/syspath.\n    Returned by the :fixture:`monkeypatch` fixture.\n    .. versionchanged:: 6.2\n        Can now also be used directly as `pytest.MonkeyPatch()`, for when\n        the fixture is not available. In this case, use\n        :meth:`with MonkeyPatch.context() as mp: <context>` or remember to call\n        :meth:`undo` explicitly.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "monkeypatch",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "def monkeypatch() -> Generator[\"MonkeyPatch\", None, None]:\n    \"\"\"A convenient fixture for monkey-patching.\n    The fixture provides these methods to modify objects, dictionaries, or\n    :data:`os.environ`:\n    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`\n    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`\n    * :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`\n    * :meth:`monkeypatch.delitem(obj, name, raising=True) <pytest.MonkeyPatch.delitem>`\n    * :meth:`monkeypatch.setenv(name, value, prepend=None) <pytest.MonkeyPatch.setenv>`\n    * :meth:`monkeypatch.delenv(name, raising=True) <pytest.MonkeyPatch.delenv>`",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "resolve",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "def resolve(name: str) -> object:\n    # Simplified from zope.dottedname.\n    parts = name.split(\".\")\n    used = parts.pop(0)\n    found: object = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "annotated_getattr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "def annotated_getattr(obj: object, name: str, ann: str) -> object:\n    try:\n        obj = getattr(obj, name)\n    except AttributeError as e:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        ) from e\n    return obj",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "derive_importpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "def derive_importpath(import_path: str, raising: bool) -> Tuple[str, object]:\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(f\"must be absolute import path string, not {import_path!r}\")\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target\nclass Notset:\n    def __repr__(self) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "RE_IMPORT_ERROR_NAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "RE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")\nK = TypeVar(\"K\")\nV = TypeVar(\"V\")\n@fixture\ndef monkeypatch() -> Generator[\"MonkeyPatch\", None, None]:\n    \"\"\"A convenient fixture for monkey-patching.\n    The fixture provides these methods to modify objects, dictionaries, or\n    :data:`os.environ`:\n    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`\n    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "K",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "K = TypeVar(\"K\")\nV = TypeVar(\"V\")\n@fixture\ndef monkeypatch() -> Generator[\"MonkeyPatch\", None, None]:\n    \"\"\"A convenient fixture for monkey-patching.\n    The fixture provides these methods to modify objects, dictionaries, or\n    :data:`os.environ`:\n    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`\n    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`\n    * :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "V",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "V = TypeVar(\"V\")\n@fixture\ndef monkeypatch() -> Generator[\"MonkeyPatch\", None, None]:\n    \"\"\"A convenient fixture for monkey-patching.\n    The fixture provides these methods to modify objects, dictionaries, or\n    :data:`os.environ`:\n    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`\n    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`\n    * :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`\n    * :meth:`monkeypatch.delitem(obj, name, raising=True) <pytest.MonkeyPatch.delitem>`",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "notset",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "description": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "peekOfCode": "notset = Notset()\n@final\nclass MonkeyPatch:\n    \"\"\"Helper to conveniently monkeypatch attributes/items/environment\n    variables/syspath.\n    Returned by the :fixture:`monkeypatch` fixture.\n    .. versionchanged:: 6.2\n        Can now also be used directly as `pytest.MonkeyPatch()`, for when\n        the fixture is not available. In this case, use\n        :meth:`with MonkeyPatch.context() as mp: <context>` or remember to call",
        "detail": "__pypackages__.3.10.lib._pytest.monkeypatch",
        "documentation": {}
    },
    {
        "label": "NodeMeta",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class NodeMeta(type):\n    def __call__(self, *k, **kw):\n        msg = (\n            \"Direct construction of {name} has been deprecated, please use {name}.from_parent.\\n\"\n            \"See \"\n            \"https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent\"\n            \" for more details.\"\n        ).format(name=f\"{self.__module__}.{self.__name__}\")\n        fail(msg, pytrace=False)\n    def _create(self, *k, **kw):",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class Node(metaclass=NodeMeta):\n    \"\"\"Base class for Collector and Item, the components of the test\n    collection tree.\n    Collector subclasses have children; Items are leaf nodes.\n    \"\"\"\n    # Implemented in the legacypath plugin.\n    #: A ``LEGACY_PATH`` copy of the :attr:`path` attribute. Intended for usage\n    #: for methods not migrated to ``pathlib.Path`` yet, such as\n    #: :meth:`Item.reportinfo`. Will be deprecated in a future release, prefer\n    #: using :attr:`path` instead.",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Collector",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class Collector(Node):\n    \"\"\"Collector instances create children through collect() and thus\n    iteratively build a tree.\"\"\"\n    class CollectError(Exception):\n        \"\"\"An error during collection, contains a custom message.\"\"\"\n    def collect(self) -> Iterable[Union[\"Item\", \"Collector\"]]:\n        \"\"\"Return a list of children (items and collectors) for this\n        collection node.\"\"\"\n        raise NotImplementedError(\"abstract\")\n    # TODO: This omits the style= parameter which breaks Liskov Substitution.",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "FSCollector",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class FSCollector(Collector):\n    def __init__(\n        self,\n        fspath: Optional[LEGACY_PATH] = None,\n        path_or_parent: Optional[Union[Path, Node]] = None,\n        path: Optional[Path] = None,\n        name: Optional[str] = None,\n        parent: Optional[Node] = None,\n        config: Optional[Config] = None,\n        session: Optional[\"Session\"] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class File(FSCollector):\n    \"\"\"Base class for collecting tests from a file.\n    :ref:`non-python tests`.\n    \"\"\"\nclass Item(Node):\n    \"\"\"A basic test invocation item.\n    Note that for a single function there might be multiple test invocation items.\n    \"\"\"\n    nextitem = None\n    def __init__(",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "class Item(Node):\n    \"\"\"A basic test invocation item.\n    Note that for a single function there might be multiple test invocation items.\n    \"\"\"\n    nextitem = None\n    def __init__(\n        self,\n        name,\n        parent=None,\n        config: Optional[Config] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "iterparentnodeids",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "def iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n    For the node ID\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n    the result would be\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo\"",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "get_fslocation_from_item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "def get_fslocation_from_item(node: \"Node\") -> Tuple[Union[str, Path], Optional[int]]:\n    \"\"\"Try to extract the actual location from a node, depending on available attributes:\n    * \"location\": a pair (path, lineno)\n    * \"obj\": a Python object that the node wraps.\n    * \"fspath\": just a path\n    :rtype: A tuple of (str|Path, int) with filename and line number.\n    \"\"\"\n    # See Item.location.\n    location: Optional[Tuple[str, Optional[int], str]] = getattr(node, \"location\", None)\n    if location is not None:",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "SEP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "SEP = \"/\"\ntracebackcutdir = Path(_pytest.__file__).parent\ndef iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n    For the node ID\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n    the result would be\n        \"\"\n        \"testing\"\n        \"testing/code\"",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "tracebackcutdir",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "tracebackcutdir = Path(_pytest.__file__).parent\ndef iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n    For the node ID\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n    the result would be\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "_NodeType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.nodes",
        "description": "__pypackages__.3.10.lib._pytest.nodes",
        "peekOfCode": "_NodeType = TypeVar(\"_NodeType\", bound=\"Node\")\nclass NodeMeta(type):\n    def __call__(self, *k, **kw):\n        msg = (\n            \"Direct construction of {name} has been deprecated, please use {name}.from_parent.\\n\"\n            \"See \"\n            \"https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent\"\n            \" for more details.\"\n        ).format(name=f\"{self.__module__}.{self.__name__}\")\n        fail(msg, pytrace=False)",
        "detail": "__pypackages__.3.10.lib._pytest.nodes",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.nose",
        "description": "__pypackages__.3.10.lib._pytest.nose",
        "peekOfCode": "def pytest_runtest_setup(item: Item) -> None:\n    if not isinstance(item, Function):\n        return\n    # Don't do nose style setup/teardown on direct unittest style classes.\n    if isinstance(item, TestCaseFunction):\n        return\n    # Capture the narrowed type of item for the teardown closure,\n    # see https://github.com/python/mypy/issues/2608\n    func = item\n    call_optional(func.obj, \"setup\", func.nodeid)",
        "detail": "__pypackages__.3.10.lib._pytest.nose",
        "documentation": {}
    },
    {
        "label": "call_optional",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.nose",
        "description": "__pypackages__.3.10.lib._pytest.nose",
        "peekOfCode": "def call_optional(obj: object, name: str, nodeid: str) -> bool:\n    method = getattr(obj, name, None)\n    if method is None:\n        return False\n    is_fixture = getfixturemarker(method) is not None\n    if is_fixture:\n        return False\n    if not callable(method):\n        return False\n    # Warn about deprecation of this plugin.",
        "detail": "__pypackages__.3.10.lib._pytest.nose",
        "documentation": {}
    },
    {
        "label": "OutcomeException",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n            error_msg = (  # type: ignore[unreachable]\n                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n                \"Perhaps you meant to use a mark?\"\n            )\n            raise TypeError(error_msg.format(type(self).__name__, type(msg).__name__))",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "Skipped",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class Skipped(OutcomeException):\n    # XXX hackish: on 3k we fake to live in the builtins\n    # in order to have Skipped exception printing shorter/nicer\n    __module__ = \"builtins\"\n    def __init__(\n        self,\n        msg: Optional[str] = None,\n        pytrace: bool = True,\n        allow_module_level: bool = False,\n        *,",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "Failed",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class Failed(OutcomeException):\n    \"\"\"Raised from an explicit call to pytest.fail().\"\"\"\n    __module__ = \"builtins\"\nclass Exit(Exception):\n    \"\"\"Raised for immediate program exits (no tracebacks/summaries).\"\"\"\n    def __init__(\n        self, msg: str = \"unknown reason\", returncode: Optional[int] = None\n    ) -> None:\n        self.msg = msg\n        self.returncode = returncode",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "Exit",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class Exit(Exception):\n    \"\"\"Raised for immediate program exits (no tracebacks/summaries).\"\"\"\n    def __init__(\n        self, msg: str = \"unknown reason\", returncode: Optional[int] = None\n    ) -> None:\n        self.msg = msg\n        self.returncode = returncode\n        super().__init__(msg)\n# Elaborate hack to work around https://github.com/python/mypy/issues/2087.\n# Ideally would just be `exit.Exception = Exit` etc.",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "_WithException",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class _WithException(Protocol[_F, _ET]):\n    Exception: _ET\n    __call__: _F\ndef _with_exception(exception_type: _ET) -> Callable[[_F], _WithException[_F, _ET]]:\n    def decorate(func: _F) -> _WithException[_F, _ET]:\n        func_with_exception = cast(_WithException[_F, _ET], func)\n        func_with_exception.Exception = exception_type\n        return func_with_exception\n    return decorate\n# Exposed helper methods.",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "XFailed",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "class XFailed(Failed):\n    \"\"\"Raised from an explicit call to pytest.xfail().\"\"\"\n@_with_exception(XFailed)\ndef xfail(reason: str = \"\") -> NoReturn:\n    \"\"\"Imperatively xfail an executing test or setup function with the given reason.\n    This function should be called only during testing (setup, call or teardown).\n    :param reason:\n        The message to show the user as reason for the xfail.\n    .. note::\n        It is better to use the :ref:`pytest.mark.xfail ref` marker when",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "exit",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "def exit(\n    reason: str = \"\", returncode: Optional[int] = None, *, msg: Optional[str] = None\n) -> NoReturn:\n    \"\"\"Exit testing process.\n    :param reason:\n        The message to show as the reason for exiting pytest.  reason has a default value\n        only because `msg` is deprecated.\n    :param returncode:\n        Return code to be used when exiting pytest.\n    :param msg:",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "skip",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "def skip(\n    reason: str = \"\", *, allow_module_level: bool = False, msg: Optional[str] = None\n) -> NoReturn:\n    \"\"\"Skip an executing test with the given message.\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n    :param reason:\n        The message to show the user as reason for the skip.\n    :param allow_module_level:",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "fail",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "def fail(reason: str = \"\", pytrace: bool = True, msg: Optional[str] = None) -> NoReturn:\n    \"\"\"Explicitly fail an executing test with the given message.\n    :param reason:\n        The message to show the user as reason for the failure.\n    :param pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    :param msg:\n        Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "xfail",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "def xfail(reason: str = \"\") -> NoReturn:\n    \"\"\"Imperatively xfail an executing test or setup function with the given reason.\n    This function should be called only during testing (setup, call or teardown).\n    :param reason:\n        The message to show the user as reason for the xfail.\n    .. note::\n        It is better to use the :ref:`pytest.mark.xfail ref` marker when\n        possible to declare a test to be xfailed under certain conditions\n        like known bugs or missing features.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "importorskip",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "def importorskip(\n    modname: str, minversion: Optional[str] = None, reason: Optional[str] = None\n) -> Any:\n    \"\"\"Import and return the requested module ``modname``, or skip the\n    current test if the module cannot be imported.\n    :param modname:\n        The name of the module to import.\n    :param minversion:\n        If given, the imported module's ``__version__`` attribute must be at\n        least this minimal version, otherwise the test is still skipped.",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "TYPE_CHECKING = False  # Avoid circular import through compat.\nif TYPE_CHECKING:\n    from typing_extensions import Protocol\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    from typing import Generic\n    Protocol = Generic\nclass OutcomeException(BaseException):",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "TEST_OUTCOME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "TEST_OUTCOME = (OutcomeException, Exception)\nclass Skipped(OutcomeException):\n    # XXX hackish: on 3k we fake to live in the builtins\n    # in order to have Skipped exception printing shorter/nicer\n    __module__ = \"builtins\"\n    def __init__(\n        self,\n        msg: Optional[str] = None,\n        pytrace: bool = True,\n        allow_module_level: bool = False,",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "_F",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "_F = TypeVar(\"_F\", bound=Callable[..., object])\n_ET = TypeVar(\"_ET\", bound=Type[BaseException])\nclass _WithException(Protocol[_F, _ET]):\n    Exception: _ET\n    __call__: _F\ndef _with_exception(exception_type: _ET) -> Callable[[_F], _WithException[_F, _ET]]:\n    def decorate(func: _F) -> _WithException[_F, _ET]:\n        func_with_exception = cast(_WithException[_F, _ET], func)\n        func_with_exception.Exception = exception_type\n        return func_with_exception",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "_ET",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.outcomes",
        "description": "__pypackages__.3.10.lib._pytest.outcomes",
        "peekOfCode": "_ET = TypeVar(\"_ET\", bound=Type[BaseException])\nclass _WithException(Protocol[_F, _ET]):\n    Exception: _ET\n    __call__: _F\ndef _with_exception(exception_type: _ET) -> Callable[[_F], _WithException[_F, _ET]]:\n    def decorate(func: _F) -> _WithException[_F, _ET]:\n        func_with_exception = cast(_WithException[_F, _ET], func)\n        func_with_exception.Exception = exception_type\n        return func_with_exception\n    return decorate",
        "detail": "__pypackages__.3.10.lib._pytest.outcomes",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"terminal reporting\")\n    group._addoption(\n        \"--pastebin\",\n        metavar=\"mode\",\n        action=\"store\",\n        dest=\"pastebin\",\n        default=None,\n        choices=[\"failed\", \"all\"],\n        help=\"Send failed|all info to bpaste.net pastebin service\",",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    if config.option.pastebin == \"all\":\n        tr = config.pluginmanager.getplugin(\"terminalreporter\")\n        # If no terminal reporter plugin is present, nothing we can do here;\n        # this can happen when this function executes in a worker node\n        # when using pytest-xdist, for example.\n        if tr is not None:\n            # pastebin file will be UTF-8 encoded binary file.\n            config.stash[pastebinfile_key] = tempfile.TemporaryFile(\"w+b\")\n            oldwrite = tr._tw.write",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "def pytest_unconfigure(config: Config) -> None:\n    if pastebinfile_key in config.stash:\n        pastebinfile = config.stash[pastebinfile_key]\n        # Get terminal contents and delete file.\n        pastebinfile.seek(0)\n        sessionlog = pastebinfile.read()\n        pastebinfile.close()\n        del config.stash[pastebinfile_key]\n        # Undo our patching in the terminal reporter.\n        tr = config.pluginmanager.getplugin(\"terminalreporter\")",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "create_new_paste",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "def create_new_paste(contents: Union[str, bytes]) -> str:\n    \"\"\"Create a new paste using the bpaste.net service.\n    :contents: Paste contents string.\n    :returns: URL to the pasted contents, or an error message.\n    \"\"\"\n    import re\n    from urllib.request import urlopen\n    from urllib.parse import urlencode\n    params = {\"code\": contents, \"lexer\": \"text\", \"expiry\": \"1week\"}\n    url = \"https://bpa.st\"",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "pytest_terminal_summary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "def pytest_terminal_summary(terminalreporter: TerminalReporter) -> None:\n    if terminalreporter.config.option.pastebin != \"failed\":\n        return\n    if \"failed\" in terminalreporter.stats:\n        terminalreporter.write_sep(\"=\", \"Sending information to Paste Service\")\n        for rep in terminalreporter.stats[\"failed\"]:\n            try:\n                msg = rep.longrepr.reprtraceback.reprentries[-1].reprfileloc\n            except AttributeError:\n                msg = terminalreporter._getfailureheadline(rep)",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "pastebinfile_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pastebin",
        "description": "__pypackages__.3.10.lib._pytest.pastebin",
        "peekOfCode": "pastebinfile_key = StashKey[IO[bytes]]()\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"terminal reporting\")\n    group._addoption(\n        \"--pastebin\",\n        metavar=\"mode\",\n        action=\"store\",\n        dest=\"pastebin\",\n        default=None,\n        choices=[\"failed\", \"all\"],",
        "detail": "__pypackages__.3.10.lib._pytest.pastebin",
        "documentation": {}
    },
    {
        "label": "ImportMode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "class ImportMode(Enum):\n    \"\"\"Possible values for `mode` parameter of `import_path`.\"\"\"\n    prepend = \"prepend\"\n    append = \"append\"\n    importlib = \"importlib\"\nclass ImportPathMismatchError(ImportError):\n    \"\"\"Raised on import_path() if there is a mismatch of __file__'s.\n    This can happen when `import_path` is called multiple times with different filenames that has\n    the same basename but reside in packages\n    (for example \"/tests1/test_foo.py\" and \"/tests2/test_foo.py\").",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "ImportPathMismatchError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "class ImportPathMismatchError(ImportError):\n    \"\"\"Raised on import_path() if there is a mismatch of __file__'s.\n    This can happen when `import_path` is called multiple times with different filenames that has\n    the same basename but reside in packages\n    (for example \"/tests1/test_foo.py\" and \"/tests2/test_foo.py\").\n    \"\"\"\ndef import_path(\n    p: Union[str, \"os.PathLike[str]\"],\n    *,\n    mode: Union[str, ImportMode] = ImportMode.prepend,",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "get_lock_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n    return path.joinpath(\".lock\")\ndef on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:\n    \"\"\"Handle known read-only errors during rmtree.\n    The returned value is used only by our own tests.\n    \"\"\"\n    exctype, excvalue = exc[:2]\n    # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).\n    # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n    if isinstance(excvalue, FileNotFoundError):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "on_rm_rf_error",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:\n    \"\"\"Handle known read-only errors during rmtree.\n    The returned value is used only by our own tests.\n    \"\"\"\n    exctype, excvalue = exc[:2]\n    # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).\n    # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n    if isinstance(excvalue, FileNotFoundError):\n        return False\n    if not isinstance(excvalue, PermissionError):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "ensure_extended_length_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def ensure_extended_length_path(path: Path) -> Path:\n    \"\"\"Get the extended-length version of a path (Windows).\n    On Windows, by default, the maximum length of a path (MAX_PATH) is 260\n    characters, and operations on paths longer than that fail. But it is possible\n    to overcome this by converting the path to \"extended-length\" form before\n    performing the operation:\n    https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n    On Windows, this function returns the extended-length absolute version of path.\n    On other platforms it returns path unchanged.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "get_extended_length_path_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def get_extended_length_path_str(path: str) -> str:\n    \"\"\"Convert a path to a Windows extended length path.\"\"\"\n    long_path_prefix = \"\\\\\\\\?\\\\\"\n    unc_long_path_prefix = \"\\\\\\\\?\\\\UNC\\\\\"\n    if path.startswith((long_path_prefix, unc_long_path_prefix)):\n        return path\n    # UNC\n    if path.startswith(\"\\\\\\\\\"):\n        return unc_long_path_prefix + path[2:]\n    return long_path_prefix + path",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "rm_rf",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def rm_rf(path: Path) -> None:\n    \"\"\"Remove the path contents recursively, even if some elements\n    are read-only.\"\"\"\n    path = ensure_extended_length_path(path)\n    onerror = partial(on_rm_rf_error, start_path=path)\n    shutil.rmtree(str(path), onerror=onerror)\ndef find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n    \"\"\"Find all elements in root that begin with the prefix, case insensitive.\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "find_prefixed",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n    \"\"\"Find all elements in root that begin with the prefix, case insensitive.\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x\ndef extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n    \"\"\"Return the parts of the paths following the prefix.\n    :param iter: Iterator over path names.\n    :param prefix: Expected prefix of the path names.",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "extract_suffixes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n    \"\"\"Return the parts of the paths following the prefix.\n    :param iter: Iterator over path names.\n    :param prefix: Expected prefix of the path names.\n    \"\"\"\n    p_len = len(prefix)\n    for p in iter:\n        yield p.name[p_len:]\ndef find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n    \"\"\"Combine find_prefixes and extract_suffixes.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "find_suffixes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n    \"\"\"Combine find_prefixes and extract_suffixes.\"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)\ndef parse_num(maybe_num) -> int:\n    \"\"\"Parse number path suffixes, returns -1 on error.\"\"\"\n    try:\n        return int(maybe_num)\n    except ValueError:\n        return -1\ndef _force_symlink(",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "parse_num",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def parse_num(maybe_num) -> int:\n    \"\"\"Parse number path suffixes, returns -1 on error.\"\"\"\n    try:\n        return int(maybe_num)\n    except ValueError:\n        return -1\ndef _force_symlink(\n    root: Path, target: Union[str, PurePath], link_to: Union[str, Path]\n) -> None:\n    \"\"\"Helper to create the current symlink.",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "make_numbered_dir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:\n    \"\"\"Create a directory with an increased number as suffix for the given prefix.\"\"\"\n    for i in range(10):\n        # try up to 10 times to create the folder\n        max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n        new_number = max_existing + 1\n        new_path = root.joinpath(f\"{prefix}{new_number}\")\n        try:\n            new_path.mkdir(mode=mode)\n        except Exception:",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "create_cleanup_lock",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def create_cleanup_lock(p: Path) -> Path:\n    \"\"\"Create a lock to prevent premature folder cleanup.\"\"\"\n    lock_path = get_lock_path(p)\n    try:\n        fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)\n    except FileExistsError as e:\n        raise OSError(f\"cannot create lockfile in {p}\") from e\n    else:\n        pid = os.getpid()\n        spid = str(pid).encode()",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "register_cleanup_lock_removal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\n    \"\"\"Register a cleanup function for removing a lock, by default on atexit.\"\"\"\n    pid = os.getpid()\n    def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:\n        current_pid = os.getpid()\n        if current_pid != original_pid:\n            # fork\n            return\n        try:\n            lock_path.unlink()",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "maybe_delete_a_numbered_dir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def maybe_delete_a_numbered_dir(path: Path) -> None:\n    \"\"\"Remove a numbered directory if its lock can be obtained and it does\n    not seem to be in use.\"\"\"\n    path = ensure_extended_length_path(path)\n    lock_path = None\n    try:\n        lock_path = create_cleanup_lock(path)\n        parent = path.parent\n        garbage = parent.joinpath(f\"garbage-{uuid.uuid4()}\")\n        path.rename(garbage)",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "ensure_deletable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\n    \"\"\"Check if `path` is deletable based on whether the lock file is expired.\"\"\"\n    if path.is_symlink():\n        return False\n    lock = get_lock_path(path)\n    try:\n        if not lock.is_file():\n            return True\n    except OSError:\n        # we might not have access to the lock file at all, in this case assume",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "try_cleanup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\n    \"\"\"Try to cleanup a folder if we can ensure it's deletable.\"\"\"\n    if ensure_deletable(path, consider_lock_dead_if_created_before):\n        maybe_delete_a_numbered_dir(path)\ndef cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n    \"\"\"List candidates for numbered directories to be removed - follows py.path.\"\"\"\n    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n    max_delete = max_existing - keep\n    paths = find_prefixed(root, prefix)\n    paths, paths2 = itertools.tee(paths)",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "cleanup_candidates",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n    \"\"\"List candidates for numbered directories to be removed - follows py.path.\"\"\"\n    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n    max_delete = max_existing - keep\n    paths = find_prefixed(root, prefix)\n    paths, paths2 = itertools.tee(paths)\n    numbers = map(parse_num, extract_suffixes(paths2, prefix))\n    for path, number in zip(paths, numbers):\n        if number <= max_delete:\n            yield path",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "cleanup_numbered_dir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def cleanup_numbered_dir(\n    root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n) -> None:\n    \"\"\"Cleanup for lock driven numbered directories.\"\"\"\n    for path in cleanup_candidates(root, prefix, keep):\n        try_cleanup(path, consider_lock_dead_if_created_before)\n    for path in root.glob(\"garbage-*\"):\n        try_cleanup(path, consider_lock_dead_if_created_before)\ndef make_numbered_dir_with_cleanup(\n    root: Path,",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "make_numbered_dir_with_cleanup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def make_numbered_dir_with_cleanup(\n    root: Path,\n    prefix: str,\n    keep: int,\n    lock_timeout: float,\n    mode: int,\n) -> Path:\n    \"\"\"Create a numbered dir with a cleanup lock and remove old ones.\"\"\"\n    e = None\n    for i in range(10):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "resolve_from_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def resolve_from_str(input: str, rootpath: Path) -> Path:\n    input = expanduser(input)\n    input = expandvars(input)\n    if isabs(input):\n        return Path(input)\n    else:\n        return rootpath.joinpath(input)\ndef fnmatch_ex(pattern: str, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n    \"\"\"A port of FNMatcher from py.path.common which works with PurePath() instances.\n    The difference between this algorithm and PurePath.match() is that the",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "fnmatch_ex",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def fnmatch_ex(pattern: str, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n    \"\"\"A port of FNMatcher from py.path.common which works with PurePath() instances.\n    The difference between this algorithm and PurePath.match() is that the\n    latter matches \"**\" glob expressions for each part of the path, while\n    this algorithm uses the whole path instead.\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\"\n        with this algorithm, but not with PurePath.match().\n    This algorithm was ported to keep backward-compatibility with existing\n    settings which assume paths match according this logic.",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "parts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def parts(s: str) -> Set[str]:\n    parts = s.split(sep)\n    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}\ndef symlink_or_skip(src, dst, **kwargs):\n    \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n    try:\n        os.symlink(str(src), str(dst), **kwargs)\n    except OSError as e:\n        skip(f\"symlinks not supported: {e}\")\nclass ImportMode(Enum):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "symlink_or_skip",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def symlink_or_skip(src, dst, **kwargs):\n    \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n    try:\n        os.symlink(str(src), str(dst), **kwargs)\n    except OSError as e:\n        skip(f\"symlinks not supported: {e}\")\nclass ImportMode(Enum):\n    \"\"\"Possible values for `mode` parameter of `import_path`.\"\"\"\n    prepend = \"prepend\"\n    append = \"append\"",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "import_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def import_path(\n    p: Union[str, \"os.PathLike[str]\"],\n    *,\n    mode: Union[str, ImportMode] = ImportMode.prepend,\n    root: Path,\n) -> ModuleType:\n    \"\"\"Import and return a module from the given path, which can be a file (a module) or\n    a directory (a package).\n    The import mechanism used is controlled by the `mode` parameter:\n    * `mode == ImportMode.prepend`: the directory containing the module (or package, taking",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "module_name_from_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "insert_missing_modules",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    while module_name:\n        if module_name not in modules:",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "resolve_package_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "visit",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def visit(\n    path: Union[str, \"os.PathLike[str]\"], recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n    Entries at each directory level are sorted.\n    \"\"\"\n    # Skip entries with symlink loops and other brokenness, so the caller doesn't\n    # have to deal with it.\n    entries = []\n    for entry in os.scandir(path):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "absolutepath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def absolutepath(path: Union[Path, str]) -> Path:\n    \"\"\"Convert a path to an absolute path using os.path.abspath.\n    Prefer this over Path.resolve() (see #6523).\n    Prefer this over Path.absolute() (not public, doesn't normalize).\n    \"\"\"\n    return Path(os.path.abspath(str(path)))\ndef commonpath(path1: Path, path2: Path) -> Optional[Path]:\n    \"\"\"Return the common part shared with the other path, or None if there is\n    no common part.\n    If one path is relative and one is absolute, returns None.",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "commonpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def commonpath(path1: Path, path2: Path) -> Optional[Path]:\n    \"\"\"Return the common part shared with the other path, or None if there is\n    no common part.\n    If one path is relative and one is absolute, returns None.\n    \"\"\"\n    try:\n        return Path(os.path.commonpath((str(path1), str(path2))))\n    except ValueError:\n        return None\ndef bestrelpath(directory: Path, dest: Path) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "bestrelpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def bestrelpath(directory: Path, dest: Path) -> str:\n    \"\"\"Return a string which is a relative path from directory to dest such\n    that directory/bestrelpath == dest.\n    The paths must be either both absolute or both relative.\n    If no such path can be determined, returns dest.\n    \"\"\"\n    assert isinstance(directory, Path)\n    assert isinstance(dest, Path)\n    if dest == directory:\n        return os.curdir",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "copytree",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "def copytree(source: Path, target: Path) -> None:\n    \"\"\"Recursively copy a source directory to target.\"\"\"\n    assert source.is_dir()\n    for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):\n        x = Path(entry)\n        relpath = x.relative_to(source)\n        newx = target / relpath\n        newx.parent.mkdir(exist_ok=True)\n        if x.is_symlink():\n            newx.symlink_to(os.readlink(x))",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "LOCK_TIMEOUT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "LOCK_TIMEOUT = 60 * 60 * 24 * 3\n_AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n# The following function, variables and comments were\n# copied from cpython 3.9 Lib/pathlib.py file.\n# EBADF - guard against macOS `stat` throwing EBADF\n_IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n_IGNORED_WINERRORS = (\n    21,  # ERROR_NOT_READY - drive exists but is not accessible\n    1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n)",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "_AnyPurePath",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "_AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n# The following function, variables and comments were\n# copied from cpython 3.9 Lib/pathlib.py file.\n# EBADF - guard against macOS `stat` throwing EBADF\n_IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n_IGNORED_WINERRORS = (\n    21,  # ERROR_NOT_READY - drive exists but is not accessible\n    1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n)\ndef _ignore_error(exception):",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "_IGNORED_ERRORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "_IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n_IGNORED_WINERRORS = (\n    21,  # ERROR_NOT_READY - drive exists but is not accessible\n    1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n)\ndef _ignore_error(exception):\n    return (\n        getattr(exception, \"errno\", None) in _IGNORED_ERRORS\n        or getattr(exception, \"winerror\", None) in _IGNORED_WINERRORS\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "_IGNORED_WINERRORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pathlib",
        "description": "__pypackages__.3.10.lib._pytest.pathlib",
        "peekOfCode": "_IGNORED_WINERRORS = (\n    21,  # ERROR_NOT_READY - drive exists but is not accessible\n    1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n)\ndef _ignore_error(exception):\n    return (\n        getattr(exception, \"errno\", None) in _IGNORED_ERRORS\n        or getattr(exception, \"winerror\", None) in _IGNORED_WINERRORS\n    )\ndef get_lock_path(path: _AnyPurePath) -> _AnyPurePath:",
        "detail": "__pypackages__.3.10.lib._pytest.pathlib",
        "documentation": {}
    },
    {
        "label": "LsofFdLeakChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class LsofFdLeakChecker:\n    def get_open_files(self) -> List[Tuple[str, str]]:\n        out = subprocess.run(\n            (\"lsof\", \"-Ffn0\", \"-p\", str(os.getpid())),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            check=True,\n            text=True,\n        ).stdout\n        def isopen(line: str) -> bool:",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "PytestArg",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class PytestArg:\n    def __init__(self, request: FixtureRequest) -> None:\n        self._request = request\n    def gethookrecorder(self, hook) -> \"HookRecorder\":\n        hookrecorder = HookRecorder(hook._pm)\n        self._request.addfinalizer(hookrecorder.finish_recording)\n        return hookrecorder\ndef get_public_names(values: Iterable[str]) -> List[str]:\n    \"\"\"Only return names from iterator values without a leading underscore.\"\"\"\n    return [x for x in values if x[0] != \"_\"]",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "RecordedHookCall",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class RecordedHookCall:\n    \"\"\"A recorded call to a hook.\n    The arguments to the hook call are set as attributes.\n    For example:\n    .. code-block:: python\n        calls = hook_recorder.getcalls(\"pytest_runtest_setup\")\n        # Suppose pytest_runtest_setup was called once with `item=an_item`.\n        assert calls[0].item is an_item\n    \"\"\"\n    def __init__(self, name: str, kwargs) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "HookRecorder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class HookRecorder:\n    \"\"\"Record all hooks called in a plugin manager.\n    Hook recorders are created by :class:`Pytester`.\n    This wraps all the hook calls in the plugin manager, recording each call\n    before propagating the normal calls.\n    \"\"\"\n    def __init__(\n        self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "RunResult",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class RunResult:\n    \"\"\"The result of running a command from :class:`~pytest.Pytester`.\"\"\"\n    def __init__(\n        self,\n        ret: Union[int, ExitCode],\n        outlines: List[str],\n        errlines: List[str],\n        duration: float,\n    ) -> None:\n        try:",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "CwdSnapshot",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class CwdSnapshot:\n    def __init__(self) -> None:\n        self.__saved = os.getcwd()\n    def restore(self) -> None:\n        os.chdir(self.__saved)\nclass SysModulesSnapshot:\n    def __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:\n        self.__preserve = preserve\n        self.__saved = dict(sys.modules)\n    def restore(self) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "SysModulesSnapshot",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class SysModulesSnapshot:\n    def __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:\n        self.__preserve = preserve\n        self.__saved = dict(sys.modules)\n    def restore(self) -> None:\n        if self.__preserve:\n            self.__saved.update(\n                (k, m) for k, m in sys.modules.items() if self.__preserve(k)\n            )\n        sys.modules.clear()",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "SysPathsSnapshot",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class SysPathsSnapshot:\n    def __init__(self) -> None:\n        self.__saved = list(sys.path), list(sys.meta_path)\n    def restore(self) -> None:\n        sys.path[:], sys.meta_path[:] = self.__saved\n@final\nclass Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "Pytester",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to :attr:`path` and environment variables during initialization.\n    \"\"\"\n    __test__ = False\n    CLOSE_STDIN: \"Final\" = NOTSET\n    class TimeoutExpired(Exception):",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "LineComp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class LineComp:\n    def __init__(self) -> None:\n        self.stringio = StringIO()\n        \"\"\":class:`python:io.StringIO()` instance used for input.\"\"\"\n    def assert_contains_lines(self, lines2: Sequence[str]) -> None:\n        \"\"\"Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.\n        Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.\n        \"\"\"\n        __tracebackhide__ = True\n        val = self.stringio.getvalue()",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "LineMatcher",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "class LineMatcher:\n    \"\"\"Flexible matching of text.\n    This is a convenience class to test large texts like the output of\n    commands.\n    The constructor takes a list of lines without their trailing newlines, i.e.\n    ``text.splitlines()``.\n    \"\"\"\n    def __init__(self, lines: List[str]) -> None:\n        self.lines = lines\n        self._log_output: List[str] = []",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    parser.addoption(\n        \"--lsof\",\n        action=\"store_true\",\n        dest=\"lsof\",\n        default=False,\n        help=\"Run FD checks if lsof is available\",\n    )\n    parser.addoption(\n        \"--runpytest\",",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    if config.getvalue(\"lsof\"):\n        checker = LsofFdLeakChecker()\n        if checker.matching_platform():\n            config.pluginmanager.register(checker)\n    config.addinivalue_line(\n        \"markers\",\n        \"pytester_example_path(*path_segments): join the given path \"\n        \"segments to `pytester_example_dir` for this test.\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "get_public_names",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def get_public_names(values: Iterable[str]) -> List[str]:\n    \"\"\"Only return names from iterator values without a leading underscore.\"\"\"\n    return [x for x in values if x[0] != \"_\"]\n@final\nclass RecordedHookCall:\n    \"\"\"A recorded call to a hook.\n    The arguments to the hook call are set as attributes.\n    For example:\n    .. code-block:: python\n        calls = hook_recorder.getcalls(\"pytest_runtest_setup\")",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "linecomp",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def linecomp() -> \"LineComp\":\n    \"\"\"A :class: `LineComp` instance for checking that an input linearly\n    contains a sequence of strings.\"\"\"\n    return LineComp()\n@fixture(name=\"LineMatcher\")\ndef LineMatcher_fixture(request: FixtureRequest) -> Type[\"LineMatcher\"]:\n    \"\"\"A reference to the :class: `LineMatcher`.\n    This is instantiable with a list of lines (without their trailing newlines).\n    This is useful for testing large texts, such as the output of commands.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "LineMatcher_fixture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def LineMatcher_fixture(request: FixtureRequest) -> Type[\"LineMatcher\"]:\n    \"\"\"A reference to the :class: `LineMatcher`.\n    This is instantiable with a list of lines (without their trailing newlines).\n    This is useful for testing large texts, such as the output of commands.\n    \"\"\"\n    return LineMatcher\n@fixture\ndef pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> \"Pytester\":",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "pytester",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "def pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> \"Pytester\":\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "pytest_plugins",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "pytest_plugins = [\"pytester_assertions\"]\nIGNORE_PAM = [  # filenames added when obtaining details about the current user\n    \"/var/lib/sss/mc/passwd\"\n]\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addoption(\n        \"--lsof\",\n        action=\"store_true\",\n        dest=\"lsof\",\n        default=False,",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "IGNORE_PAM",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "IGNORE_PAM = [  # filenames added when obtaining details about the current user\n    \"/var/lib/sss/mc/passwd\"\n]\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addoption(\n        \"--lsof\",\n        action=\"store_true\",\n        dest=\"lsof\",\n        default=False,\n        help=\"Run FD checks if lsof is available\",",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "rex_session_duration",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "rex_session_duration = re.compile(r\"\\d+\\.\\d\\ds\")\n# Regex to match all the counts and phrases in the summary line: \"34 passed, 111 skipped\".\nrex_outcome = re.compile(r\"(\\d+) (\\w+)\")\n@final\nclass RunResult:\n    \"\"\"The result of running a command from :class:`~pytest.Pytester`.\"\"\"\n    def __init__(\n        self,\n        ret: Union[int, ExitCode],\n        outlines: List[str],",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "rex_outcome",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester",
        "description": "__pypackages__.3.10.lib._pytest.pytester",
        "peekOfCode": "rex_outcome = re.compile(r\"(\\d+) (\\w+)\")\n@final\nclass RunResult:\n    \"\"\"The result of running a command from :class:`~pytest.Pytester`.\"\"\"\n    def __init__(\n        self,\n        ret: Union[int, ExitCode],\n        outlines: List[str],\n        errlines: List[str],\n        duration: float,",
        "detail": "__pypackages__.3.10.lib._pytest.pytester",
        "documentation": {}
    },
    {
        "label": "assertoutcome",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "description": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "peekOfCode": "def assertoutcome(\n    outcomes: Tuple[\n        Sequence[TestReport],\n        Sequence[Union[CollectReport, TestReport]],\n        Sequence[Union[CollectReport, TestReport]],\n    ],\n    passed: int = 0,\n    skipped: int = 0,\n    failed: int = 0,\n) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "documentation": {}
    },
    {
        "label": "assert_outcomes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "description": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "peekOfCode": "def assert_outcomes(\n    outcomes: Dict[str, int],\n    passed: int = 0,\n    skipped: int = 0,\n    failed: int = 0,\n    errors: int = 0,\n    xpassed: int = 0,\n    xfailed: int = 0,\n    warnings: Optional[int] = None,\n    deselected: Optional[int] = None,",
        "detail": "__pypackages__.3.10.lib._pytest.pytester_assertions",
        "documentation": {}
    },
    {
        "label": "PyobjMixin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class PyobjMixin(nodes.Node):\n    \"\"\"this mix-in inherits from Node to carry over the typing information\n    as its intended to always mix in before a node\n    its position in the mro is unaffected\"\"\"\n    _ALLOW_MARKERS = True\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "_EmptyClass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class _EmptyClass: pass  # noqa: E701\nIGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file__\", \"__cached__\"},\n    # Class.\n    dir(_EmptyClass),\n    # Instance.",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "PyCollector",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class PyCollector(PyobjMixin, nodes.Collector):\n    def funcnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)\n    def isnosetest(self, obj: object) -> bool:\n        \"\"\"Look for the __test__ attribute, which is applied by the\n        @nose.tools.istest decorator.\n        \"\"\"\n        # We explicitly check for \"is True\" here to not mistakenly treat\n        # classes with a custom __getattr__ returning something truthy (like a\n        # function) as test classes.",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "Module",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class Module(nodes.File, PyCollector):\n    \"\"\"Collector for test classes and functions.\"\"\"\n    def _getobj(self):\n        return self._importtestmodule()\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        self._inject_setup_module_fixture()\n        self._inject_setup_function_fixture()\n        self.session._fixturemanager.parsefactories(self)\n        return super().collect()\n    def _inject_setup_module_fixture(self) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "Package",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class Package(Module):\n    def __init__(\n        self,\n        fspath: Optional[LEGACY_PATH],\n        parent: nodes.Collector,\n        # NOTE: following args are unused:\n        config=None,\n        session=None,\n        nodeid=None,\n        path=Optional[Path],",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "Class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class Class(PyCollector):\n    \"\"\"Collector for test methods.\"\"\"\n    @classmethod\n    def from_parent(cls, parent, *, name, obj=None, **kw):\n        \"\"\"The public constructor.\"\"\"\n        return super().from_parent(name=name, parent=parent, **kw)\n    def newinstance(self):\n        return self.obj()\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not safe_getattr(self.obj, \"__test__\", True):",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "InstanceDummy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class InstanceDummy:\n    \"\"\"Instance used to be a node type between Class and Function. It has been\n    removed in pytest 7.0. Some plugins exist which reference `pytest.Instance`\n    only to ignore it; this dummy class keeps them working. This will be removed\n    in pytest 8.\"\"\"\ndef __getattr__(name: str) -> object:\n    if name == \"Instance\":\n        warnings.warn(INSTANCE_COLLECTOR, 2)\n        return InstanceDummy\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "IdMaker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class IdMaker:\n    \"\"\"Make IDs for a parametrization.\"\"\"\n    # The argnames of the parametrization.\n    argnames: Sequence[str]\n    # The ParameterSets of the parametrization.\n    parametersets: Sequence[ParameterSet]\n    # Optionally, a user-provided callable to make IDs for parameters in a\n    # ParameterSet.\n    idfn: Optional[Callable[[Any], Optional[object]]]\n    # Optionally, explicit IDs for ParameterSets by index.",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "CallSpec2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class CallSpec2:\n    \"\"\"A planned parameterized invocation of a test function.\n    Calculated during collection for a given test function's Metafunc.\n    Once collection is over, each callspec is turned into a single Item\n    and stored in item.callspec.\n    \"\"\"\n    # arg name -> arg value which will be passed to the parametrized test\n    # function (direct parameterization).\n    funcargs: Dict[str, object] = attr.Factory(dict)\n    # arg name -> arg value which will be passed to a fixture of the same name",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "Metafunc",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class Metafunc:\n    \"\"\"Objects passed to the :hook:`pytest_generate_tests` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class Function(PyobjMixin, nodes.Item):\n    \"\"\"An Item responsible for setting up and executing a Python test function.\n    :param name:\n        The full function name, including any decorations like those\n        added by parametrization (``my_func[my_param]``).\n    :param parent:\n        The parent Node.\n    :param config:\n        The pytest Config object.\n    :param callspec:",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "FunctionDefinition",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "class FunctionDefinition(Function):\n    \"\"\"\n    This class is a step gap solution until we evolve to have actual function definition nodes\n    and manage to get rid of ``metafunc``.\n    \"\"\"\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be run as tests\")\n    setup = runtest",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--fixtures\",\n        \"--funcargs\",\n        action=\"store_true\",\n        dest=\"showfixtures\",\n        default=False,\n        help=\"Show available fixtures, sorted by plugin appearance \"\n        \"(fixtures with leading '_' are only shown with '-v')\",",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n    return None\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)\ndef pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info \"",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "async_warn_and_skip",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - anyio\\n\"\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-twisted\"",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_pyfunc_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    elif result is not None:",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_collect_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_collect_file(file_path: Path, parent: nodes.Collector) -> Optional[\"Module\"]:\n    if file_path.suffix == \".py\":\n        if not parent.session.isinitpath(file_path):\n            if not path_matches_patterns(\n                file_path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(file_path)\n        module: Module = ihook.pytest_pycollect_makemodule(\n            module_path=file_path, parent=parent",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "path_matches_patterns",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def path_matches_patterns(path: Path, patterns: Iterable[str]) -> bool:\n    \"\"\"Return whether path matches any of the patterns in the list of globs given.\"\"\"\n    return any(fnmatch_ex(pattern, path) for pattern in patterns)\ndef pytest_pycollect_makemodule(module_path: Path, parent) -> \"Module\":\n    if module_path.name == \"__init__.py\":\n        pkg: Package = Package.from_parent(parent, path=module_path)\n        return pkg\n    mod: Module = Module.from_parent(parent, path=module_path)\n    return mod\n@hookimpl(trylast=True)",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_pycollect_makemodule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_pycollect_makemodule(module_path: Path, parent) -> \"Module\":\n    if module_path.name == \"__init__.py\":\n        pkg: Package = Package.from_parent(parent, path=module_path)\n        return pkg\n    mod: Module = Module.from_parent(parent, path=module_path)\n    return mod\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(\n    collector: Union[\"Module\", \"Class\"], name: str, obj: object\n) -> Union[None, nodes.Item, nodes.Collector, List[Union[nodes.Item, nodes.Collector]]]:",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "pytest_pycollect_makeitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def pytest_pycollect_makeitem(\n    collector: Union[\"Module\", \"Class\"], name: str, obj: object\n) -> Union[None, nodes.Item, nodes.Collector, List[Union[nodes.Item, nodes.Collector]]]:\n    assert isinstance(collector, (Class, Module)), type(collector)\n    # Nothing was collected elsewhere, let's do it here.\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            klass: Class = Class.from_parent(collector, name=name, obj=obj)\n            return klass\n    elif collector.istestfunction(obj, name):",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "hasinit",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def hasinit(obj: object) -> bool:\n    init: object = getattr(obj, \"__init__\", None)\n    if init:\n        return init != object.__init__\n    return False\ndef hasnew(obj: object) -> bool:\n    new: object = getattr(obj, \"__new__\", None)\n    if new:\n        return new != object.__new__\n    return False",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "hasnew",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def hasnew(obj: object) -> bool:\n    new: object = getattr(obj, \"__new__\", None)\n    if new:\n        return new != object.__new__\n    return False\n@final\n@attr.s(frozen=True, auto_attribs=True, slots=True)\nclass IdMaker:\n    \"\"\"Make IDs for a parametrization.\"\"\"\n    # The argnames of the parametrization.",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "show_fixtures_per_test",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def show_fixtures_per_test(config):\n    from _pytest.main import wrap_session\n    return wrap_session(config, _show_fixtures_per_test)\ndef _show_fixtures_per_test(config: Config, session: Session) -> None:\n    import _pytest.config\n    session.perform_collect()\n    curdir = Path.cwd()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n    def get_best_relpath(func) -> str:",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "showfixtures",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def showfixtures(config: Config) -> Union[int, ExitCode]:\n    from _pytest.main import wrap_session\n    return wrap_session(config, _showfixtures_main)\ndef _showfixtures_main(config: Config, session: Session) -> None:\n    import _pytest.config\n    session.perform_collect()\n    curdir = Path.cwd()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n    fm = session._fixturemanager",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "write_docstring",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "def write_docstring(tw: TerminalWriter, doc: str, indent: str = \"    \") -> None:\n    for line in doc.split(\"\\n\"):\n        tw.line(indent + line)\nclass Function(PyobjMixin, nodes.Item):\n    \"\"\"An Item responsible for setting up and executing a Python test function.\n    :param name:\n        The full function name, including any decorations like those\n        added by parametrization (``my_func[my_param]``).\n    :param parent:\n        The parent Node.",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "_PYTEST_DIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "_PYTEST_DIR = Path(_pytest.__file__).parent\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--fixtures\",\n        \"--funcargs\",\n        action=\"store_true\",\n        dest=\"showfixtures\",\n        default=False,\n        help=\"Show available fixtures, sorted by plugin appearance \"",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "IGNORED_ATTRIBUTES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.python",
        "description": "__pypackages__.3.10.lib._pytest.python",
        "peekOfCode": "IGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file__\", \"__cached__\"},\n    # Class.\n    dir(_EmptyClass),\n    # Instance.\n    dir(_EmptyClass()),",
        "detail": "__pypackages__.3.10.lib._pytest.python",
        "documentation": {}
    },
    {
        "label": "ApproxBase",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxBase:\n    \"\"\"Provide shared utilities for making approximate comparisons between\n    numbers or sequences of numbers.\"\"\"\n    # Tell numpy to use our `__eq__` operator instead of its.\n    __array_ufunc__ = None\n    __array_priority__ = 100\n    def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:\n        __tracebackhide__ = True\n        self.expected = expected\n        self.abs = abs",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "ApproxNumpy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxNumpy(ApproxBase):\n    \"\"\"Perform approximate comparisons where the expected value is numpy array.\"\"\"\n    def __repr__(self) -> str:\n        list_scalars = _recursive_sequence_map(\n            self._approx_scalar, self.expected.tolist()\n        )\n        return f\"approx({list_scalars!r})\"\n    def _repr_compare(self, other_side: \"ndarray\") -> List[str]:\n        import itertools\n        import math",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "ApproxMapping",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxMapping(ApproxBase):\n    \"\"\"Perform approximate comparisons where the expected value is a mapping\n    with numeric values (the keys can be anything).\"\"\"\n    def __repr__(self) -> str:\n        return \"approx({!r})\".format(\n            {k: self._approx_scalar(v) for k, v in self.expected.items()}\n        )\n    def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:\n        import math\n        approx_side_as_map = {",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "ApproxSequenceLike",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxSequenceLike(ApproxBase):\n    \"\"\"Perform approximate comparisons where the expected value is a sequence of numbers.\"\"\"\n    def __repr__(self) -> str:\n        seq_type = type(self.expected)\n        if seq_type not in (tuple, list):\n            seq_type = list\n        return \"approx({!r})\".format(\n            seq_type(self._approx_scalar(x) for x in self.expected)\n        )\n    def _repr_compare(self, other_side: Sequence[float]) -> List[str]:",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "ApproxScalar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxScalar(ApproxBase):\n    \"\"\"Perform approximate comparisons where the expected value is a single number.\"\"\"\n    # Using Real should be better than this Union, but not possible yet:\n    # https://github.com/python/typeshed/pull/3108\n    DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12\n    DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6\n    def __repr__(self) -> str:\n        \"\"\"Return a string communicating both the expected value and the\n        tolerance for the comparison being made.\n        For example, ``1.0 ± 1e-6``, ``(3+4j) ± 5e-6 ∠ ±180°``.",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "ApproxDecimal",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class ApproxDecimal(ApproxScalar):\n    \"\"\"Perform approximate comparisons where the expected value is a Decimal.\"\"\"\n    DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n    DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\ndef approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n    \"\"\"Assert that two numbers (or two ordered sequences of numbers) are equal to each other\n    within some tolerance.\n    Due to the :doc:`python:tutorial/floatingpoint`, numbers that we\n    would intuitively expect to be equal are not always so::\n        >>> 0.1 + 0.2 == 0.3",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "RaisesContext",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "class RaisesContext(Generic[E]):\n    def __init__(\n        self,\n        expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n        message: str,\n        match_expr: Optional[Union[str, Pattern[str]]] = None,\n    ) -> None:\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "approx",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n    \"\"\"Assert that two numbers (or two ordered sequences of numbers) are equal to each other\n    within some tolerance.\n    Due to the :doc:`python:tutorial/floatingpoint`, numbers that we\n    would intuitively expect to be equal are not always so::\n        >>> 0.1 + 0.2 == 0.3\n        False\n    This problem is commonly encountered when writing tests, e.g. when making\n    sure that floating-point values are what you expect them to be.  One way to\n    deal with this problem is to assert that two floating-point numbers are",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "raises",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "def raises(\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n    *,\n    match: Optional[Union[str, Pattern[str]]] = ...,\n) -> \"RaisesContext[E]\":\n    ...\n@overload\ndef raises(  # noqa: F811\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n    func: Callable[..., Any],",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "raises",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "def raises(  # noqa: F811\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n    func: Callable[..., Any],\n    *args: Any,\n    **kwargs: Any,\n) -> _pytest._code.ExceptionInfo[E]:\n    ...\ndef raises(  # noqa: F811\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any\n) -> Union[\"RaisesContext[E]\", _pytest._code.ExceptionInfo[E]]:",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "raises",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "def raises(  # noqa: F811\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any\n) -> Union[\"RaisesContext[E]\", _pytest._code.ExceptionInfo[E]]:\n    r\"\"\"Assert that a code block/function call raises an exception.\n    :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:\n        The excpected exception type, or a tuple if one of multiple possible\n        exception types are excepted.\n    :kwparam str | typing.Pattern[str] | None match:\n        If specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "E",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "E = TypeVar(\"E\", bound=BaseException)\n@overload\ndef raises(\n    expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n    *,\n    match: Optional[Union[str, Pattern[str]]] = ...,\n) -> \"RaisesContext[E]\":\n    ...\n@overload\ndef raises(  # noqa: F811",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "raises.Exception",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.python_api",
        "description": "__pypackages__.3.10.lib._pytest.python_api",
        "peekOfCode": "raises.Exception = fail.Exception  # type: ignore\n@final\nclass RaisesContext(Generic[E]):\n    def __init__(\n        self,\n        expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n        message: str,\n        match_expr: Optional[Union[str, Pattern[str]]] = None,\n    ) -> None:\n        self.expected_exception = expected_exception",
        "detail": "__pypackages__.3.10.lib._pytest.python_api",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_path",
        "description": "__pypackages__.3.10.lib._pytest.python_path",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\"pythonpath\", type=\"paths\", help=\"Add paths to sys.path\", default=[])\n@pytest.hookimpl(tryfirst=True)\ndef pytest_load_initial_conftests(early_config: Config) -> None:\n    # `pythonpath = a b` will set `sys.path` to `[a, b, x, y, z, ...]`\n    for path in reversed(early_config.getini(\"pythonpath\")):\n        sys.path.insert(0, str(path))\n@pytest.hookimpl(trylast=True)\ndef pytest_unconfigure(config: Config) -> None:\n    for path in config.getini(\"pythonpath\"):",
        "detail": "__pypackages__.3.10.lib._pytest.python_path",
        "documentation": {}
    },
    {
        "label": "pytest_load_initial_conftests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_path",
        "description": "__pypackages__.3.10.lib._pytest.python_path",
        "peekOfCode": "def pytest_load_initial_conftests(early_config: Config) -> None:\n    # `pythonpath = a b` will set `sys.path` to `[a, b, x, y, z, ...]`\n    for path in reversed(early_config.getini(\"pythonpath\")):\n        sys.path.insert(0, str(path))\n@pytest.hookimpl(trylast=True)\ndef pytest_unconfigure(config: Config) -> None:\n    for path in config.getini(\"pythonpath\"):\n        path_str = str(path)\n        if path_str in sys.path:\n            sys.path.remove(path_str)",
        "detail": "__pypackages__.3.10.lib._pytest.python_path",
        "documentation": {}
    },
    {
        "label": "pytest_unconfigure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.python_path",
        "description": "__pypackages__.3.10.lib._pytest.python_path",
        "peekOfCode": "def pytest_unconfigure(config: Config) -> None:\n    for path in config.getini(\"pythonpath\"):\n        path_str = str(path)\n        if path_str in sys.path:\n            sys.path.remove(path_str)",
        "detail": "__pypackages__.3.10.lib._pytest.python_path",
        "documentation": {}
    },
    {
        "label": "WarningsRecorder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "class WarningsRecorder(warnings.catch_warnings):  # type:ignore[type-arg]\n    \"\"\"A context manager to record raised warnings.\n    Each recorded warning is an instance of :class:`warnings.WarningMessage`.\n    Adapted from `warnings.catch_warnings`.\n    .. note::\n        ``DeprecationWarning`` and ``PendingDeprecationWarning`` are treated\n        differently; see :ref:`ensuring_function_triggers`.\n    \"\"\"\n    def __init__(self, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "WarningsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "class WarningsChecker(WarningsRecorder):\n    def __init__(\n        self,\n        expected_warning: Optional[\n            Union[Type[Warning], Tuple[Type[Warning], ...]]\n        ] = Warning,\n        match_expr: Optional[Union[str, Pattern[str]]] = None,\n        *,\n        _ispytest: bool = False,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "recwarn",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def recwarn() -> Generator[\"WarningsRecorder\", None, None]:\n    \"\"\"Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.\n    See https://docs.pytest.org/en/latest/how-to/capture-warnings.html for information\n    on warning categories.\n    \"\"\"\n    wrec = WarningsRecorder(_ispytest=True)\n    with wrec:\n        warnings.simplefilter(\"default\")\n        yield wrec\n@overload",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "deprecated_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def deprecated_call(\n    *, match: Optional[Union[str, Pattern[str]]] = ...\n) -> \"WarningsRecorder\":\n    ...\n@overload\ndef deprecated_call(  # noqa: F811\n    func: Callable[..., T], *args: Any, **kwargs: Any\n) -> T:\n    ...\ndef deprecated_call(  # noqa: F811",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "deprecated_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def deprecated_call(  # noqa: F811\n    func: Callable[..., T], *args: Any, **kwargs: Any\n) -> T:\n    ...\ndef deprecated_call(  # noqa: F811\n    func: Optional[Callable[..., Any]] = None, *args: Any, **kwargs: Any\n) -> Union[\"WarningsRecorder\", Any]:\n    \"\"\"Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning``.\n    This function can be used as a context manager::\n        >>> import warnings",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "deprecated_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def deprecated_call(  # noqa: F811\n    func: Optional[Callable[..., Any]] = None, *args: Any, **kwargs: Any\n) -> Union[\"WarningsRecorder\", Any]:\n    \"\"\"Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning``.\n    This function can be used as a context manager::\n        >>> import warnings\n        >>> def api_call_v2():\n        ...     warnings.warn('use v3 of this api', DeprecationWarning)\n        ...     return 200\n        >>> import pytest",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "warns",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def warns(\n    expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = ...,\n    *,\n    match: Optional[Union[str, Pattern[str]]] = ...,\n) -> \"WarningsChecker\":\n    ...\n@overload\ndef warns(  # noqa: F811\n    expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n    func: Callable[..., T],",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "warns",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def warns(  # noqa: F811\n    expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n    func: Callable[..., T],\n    *args: Any,\n    **kwargs: Any,\n) -> T:\n    ...\ndef warns(  # noqa: F811\n    expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = Warning,\n    *args: Any,",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "warns",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "def warns(  # noqa: F811\n    expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = Warning,\n    *args: Any,\n    match: Optional[Union[str, Pattern[str]]] = None,\n    **kwargs: Any,\n) -> Union[\"WarningsChecker\", Any]:\n    r\"\"\"Assert that code raises a particular class of warning.\n    Specifically, the parameter ``expected_warning`` can be a warning class or sequence\n    of warning classes, and the code inside the ``with`` block must issue at least one\n    warning of that class or classes.",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.recwarn",
        "description": "__pypackages__.3.10.lib._pytest.recwarn",
        "peekOfCode": "T = TypeVar(\"T\")\n@fixture\ndef recwarn() -> Generator[\"WarningsRecorder\", None, None]:\n    \"\"\"Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.\n    See https://docs.pytest.org/en/latest/how-to/capture-warnings.html for information\n    on warning categories.\n    \"\"\"\n    wrec = WarningsRecorder(_ispytest=True)\n    with wrec:\n        warnings.simplefilter(\"default\")",
        "detail": "__pypackages__.3.10.lib._pytest.recwarn",
        "documentation": {}
    },
    {
        "label": "BaseReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "class BaseReport:\n    when: Optional[str]\n    location: Optional[Tuple[str, Optional[int], str]]\n    longrepr: Union[\n        None, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr\n    ]\n    sections: List[Tuple[str, str]]\n    nodeid: str\n    outcome: \"Literal['passed', 'failed', 'skipped']\"\n    def __init__(self, **kw: Any) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "TestReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "class TestReport(BaseReport):\n    \"\"\"Basic test report object (also used for setup and teardown calls if\n    they fail).\n    Reports can contain arbitrary extra attributes.\n    \"\"\"\n    __test__ = False\n    def __init__(\n        self,\n        nodeid: str,\n        location: Tuple[str, Optional[int], str],",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "class CollectReport(BaseReport):\n    \"\"\"Collection report object.\n    Reports can contain arbitrary extra attributes.\n    \"\"\"\n    when = \"collect\"\n    def __init__(\n        self,\n        nodeid: str,\n        outcome: \"Literal['passed', 'failed', 'skipped']\",\n        longrepr: Union[",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "CollectErrorRepr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "class CollectErrorRepr(TerminalRepr):\n    def __init__(self, msg: str) -> None:\n        self.longrepr = msg\n    def toterminal(self, out: TerminalWriter) -> None:\n        out.line(self.longrepr, red=True)\ndef pytest_report_to_serializable(\n    report: Union[CollectReport, TestReport]\n) -> Optional[Dict[str, Any]]:\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "getworkerinfoline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "def getworkerinfoline(node):\n    try:\n        return node._workerinfocache\n    except AttributeError:\n        d = node.workerinfo\n        ver = \"%s.%s.%s\" % d[\"version_info\"][:3]\n        node._workerinfocache = s = \"[{}] {} -- Python {} {}\".format(\n            d[\"id\"], d[\"sysplatform\"], ver, d[\"executable\"]\n        )\n        return s",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "pytest_report_to_serializable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "def pytest_report_to_serializable(\n    report: Union[CollectReport, TestReport]\n) -> Optional[Dict[str, Any]]:\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"$report_type\"] = report.__class__.__name__\n        return data\n    # TODO: Check if this is actually reachable.\n    return None  # type: ignore[unreachable]\ndef pytest_report_from_serializable(",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "pytest_report_from_serializable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "def pytest_report_from_serializable(\n    data: Dict[str, Any],\n) -> Optional[Union[CollectReport, TestReport]]:\n    if \"$report_type\" in data:\n        if data[\"$report_type\"] == \"TestReport\":\n            return TestReport._from_json(data)\n        elif data[\"$report_type\"] == \"CollectReport\":\n            return CollectReport._from_json(data)\n        assert False, \"Unknown report_type unserialize data: {}\".format(\n            data[\"$report_type\"]",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "_R",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.reports",
        "description": "__pypackages__.3.10.lib._pytest.reports",
        "peekOfCode": "_R = TypeVar(\"_R\", bound=\"BaseReport\")\nclass BaseReport:\n    when: Optional[str]\n    location: Optional[Tuple[str, Optional[int], str]]\n    longrepr: Union[\n        None, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr\n    ]\n    sections: List[Tuple[str, str]]\n    nodeid: str\n    outcome: \"Literal['passed', 'failed', 'skipped']\"",
        "detail": "__pypackages__.3.10.lib._pytest.reports",
        "documentation": {}
    },
    {
        "label": "CallInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "class CallInfo(Generic[TResult]):\n    \"\"\"Result/Exception info of a function invocation.\"\"\"\n    _result: Optional[TResult]\n    #: The captured exception of the call, if it raised.\n    excinfo: Optional[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "SetupState",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "class SetupState:\n    \"\"\"Shared state for setting up/tearing down test items or collectors\n    in a session.\n    Suppose we have a collection tree as follows:\n    <Session session>\n        <Module mod1>\n            <Function item1>\n        <Module mod2>\n            <Function item2>\n    The SetupState maintains a stack. The stack starts out empty:",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"terminal reporting\", \"Reporting\", after=\"general\")\n    group.addoption(\n        \"--durations\",\n        action=\"store\",\n        type=int,\n        default=None,\n        metavar=\"N\",\n        help=\"Show N slowest setup/test durations (N=0 for all)\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_terminal_summary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_terminal_summary(terminalreporter: \"TerminalReporter\") -> None:\n    durations = terminalreporter.config.option.durations\n    durations_min = terminalreporter.config.option.durations_min\n    verbose = terminalreporter.config.getvalue(\"verbose\")\n    if durations is None:\n        return\n    tr = terminalreporter\n    dlist = []\n    for replist in tr.stats.values():\n        for rep in replist:",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_sessionstart(session: \"Session\") -> None:\n    session._setupstate = SetupState()\ndef pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\ndef pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:\n    ihook = item.ihook\n    ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_sessionfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\ndef pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:\n    ihook = item.ihook\n    ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True\ndef runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:\n    ihook = item.ihook\n    ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True\ndef runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "runtestprotocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "show_test_item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def show_test_item(item: Item) -> None:\n    \"\"\"Show test function, parameters and the fixtures of the test item.\"\"\"\n    tw = item.config.get_terminal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n    tw.flush()",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_runtest_setup(item: Item) -> None:\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.setup(item)\ndef pytest_runtest_call(item: Item) -> None:\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_runtest_call(item: Item) -> None:\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_teardown",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(nextitem)\n    _update_current_test_var(item, None)\ndef _update_current_test_var(\n    item: Item, when: Optional[\"Literal['setup', 'call', 'teardown']\"]\n) -> None:\n    \"\"\"Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_report_teststatus",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n    return None",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "call_and_report",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "check_interactive_exception",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def check_interactive_exception(call: \"CallInfo[object]\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "call_runtest_hook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def call_runtest_hook(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", **kwds\n) -> \"CallInfo[None]\":\n    if when == \"setup\":\n        ihook: Callable[..., None] = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_makereport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"unittest\")",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "pytest_make_collect_report",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"unittest\")\n        if unittest is not None:\n            # Type ignored because unittest is loaded dynamically.",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "collect_one_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "def collect_one_node(collector: Collector) -> CollectReport:\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "TResult",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.runner",
        "description": "__pypackages__.3.10.lib._pytest.runner",
        "peekOfCode": "TResult = TypeVar(\"TResult\", covariant=True)\n@final\n@attr.s(repr=False, init=False, auto_attribs=True)\nclass CallInfo(Generic[TResult]):\n    \"\"\"Result/Exception info of a function invocation.\"\"\"\n    _result: Optional[TResult]\n    #: The captured exception of the call, if it raised.\n    excinfo: Optional[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float",
        "detail": "__pypackages__.3.10.lib._pytest.runner",
        "documentation": {}
    },
    {
        "label": "Scope",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.scope",
        "description": "__pypackages__.3.10.lib._pytest.scope",
        "peekOfCode": "class Scope(Enum):\n    \"\"\"\n    Represents one of the possible fixture scopes in pytest.\n    Scopes are ordered from lower to higher, that is:\n              ->>> higher ->>>\n    Function < Class < Module < Package < Session\n              <<<- lower  <<<-\n    \"\"\"\n    # Scopes need to be listed from lower to higher.\n    Function: \"_ScopeName\" = \"function\"",
        "detail": "__pypackages__.3.10.lib._pytest.scope",
        "documentation": {}
    },
    {
        "label": "_ALL_SCOPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.scope",
        "description": "__pypackages__.3.10.lib._pytest.scope",
        "peekOfCode": "_ALL_SCOPES = list(Scope)\n_SCOPE_INDICES = {scope: index for index, scope in enumerate(_ALL_SCOPES)}\n# Ordered list of scopes which can contain many tests (in practice all except Function).\nHIGH_SCOPES = [x for x in Scope if x is not Scope.Function]",
        "detail": "__pypackages__.3.10.lib._pytest.scope",
        "documentation": {}
    },
    {
        "label": "_SCOPE_INDICES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.scope",
        "description": "__pypackages__.3.10.lib._pytest.scope",
        "peekOfCode": "_SCOPE_INDICES = {scope: index for index, scope in enumerate(_ALL_SCOPES)}\n# Ordered list of scopes which can contain many tests (in practice all except Function).\nHIGH_SCOPES = [x for x in Scope if x is not Scope.Function]",
        "detail": "__pypackages__.3.10.lib._pytest.scope",
        "documentation": {}
    },
    {
        "label": "HIGH_SCOPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.scope",
        "description": "__pypackages__.3.10.lib._pytest.scope",
        "peekOfCode": "HIGH_SCOPES = [x for x in Scope if x is not Scope.Function]",
        "detail": "__pypackages__.3.10.lib._pytest.scope",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setuponly",
        "description": "__pypackages__.3.10.lib._pytest.setuponly",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--setuponly\",\n        \"--setup-only\",\n        action=\"store_true\",\n        help=\"Only setup fixtures, do not execute tests\",\n    )\n    group.addoption(\n        \"--setupshow\",",
        "detail": "__pypackages__.3.10.lib._pytest.setuponly",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setuponly",
        "description": "__pypackages__.3.10.lib._pytest.setuponly",
        "peekOfCode": "def pytest_fixture_setup(\n    fixturedef: FixtureDef[object], request: SubRequest\n) -> Generator[None, None, None]:\n    yield\n    if request.config.option.setupshow:\n        if hasattr(request, \"param\"):\n            # Save the fixture parameter so ._show_fixture_action() can\n            # display it now and during the teardown (in .finish()).\n            if fixturedef.ids:\n                if callable(fixturedef.ids):",
        "detail": "__pypackages__.3.10.lib._pytest.setuponly",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_post_finalizer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setuponly",
        "description": "__pypackages__.3.10.lib._pytest.setuponly",
        "peekOfCode": "def pytest_fixture_post_finalizer(fixturedef: FixtureDef[object]) -> None:\n    if fixturedef.cached_result is not None:\n        config = fixturedef._fixturemanager.config\n        if config.option.setupshow:\n            _show_fixture_action(fixturedef, \"TEARDOWN\")\n            if hasattr(fixturedef, \"cached_param\"):\n                del fixturedef.cached_param  # type: ignore[attr-defined]\ndef _show_fixture_action(fixturedef: FixtureDef[object], msg: str) -> None:\n    config = fixturedef._fixturemanager.config\n    capman = config.pluginmanager.getplugin(\"capturemanager\")",
        "detail": "__pypackages__.3.10.lib._pytest.setuponly",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setuponly",
        "description": "__pypackages__.3.10.lib._pytest.setuponly",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    if config.option.setuponly:\n        config.option.setupshow = True\n    return None",
        "detail": "__pypackages__.3.10.lib._pytest.setuponly",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setupplan",
        "description": "__pypackages__.3.10.lib._pytest.setupplan",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--setupplan\",\n        \"--setup-plan\",\n        action=\"store_true\",\n        help=\"Show what fixtures and tests would be executed but \"\n        \"don't execute anything\",\n    )\n@pytest.hookimpl(tryfirst=True)",
        "detail": "__pypackages__.3.10.lib._pytest.setupplan",
        "documentation": {}
    },
    {
        "label": "pytest_fixture_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setupplan",
        "description": "__pypackages__.3.10.lib._pytest.setupplan",
        "peekOfCode": "def pytest_fixture_setup(\n    fixturedef: FixtureDef[object], request: SubRequest\n) -> Optional[object]:\n    # Will return a dummy fixture if the setuponly option is provided.\n    if request.config.option.setupplan:\n        my_cache_key = fixturedef.cache_key(request)\n        fixturedef.cached_result = (None, my_cache_key, None)\n        return fixturedef.cached_result\n    return None\n@pytest.hookimpl(tryfirst=True)",
        "detail": "__pypackages__.3.10.lib._pytest.setupplan",
        "documentation": {}
    },
    {
        "label": "pytest_cmdline_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.setupplan",
        "description": "__pypackages__.3.10.lib._pytest.setupplan",
        "peekOfCode": "def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    if config.option.setupplan:\n        config.option.setuponly = True\n        config.option.setupshow = True\n    return None",
        "detail": "__pypackages__.3.10.lib._pytest.setupplan",
        "documentation": {}
    },
    {
        "label": "Skip",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "class Skip:\n    \"\"\"The result of evaluate_skip_marks().\"\"\"\n    reason: str = \"unconditional skip\"\ndef evaluate_skip_marks(item: Item) -> Optional[Skip]:\n    \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"skipif\"):\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "Xfail",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "class Xfail:\n    \"\"\"The result of evaluate_xfail_marks().\"\"\"\n    reason: str\n    run: bool\n    strict: bool\n    raises: Optional[Tuple[Type[BaseException], ...]]\ndef evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"Report the results of xfail tests as if they were not marked\",\n    )\n    parser.addini(",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n        old = pytest.xfail\n        config.add_cleanup(lambda: setattr(pytest, \"xfail\", old))\n        def nop(*args, **kwargs):\n            pass\n        nop.Exception = xfail.Exception  # type: ignore[attr-defined]\n        setattr(pytest, \"xfail\", nop)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "evaluate_condition",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def evaluate_condition(item: Item, mark: Mark, condition: object) -> Tuple[bool, str]:\n    \"\"\"Evaluate a single skipif/xfail condition.\n    If an old-style string condition is given, it is eval()'d, otherwise the\n    condition is bool()'d. If this fails, an appropriately formatted pytest.fail\n    is raised.\n    Returns (result, reason). The reason is only relevant if the result is True.\n    \"\"\"\n    # String condition.\n    if isinstance(condition, str):\n        globals_ = {",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "evaluate_skip_marks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def evaluate_skip_marks(item: Item) -> Optional[Skip]:\n    \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"skipif\"):\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "evaluate_xfail_marks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_runtest_setup(item: Item) -> None:\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        raise skip.Exception(skipped.reason, _use_item_location=True)\n    item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n    if xfailed and not item.config.option.runxfail and not xfailed.run:\n        xfail(\"[NOTRUN] \" + xfailed.reason)\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item.stash.get(xfailed_key, None)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item.stash.get(xfailed_key, None)\n    if xfailed is None:\n        item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n    if xfailed and not item.config.option.runxfail and not xfailed.run:\n        xfail(\"[NOTRUN] \" + xfailed.reason)\n    yield\n    # The test run may have added an xfail mark dynamically.\n    xfailed = item.stash.get(xfailed_key, None)\n    if xfailed is None:",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_makereport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item.stash.get(xfailed_key, None)\n    if item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "pytest_report_teststatus",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped:\n            return \"xfailed\", \"x\", \"XFAIL\"\n        elif report.passed:\n            return \"xpassed\", \"X\", \"XPASS\"\n    return None",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "xfailed_key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.skipping",
        "description": "__pypackages__.3.10.lib._pytest.skipping",
        "peekOfCode": "xfailed_key = StashKey[Optional[Xfail]]()\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        raise skip.Exception(skipped.reason, _use_item_location=True)\n    item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n    if xfailed and not item.config.option.runxfail and not xfailed.run:\n        xfail(\"[NOTRUN] \" + xfailed.reason)\n@hookimpl(hookwrapper=True)",
        "detail": "__pypackages__.3.10.lib._pytest.skipping",
        "documentation": {}
    },
    {
        "label": "StashKey",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.stash",
        "description": "__pypackages__.3.10.lib._pytest.stash",
        "peekOfCode": "class StashKey(Generic[T]):\n    \"\"\"``StashKey`` is an object used as a key to a :class:`Stash`.\n    A ``StashKey`` is associated with the type ``T`` of the value of the key.\n    A ``StashKey`` is unique and cannot conflict with another key.\n    \"\"\"\n    __slots__ = ()\nclass Stash:\n    r\"\"\"``Stash`` is a type-safe heterogeneous mutable mapping that\n    allows keys and value types to be defined separately from\n    where it (the ``Stash``) is created.",
        "detail": "__pypackages__.3.10.lib._pytest.stash",
        "documentation": {}
    },
    {
        "label": "Stash",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.stash",
        "description": "__pypackages__.3.10.lib._pytest.stash",
        "peekOfCode": "class Stash:\n    r\"\"\"``Stash`` is a type-safe heterogeneous mutable mapping that\n    allows keys and value types to be defined separately from\n    where it (the ``Stash``) is created.\n    Usually you will be given an object which has a ``Stash``, for example\n    :class:`~pytest.Config` or a :class:`~_pytest.nodes.Node`:\n    .. code-block:: python\n        stash: Stash = some_object.stash\n    If a module or plugin wants to store data in this ``Stash``, it creates\n    :class:`StashKey`\\s for its keys (at the module level):",
        "detail": "__pypackages__.3.10.lib._pytest.stash",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.stash",
        "description": "__pypackages__.3.10.lib._pytest.stash",
        "peekOfCode": "__all__ = [\"Stash\", \"StashKey\"]\nT = TypeVar(\"T\")\nD = TypeVar(\"D\")\nclass StashKey(Generic[T]):\n    \"\"\"``StashKey`` is an object used as a key to a :class:`Stash`.\n    A ``StashKey`` is associated with the type ``T`` of the value of the key.\n    A ``StashKey`` is unique and cannot conflict with another key.\n    \"\"\"\n    __slots__ = ()\nclass Stash:",
        "detail": "__pypackages__.3.10.lib._pytest.stash",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.stash",
        "description": "__pypackages__.3.10.lib._pytest.stash",
        "peekOfCode": "T = TypeVar(\"T\")\nD = TypeVar(\"D\")\nclass StashKey(Generic[T]):\n    \"\"\"``StashKey`` is an object used as a key to a :class:`Stash`.\n    A ``StashKey`` is associated with the type ``T`` of the value of the key.\n    A ``StashKey`` is unique and cannot conflict with another key.\n    \"\"\"\n    __slots__ = ()\nclass Stash:\n    r\"\"\"``Stash`` is a type-safe heterogeneous mutable mapping that",
        "detail": "__pypackages__.3.10.lib._pytest.stash",
        "documentation": {}
    },
    {
        "label": "D",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.stash",
        "description": "__pypackages__.3.10.lib._pytest.stash",
        "peekOfCode": "D = TypeVar(\"D\")\nclass StashKey(Generic[T]):\n    \"\"\"``StashKey`` is an object used as a key to a :class:`Stash`.\n    A ``StashKey`` is associated with the type ``T`` of the value of the key.\n    A ``StashKey`` is unique and cannot conflict with another key.\n    \"\"\"\n    __slots__ = ()\nclass Stash:\n    r\"\"\"``Stash`` is a type-safe heterogeneous mutable mapping that\n    allows keys and value types to be defined separately from",
        "detail": "__pypackages__.3.10.lib._pytest.stash",
        "documentation": {}
    },
    {
        "label": "StepwisePlugin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.stepwise",
        "description": "__pypackages__.3.10.lib._pytest.stepwise",
        "peekOfCode": "class StepwisePlugin:\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.session: Optional[Session] = None\n        self.report_status = \"\"\n        assert config.cache is not None\n        self.cache: Cache = config.cache\n        self.lastfailed: Optional[str] = self.cache.get(STEPWISE_CACHE_DIR, None)\n        self.skip: bool = config.getoption(\"stepwise_skip\")\n    def pytest_sessionstart(self, session: Session) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.stepwise",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.stepwise",
        "description": "__pypackages__.3.10.lib._pytest.stepwise",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--sw\",\n        \"--stepwise\",\n        action=\"store_true\",\n        default=False,\n        dest=\"stepwise\",\n        help=\"Exit on test failure and continue from last failing test next time\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.stepwise",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.stepwise",
        "description": "__pypackages__.3.10.lib._pytest.stepwise",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    if config.option.stepwise_skip:\n        # allow --stepwise-skip to work on it's own merits.\n        config.option.stepwise = True\n    if config.getoption(\"stepwise\"):\n        config.pluginmanager.register(StepwisePlugin(config), \"stepwiseplugin\")\ndef pytest_sessionfinish(session: Session) -> None:\n    if not session.config.getoption(\"stepwise\"):\n        assert session.config.cache is not None\n        if hasattr(session.config, \"workerinput\"):",
        "detail": "__pypackages__.3.10.lib._pytest.stepwise",
        "documentation": {}
    },
    {
        "label": "pytest_sessionfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.stepwise",
        "description": "__pypackages__.3.10.lib._pytest.stepwise",
        "peekOfCode": "def pytest_sessionfinish(session: Session) -> None:\n    if not session.config.getoption(\"stepwise\"):\n        assert session.config.cache is not None\n        if hasattr(session.config, \"workerinput\"):\n            # Do not update cache if this process is a xdist worker to prevent\n            # race conditions (#10641).\n            return\n        # Clear the list of failing tests if the plugin is not active.\n        session.config.cache.set(STEPWISE_CACHE_DIR, [])\nclass StepwisePlugin:",
        "detail": "__pypackages__.3.10.lib._pytest.stepwise",
        "documentation": {}
    },
    {
        "label": "STEPWISE_CACHE_DIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.stepwise",
        "description": "__pypackages__.3.10.lib._pytest.stepwise",
        "peekOfCode": "STEPWISE_CACHE_DIR = \"cache/stepwise\"\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--sw\",\n        \"--stepwise\",\n        action=\"store_true\",\n        default=False,\n        dest=\"stepwise\",\n        help=\"Exit on test failure and continue from last failing test next time\",",
        "detail": "__pypackages__.3.10.lib._pytest.stepwise",
        "documentation": {}
    },
    {
        "label": "MoreQuietAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "class MoreQuietAction(argparse.Action):\n    \"\"\"A modified copy of the argparse count action which counts down and updates\n    the legacy quiet attribute at the same time.\n    Used to unify verbosity handling.\n    \"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        default: object = None,",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "WarningReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "class WarningReport:\n    \"\"\"Simple structure to hold warnings information captured by ``pytest_warning_recorded``.\n    :ivar str message:\n        User friendly message about the warning.\n    :ivar str|None nodeid:\n        nodeid that generated the warning (see ``get_location``).\n    :ivar tuple fslocation:\n        File system location of the source of the warning (see ``get_location``).\n    \"\"\"\n    message: str",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "TerminalReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "class TerminalReporter:\n    def __init__(self, config: Config, file: Optional[TextIO] = None) -> None:\n        import _pytest.config\n        self.config = config\n        self._numcollected = 0\n        self._session: Optional[Session] = None\n        self._showfspath: Optional[bool] = None\n        self.stats: Dict[str, List[Any]] = {}\n        self._main_color: Optional[str] = None\n        self._known_types: Optional[List[str]] = None",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"terminal reporting\", \"Reporting\", after=\"general\")\n    group._addoption(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        default=0,\n        dest=\"verbose\",\n        help=\"Increase verbosity\",\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    reporter = TerminalReporter(config, sys.stdout)\n    config.pluginmanager.register(reporter, \"terminalreporter\")\n    if config.option.debug or config.option.traceconfig:\n        def mywriter(tags, args):\n            msg = \" \".join(map(str, args))\n            reporter.write_line(\"[traceconfig] \" + msg)\n        config.trace.root.setprocessor(\"pytest:config\", mywriter)\ndef getreportopt(config: Config) -> str:\n    reportchars: str = config.option.reportchars",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "getreportopt",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def getreportopt(config: Config) -> str:\n    reportchars: str = config.option.reportchars\n    old_aliases = {\"F\", \"S\"}\n    reportopts = \"\"\n    for char in reportchars:\n        if char in old_aliases:\n            char = char.lower()\n        if char == \"a\":\n            reportopts = \"sxXEf\"\n        elif char == \"A\":",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "pytest_report_teststatus",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def pytest_report_teststatus(report: BaseReport) -> Tuple[str, str, str]:\n    letter = \"F\"\n    if report.passed:\n        letter = \".\"\n    elif report.skipped:\n        letter = \"s\"\n    outcome: str = report.outcome\n    if report.when in (\"collect\", \"setup\", \"teardown\") and outcome == \"failed\":\n        outcome = \"error\"\n        letter = \"E\"",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "pluralize",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n    return count, noun + \"s\" if count != 1 else noun\ndef _plugin_nameversions(plugininfo) -> List[str]:",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "format_session_duration",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\"\ndef _get_raw_skip_reason(report: TestReport) -> str:\n    \"\"\"Get the reason string of a skip/xfail/xpass test report.\n    The string is just the part given by the user.",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "REPORT_COLLECTING_RESOLUTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "REPORT_COLLECTING_RESOLUTION = 0.5\nKNOWN_TYPES = (\n    \"failed\",\n    \"passed\",\n    \"skipped\",\n    \"deselected\",\n    \"xfailed\",\n    \"xpassed\",\n    \"warnings\",\n    \"error\",",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "KNOWN_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "KNOWN_TYPES = (\n    \"failed\",\n    \"passed\",\n    \"skipped\",\n    \"deselected\",\n    \"xfailed\",\n    \"xpassed\",\n    \"warnings\",\n    \"error\",\n)",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "_REPORTCHARS_DEFAULT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "_REPORTCHARS_DEFAULT = \"fE\"\nclass MoreQuietAction(argparse.Action):\n    \"\"\"A modified copy of the argparse count action which counts down and updates\n    the legacy quiet attribute at the same time.\n    Used to unify verbosity handling.\n    \"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "_color_for_type",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "_color_for_type = {\n    \"failed\": \"red\",\n    \"error\": \"red\",\n    \"warnings\": \"yellow\",\n    \"passed\": \"green\",\n}\n_color_for_type_default = \"yellow\"\ndef pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "_color_for_type_default",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.terminal",
        "description": "__pypackages__.3.10.lib._pytest.terminal",
        "peekOfCode": "_color_for_type_default = \"yellow\"\ndef pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n    return count, noun + \"s\" if count != 1 else noun",
        "detail": "__pypackages__.3.10.lib._pytest.terminal",
        "documentation": {}
    },
    {
        "label": "catch_threading_exception",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.threadexception",
        "description": "__pypackages__.3.10.lib._pytest.threadexception",
        "peekOfCode": "class catch_threading_exception:\n    \"\"\"Context manager catching threading.Thread exception using\n    threading.excepthook.\n    Storing exc_value using a custom hook can create a reference cycle. The\n    reference cycle is broken explicitly when the context manager exits.\n    Storing thread using a custom hook can resurrect it if it is set to an\n    object which is being finalized. Exiting the context manager clears the\n    stored object.\n    Usage:\n        with threading_helper.catch_threading_exception() as cm:",
        "detail": "__pypackages__.3.10.lib._pytest.threadexception",
        "documentation": {}
    },
    {
        "label": "thread_exception_runtest_hook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.threadexception",
        "description": "__pypackages__.3.10.lib._pytest.threadexception",
        "peekOfCode": "def thread_exception_runtest_hook() -> Generator[None, None, None]:\n    with catch_threading_exception() as cm:\n        yield\n        if cm.args:\n            thread_name = \"<unknown>\" if cm.args.thread is None else cm.args.thread.name\n            msg = f\"Exception in thread {thread_name}\\n\\n\"\n            msg += \"\".join(\n                traceback.format_exception(\n                    cm.args.exc_type,\n                    cm.args.exc_value,",
        "detail": "__pypackages__.3.10.lib._pytest.threadexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.threadexception",
        "description": "__pypackages__.3.10.lib._pytest.threadexception",
        "peekOfCode": "def pytest_runtest_setup() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_call() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.threadexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.threadexception",
        "description": "__pypackages__.3.10.lib._pytest.threadexception",
        "peekOfCode": "def pytest_runtest_call() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.threadexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_teardown",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.threadexception",
        "description": "__pypackages__.3.10.lib._pytest.threadexception",
        "peekOfCode": "def pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from thread_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.threadexception",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.timing",
        "description": "__pypackages__.3.10.lib._pytest.timing",
        "peekOfCode": "__all__ = [\"perf_counter\", \"sleep\", \"time\"]",
        "detail": "__pypackages__.3.10.lib._pytest.timing",
        "documentation": {}
    },
    {
        "label": "TempPathFactory",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.tmpdir",
        "description": "__pypackages__.3.10.lib._pytest.tmpdir",
        "peekOfCode": "class TempPathFactory:\n    \"\"\"Factory for temporary directories under the common base temp directory.\n    The base directory can be configured using the ``--basetemp`` option.\n    \"\"\"\n    _given_basetemp = attr.ib(type=Optional[Path])\n    _trace = attr.ib()\n    _basetemp = attr.ib(type=Optional[Path])\n    def __init__(\n        self,\n        given_basetemp: Optional[Path],",
        "detail": "__pypackages__.3.10.lib._pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "get_user",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.tmpdir",
        "description": "__pypackages__.3.10.lib._pytest.tmpdir",
        "peekOfCode": "def get_user() -> Optional[str]:\n    \"\"\"Return the current user name, or None if getuser() does not work\n    in the current environment (see #1010).\"\"\"\n    try:\n        # In some exotic environments, getpass may not be importable.\n        import getpass\n        return getpass.getuser()\n    except (ImportError, KeyError):\n        return None\ndef pytest_configure(config: Config) -> None:",
        "detail": "__pypackages__.3.10.lib._pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.tmpdir",
        "description": "__pypackages__.3.10.lib._pytest.tmpdir",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    \"\"\"Create a TempPathFactory and attach it to the config object.\n    This is to comply with existing plugins which expect the handler to be\n    available at pytest_configure time, but ideally should be moved entirely\n    to the tmp_path_factory session fixture.\n    \"\"\"\n    mp = MonkeyPatch()\n    config.add_cleanup(mp.undo)\n    _tmp_path_factory = TempPathFactory.from_config(config, _ispytest=True)\n    mp.setattr(config, \"_tmp_path_factory\", _tmp_path_factory, raising=False)",
        "detail": "__pypackages__.3.10.lib._pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "tmp_path_factory",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.tmpdir",
        "description": "__pypackages__.3.10.lib._pytest.tmpdir",
        "peekOfCode": "def tmp_path_factory(request: FixtureRequest) -> TempPathFactory:\n    \"\"\"Return a :class:`pytest.TempPathFactory` instance for the test session.\"\"\"\n    # Set dynamically by pytest_configure() above.\n    return request.config._tmp_path_factory  # type: ignore\ndef _mk_tmp(request: FixtureRequest, factory: TempPathFactory) -> Path:\n    name = request.node.name\n    name = re.sub(r\"[\\W]\", \"_\", name)\n    MAXVAL = 30\n    name = name[:MAXVAL]\n    return factory.mktemp(name, numbered=True)",
        "detail": "__pypackages__.3.10.lib._pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "tmp_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.tmpdir",
        "description": "__pypackages__.3.10.lib._pytest.tmpdir",
        "peekOfCode": "def tmp_path(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Path:\n    \"\"\"Return a temporary directory path object which is unique to each test\n    function invocation, created as a sub directory of the base temporary\n    directory.\n    By default, a new base temporary directory is created each test session,\n    and old bases are removed after 3 sessions, to aid in debugging. If\n    ``--basetemp`` is used then it is cleared each session. See :ref:`base\n    temporary directory`.\n    The returned object is a :class:`pathlib.Path` object.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.tmpdir",
        "documentation": {}
    },
    {
        "label": "UnitTestCase",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "class UnitTestCase(Class):\n    # Marker for fixturemanger.getfixtureinfo()\n    # to declare that our children do not support funcargs.\n    nofuncargs = True\n    def collect(self) -> Iterable[Union[Item, Collector]]:\n        from unittest import TestLoader\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n        skipped = _is_skipped(cls)",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "TestCaseFunction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "class TestCaseFunction(Function):\n    nofuncargs = True\n    _excinfo: Optional[List[_pytest._code.ExceptionInfo[BaseException]]] = None\n    _testcase: Optional[\"unittest.TestCase\"] = None\n    def _getobj(self):\n        assert self.parent is not None\n        # Unlike a regular Function in a Class, where `item.obj` returns\n        # a *bound* method (attached to an instance), TestCaseFunction's\n        # `obj` returns an *unbound* method (not attached to an instance).\n        # This inconsistency is probably not desirable, but needs some",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "pytest_pycollect_makeitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "def pytest_pycollect_makeitem(\n    collector: Union[Module, Class], name: str, obj: object\n) -> Optional[\"UnitTestCase\"]:\n    # Has unittest been imported and is obj a subclass of its TestCase?\n    try:\n        ut = sys.modules[\"unittest\"]\n        # Type ignored because `ut` is an opaque module.\n        if not issubclass(obj, ut.TestCase):  # type: ignore\n            return None\n    except Exception:",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_makereport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    if isinstance(item, TestCaseFunction):\n        if item._excinfo:\n            call.excinfo = item._excinfo.pop(0)\n            try:\n                del call.result\n            except AttributeError:\n                pass\n    # Convert unittest.SkipTest to pytest.skip.\n    # This is actually only needed for nose, which reuses unittest.SkipTest for",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    if isinstance(item, TestCaseFunction) and \"twisted.trial.unittest\" in sys.modules:\n        ut: Any = sys.modules[\"twisted.python.failure\"]\n        Failure__init__ = ut.Failure.__init__\n        check_testcase_implements_trial_reporter()\n        def excstore(\n            self, exc_value=None, exc_type=None, exc_tb=None, captureVars=None\n        ):\n            if exc_value is None:\n                self._rawexcinfo = sys.exc_info()",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "check_testcase_implements_trial_reporter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unittest",
        "description": "__pypackages__.3.10.lib._pytest.unittest",
        "peekOfCode": "def check_testcase_implements_trial_reporter(done: List[int] = []) -> None:\n    if done:\n        return\n    from zope.interface import classImplements\n    from twisted.trial.itrial import IReporter\n    classImplements(TestCaseFunction, IReporter)\n    done.append(1)\ndef _is_skipped(obj) -> bool:\n    \"\"\"Return True if the given object has been marked with @unittest.skip.\"\"\"\n    return bool(getattr(obj, \"__unittest_skip__\", False))",
        "detail": "__pypackages__.3.10.lib._pytest.unittest",
        "documentation": {}
    },
    {
        "label": "catch_unraisable_exception",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "description": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "peekOfCode": "class catch_unraisable_exception:\n    \"\"\"Context manager catching unraisable exception using sys.unraisablehook.\n    Storing the exception value (cm.unraisable.exc_value) creates a reference\n    cycle. The reference cycle is broken explicitly when the context manager\n    exits.\n    Storing the object (cm.unraisable.object) can resurrect it if it is set to\n    an object which is being finalized. Exiting the context manager clears the\n    stored object.\n    Usage:\n        with catch_unraisable_exception() as cm:",
        "detail": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "documentation": {}
    },
    {
        "label": "unraisable_exception_runtest_hook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "description": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "peekOfCode": "def unraisable_exception_runtest_hook() -> Generator[None, None, None]:\n    with catch_unraisable_exception() as cm:\n        yield\n        if cm.unraisable:\n            if cm.unraisable.err_msg is not None:\n                err_msg = cm.unraisable.err_msg\n            else:\n                err_msg = \"Exception ignored in\"\n            msg = f\"{err_msg}: {cm.unraisable.object!r}\\n\\n\"\n            msg += \"\".join(",
        "detail": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "description": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "peekOfCode": "def pytest_runtest_setup() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_call() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "description": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "peekOfCode": "def pytest_runtest_call() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_teardown",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "description": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "peekOfCode": "def pytest_runtest_teardown() -> Generator[None, None, None]:\n    yield from unraisable_exception_runtest_hook()",
        "detail": "__pypackages__.3.10.lib._pytest.unraisableexception",
        "documentation": {}
    },
    {
        "label": "PytestWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestWarning(UserWarning):\n    \"\"\"Base class for all warnings emitted by pytest.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestAssertRewriteWarning(PytestWarning):\n    \"\"\"Warning emitted by the pytest assert rewrite module.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestCacheWarning(PytestWarning):\n    \"\"\"Warning emitted by the cache plugin in various situations.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestAssertRewriteWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestAssertRewriteWarning(PytestWarning):\n    \"\"\"Warning emitted by the pytest assert rewrite module.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestCacheWarning(PytestWarning):\n    \"\"\"Warning emitted by the cache plugin in various situations.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestConfigWarning(PytestWarning):\n    \"\"\"Warning emitted for configuration issues.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestCacheWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestCacheWarning(PytestWarning):\n    \"\"\"Warning emitted by the cache plugin in various situations.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestConfigWarning(PytestWarning):\n    \"\"\"Warning emitted for configuration issues.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestCollectionWarning(PytestWarning):\n    \"\"\"Warning emitted when pytest is not able to collect a file or symbol in a module.\"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestConfigWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestConfigWarning(PytestWarning):\n    \"\"\"Warning emitted for configuration issues.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestCollectionWarning(PytestWarning):\n    \"\"\"Warning emitted when pytest is not able to collect a file or symbol in a module.\"\"\"\n    __module__ = \"pytest\"\nclass PytestDeprecationWarning(PytestWarning, DeprecationWarning):\n    \"\"\"Warning class for features that will be removed in a future version.\"\"\"\n    __module__ = \"pytest\"",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestCollectionWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestCollectionWarning(PytestWarning):\n    \"\"\"Warning emitted when pytest is not able to collect a file or symbol in a module.\"\"\"\n    __module__ = \"pytest\"\nclass PytestDeprecationWarning(PytestWarning, DeprecationWarning):\n    \"\"\"Warning class for features that will be removed in a future version.\"\"\"\n    __module__ = \"pytest\"\nclass PytestRemovedIn8Warning(PytestDeprecationWarning):\n    \"\"\"Warning class for features that will be removed in pytest 8.\"\"\"\n    __module__ = \"pytest\"\nclass PytestReturnNotNoneWarning(PytestRemovedIn8Warning):",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestDeprecationWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestDeprecationWarning(PytestWarning, DeprecationWarning):\n    \"\"\"Warning class for features that will be removed in a future version.\"\"\"\n    __module__ = \"pytest\"\nclass PytestRemovedIn8Warning(PytestDeprecationWarning):\n    \"\"\"Warning class for features that will be removed in pytest 8.\"\"\"\n    __module__ = \"pytest\"\nclass PytestReturnNotNoneWarning(PytestRemovedIn8Warning):\n    \"\"\"Warning emitted when a test function is returning value other than None.\"\"\"\n    __module__ = \"pytest\"\n@final",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestRemovedIn8Warning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestRemovedIn8Warning(PytestDeprecationWarning):\n    \"\"\"Warning class for features that will be removed in pytest 8.\"\"\"\n    __module__ = \"pytest\"\nclass PytestReturnNotNoneWarning(PytestRemovedIn8Warning):\n    \"\"\"Warning emitted when a test function is returning value other than None.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestExperimentalApiWarning(PytestWarning, FutureWarning):\n    \"\"\"Warning category used to denote experiments in pytest.\n    Use sparingly as the API might change or even be removed completely in a",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestReturnNotNoneWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestReturnNotNoneWarning(PytestRemovedIn8Warning):\n    \"\"\"Warning emitted when a test function is returning value other than None.\"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestExperimentalApiWarning(PytestWarning, FutureWarning):\n    \"\"\"Warning category used to denote experiments in pytest.\n    Use sparingly as the API might change or even be removed completely in a\n    future version.\n    \"\"\"\n    __module__ = \"pytest\"",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestExperimentalApiWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestExperimentalApiWarning(PytestWarning, FutureWarning):\n    \"\"\"Warning category used to denote experiments in pytest.\n    Use sparingly as the API might change or even be removed completely in a\n    future version.\n    \"\"\"\n    __module__ = \"pytest\"\n    @classmethod\n    def simple(cls, apiname: str) -> \"PytestExperimentalApiWarning\":\n        return cls(\n            \"{apiname} is an experimental api that may change over time\".format(",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestUnhandledCoroutineWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestUnhandledCoroutineWarning(PytestReturnNotNoneWarning):\n    \"\"\"Warning emitted for an unhandled coroutine.\n    A coroutine was encountered when collecting test functions, but was not\n    handled by any async-aware plugin.\n    Coroutine test functions are not natively supported.\n    \"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestUnknownMarkWarning(PytestWarning):\n    \"\"\"Warning emitted on use of unknown markers.",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestUnknownMarkWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestUnknownMarkWarning(PytestWarning):\n    \"\"\"Warning emitted on use of unknown markers.\n    See :ref:`mark` for details.\n    \"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestUnraisableExceptionWarning(PytestWarning):\n    \"\"\"An unraisable exception was reported.\n    Unraisable exceptions are exceptions raised in :meth:`__del__ <object.__del__>`\n    implementations and similar situations when the exception cannot be raised",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestUnraisableExceptionWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestUnraisableExceptionWarning(PytestWarning):\n    \"\"\"An unraisable exception was reported.\n    Unraisable exceptions are exceptions raised in :meth:`__del__ <object.__del__>`\n    implementations and similar situations when the exception cannot be raised\n    as normal.\n    \"\"\"\n    __module__ = \"pytest\"\n@final\nclass PytestUnhandledThreadExceptionWarning(PytestWarning):\n    \"\"\"An unhandled exception occurred in a :class:`~threading.Thread`.",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "PytestUnhandledThreadExceptionWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class PytestUnhandledThreadExceptionWarning(PytestWarning):\n    \"\"\"An unhandled exception occurred in a :class:`~threading.Thread`.\n    Such exceptions don't propagate normally.\n    \"\"\"\n    __module__ = \"pytest\"\n_W = TypeVar(\"_W\", bound=PytestWarning)\n@final\n@attr.s(auto_attribs=True)\nclass UnformattedWarning(Generic[_W]):\n    \"\"\"A warning meant to be formatted during runtime.",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "UnformattedWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "class UnformattedWarning(Generic[_W]):\n    \"\"\"A warning meant to be formatted during runtime.\n    This is used to hold warnings that need to format their message at runtime,\n    as opposed to a direct message.\n    \"\"\"\n    category: Type[\"_W\"]\n    template: str\n    def format(self, **kwargs: Any) -> _W:\n        \"\"\"Return an instance of the warning category, formatted with given kwargs.\"\"\"\n        return self.category(self.template.format(**kwargs))",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "warn_explicit_for",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "def warn_explicit_for(method: FunctionType, message: PytestWarning) -> None:\n    \"\"\"\n    Issue the warning :param:`message` for the definition of the given :param:`method`\n    this helps to log warnigns for functions defined prior to finding an issue with them\n    (like hook wrappers being marked in a legacy mechanism)\n    \"\"\"\n    lineno = method.__code__.co_firstlineno\n    filename = inspect.getfile(method)\n    module = method.__module__\n    mod_globals = method.__globals__",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "_W",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib._pytest.warning_types",
        "description": "__pypackages__.3.10.lib._pytest.warning_types",
        "peekOfCode": "_W = TypeVar(\"_W\", bound=PytestWarning)\n@final\n@attr.s(auto_attribs=True)\nclass UnformattedWarning(Generic[_W]):\n    \"\"\"A warning meant to be formatted during runtime.\n    This is used to hold warnings that need to format their message at runtime,\n    as opposed to a direct message.\n    \"\"\"\n    category: Type[\"_W\"]\n    template: str",
        "detail": "__pypackages__.3.10.lib._pytest.warning_types",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"filterwarnings(warning): add a warning filter to the given test. \"\n        \"see https://docs.pytest.org/en/stable/how-to/capture-warnings.html#pytest-mark-filterwarnings \",\n    )\n@contextmanager\ndef catch_warnings_for_item(\n    config: Config,\n    ihook,",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "catch_warnings_for_item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def catch_warnings_for_item(\n    config: Config,\n    ihook,\n    when: \"Literal['config', 'collect', 'runtest']\",\n    item: Optional[Item],\n) -> Generator[None, None, None]:\n    \"\"\"Context manager that catches warnings generated in the contained execution block.\n    ``item`` can be None if we are not in the context of an item execution.\n    Each warning captured triggers the ``pytest_warning_recorded`` hook.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "warning_record_to_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def warning_record_to_str(warning_message: warnings.WarningMessage) -> str:\n    \"\"\"Convert a warnings.WarningMessage to a string.\"\"\"\n    warn_msg = warning_message.message\n    msg = warnings.formatwarning(\n        str(warn_msg),\n        warning_message.category,\n        warning_message.filename,\n        warning_message.lineno,\n        warning_message.line,\n    )",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    with catch_warnings_for_item(\n        config=item.config, ihook=item.ihook, when=\"runtest\", item=item\n    ):\n        yield\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_collection(session: Session) -> Generator[None, None, None]:\n    config = session.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"collect\", item=None",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "pytest_collection",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_collection(session: Session) -> Generator[None, None, None]:\n    config = session.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"collect\", item=None\n    ):\n        yield\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_terminal_summary(\n    terminalreporter: TerminalReporter,\n) -> Generator[None, None, None]:",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "pytest_terminal_summary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_terminal_summary(\n    terminalreporter: TerminalReporter,\n) -> Generator[None, None, None]:\n    config = terminalreporter.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"config\", item=None\n    ):\n        yield\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_sessionfinish(session: Session) -> Generator[None, None, None]:",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "pytest_sessionfinish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_sessionfinish(session: Session) -> Generator[None, None, None]:\n    config = session.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"config\", item=None\n    ):\n        yield\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_load_initial_conftests(\n    early_config: \"Config\",\n) -> Generator[None, None, None]:",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "pytest_load_initial_conftests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib._pytest.warnings",
        "description": "__pypackages__.3.10.lib._pytest.warnings",
        "peekOfCode": "def pytest_load_initial_conftests(\n    early_config: \"Config\",\n) -> Generator[None, None, None]:\n    with catch_warnings_for_item(\n        config=early_config, ihook=early_config.hook, when=\"config\", item=None\n    ):\n        yield",
        "detail": "__pypackages__.3.10.lib._pytest.warnings",
        "documentation": {}
    },
    {
        "label": "infer_namespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_argparse",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_argparse",
        "peekOfCode": "def infer_namespace(node, context: InferenceContext | None = None):\n    callsite = arguments.CallSite.from_call(node, context=context)\n    if not callsite.keyword_arguments:\n        # Cannot make sense of it.\n        raise UseInferenceDefault()\n    class_node = nodes.ClassDef(\"Namespace\")\n    # Set parent manually until ClassDef constructor fixed:\n    # https://github.com/PyCQA/astroid/issues/1490\n    class_node.parent = node.parent\n    for attr in set(callsite.keyword_arguments):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_argparse",
        "documentation": {}
    },
    {
        "label": "is_decorated_with_attrs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "peekOfCode": "def is_decorated_with_attrs(node, decorator_names=ATTRS_NAMES) -> bool:\n    \"\"\"Return whether a decorated node has an attr decorator applied.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator_attribute in node.decorators.nodes:\n        if isinstance(decorator_attribute, Call):  # decorator with arguments\n            decorator_attribute = decorator_attribute.func\n        if decorator_attribute.as_string() in decorator_names:\n            return True\n    return False",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "documentation": {}
    },
    {
        "label": "attr_attributes_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "peekOfCode": "def attr_attributes_transform(node: ClassDef) -> None:\n    \"\"\"Given that the ClassNode has an attr decorator,\n    rewrite class attributes as instance attributes\n    \"\"\"\n    # Astroid can't infer this attribute properly\n    # Prevents https://github.com/PyCQA/pylint/issues/1884\n    node.locals[\"__attrs_attrs__\"] = [Unknown(parent=node)]\n    for cdef_body_node in node.body:\n        if not isinstance(cdef_body_node, (Assign, AnnAssign)):\n            continue",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "documentation": {}
    },
    {
        "label": "ATTRIB_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "peekOfCode": "ATTRIB_NAMES = frozenset(\n    (\"attr.ib\", \"attrib\", \"attr.attrib\", \"attr.field\", \"attrs.field\", \"field\")\n)\nATTRS_NAMES = frozenset(\n    (\n        \"attr.s\",\n        \"attrs\",\n        \"attr.attrs\",\n        \"attr.attributes\",\n        \"attr.define\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "documentation": {}
    },
    {
        "label": "ATTRS_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "peekOfCode": "ATTRS_NAMES = frozenset(\n    (\n        \"attr.s\",\n        \"attrs\",\n        \"attr.attrs\",\n        \"attr.attributes\",\n        \"attr.define\",\n        \"attr.mutable\",\n        \"attr.frozen\",\n        \"attrs.define\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_attrs",
        "documentation": {}
    },
    {
        "label": "service_request_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "peekOfCode": "def service_request_transform(node):\n    \"\"\"Transform ServiceResource to look like dynamic classes.\"\"\"\n    code = \"\"\"\n    def __getattr__(self, attr):\n        return 0\n    \"\"\"\n    func_getattr = extract_node(code)\n    node.locals[\"__getattr__\"] = [func_getattr]\n    return node\ndef _looks_like_boto3_service_request(node) -> bool:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "documentation": {}
    },
    {
        "label": "BOTO_SERVICE_FACTORY_QUALIFIED_NAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "peekOfCode": "BOTO_SERVICE_FACTORY_QUALIFIED_NAME = \"boto3.resources.base.ServiceResource\"\ndef service_request_transform(node):\n    \"\"\"Transform ServiceResource to look like dynamic classes.\"\"\"\n    code = \"\"\"\n    def __getattr__(self, attr):\n        return 0\n    \"\"\"\n    func_getattr = extract_node(code)\n    node.locals[\"__getattr__\"] = [func_getattr]\n    return node",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_boto3",
        "documentation": {}
    },
    {
        "label": "whatever",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "class whatever(object):\n    def join(self, iterable):\n        return {rvalue}\n    def replace(self, old, new, count=None):\n        return {rvalue}\n    def format(self, *args, **kwargs):\n        return {rvalue}\n    def encode(self, encoding='ascii', errors=None):\n        return b''\n    def decode(self, encoding='ascii', errors=None):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "whatever",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "class whatever(object):\n    def join(self, iterable):\n        return {rvalue}\n    def replace(self, old, new, count=None):\n        return {rvalue}\n    def decode(self, encoding='ascii', errors=None):\n        return u''\n    def capitalize(self):\n        return {rvalue}\n    def title(self):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "register_builtin_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def register_builtin_transform(transform, builtin_name) -> None:\n    \"\"\"Register a new transform function for the given *builtin_name*.\n    The transform function must accept two parameters, a node and\n    an optional context.\n    \"\"\"\n    def _transform_wrapper(node, context: InferenceContext | None = None):\n        result = transform(node, context=context)\n        if result:\n            if not result.parent:\n                # Let the transformation function determine",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_dict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_dict(node, context: InferenceContext | None = None):\n    \"\"\"Try to infer a dict call to a Dict node.\n    The function treats the following cases:\n        * dict()\n        * dict(mapping)\n        * dict(iterable)\n        * dict(iterable, **kwargs)\n        * dict(mapping, **kwargs)\n        * dict(**kwargs)\n    If a case can't be inferred, we'll fallback to default inference.",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_super",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_super(node, context: InferenceContext | None = None):\n    \"\"\"Understand super calls.\n    There are some restrictions for what can be understood:\n        * unbounded super (one argument form) is not understood.\n        * if the super call is not inside a function (classmethod or method),\n          then the default inference will be used.\n        * if the super arguments can't be inferred, the default inference\n          will be used.\n    \"\"\"\n    if len(node.args) == 1:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_getattr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_getattr(node, context: InferenceContext | None = None):\n    \"\"\"Understand getattr calls.\n    If one of the arguments is an Uninferable object, then the\n    result will be an Uninferable object. Otherwise, the normal attribute\n    lookup will be done.\n    \"\"\"\n    obj, attr = _infer_getattr_args(node, context)\n    if (\n        obj is util.Uninferable\n        or attr is util.Uninferable",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_hasattr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_hasattr(node, context: InferenceContext | None = None):\n    \"\"\"Understand hasattr calls.\n    This always guarantees three possible outcomes for calling\n    hasattr: Const(False) when we are sure that the object\n    doesn't have the intended attribute, Const(True) when\n    we know that the object has the attribute and Uninferable\n    when we are unsure of the outcome of the function call.\n    \"\"\"\n    try:\n        obj, attr = _infer_getattr_args(node, context)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_callable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_callable(node, context: InferenceContext | None = None):\n    \"\"\"Understand callable calls.\n    This follows Python's semantics, where an object\n    is callable if it provides an attribute __call__,\n    even though that attribute is something which can't be\n    called.\n    \"\"\"\n    if len(node.args) != 1:\n        # Invalid callable call.\n        raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_property(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> objects.Property:\n    \"\"\"Understand `property` class.\n    This only infers the output of `property`\n    call, not the arguments themselves.\n    \"\"\"\n    if len(node.args) < 1:\n        # Invalid property call.\n        raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_bool",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_bool(node, context: InferenceContext | None = None):\n    \"\"\"Understand bool calls.\"\"\"\n    if len(node.args) > 1:\n        # Invalid bool call.\n        raise UseInferenceDefault\n    if not node.args:\n        return nodes.Const(False)\n    argument = node.args[0]\n    try:\n        inferred = next(argument.infer(context=context))",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_type(node, context: InferenceContext | None = None):\n    \"\"\"Understand the one-argument form of *type*.\"\"\"\n    if len(node.args) != 1:\n        raise UseInferenceDefault\n    return helpers.object_type(node.args[0], context)\ndef infer_slice(node, context: InferenceContext | None = None):\n    \"\"\"Understand `slice` calls.\"\"\"\n    args = node.args\n    if not 0 < len(args) <= 3:\n        raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_slice",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_slice(node, context: InferenceContext | None = None):\n    \"\"\"Understand `slice` calls.\"\"\"\n    args = node.args\n    if not 0 < len(args) <= 3:\n        raise UseInferenceDefault\n    infer_func = partial(helpers.safe_infer, context=context)\n    args = [infer_func(arg) for arg in args]\n    for arg in args:\n        if not arg or arg is util.Uninferable:\n            raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_issubclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_issubclass(callnode, context: InferenceContext | None = None):\n    \"\"\"Infer issubclass() calls.\n    :param nodes.Call callnode: an `issubclass` call\n    :param InferenceContext context: the context for the inference\n    :rtype nodes.Const: Boolean Const value of the `issubclass` call\n    :raises UseInferenceDefault: If the node cannot be inferred\n    \"\"\"\n    call = arguments.CallSite.from_call(callnode, context=context)\n    if call.keyword_arguments:\n        # issubclass doesn't support keyword arguments",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_isinstance",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_isinstance(callnode, context: InferenceContext | None = None):\n    \"\"\"Infer isinstance calls.\n    :param nodes.Call callnode: an isinstance call\n    :rtype nodes.Const: Boolean Const value of isinstance call\n    :raises UseInferenceDefault: If the node cannot be inferred\n    \"\"\"\n    call = arguments.CallSite.from_call(callnode, context=context)\n    if call.keyword_arguments:\n        # isinstance doesn't support keyword arguments\n        raise UseInferenceDefault(\"TypeError: isinstance() takes no keyword arguments\")",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_len",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_len(node, context: InferenceContext | None = None):\n    \"\"\"Infer length calls.\n    :param nodes.Call node: len call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const node with the inferred length, if possible\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: len() must take no keyword arguments\")\n    if len(call.positional_arguments) != 1:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_str(node, context: InferenceContext | None = None):\n    \"\"\"Infer str() calls.\n    :param nodes.Call node: str() call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const containing an empty string\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: str() must take no keyword arguments\")\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_int",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_int(node, context: InferenceContext | None = None):\n    \"\"\"Infer int() calls.\n    :param nodes.Call node: int() call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const containing the integer value of the int() call\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: int() must take no keyword arguments\")\n    if call.positional_arguments:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_dict_fromkeys",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "def infer_dict_fromkeys(node, context: InferenceContext | None = None):\n    \"\"\"Infer dict.fromkeys.\n    :param nodes.Call node: dict.fromkeys() call to infer\n    :param context.InferenceContext context: node context\n    :rtype nodes.Dict:\n        a Dictionary containing the values that astroid was able to infer.\n        In case the inference failed for any reason, an empty dictionary\n        will be inferred instead.\n    \"\"\"\n    def _build_dict_with_elements(elements):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "OBJECT_DUNDER_NEW",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "OBJECT_DUNDER_NEW = \"object.__new__\"\nSTR_CLASS = \"\"\"\nclass whatever(object):\n    def join(self, iterable):\n        return {rvalue}\n    def replace(self, old, new, count=None):\n        return {rvalue}\n    def format(self, *args, **kwargs):\n        return {rvalue}\n    def encode(self, encoding='ascii', errors=None):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "STR_CLASS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "STR_CLASS = \"\"\"\nclass whatever(object):\n    def join(self, iterable):\n        return {rvalue}\n    def replace(self, old, new, count=None):\n        return {rvalue}\n    def format(self, *args, **kwargs):\n        return {rvalue}\n    def encode(self, encoding='ascii', errors=None):\n        return b''",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "BYTES_CLASS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "BYTES_CLASS = \"\"\"\nclass whatever(object):\n    def join(self, iterable):\n        return {rvalue}\n    def replace(self, old, new, count=None):\n        return {rvalue}\n    def decode(self, encoding='ascii', errors=None):\n        return u''\n    def capitalize(self):\n        return {rvalue}",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_tuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "infer_tuple = partial(\n    _infer_builtin_container,\n    klass=nodes.Tuple,\n    iterables=(\n        nodes.List,\n        nodes.Set,\n        objects.FrozenSet,\n        objects.DictItems,\n        objects.DictKeys,\n        objects.DictValues,",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_list",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "infer_list = partial(\n    _infer_builtin_container,\n    klass=nodes.List,\n    iterables=(\n        nodes.Tuple,\n        nodes.Set,\n        objects.FrozenSet,\n        objects.DictItems,\n        objects.DictKeys,\n        objects.DictValues,",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_set",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "infer_set = partial(\n    _infer_builtin_container,\n    klass=nodes.Set,\n    iterables=(nodes.List, nodes.Tuple, objects.FrozenSet, objects.DictKeys),\n    build_elts=set,\n)\ninfer_frozenset = partial(\n    _infer_builtin_container,\n    klass=objects.FrozenSet,\n    iterables=(nodes.List, nodes.Tuple, nodes.Set, objects.FrozenSet, objects.DictKeys),",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "infer_frozenset",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "peekOfCode": "infer_frozenset = partial(\n    _infer_builtin_container,\n    klass=objects.FrozenSet,\n    iterables=(nodes.List, nodes.Tuple, nodes.Set, objects.FrozenSet, objects.DictKeys),\n    build_elts=frozenset,\n)\ndef _get_elts(arg, context):\n    def is_iterable(n):\n        return isinstance(n, (nodes.List, nodes.Tuple, nodes.Set))\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_builtin_inference",
        "documentation": {}
    },
    {
        "label": "easy_class_getitem_inference",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "peekOfCode": "def easy_class_getitem_inference(node, context: InferenceContext | None = None):\n    # Here __class_getitem__ exists but is quite a mess to infer thus\n    # put an easy inference tip\n    func_to_add = extract_node(CLASS_GET_ITEM_TEMPLATE)\n    node.locals[\"__class_getitem__\"] = [func_to_add]\nif PY39_PLUS:\n    # Starting with Python39 some objects of the collection module are subscriptable\n    # thanks to the __class_getitem__ method but the way it is implemented in\n    # _collection_abc makes it difficult to infer. (We would have to handle AssignName inference in the\n    # getitem method of the ClassDef class) Instead we put here a mock of the __class_getitem__ method",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "documentation": {}
    },
    {
        "label": "CLASS_GET_ITEM_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "peekOfCode": "CLASS_GET_ITEM_TEMPLATE = \"\"\"\n@classmethod\ndef __class_getitem__(cls, item):\n    return cls\n\"\"\"\ndef easy_class_getitem_inference(node, context: InferenceContext | None = None):\n    # Here __class_getitem__ exists but is quite a mess to infer thus\n    # put an easy inference tip\n    func_to_add = extract_node(CLASS_GET_ITEM_TEMPLATE)\n    node.locals[\"__class_getitem__\"] = [func_to_add]",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_collections",
        "documentation": {}
    },
    {
        "label": "c_bool",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "peekOfCode": "class c_bool(_SimpleCData):\n    def __init__(self, value):\n        self.value = True\n        self._type_ = '?'\n    \"\"\"\n    ]\n    for c_type, builtin_type, type_code in c_class_to_type:\n        src.append(\n            f\"\"\"\nclass {c_type}(_SimpleCData):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "documentation": {}
    },
    {
        "label": "{c_type}",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "peekOfCode": "class {c_type}(_SimpleCData):\n    def __init__(self, value):\n        self.value = {builtin_type}(value)\n        self._type_ = '{type_code}'\n        \"\"\"\n        )\n    return parse(\"\\n\".join(src))\nif not hasattr(sys, \"pypy_version_info\"):\n    # No need of this module in pypy where everything is written in python\n    register_module_extender(AstroidManager(), \"ctypes\", enrich_ctypes_redefined_types)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "documentation": {}
    },
    {
        "label": "enrich_ctypes_redefined_types",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "peekOfCode": "def enrich_ctypes_redefined_types():\n    \"\"\"\n    For each ctypes redefined types, overload 'value' and '_type_' members\n    definition.\n    Overloading 'value' is mandatory otherwise astroid cannot infer the correct type for it.\n    Overloading '_type_' is necessary because the class definition made here replaces the original\n    one, in which '_type_' member is defined. Luckily those original class definitions are very short\n    and contain only the '_type_' member definition.\n    \"\"\"\n    c_class_to_type = (",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_ctypes",
        "documentation": {}
    },
    {
        "label": "is_decorated_with_dataclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "def is_decorated_with_dataclass(\n    node: nodes.ClassDef, decorator_names: frozenset[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"\n    if not isinstance(node, nodes.ClassDef) or not node.decorators:\n        return False\n    return any(\n        _looks_like_dataclass_decorator(decorator_attribute, decorator_names)\n        for decorator_attribute in node.decorators.nodes\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "def dataclass_transform(node: nodes.ClassDef) -> None:\n    \"\"\"Rewrite a dataclass to be easily understood by pylint.\"\"\"\n    node.is_dataclass = True\n    for assign_node in _get_dataclass_attributes(node):\n        name = assign_node.target.name\n        rhs_node = nodes.Unknown(\n            lineno=assign_node.lineno,\n            col_offset=assign_node.col_offset,\n            parent=assign_node,\n        )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "infer_dataclass_attribute",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "def infer_dataclass_attribute(\n    node: nodes.Unknown, ctx: context.InferenceContext | None = None\n) -> Iterator[InferenceResult]:\n    \"\"\"Inference tip for an Unknown node that was dynamically generated to\n    represent a dataclass attribute.\n    In the case that a default value is provided, that is inferred first.\n    Then, an Instance of the annotated class is yielded.\n    \"\"\"\n    assign = node.parent\n    if not isinstance(assign, nodes.AnnAssign):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "infer_dataclass_field_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "def infer_dataclass_field_call(\n    node: nodes.Call, ctx: context.InferenceContext | None = None\n) -> Iterator[InferenceResult]:\n    \"\"\"Inference tip for dataclass field calls.\"\"\"\n    if not isinstance(node.parent, (nodes.AnnAssign, nodes.Assign)):\n        raise UseInferenceDefault\n    result = _get_field_default(node)\n    if not result:\n        yield Uninferable\n    else:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "_FieldDefaultReturn",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "_FieldDefaultReturn = Union[\n    None,\n    Tuple[Literal[\"default\"], nodes.NodeNG],\n    Tuple[Literal[\"default_factory\"], nodes.Call],\n]\nDATACLASSES_DECORATORS = frozenset((\"dataclass\",))\nFIELD_NAME = \"field\"\nDATACLASS_MODULES = frozenset(\n    (\"dataclasses\", \"marshmallow_dataclass\", \"pydantic.dataclasses\")\n)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "DATACLASSES_DECORATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "DATACLASSES_DECORATORS = frozenset((\"dataclass\",))\nFIELD_NAME = \"field\"\nDATACLASS_MODULES = frozenset(\n    (\"dataclasses\", \"marshmallow_dataclass\", \"pydantic.dataclasses\")\n)\nDEFAULT_FACTORY = \"_HAS_DEFAULT_FACTORY\"  # based on typing.py\ndef is_decorated_with_dataclass(\n    node: nodes.ClassDef, decorator_names: frozenset[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "FIELD_NAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "FIELD_NAME = \"field\"\nDATACLASS_MODULES = frozenset(\n    (\"dataclasses\", \"marshmallow_dataclass\", \"pydantic.dataclasses\")\n)\nDEFAULT_FACTORY = \"_HAS_DEFAULT_FACTORY\"  # based on typing.py\ndef is_decorated_with_dataclass(\n    node: nodes.ClassDef, decorator_names: frozenset[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"\n    if not isinstance(node, nodes.ClassDef) or not node.decorators:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "DATACLASS_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "DATACLASS_MODULES = frozenset(\n    (\"dataclasses\", \"marshmallow_dataclass\", \"pydantic.dataclasses\")\n)\nDEFAULT_FACTORY = \"_HAS_DEFAULT_FACTORY\"  # based on typing.py\ndef is_decorated_with_dataclass(\n    node: nodes.ClassDef, decorator_names: frozenset[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"\n    if not isinstance(node, nodes.ClassDef) or not node.decorators:\n        return False",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FACTORY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "DEFAULT_FACTORY = \"_HAS_DEFAULT_FACTORY\"  # based on typing.py\ndef is_decorated_with_dataclass(\n    node: nodes.ClassDef, decorator_names: frozenset[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"\n    if not isinstance(node, nodes.ClassDef) or not node.decorators:\n        return False\n    return any(\n        _looks_like_dataclass_decorator(decorator_attribute, decorator_names)\n        for decorator_attribute in node.decorators.nodes",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "_INFERABLE_TYPING_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "peekOfCode": "_INFERABLE_TYPING_TYPES = frozenset(\n    (\n        \"Dict\",\n        \"FrozenSet\",\n        \"List\",\n        \"Set\",\n        \"Tuple\",\n    )\n)\ndef _infer_instance_from_annotation(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dataclasses",
        "documentation": {}
    },
    {
        "label": "dateutil_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_dateutil",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_dateutil",
        "peekOfCode": "def dateutil_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        textwrap.dedent(\n            \"\"\"\n    import datetime\n    def parse(timestr, parserinfo=None, **kwargs):\n        return datetime.datetime()\n    \"\"\"\n        )\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_dateutil",
        "documentation": {}
    },
    {
        "label": "LruWrappedModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "peekOfCode": "class LruWrappedModel(objectmodel.FunctionModel):\n    \"\"\"Special attribute model for functions decorated with functools.lru_cache.\n    The said decorators patches at decoration time some functions onto\n    the decorated function.\n    \"\"\"\n    @property\n    def attr___wrapped__(self):\n        return self._instance\n    @property\n    def attr_cache_info(self):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "documentation": {}
    },
    {
        "label": "LRU_CACHE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "peekOfCode": "LRU_CACHE = \"functools.lru_cache\"\nclass LruWrappedModel(objectmodel.FunctionModel):\n    \"\"\"Special attribute model for functions decorated with functools.lru_cache.\n    The said decorators patches at decoration time some functions onto\n    the decorated function.\n    \"\"\"\n    @property\n    def attr___wrapped__(self):\n        return self._instance\n    @property",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "documentation": {}
    },
    {
        "label": "_looks_like_partial",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "peekOfCode": "_looks_like_partial = partial(_looks_like_functools_member, member=\"partial\")\nAstroidManager().register_transform(\n    FunctionDef, _transform_lru_cache, _looks_like_lru_cache\n)\nAstroidManager().register_transform(\n    Call,\n    inference_tip(_functools_partial_inference),\n    _looks_like_partial,\n)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_functools",
        "documentation": {}
    },
    {
        "label": "_inspected_modules",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "peekOfCode": "_inspected_modules = {}\n_identifier_re = r\"^[A-Za-z_]\\w*$\"\n_special_methods = frozenset(\n    {\n        \"__lt__\",\n        \"__le__\",\n        \"__eq__\",\n        \"__ne__\",\n        \"__ge__\",\n        \"__gt__\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "documentation": {}
    },
    {
        "label": "_identifier_re",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "peekOfCode": "_identifier_re = r\"^[A-Za-z_]\\w*$\"\n_special_methods = frozenset(\n    {\n        \"__lt__\",\n        \"__le__\",\n        \"__eq__\",\n        \"__ne__\",\n        \"__ge__\",\n        \"__gt__\",\n        \"__iter__\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "documentation": {}
    },
    {
        "label": "_special_methods",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "peekOfCode": "_special_methods = frozenset(\n    {\n        \"__lt__\",\n        \"__le__\",\n        \"__eq__\",\n        \"__ne__\",\n        \"__ge__\",\n        \"__gt__\",\n        \"__iter__\",\n        \"__getitem__\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_gi",
        "documentation": {}
    },
    {
        "label": "is_decorated_with_st_composite",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "peekOfCode": "def is_decorated_with_st_composite(node) -> bool:\n    \"\"\"Return whether a decorated node has @st.composite applied.\"\"\"\n    if node.decorators and node.args.args and node.args.args[0].name == \"draw\":\n        for decorator_attribute in node.decorators.nodes:\n            if decorator_attribute.as_string() in COMPOSITE_NAMES:\n                return True\n    return False\ndef remove_draw_parameter_from_composite_strategy(node):\n    \"\"\"Given that the FunctionDef is decorated with @st.composite, remove the\n    first argument (`draw`) - it's always supplied by Hypothesis so we don't",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "documentation": {}
    },
    {
        "label": "remove_draw_parameter_from_composite_strategy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "peekOfCode": "def remove_draw_parameter_from_composite_strategy(node):\n    \"\"\"Given that the FunctionDef is decorated with @st.composite, remove the\n    first argument (`draw`) - it's always supplied by Hypothesis so we don't\n    need to emit the no-value-for-parameter lint.\n    \"\"\"\n    del node.args.args[0]\n    del node.args.annotations[0]\n    del node.args.type_comment_args[0]\n    return node\nAstroidManager().register_transform(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "documentation": {}
    },
    {
        "label": "COMPOSITE_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "peekOfCode": "COMPOSITE_NAMES = (\n    \"composite\",\n    \"st.composite\",\n    \"strategies.composite\",\n    \"hypothesis.strategies.composite\",\n)\ndef is_decorated_with_st_composite(node) -> bool:\n    \"\"\"Return whether a decorated node has @st.composite applied.\"\"\"\n    if node.decorators and node.args.args and node.args.args[0].name == \"draw\":\n        for decorator_attribute in node.decorators.nodes:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_hypothesis",
        "documentation": {}
    },
    {
        "label": "BUFFERED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "peekOfCode": "BUFFERED = {\"BufferedWriter\", \"BufferedReader\"}\nTextIOWrapper = \"TextIOWrapper\"\nFileIO = \"FileIO\"\nBufferedWriter = \"BufferedWriter\"\ndef _generic_io_transform(node, name, cls):\n    \"\"\"Transform the given name, by adding the given *class* as a member of the\n    node.\n    \"\"\"\n    io_module = AstroidManager().ast_from_module_name(\"_io\")\n    attribute_object = io_module[cls]",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "peekOfCode": "TextIOWrapper = \"TextIOWrapper\"\nFileIO = \"FileIO\"\nBufferedWriter = \"BufferedWriter\"\ndef _generic_io_transform(node, name, cls):\n    \"\"\"Transform the given name, by adding the given *class* as a member of the\n    node.\n    \"\"\"\n    io_module = AstroidManager().ast_from_module_name(\"_io\")\n    attribute_object = io_module[cls]\n    instance = attribute_object.instantiate_class()",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "documentation": {}
    },
    {
        "label": "FileIO",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "peekOfCode": "FileIO = \"FileIO\"\nBufferedWriter = \"BufferedWriter\"\ndef _generic_io_transform(node, name, cls):\n    \"\"\"Transform the given name, by adding the given *class* as a member of the\n    node.\n    \"\"\"\n    io_module = AstroidManager().ast_from_module_name(\"_io\")\n    attribute_object = io_module[cls]\n    instance = attribute_object.instantiate_class()\n    node.locals[name] = [instance]",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "documentation": {}
    },
    {
        "label": "BufferedWriter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "peekOfCode": "BufferedWriter = \"BufferedWriter\"\ndef _generic_io_transform(node, name, cls):\n    \"\"\"Transform the given name, by adding the given *class* as a member of the\n    node.\n    \"\"\"\n    io_module = AstroidManager().ast_from_module_name(\"_io\")\n    attribute_object = io_module[cls]\n    instance = attribute_object.instantiate_class()\n    node.locals[name] = [instance]\ndef _transform_text_io_wrapper(node):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_io",
        "documentation": {}
    },
    {
        "label": "mechanize_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_mechanize",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_mechanize",
        "peekOfCode": "def mechanize_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"class Browser(object):\n    def __getattr__(self, name):\n        return None\n    def __getitem__(self, name):\n        return None\n    def __setitem__(self, name, val):\n        return None\n    def back(self, n=1):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_mechanize",
        "documentation": {}
    },
    {
        "label": "{name}",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "class {name}(tuple):\n    __slots__ = ()\n    _fields = {attributes!r}\n    def _asdict(self):\n        return self.__dict__\n    @classmethod\n    def _make(cls, iterable, new=tuple.__new__, len=len):\n        return new(cls, iterable)\n    def _replace(self, {replace_args}):\n        return self",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_func_form",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_func_form(\n    node: nodes.Call,\n    base_type: list[nodes.NodeNG],\n    context: InferenceContext | None = None,\n    enum: bool = False,\n) -> tuple[nodes.ClassDef, str, list[str]]:\n    \"\"\"Specific inference function for namedtuple or Python 3 enum.\"\"\"\n    # node is a Call node, class name as first argument and generated class\n    # attributes as second argument\n    # namedtuple or enums list of attributes can be a list of strings or a",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_named_tuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_named_tuple(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[nodes.ClassDef]:\n    \"\"\"Specific inference function for namedtuple Call node.\"\"\"\n    tuple_base_name: list[nodes.NodeNG] = [nodes.Name(name=\"tuple\", parent=node.root())]\n    class_node, name, attributes = infer_func_form(\n        node, tuple_base_name, context=context\n    )\n    call_site = arguments.CallSite.from_call(node, context=context)\n    node = extract_node(\"import collections; collections.namedtuple\")",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_enum",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_enum(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[bases.Instance]:\n    \"\"\"Specific inference function for enum Call node.\"\"\"\n    # Raise `UseInferenceDefault` if `node` is a call to a a user-defined Enum.\n    try:\n        inferred = node.func.infer(context)\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if not any(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_enum_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_enum_class(node: nodes.ClassDef) -> nodes.ClassDef:\n    \"\"\"Specific inference for enums.\"\"\"\n    for basename in (b for cls in node.mro() for b in cls.basenames):\n        if node.root().name == \"enum\":\n            # Skip if the class is directly from enum module.\n            break\n        dunder_members = {}\n        target_names = set()\n        for local, values in node.locals.items():\n            if any(not isinstance(value, nodes.AssignName) for value in values):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_typing_namedtuple_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_typing_namedtuple_class(class_node, context: InferenceContext | None = None):\n    \"\"\"Infer a subclass of typing.NamedTuple.\"\"\"\n    # Check if it has the corresponding bases\n    annassigns_fields = [\n        annassign.target.name\n        for annassign in class_node.body\n        if isinstance(annassign, nodes.AnnAssign)\n    ]\n    code = dedent(\n        \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_typing_namedtuple_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_typing_namedtuple_function(node, context: InferenceContext | None = None):\n    \"\"\"\n    Starting with python3.9, NamedTuple is a function of the typing module.\n    The class NamedTuple is build dynamically through a call to `type` during\n    initialization of the `_NamedTuple` variable.\n    \"\"\"\n    klass = extract_node(\n        \"\"\"\n        from typing import _NamedTuple\n        _NamedTuple",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "infer_typing_namedtuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "def infer_typing_namedtuple(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[nodes.ClassDef]:\n    \"\"\"Infer a typing.NamedTuple(...) call.\"\"\"\n    # This is essentially a namedtuple with different arguments\n    # so we extract the args and infer a named tuple.\n    try:\n        func = next(node.func.infer())\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "ENUM_BASE_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "ENUM_BASE_NAMES = {\n    \"Enum\",\n    \"IntEnum\",\n    \"enum.Enum\",\n    \"enum.IntEnum\",\n    \"IntFlag\",\n    \"enum.IntFlag\",\n}\nENUM_QNAME: Final[str] = \"enum.Enum\"\nTYPING_NAMEDTUPLE_QUALIFIED: Final = {",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "_looks_like_namedtuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "_looks_like_namedtuple = functools.partial(_looks_like, name=\"namedtuple\")\n_looks_like_enum = functools.partial(_looks_like, name=\"Enum\")\n_looks_like_typing_namedtuple = functools.partial(_looks_like, name=\"NamedTuple\")\ndef infer_named_tuple(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[nodes.ClassDef]:\n    \"\"\"Specific inference function for namedtuple Call node.\"\"\"\n    tuple_base_name: list[nodes.NodeNG] = [nodes.Name(name=\"tuple\", parent=node.root())]\n    class_node, name, attributes = infer_func_form(\n        node, tuple_base_name, context=context",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "_looks_like_enum",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "_looks_like_enum = functools.partial(_looks_like, name=\"Enum\")\n_looks_like_typing_namedtuple = functools.partial(_looks_like, name=\"NamedTuple\")\ndef infer_named_tuple(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[nodes.ClassDef]:\n    \"\"\"Specific inference function for namedtuple Call node.\"\"\"\n    tuple_base_name: list[nodes.NodeNG] = [nodes.Name(name=\"tuple\", parent=node.root())]\n    class_node, name, attributes = infer_func_form(\n        node, tuple_base_name, context=context\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "_looks_like_typing_namedtuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "_looks_like_typing_namedtuple = functools.partial(_looks_like, name=\"NamedTuple\")\ndef infer_named_tuple(\n    node: nodes.Call, context: InferenceContext | None = None\n) -> Iterator[nodes.ClassDef]:\n    \"\"\"Specific inference function for namedtuple Call node.\"\"\"\n    tuple_base_name: list[nodes.NodeNG] = [nodes.Name(name=\"tuple\", parent=node.root())]\n    class_node, name, attributes = infer_func_form(\n        node, tuple_base_name, context=context\n    )\n    call_site = arguments.CallSite.from_call(node, context=context)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "INT_FLAG_ADDITION_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "peekOfCode": "INT_FLAG_ADDITION_METHODS = \"\"\"\n    def __or__(self, other):\n        return {name}(self.value | other.value)\n    def __and__(self, other):\n        return {name}(self.value & other.value)\n    def __xor__(self, other):\n        return {name}(self.value ^ other.value)\n    def __add__(self, other):\n        return {name}(self.value + other.value)\n    def __div__(self, other):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_namedtuple_enum",
        "documentation": {}
    },
    {
        "label": "_BUILDER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "peekOfCode": "_BUILDER = astroid.builder.AstroidBuilder(AstroidManager())\nCAPITALS = re.compile(\"([A-Z])\")\ndef _pep8(name, caps=CAPITALS):\n    return caps.sub(lambda m: \"_\" + m.groups()[0].lower(), name)\ndef _nose_tools_functions():\n    \"\"\"Get an iterator of names and bound methods.\"\"\"\n    module = _BUILDER.string_build(\n        textwrap.dedent(\n            \"\"\"\n    import unittest",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "documentation": {}
    },
    {
        "label": "CAPITALS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "peekOfCode": "CAPITALS = re.compile(\"([A-Z])\")\ndef _pep8(name, caps=CAPITALS):\n    return caps.sub(lambda m: \"_\" + m.groups()[0].lower(), name)\ndef _nose_tools_functions():\n    \"\"\"Get an iterator of names and bound methods.\"\"\"\n    module = _BUILDER.string_build(\n        textwrap.dedent(\n            \"\"\"\n    import unittest\n    class Test(unittest.TestCase):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_nose",
        "documentation": {}
    },
    {
        "label": "numpy_core_einsumfunc_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_einsumfunc",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_einsumfunc",
        "peekOfCode": "def numpy_core_einsumfunc_transform() -> nodes.Module:\n    return parse(\n        \"\"\"\n    def einsum(*operands, out=None, optimize=False, **kwargs):\n        return numpy.ndarray([0, 0])\n    \"\"\"\n    )\nregister_module_extender(\n    AstroidManager(), \"numpy.core.einsumfunc\", numpy_core_einsumfunc_transform\n)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_einsumfunc",
        "documentation": {}
    },
    {
        "label": "numpy_core_fromnumeric_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_fromnumeric",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_fromnumeric",
        "peekOfCode": "def numpy_core_fromnumeric_transform():\n    return parse(\n        \"\"\"\n    def sum(a, axis=None, dtype=None, out=None, keepdims=None, initial=None):\n        return numpy.ndarray([0, 0])\n    \"\"\"\n    )\nregister_module_extender(\n    AstroidManager(), \"numpy.core.fromnumeric\", numpy_core_fromnumeric_transform\n)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_fromnumeric",
        "documentation": {}
    },
    {
        "label": "METHODS_TO_BE_INFERRED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_function_base",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_function_base",
        "peekOfCode": "METHODS_TO_BE_INFERRED = {\n    \"linspace\": \"\"\"def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0):\n            return numpy.ndarray([0, 0])\"\"\",\n    \"logspace\": \"\"\"def logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0):\n            return numpy.ndarray([0, 0])\"\"\",\n    \"geomspace\": \"\"\"def geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0):\n            return numpy.ndarray([0, 0])\"\"\",\n}\nfor func_name, func_src in METHODS_TO_BE_INFERRED.items():\n    inference_function = functools.partial(infer_numpy_member, func_src)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_function_base",
        "documentation": {}
    },
    {
        "label": "numpy_core_multiarray_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "peekOfCode": "def numpy_core_multiarray_transform():\n    return parse(\n        \"\"\"\n    # different functions defined in multiarray.py\n    def inner(a, b):\n        return numpy.ndarray([0, 0])\n    def vdot(a, b):\n        return numpy.ndarray([0, 0])\n        \"\"\"\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "documentation": {}
    },
    {
        "label": "METHODS_TO_BE_INFERRED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "peekOfCode": "METHODS_TO_BE_INFERRED = {\n    \"array\": \"\"\"def array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0):\n            return numpy.ndarray([0, 0])\"\"\",\n    \"dot\": \"\"\"def dot(a, b, out=None):\n            return numpy.ndarray([0, 0])\"\"\",\n    \"empty_like\": \"\"\"def empty_like(a, dtype=None, order='K', subok=True):\n            return numpy.ndarray((0, 0))\"\"\",\n    \"concatenate\": \"\"\"def concatenate(arrays, axis=None, out=None):\n            return numpy.ndarray((0, 0))\"\"\",\n    \"where\": \"\"\"def where(condition, x=None, y=None):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_multiarray",
        "documentation": {}
    },
    {
        "label": "numpy_core_numeric_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "peekOfCode": "def numpy_core_numeric_transform():\n    return parse(\n        \"\"\"\n    # different functions defined in numeric.py\n    import numpy\n    def zeros_like(a, dtype=None, order='K', subok=True, shape=None): return numpy.ndarray((0, 0))\n    def ones_like(a, dtype=None, order='K', subok=True, shape=None): return numpy.ndarray((0, 0))\n    def full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None): return numpy.ndarray((0, 0))\n        \"\"\"\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "documentation": {}
    },
    {
        "label": "METHODS_TO_BE_INFERRED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "peekOfCode": "METHODS_TO_BE_INFERRED = {\n    \"ones\": \"\"\"def ones(shape, dtype=None, order='C'):\n            return numpy.ndarray([0, 0])\"\"\"\n}\nfor method_name, function_src in METHODS_TO_BE_INFERRED.items():\n    inference_function = functools.partial(infer_numpy_member, function_src)\n    AstroidManager().register_transform(\n        Attribute,\n        inference_tip(inference_function),\n        functools.partial(looks_like_numpy_member, method_name),",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numeric",
        "documentation": {}
    },
    {
        "label": "numpy_core_numerictypes_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numerictypes",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numerictypes",
        "peekOfCode": "def numpy_core_numerictypes_transform():\n    # TODO: Uniformize the generic API with the ndarray one.\n    #       According to numpy doc the generic object should expose\n    #       the same API than ndarray. This has been done here partially\n    #       through the astype method.\n    generic_src = \"\"\"\n    class generic(object):\n        def __init__(self, value):\n            self.T = np.ndarray([0, 0])\n            self.base = None",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_numerictypes",
        "documentation": {}
    },
    {
        "label": "numpy_core_umath_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_umath",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_umath",
        "peekOfCode": "def numpy_core_umath_transform():\n    ufunc_optional_keyword_arguments = (\n        \"\"\"out=None, where=True, casting='same_kind', order='K', \"\"\"\n        \"\"\"dtype=None, subok=True\"\"\"\n    )\n    return parse(\n        \"\"\"\n    class FakeUfunc:\n        def __init__(self):\n            self.__doc__ = str()",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_core_umath",
        "documentation": {}
    },
    {
        "label": "numpy_ma_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ma",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ma",
        "peekOfCode": "def numpy_ma_transform():\n    \"\"\"\n    Infer the call of various numpy.ma functions.\n    :param node: node to infer\n    :param context: inference context\n    \"\"\"\n    return parse(\n        \"\"\"\n    import numpy.ma\n    def masked_where(condition, a, copy=True):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ma",
        "documentation": {}
    },
    {
        "label": "infer_numpy_ndarray",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ndarray",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ndarray",
        "peekOfCode": "def infer_numpy_ndarray(node, context: InferenceContext | None = None):\n    ndarray = \"\"\"\n    class ndarray(object):\n        def __init__(self, shape, dtype=float, buffer=None, offset=0,\n                     strides=None, order=None):\n            self.T = numpy.ndarray([0, 0])\n            self.base = None\n            self.ctypes = None\n            self.data = None\n            self.dtype = None",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_ndarray",
        "documentation": {}
    },
    {
        "label": "numpy_random_mtrand_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_random_mtrand",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_random_mtrand",
        "peekOfCode": "def numpy_random_mtrand_transform():\n    return parse(\n        \"\"\"\n    def beta(a, b, size=None): return uninferable\n    def binomial(n, p, size=None): return uninferable\n    def bytes(length): return uninferable\n    def chisquare(df, size=None): return uninferable\n    def choice(a, size=None, replace=True, p=None): return uninferable\n    def dirichlet(alpha, size=None): return uninferable\n    def exponential(scale=1.0, size=None): return uninferable",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_random_mtrand",
        "documentation": {}
    },
    {
        "label": "numpy_supports_type_hints",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "peekOfCode": "def numpy_supports_type_hints() -> bool:\n    \"\"\"Returns True if numpy supports type hints.\"\"\"\n    np_ver = _get_numpy_version()\n    return np_ver and np_ver > NUMPY_VERSION_TYPE_HINTS_SUPPORT\ndef _get_numpy_version() -> tuple[str, str, str]:\n    \"\"\"\n    Return the numpy version number if numpy can be imported.\n    Otherwise returns ('0', '0', '0')\n    \"\"\"\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "infer_numpy_member",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "peekOfCode": "def infer_numpy_member(src, node, context: InferenceContext | None = None):\n    node = extract_node(src)\n    return node.infer(context=context)\ndef _is_a_numpy_module(node: Name) -> bool:\n    \"\"\"\n    Returns True if the node is a representation of a numpy module.\n    For example in :\n        import numpy as np\n        x = np.linspace(1, 2)\n    The node <Name.np> is a representation of the numpy module.",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "looks_like_numpy_member",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "peekOfCode": "def looks_like_numpy_member(member_name: str, node: NodeNG) -> bool:\n    \"\"\"\n    Returns True if the node is a member of numpy whose\n    name is member_name.\n    :param member_name: name of the member\n    :param node: node to test\n    :return: True if the node is a member of numpy\n    \"\"\"\n    if (\n        isinstance(node, Attribute)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "NUMPY_VERSION_TYPE_HINTS_SUPPORT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "peekOfCode": "NUMPY_VERSION_TYPE_HINTS_SUPPORT = (\"1\", \"20\", \"0\")\ndef numpy_supports_type_hints() -> bool:\n    \"\"\"Returns True if numpy supports type hints.\"\"\"\n    np_ver = _get_numpy_version()\n    return np_ver and np_ver > NUMPY_VERSION_TYPE_HINTS_SUPPORT\ndef _get_numpy_version() -> tuple[str, str, str]:\n    \"\"\"\n    Return the numpy version number if numpy can be imported.\n    Otherwise returns ('0', '0', '0')\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_numpy_utils",
        "documentation": {}
    },
    {
        "label": "infer_parents_subscript",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "peekOfCode": "def infer_parents_subscript(\n    subscript_node: nodes.Subscript, ctx: context.InferenceContext | None = None\n) -> Iterator[bases.Instance]:\n    if isinstance(subscript_node.slice, nodes.Const):\n        path_cls = next(_extract_single_node(PATH_TEMPLATE).infer())\n        return iter([path_cls.instantiate_class()])\n    raise UseInferenceDefault\nAstroidManager().register_transform(\n    nodes.Subscript,\n    inference_tip(infer_parents_subscript),",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "documentation": {}
    },
    {
        "label": "PATH_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "peekOfCode": "PATH_TEMPLATE = \"\"\"\nfrom pathlib import Path\nPath\n\"\"\"\ndef _looks_like_parents_subscript(node: nodes.Subscript) -> bool:\n    if not (\n        isinstance(node.value, nodes.Attribute) and node.value.attrname == \"parents\"\n    ):\n        return False\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pathlib",
        "documentation": {}
    },
    {
        "label": "pkg_resources_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def pkg_resources_transform():\n    return parse(\n        \"\"\"\ndef require(*requirements):\n    return pkg_resources.working_set.require(*requirements)\ndef run_script(requires, script_name):\n    return pkg_resources.working_set.run_script(requires, script_name)\ndef iter_entry_points(group, name=None):\n    return pkg_resources.working_set.iter_entry_points(group, name)\ndef resource_exists(package_or_requirement, resource_name):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "require",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def require(*requirements):\n    return pkg_resources.working_set.require(*requirements)\ndef run_script(requires, script_name):\n    return pkg_resources.working_set.run_script(requires, script_name)\ndef iter_entry_points(group, name=None):\n    return pkg_resources.working_set.iter_entry_points(group, name)\ndef resource_exists(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).has_resource(resource_name)\ndef resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "run_script",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def run_script(requires, script_name):\n    return pkg_resources.working_set.run_script(requires, script_name)\ndef iter_entry_points(group, name=None):\n    return pkg_resources.working_set.iter_entry_points(group, name)\ndef resource_exists(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).has_resource(resource_name)\ndef resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(\n        resource_name)\ndef resource_filename(package_or_requirement, resource_name):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "iter_entry_points",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def iter_entry_points(group, name=None):\n    return pkg_resources.working_set.iter_entry_points(group, name)\ndef resource_exists(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).has_resource(resource_name)\ndef resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(\n        resource_name)\ndef resource_filename(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_filename(\n        self, resource_name)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_exists",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_exists(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).has_resource(resource_name)\ndef resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(\n        resource_name)\ndef resource_filename(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_filename(\n        self, resource_name)\ndef resource_stream(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_stream(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_isdir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(\n        resource_name)\ndef resource_filename(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_filename(\n        self, resource_name)\ndef resource_stream(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_stream(\n        self, resource_name)\ndef resource_string(package_or_requirement, resource_name):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_filename",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_filename(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_filename(\n        self, resource_name)\ndef resource_stream(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_stream(\n        self, resource_name)\ndef resource_string(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_string(\n        self, resource_name)\ndef resource_listdir(package_or_requirement, resource_name):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_stream(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_stream(\n        self, resource_name)\ndef resource_string(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_string(\n        self, resource_name)\ndef resource_listdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_listdir(\n        resource_name)\ndef extraction_error():",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_string(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_string(\n        self, resource_name)\ndef resource_listdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_listdir(\n        resource_name)\ndef extraction_error():\n    pass\ndef get_cache_path(archive_name, names=()):\n    extract_path = self.extraction_path or get_default_cache()",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "resource_listdir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def resource_listdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_listdir(\n        resource_name)\ndef extraction_error():\n    pass\ndef get_cache_path(archive_name, names=()):\n    extract_path = self.extraction_path or get_default_cache()\n    target_path = os.path.join(extract_path, archive_name+'-tmp', *names)\n    return target_path\ndef postprocess(tempname, filename):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "extraction_error",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def extraction_error():\n    pass\ndef get_cache_path(archive_name, names=()):\n    extract_path = self.extraction_path or get_default_cache()\n    target_path = os.path.join(extract_path, archive_name+'-tmp', *names)\n    return target_path\ndef postprocess(tempname, filename):\n    pass\ndef set_extraction_path(path):\n    pass",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "get_cache_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def get_cache_path(archive_name, names=()):\n    extract_path = self.extraction_path or get_default_cache()\n    target_path = os.path.join(extract_path, archive_name+'-tmp', *names)\n    return target_path\ndef postprocess(tempname, filename):\n    pass\ndef set_extraction_path(path):\n    pass\ndef cleanup_resources(force=False):\n    pass",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "postprocess",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def postprocess(tempname, filename):\n    pass\ndef set_extraction_path(path):\n    pass\ndef cleanup_resources(force=False):\n    pass\ndef get_distribution(dist):\n    return Distribution(dist)\n_namespace_packages = {}\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "set_extraction_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def set_extraction_path(path):\n    pass\ndef cleanup_resources(force=False):\n    pass\ndef get_distribution(dist):\n    return Distribution(dist)\n_namespace_packages = {}\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"pkg_resources\", pkg_resources_transform)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "cleanup_resources",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def cleanup_resources(force=False):\n    pass\ndef get_distribution(dist):\n    return Distribution(dist)\n_namespace_packages = {}\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"pkg_resources\", pkg_resources_transform)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "get_distribution",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "def get_distribution(dist):\n    return Distribution(dist)\n_namespace_packages = {}\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"pkg_resources\", pkg_resources_transform)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "_namespace_packages",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "peekOfCode": "_namespace_packages = {}\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"pkg_resources\", pkg_resources_transform)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pkg_resources",
        "documentation": {}
    },
    {
        "label": "pytest_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_pytest",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_pytest",
        "peekOfCode": "def pytest_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"\ntry:\n    import _pytest.mark\n    import _pytest.recwarn\n    import _pytest.runner\n    import _pytest.python\n    import _pytest.skipping\n    import _pytest.assertion",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_pytest",
        "documentation": {}
    },
    {
        "label": "QObject",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "peekOfCode": "class QObject(object):\n    def emit(self, signal): pass\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"PyQt4.QtCore\", pyqt4_qtcore_transform)\nAstroidManager().register_transform(\n    nodes.FunctionDef, transform_pyqt_signal, _looks_like_signal\n)\nAstroidManager().register_transform(\n    nodes.ClassDef,",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "documentation": {}
    },
    {
        "label": "transform_pyqt_signal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "peekOfCode": "def transform_pyqt_signal(node: nodes.FunctionDef) -> None:\n    module = parse(\n        \"\"\"\n    _UNSET = object()\n    class pyqtSignal(object):\n        def connect(self, slot, type=None, no_receiver_check=False):\n            pass\n        def disconnect(self, slot=_UNSET):\n            pass\n        def emit(self, *args):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "documentation": {}
    },
    {
        "label": "transform_pyside_signal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "peekOfCode": "def transform_pyside_signal(node: nodes.FunctionDef) -> None:\n    module = parse(\n        \"\"\"\n    class NotPySideSignal(object):\n        def connect(self, receiver, type=None):\n            pass\n        def disconnect(self, receiver):\n            pass\n        def emit(self, *args):\n            pass",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "documentation": {}
    },
    {
        "label": "pyqt4_qtcore_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "peekOfCode": "def pyqt4_qtcore_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"\ndef SIGNAL(signal_name): pass\nclass QObject(object):\n    def emit(self, signal): pass\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"PyQt4.QtCore\", pyqt4_qtcore_transform)\nAstroidManager().register_transform(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "documentation": {}
    },
    {
        "label": "SIGNAL",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "peekOfCode": "def SIGNAL(signal_name): pass\nclass QObject(object):\n    def emit(self, signal): pass\n\"\"\"\n    )\nregister_module_extender(AstroidManager(), \"PyQt4.QtCore\", pyqt4_qtcore_transform)\nAstroidManager().register_transform(\n    nodes.FunctionDef, transform_pyqt_signal, _looks_like_signal\n)\nAstroidManager().register_transform(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_qt",
        "documentation": {}
    },
    {
        "label": "infer_random_sample",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "peekOfCode": "def infer_random_sample(node, context: InferenceContext | None = None):\n    if len(node.args) != 2:\n        raise UseInferenceDefault\n    inferred_length = helpers.safe_infer(node.args[1], context=context)\n    if not isinstance(inferred_length, Const):\n        raise UseInferenceDefault\n    if not isinstance(inferred_length.value, int):\n        raise UseInferenceDefault\n    inferred_sequence = helpers.safe_infer(node.args[0], context=context)\n    if not inferred_sequence:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "documentation": {}
    },
    {
        "label": "ACCEPTED_ITERABLES_FOR_SAMPLE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "peekOfCode": "ACCEPTED_ITERABLES_FOR_SAMPLE = (List, Set, Tuple)\ndef _clone_node_with_lineno(node, parent, lineno):\n    if isinstance(node, EvaluatedObject):\n        node = node.original\n    cls = node.__class__\n    other_fields = node._other_fields\n    _astroid_fields = node._astroid_fields\n    init_params = {\"lineno\": lineno, \"col_offset\": node.col_offset, \"parent\": parent}\n    postinit_params = {param: getattr(node, param) for param in _astroid_fields}\n    if other_fields:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_random",
        "documentation": {}
    },
    {
        "label": "infer_pattern_match",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "peekOfCode": "def infer_pattern_match(node: nodes.Call, ctx: context.InferenceContext | None = None):\n    \"\"\"Infer re.Pattern and re.Match as classes.\n    For PY39+ add `__class_getitem__`.\n    \"\"\"\n    class_def = nodes.ClassDef(\n        name=node.parent.targets[0].name,\n        lineno=node.lineno,\n        col_offset=node.col_offset,\n        parent=node.parent,\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "documentation": {}
    },
    {
        "label": "CLASS_GETITEM_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "peekOfCode": "CLASS_GETITEM_TEMPLATE = \"\"\"\n@classmethod\ndef __class_getitem__(cls, item):\n    return cls\n\"\"\"\ndef _looks_like_pattern_or_match(node: nodes.Call) -> bool:\n    \"\"\"Check for re.Pattern or re.Match call in stdlib.\n    Match these patterns from stdlib/re.py\n    ```py\n    Pattern = type(...)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_re",
        "documentation": {}
    },
    {
        "label": "infer_pattern_match",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "peekOfCode": "def infer_pattern_match(node: nodes.Call, ctx: context.InferenceContext | None = None):\n    \"\"\"Infer regex.Pattern and regex.Match as classes.\n    For PY39+ add `__class_getitem__`.\n    \"\"\"\n    class_def = nodes.ClassDef(\n        name=node.parent.targets[0].name,\n        lineno=node.lineno,\n        col_offset=node.col_offset,\n        parent=node.parent,\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "documentation": {}
    },
    {
        "label": "CLASS_GETITEM_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "peekOfCode": "CLASS_GETITEM_TEMPLATE = \"\"\"\n@classmethod\ndef __class_getitem__(cls, item):\n    return cls\n\"\"\"\ndef _looks_like_pattern_or_match(node: nodes.Call) -> bool:\n    \"\"\"Check for regex.Pattern or regex.Match call in stdlib.\n    Match these patterns from stdlib/re.py\n    ```py\n    Pattern = type(...)",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_regex",
        "documentation": {}
    },
    {
        "label": "responses_funcs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_responses",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_responses",
        "peekOfCode": "def responses_funcs():\n    return parse(\n        \"\"\"\n        DELETE = \"DELETE\"\n        GET = \"GET\"\n        HEAD = \"HEAD\"\n        OPTIONS = \"OPTIONS\"\n        PATCH = \"PATCH\"\n        POST = \"POST\"\n        PUT = \"PUT\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_responses",
        "documentation": {}
    },
    {
        "label": "scipy_signal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_scipy_signal",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_scipy_signal",
        "peekOfCode": "def scipy_signal():\n    return parse(\n        \"\"\"\n    # different functions defined in scipy.signals\n    def barthann(M, sym=True):\n        return numpy.ndarray([0])\n    def bartlett(M, sym=True):\n        return numpy.ndarray([0])\n    def blackman(M, sym=True):\n        return numpy.ndarray([0])",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_scipy_signal",
        "documentation": {}
    },
    {
        "label": "default_predicate",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "def default_predicate(line):\n    return line.strip()\ndef _indent(text, prefix, predicate=default_predicate) -> str:\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"\n    def prefixed_lines():",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "six_moves_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "def six_moves_transform():\n    code = dedent(\n        \"\"\"\n    class Moves(object):\n    {}\n    moves = Moves()\n    \"\"\"\n    ).format(_indent(_IMPORTS, \"    \"))\n    module = AstroidBuilder(AstroidManager()).string_build(code)\n    module.name = \"six.moves\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "transform_six_add_metaclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "def transform_six_add_metaclass(node):  # pylint: disable=inconsistent-return-statements\n    \"\"\"Check if the given class node is decorated with *six.add_metaclass*.\n    If so, inject its argument as the metaclass of the underlying class.\n    \"\"\"\n    if not node.decorators:\n        return\n    for decorator in node.decorators.nodes:\n        if not isinstance(decorator, nodes.Call):\n            continue\n        try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "transform_six_with_metaclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "def transform_six_with_metaclass(node):\n    \"\"\"Check if the given class node is defined with *six.with_metaclass*.\n    If so, inject its argument as the metaclass of the underlying class.\n    \"\"\"\n    call = node.bases[0]\n    node._metaclass = call.args[0]\n    node.bases = call.args[1:]\n    return node\nregister_module_extender(AstroidManager(), \"six\", six_moves_transform)\nregister_module_extender(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "SIX_ADD_METACLASS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "SIX_ADD_METACLASS = \"six.add_metaclass\"\nSIX_WITH_METACLASS = \"six.with_metaclass\"\ndef default_predicate(line):\n    return line.strip()\ndef _indent(text, prefix, predicate=default_predicate) -> str:\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "SIX_WITH_METACLASS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "SIX_WITH_METACLASS = \"six.with_metaclass\"\ndef default_predicate(line):\n    return line.strip()\ndef _indent(text, prefix, predicate=default_predicate) -> str:\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "_IMPORTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "_IMPORTS = \"\"\"\nimport _io\ncStringIO = _io.StringIO\nfilter = filter\nfrom itertools import filterfalse\ninput = input\nfrom sys import intern\nmap = map\nrange = range\nfrom importlib import reload",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "cStringIO",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "cStringIO = _io.StringIO\nfilter = filter\nfrom itertools import filterfalse\ninput = input\nfrom sys import intern\nmap = map\nrange = range\nfrom importlib import reload\nreload_module = lambda module: reload(module)\nfrom functools import reduce",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "filter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "filter = filter\nfrom itertools import filterfalse\ninput = input\nfrom sys import intern\nmap = map\nrange = range\nfrom importlib import reload\nreload_module = lambda module: reload(module)\nfrom functools import reduce\nfrom shlex import quote as shlex_quote",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "input = input\nfrom sys import intern\nmap = map\nrange = range\nfrom importlib import reload\nreload_module = lambda module: reload(module)\nfrom functools import reduce\nfrom shlex import quote as shlex_quote\nfrom io import StringIO\nfrom collections import UserDict, UserList, UserString",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "map",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "map = map\nrange = range\nfrom importlib import reload\nreload_module = lambda module: reload(module)\nfrom functools import reduce\nfrom shlex import quote as shlex_quote\nfrom io import StringIO\nfrom collections import UserDict, UserList, UserString\nxrange = range\nzip = zip",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "range",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "range = range\nfrom importlib import reload\nreload_module = lambda module: reload(module)\nfrom functools import reduce\nfrom shlex import quote as shlex_quote\nfrom io import StringIO\nfrom collections import UserDict, UserList, UserString\nxrange = range\nzip = zip\nfrom itertools import zip_longest",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "reload_module",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "reload_module = lambda module: reload(module)\nfrom functools import reduce\nfrom shlex import quote as shlex_quote\nfrom io import StringIO\nfrom collections import UserDict, UserList, UserString\nxrange = range\nzip = zip\nfrom itertools import zip_longest\nimport builtins\nimport configparser",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "xrange",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "xrange = range\nzip = zip\nfrom itertools import zip_longest\nimport builtins\nimport configparser\nimport copyreg\nimport _dummy_thread\nimport http.cookiejar as http_cookiejar\nimport http.cookies as http_cookies\nimport html.entities as html_entities",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "zip",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "zip = zip\nfrom itertools import zip_longest\nimport builtins\nimport configparser\nimport copyreg\nimport _dummy_thread\nimport http.cookiejar as http_cookiejar\nimport http.cookies as http_cookies\nimport html.entities as html_entities\nimport html.parser as html_parser",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "BaseHTTPServer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "peekOfCode": "BaseHTTPServer = CGIHTTPServer = SimpleHTTPServer = http.server\nimport pickle as cPickle\nimport queue\nimport reprlib\nimport socketserver\nimport _thread\nimport winreg\nimport xmlrpc.server as xmlrpc_server\nimport xmlrpc.client as xmlrpc_client\nimport urllib.robotparser as urllib_robotparser",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_six",
        "documentation": {}
    },
    {
        "label": "ssl_transform",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_ssl",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_ssl",
        "peekOfCode": "def ssl_transform():\n    return parse(\n        \"\"\"\n    # Import necessary for conversion of objects defined in C into enums\n    from enum import IntEnum as _IntEnum, IntFlag as _IntFlag\n    from _ssl import OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_INFO, OPENSSL_VERSION\n    from _ssl import _SSLContext, MemoryBIO\n    from _ssl import (\n        SSLError, SSLZeroReturnError, SSLWantReadError, SSLWantWriteError,\n        SSLSyscallError, SSLEOFError,",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_ssl",
        "documentation": {}
    },
    {
        "label": "infer_type_sub",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_type",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_type",
        "peekOfCode": "def infer_type_sub(node, context: InferenceContext | None = None):\n    \"\"\"\n    Infer a type[...] subscript.\n    :param node: node to infer\n    :type node: astroid.nodes.node_classes.NodeNG\n    :return: the inferred node\n    :rtype: nodes.NodeNG\n    \"\"\"\n    node_scope, _ = node.scope().lookup(\"type\")\n    if not isinstance(node_scope, nodes.Module) or node_scope.qname() != \"builtins\":",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_type",
        "documentation": {}
    },
    {
        "label": "Meta",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "class Meta(type):\n    def __getitem__(self, item):\n        return self\n    @property\n    def __args__(self):\n        return ()\nclass {0}(metaclass=Meta):\n    pass\n\"\"\"\nTYPING_MEMBERS = set(getattr(typing, \"__all__\", []))",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "{0}",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "class {0}(metaclass=Meta):\n    pass\n\"\"\"\nTYPING_MEMBERS = set(getattr(typing, \"__all__\", []))\nTYPING_ALIAS = frozenset(\n    (\n        \"typing.Hashable\",\n        \"typing.Awaitable\",\n        \"typing.Coroutine\",\n        \"typing.AsyncIterable\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "looks_like_typing_typevar_or_newtype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def looks_like_typing_typevar_or_newtype(node) -> bool:\n    func = node.func\n    if isinstance(func, Attribute):\n        return func.attrname in TYPING_TYPEVARS\n    if isinstance(func, Name):\n        return func.name in TYPING_TYPEVARS\n    return False\ndef infer_typing_typevar_or_newtype(node, context_itton=None):\n    \"\"\"Infer a typing.TypeVar(...) or typing.NewType(...) call.\"\"\"\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_typing_typevar_or_newtype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_typing_typevar_or_newtype(node, context_itton=None):\n    \"\"\"Infer a typing.TypeVar(...) or typing.NewType(...) call.\"\"\"\n    try:\n        func = next(node.func.infer(context=context_itton))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if func.qname() not in TYPING_TYPEVARS_QUALIFIED:\n        raise UseInferenceDefault\n    if not node.args:\n        raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_typing_attr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_typing_attr(\n    node: Subscript, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    \"\"\"Infer a typing.X[...] subscript.\"\"\"\n    try:\n        value = next(node.value.infer())  # type: ignore[union-attr] # value shouldn't be None for Subscript.\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if not value.qname().startswith(\"typing.\") or value.qname() in TYPING_ALIAS:\n        # If typing subscript belongs to an alias handle it separately.",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_old_typedDict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_old_typedDict(  # pylint: disable=invalid-name\n    node: ClassDef, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    func_to_add = _extract_single_node(\"dict\")\n    node.locals[\"__call__\"] = [func_to_add]\n    return iter([node])\ndef infer_typedDict(  # pylint: disable=invalid-name\n    node: FunctionDef, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    \"\"\"Replace TypedDict FunctionDef with ClassDef.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_typedDict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_typedDict(  # pylint: disable=invalid-name\n    node: FunctionDef, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    \"\"\"Replace TypedDict FunctionDef with ClassDef.\"\"\"\n    class_def = ClassDef(\n        name=\"TypedDict\",\n        lineno=node.lineno,\n        col_offset=node.col_offset,\n        parent=node.parent,\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_typing_alias",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_typing_alias(\n    node: Call, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    \"\"\"\n    Infers the call to _alias function\n    Insert ClassDef, with same name as aliased class,\n    in mro to simulate _GenericAlias.\n    :param node: call node\n    :param context: inference context\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_special_alias",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_special_alias(\n    node: Call, ctx: context.InferenceContext | None = None\n) -> Iterator[ClassDef]:\n    \"\"\"Infer call to tuple alias as new subscriptable class typing.Tuple.\"\"\"\n    if not (\n        isinstance(node.parent, Assign)\n        and len(node.parent.targets) == 1\n        and isinstance(node.parent.targets[0], AssignName)\n    ):\n        raise UseInferenceDefault",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "infer_typing_cast",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "def infer_typing_cast(\n    node: Call, ctx: context.InferenceContext | None = None\n) -> Iterator[NodeNG]:\n    \"\"\"Infer call to cast() returning same type as casted-from var.\"\"\"\n    if not isinstance(node.func, (Name, Attribute)):\n        raise UseInferenceDefault\n    try:\n        func = next(node.func.infer(context=ctx))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "TYPING_TYPEVARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "TYPING_TYPEVARS = {\"TypeVar\", \"NewType\"}\nTYPING_TYPEVARS_QUALIFIED: Final = {\n    \"typing.TypeVar\",\n    \"typing.NewType\",\n    \"typing_extensions.TypeVar\",\n}\nTYPING_TYPEDDICT_QUALIFIED: Final = {\"typing.TypedDict\", \"typing_extensions.TypedDict\"}\nTYPING_TYPE_TEMPLATE = \"\"\"\nclass Meta(type):\n    def __getitem__(self, item):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "TYPING_TYPE_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "TYPING_TYPE_TEMPLATE = \"\"\"\nclass Meta(type):\n    def __getitem__(self, item):\n        return self\n    @property\n    def __args__(self):\n        return ()\nclass {0}(metaclass=Meta):\n    pass\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "TYPING_MEMBERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "TYPING_MEMBERS = set(getattr(typing, \"__all__\", []))\nTYPING_ALIAS = frozenset(\n    (\n        \"typing.Hashable\",\n        \"typing.Awaitable\",\n        \"typing.Coroutine\",\n        \"typing.AsyncIterable\",\n        \"typing.AsyncIterator\",\n        \"typing.Iterable\",\n        \"typing.Iterator\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "TYPING_ALIAS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "TYPING_ALIAS = frozenset(\n    (\n        \"typing.Hashable\",\n        \"typing.Awaitable\",\n        \"typing.Coroutine\",\n        \"typing.AsyncIterable\",\n        \"typing.AsyncIterator\",\n        \"typing.Iterable\",\n        \"typing.Iterator\",\n        \"typing.Reversible\",",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "CLASS_GETITEM_TEMPLATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "peekOfCode": "CLASS_GETITEM_TEMPLATE = \"\"\"\n@classmethod\ndef __class_getitem__(cls, item):\n    return cls\n\"\"\"\ndef looks_like_typing_typevar_or_newtype(node) -> bool:\n    func = node.func\n    if isinstance(func, Attribute):\n        return func.attrname in TYPING_TYPEVARS\n    if isinstance(func, Name):",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_typing",
        "documentation": {}
    },
    {
        "label": "IsolatedAsyncioTestCaseImport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.brain_unittest",
        "description": "__pypackages__.3.10.lib.astroid.brain.brain_unittest",
        "peekOfCode": "def IsolatedAsyncioTestCaseImport():\n    \"\"\"\n    In the unittest package, the IsolatedAsyncioTestCase class is imported lazily.\n    I.E. only when the ``__getattr__`` method of the unittest module is called with\n    'IsolatedAsyncioTestCase' as argument. Thus the IsolatedAsyncioTestCase\n    is not imported statically (during import time).\n    This function mocks a classical static import of the IsolatedAsyncioTestCase.\n    (see https://github.com/PyCQA/pylint/issues/4060)\n    \"\"\"\n    return parse(",
        "detail": "__pypackages__.3.10.lib.astroid.brain.brain_unittest",
        "documentation": {}
    },
    {
        "label": "register_module_extender",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.brain.helpers",
        "description": "__pypackages__.3.10.lib.astroid.brain.helpers",
        "peekOfCode": "def register_module_extender(\n    manager: AstroidManager, module_name: str, get_extension_mod: Callable[[], Module]\n) -> None:\n    def transform(node: Module) -> None:\n        extension_module = get_extension_mod()\n        for name, objs in extension_module.locals.items():\n            node.locals[name] = objs\n            for obj in objs:\n                if obj.parent is extension_module:\n                    obj.parent = node",
        "detail": "__pypackages__.3.10.lib.astroid.brain.helpers",
        "documentation": {}
    },
    {
        "label": "ModuleType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class ModuleType(enum.Enum):\n    \"\"\"Python module types used for ModuleSpec.\"\"\"\n    C_BUILTIN = enum.auto()\n    C_EXTENSION = enum.auto()\n    PKG_DIRECTORY = enum.auto()\n    PY_CODERESOURCE = enum.auto()\n    PY_COMPILED = enum.auto()\n    PY_FROZEN = enum.auto()\n    PY_RESOURCE = enum.auto()\n    PY_SOURCE = enum.auto()",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "ModuleSpec",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class ModuleSpec(NamedTuple):\n    \"\"\"Defines a class similar to PEP 420's ModuleSpec.\n    A module spec defines a name of a module, its type, location\n    and where submodules can be found, if the module is a package.\n    \"\"\"\n    name: str\n    type: ModuleType | None\n    location: str | None = None\n    origin: str | None = None\n    submodule_search_locations: Sequence[str] | None = None",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "Finder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class Finder:\n    \"\"\"A finder is a class which knows how to find a particular module.\"\"\"\n    def __init__(self, path: Sequence[str] | None = None) -> None:\n        self._path = path or sys.path\n    @abc.abstractmethod\n    def find_module(\n        self,\n        modname: str,\n        module_parts: Sequence[str],\n        processed: list[str],",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "ImportlibFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class ImportlibFinder(Finder):\n    \"\"\"A finder based on the importlib module.\"\"\"\n    _SUFFIXES: Sequence[tuple[str, ModuleType]] = (\n        [(s, ModuleType.C_EXTENSION) for s in importlib.machinery.EXTENSION_SUFFIXES]\n        + [(s, ModuleType.PY_SOURCE) for s in importlib.machinery.SOURCE_SUFFIXES]\n        + [(s, ModuleType.PY_COMPILED) for s in importlib.machinery.BYTECODE_SUFFIXES]\n    )\n    def find_module(\n        self,\n        modname: str,",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "ExplicitNamespacePackageFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class ExplicitNamespacePackageFinder(ImportlibFinder):\n    \"\"\"A finder for the explicit namespace packages.\"\"\"\n    def find_module(\n        self,\n        modname: str,\n        module_parts: Sequence[str],\n        processed: list[str],\n        submodule_path: Sequence[str] | None,\n    ) -> ModuleSpec | None:\n        if processed:",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "ZipFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class ZipFinder(Finder):\n    \"\"\"Finder that knows how to find a module inside zip files.\"\"\"\n    def __init__(self, path: Sequence[str]) -> None:\n        super().__init__(path)\n        for entry_path in path:\n            if entry_path not in sys.path_importer_cache:\n                # pylint: disable=no-member\n                try:\n                    sys.path_importer_cache[entry_path] = zipimport.zipimporter(  # type: ignore[assignment]\n                        entry_path",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "PathSpecFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "class PathSpecFinder(Finder):\n    \"\"\"Finder based on importlib.machinery.PathFinder.\"\"\"\n    def find_module(\n        self,\n        modname: str,\n        module_parts: Sequence[str],\n        processed: list[str],\n        submodule_path: Sequence[str] | None,\n    ) -> ModuleSpec | None:\n        spec = importlib.machinery.PathFinder.find_spec(modname, path=submodule_path)",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "find_spec",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "def find_spec(modpath: list[str], path: Sequence[str] | None = None) -> ModuleSpec:\n    \"\"\"Find a spec for the given module.\n    :type modpath: list or tuple\n    :param modpath:\n      split module's name (i.e name of a module or package split\n      on '.'), with leading empty strings for explicit relative import\n    :type path: list or None\n    :param path:\n      optional list of path where the module or package should be\n      searched (use sys.path if nothing or None is given)",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "_SPEC_FINDERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "peekOfCode": "_SPEC_FINDERS = (\n    ImportlibFinder,\n    ZipFinder,\n    PathSpecFinder,\n    ExplicitNamespacePackageFinder,\n)\ndef _is_setuptools_namespace(location: pathlib.Path) -> bool:\n    try:\n        with open(location / \"__init__.py\", \"rb\") as stream:\n            data = stream.read(4096)",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.spec",
        "documentation": {}
    },
    {
        "label": "is_namespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter._import.util",
        "description": "__pypackages__.3.10.lib.astroid.interpreter._import.util",
        "peekOfCode": "def is_namespace(modname: str) -> bool:\n    from astroid.modutils import (  # pylint: disable=import-outside-toplevel\n        EXT_LIB_DIRS,\n        STD_LIB_DIRS,\n    )\n    STD_AND_EXT_LIB_DIRS = STD_LIB_DIRS.union(EXT_LIB_DIRS)\n    if modname in sys.builtin_module_names:\n        return False\n    found_spec = None\n    # find_spec() attempts to import parent packages when given dotted paths.",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter._import.util",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.dunder_lookup",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.dunder_lookup",
        "peekOfCode": "def lookup(node, name) -> list:\n    \"\"\"Lookup the given special method name in the given *node*.\n    If the special method was found, then a list of attributes\n    will be returned. Otherwise, `astroid.AttributeInferenceError`\n    is going to be raised.\n    \"\"\"\n    if isinstance(\n        node, (astroid.List, astroid.Tuple, astroid.Const, astroid.Dict, astroid.Set)\n    ):\n        return _builtin_lookup(node, name)",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.dunder_lookup",
        "documentation": {}
    },
    {
        "label": "ObjectModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ObjectModel:\n    def __init__(self):\n        self._instance = None\n    def __repr__(self):\n        result = []\n        cname = type(self).__name__\n        string = \"%(cname)s(%(fields)s)\"\n        alignment = len(cname) + 1\n        for field in sorted(self.attributes()):\n            width = 80 - len(field) - alignment",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ModuleModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ModuleModel(ObjectModel):\n    def _builtins(self):\n        builtins_ast_module = AstroidManager().builtins_module\n        return builtins_ast_module.special_attributes.lookup(\"__dict__\")\n    @property\n    def attr_builtins(self):\n        return self._builtins()\n    @property\n    def attr___path__(self):\n        if not self._instance.package:",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "FunctionModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class FunctionModel(ObjectModel):\n    @property\n    def attr___name__(self):\n        return node_classes.Const(value=self._instance.name, parent=self._instance)\n    @property\n    def attr___doc__(self):\n        return node_classes.Const(\n            value=getattr(self._instance.doc_node, \"value\", None),\n            parent=self._instance,\n        )",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ClassModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ClassModel(ObjectModel):\n    def __init__(self):\n        # Add a context so that inferences called from an instance don't recurse endlessly\n        self.context = InferenceContext()\n        super().__init__()\n    @property\n    def attr___module__(self):\n        return node_classes.Const(self._instance.root().qname())\n    @property\n    def attr___name__(self):",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "SuperModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class SuperModel(ObjectModel):\n    @property\n    def attr___thisclass__(self):\n        return self._instance.mro_pointer\n    @property\n    def attr___self_class__(self):\n        return self._instance._self_class\n    @property\n    def attr___self__(self):\n        return self._instance.type",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "UnboundMethodModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class UnboundMethodModel(ObjectModel):\n    @property\n    def attr___class__(self):\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import helpers\n        return helpers.object_type(self._instance)\n    @property\n    def attr___func__(self):\n        return self._instance._proxied\n    @property",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ContextManagerModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ContextManagerModel(ObjectModel):\n    \"\"\"Model for context managers.\n    Based on 3.3.9 of the Data Model documentation:\n    https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers\n    \"\"\"\n    @property\n    def attr___enter__(self) -> bases.BoundMethod:\n        \"\"\"Representation of the base implementation of __enter__.\n        As per Python documentation:\n        Enter the runtime context related to this object. The with statement",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "BoundMethodModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class BoundMethodModel(FunctionModel):\n    @property\n    def attr___func__(self):\n        return self._instance._proxied._proxied\n    @property\n    def attr___self__(self):\n        return self._instance.bound\nclass GeneratorModel(FunctionModel, ContextManagerModel):\n    def __new__(cls, *args, **kwargs):\n        # Append the values from the GeneratorType unto this object.",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "GeneratorModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class GeneratorModel(FunctionModel, ContextManagerModel):\n    def __new__(cls, *args, **kwargs):\n        # Append the values from the GeneratorType unto this object.\n        ret = super().__new__(cls, *args, **kwargs)\n        generator = AstroidManager().builtins_module[\"generator\"]\n        for name, values in generator.locals.items():\n            method = values[0]\n            def patched(cls, meth=method):\n                return meth\n            setattr(type(ret), IMPL_PREFIX + name, property(patched))",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "AsyncGeneratorModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class AsyncGeneratorModel(GeneratorModel):\n    def __new__(cls, *args, **kwargs):\n        # Append the values from the AGeneratorType unto this object.\n        ret = super().__new__(cls, *args, **kwargs)\n        astroid_builtins = AstroidManager().builtins_module\n        generator = astroid_builtins.get(\"async_generator\")\n        if generator is None:\n            # Make it backward compatible.\n            generator = astroid_builtins.get(\"generator\")\n        for name, values in generator.locals.items():",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "InstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class InstanceModel(ObjectModel):\n    @property\n    def attr___class__(self):\n        return self._instance._proxied\n    @property\n    def attr___module__(self):\n        return node_classes.Const(self._instance.root().qname())\n    @property\n    def attr___doc__(self):\n        return node_classes.Const(getattr(self._instance.doc_node, \"value\", None))",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ExceptionInstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ExceptionInstanceModel(InstanceModel):\n    @property\n    def attr_args(self) -> nodes.Tuple:\n        return nodes.Tuple(parent=self._instance)\n    @property\n    def attr___traceback__(self):\n        builtins_ast_module = AstroidManager().builtins_module\n        traceback_type = builtins_ast_module[types.TracebackType.__name__]\n        return traceback_type.instantiate_class()\nclass SyntaxErrorInstanceModel(ExceptionInstanceModel):",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "SyntaxErrorInstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class SyntaxErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_text(self):\n        return node_classes.Const(\"\")\nclass OSErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_filename(self):\n        return node_classes.Const(\"\")\n    @property\n    def attr_errno(self):",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "OSErrorInstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class OSErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_filename(self):\n        return node_classes.Const(\"\")\n    @property\n    def attr_errno(self):\n        return node_classes.Const(0)\n    @property\n    def attr_strerror(self):\n        return node_classes.Const(\"\")",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "ImportErrorInstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class ImportErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_name(self):\n        return node_classes.Const(\"\")\n    @property\n    def attr_path(self):\n        return node_classes.Const(\"\")\nclass UnicodeDecodeErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_object(self):",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "UnicodeDecodeErrorInstanceModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class UnicodeDecodeErrorInstanceModel(ExceptionInstanceModel):\n    @property\n    def attr_object(self):\n        return node_classes.Const(\"\")\nBUILTIN_EXCEPTIONS = {\n    \"builtins.SyntaxError\": SyntaxErrorInstanceModel,\n    \"builtins.ImportError\": ImportErrorInstanceModel,\n    \"builtins.UnicodeDecodeError\": UnicodeDecodeErrorInstanceModel,\n    # These are all similar to OSError in terms of attributes\n    \"builtins.OSError\": OSErrorInstanceModel,",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "DictModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class DictModel(ObjectModel):\n    @property\n    def attr___class__(self):\n        return self._instance._proxied\n    def _generic_dict_attribute(self, obj, name):\n        \"\"\"Generate a bound method that can infer the given *obj*.\"\"\"\n        class DictMethodBoundMethod(astroid.BoundMethod):\n            def infer_call_result(\n                self, caller, context: InferenceContext | None = None\n            ):",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "PropertyModel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "class PropertyModel(ObjectModel):\n    \"\"\"Model for a builtin property.\"\"\"\n    def _init_function(self, name):\n        function = nodes.FunctionDef(name=name, parent=self._instance)\n        args = nodes.Arguments(parent=function)\n        args.postinit(\n            args=[],\n            defaults=[],\n            kwonlyargs=[],\n            kw_defaults=[],",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "objects",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "objects = util.lazy_import(\"objects\")\nbuilder = util.lazy_import(\"builder\")\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from typing_extensions import Literal\nif TYPE_CHECKING:\n    from astroid import builder\n    from astroid.objects import Property\nIMPL_PREFIX = \"attr_\"",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "builder",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "builder = util.lazy_import(\"builder\")\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from typing_extensions import Literal\nif TYPE_CHECKING:\n    from astroid import builder\n    from astroid.objects import Property\nIMPL_PREFIX = \"attr_\"\nLEN_OF_IMPL_PREFIX = len(IMPL_PREFIX)",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "IMPL_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "IMPL_PREFIX = \"attr_\"\nLEN_OF_IMPL_PREFIX = len(IMPL_PREFIX)\ndef _dunder_dict(instance, attributes):\n    obj = node_classes.Dict(parent=instance)\n    # Convert the keys to node strings\n    keys = [\n        node_classes.Const(value=value, parent=obj) for value in list(attributes.keys())\n    ]\n    # The original attribute has a list of elements for each key,\n    # but that is not useful for retrieving the special attribute's value.",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "LEN_OF_IMPL_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "LEN_OF_IMPL_PREFIX = len(IMPL_PREFIX)\ndef _dunder_dict(instance, attributes):\n    obj = node_classes.Dict(parent=instance)\n    # Convert the keys to node strings\n    keys = [\n        node_classes.Const(value=value, parent=obj) for value in list(attributes.keys())\n    ]\n    # The original attribute has a list of elements for each key,\n    # but that is not useful for retrieving the special attribute's value.\n    # In this case, we're picking the last value from each list.",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "BUILTIN_EXCEPTIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "description": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "peekOfCode": "BUILTIN_EXCEPTIONS = {\n    \"builtins.SyntaxError\": SyntaxErrorInstanceModel,\n    \"builtins.ImportError\": ImportErrorInstanceModel,\n    \"builtins.UnicodeDecodeError\": UnicodeDecodeErrorInstanceModel,\n    # These are all similar to OSError in terms of attributes\n    \"builtins.OSError\": OSErrorInstanceModel,\n    \"builtins.BlockingIOError\": OSErrorInstanceModel,\n    \"builtins.BrokenPipeError\": OSErrorInstanceModel,\n    \"builtins.ChildProcessError\": OSErrorInstanceModel,\n    \"builtins.ConnectionAbortedError\": OSErrorInstanceModel,",
        "detail": "__pypackages__.3.10.lib.astroid.interpreter.objectmodel",
        "documentation": {}
    },
    {
        "label": "LocalsDictNodeNG",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "peekOfCode": "class LocalsDictNodeNG(node_classes.LookupMixIn):\n    \"\"\"this class provides locals handling common to Module, FunctionDef\n    and ClassDef nodes, including a dict like interface for direct access\n    to locals information\n    \"\"\"\n    # attributes below are set by the builder module or by raw factories\n    locals: dict[str, list[SuccessfulInferenceResult]] = {}\n    \"\"\"A map of the name of a local variable to the node defining the local.\"\"\"\n    def qname(self) -> str:\n        \"\"\"Get the 'qualified' name of the node.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "documentation": {}
    },
    {
        "label": "ComprehensionScope",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "peekOfCode": "class ComprehensionScope(LocalsDictNodeNG):\n    \"\"\"Scoping for different types of comprehensions.\"\"\"\n    scope_lookup = LocalsDictNodeNG._scope_lookup\n    generators: list[nodes.Comprehension]\n    \"\"\"The generators that are looped through.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "peekOfCode": "_T = TypeVar(\"_T\")\nclass LocalsDictNodeNG(node_classes.LookupMixIn):\n    \"\"\"this class provides locals handling common to Module, FunctionDef\n    and ClassDef nodes, including a dict like interface for direct access\n    to locals information\n    \"\"\"\n    # attributes below are set by the builder module or by raw factories\n    locals: dict[str, list[SuccessfulInferenceResult]] = {}\n    \"\"\"A map of the name of a local variable to the node defining the local.\"\"\"\n    def qname(self) -> str:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.mixin",
        "documentation": {}
    },
    {
        "label": "Module",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class Module(LocalsDictNodeNG):\n    \"\"\"Class representing an :class:`ast.Module` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('import astroid')\n    >>> node\n    <Import l.1 at 0x7f23b2e4e5c0>\n    >>> node.parent\n    <Module l.0 at 0x7f23b2e4eda0>\n    \"\"\"\n    _astroid_fields = (\"doc_node\", \"body\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "GeneratorExp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class GeneratorExp(ComprehensionScope):\n    \"\"\"Class representing an :class:`ast.GeneratorExp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('(thing for thing in things if thing)')\n    >>> node\n    <GeneratorExp l.1 at 0x7f23b2e4e400>\n    \"\"\"\n    _astroid_fields = (\"elt\", \"generators\")\n    _other_other_fields = (\"locals\",)\n    elt = None",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "DictComp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class DictComp(ComprehensionScope):\n    \"\"\"Class representing an :class:`ast.DictComp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('{k:v for k, v in things if k > v}')\n    >>> node\n    <DictComp l.1 at 0x7f23b2e41d68>\n    \"\"\"\n    _astroid_fields = (\"key\", \"value\", \"generators\")\n    _other_other_fields = (\"locals\",)\n    key = None",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "SetComp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class SetComp(ComprehensionScope):\n    \"\"\"Class representing an :class:`ast.SetComp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('{thing for thing in things if thing}')\n    >>> node\n    <SetComp l.1 at 0x7f23b2e41898>\n    \"\"\"\n    _astroid_fields = (\"elt\", \"generators\")\n    _other_other_fields = (\"locals\",)\n    elt = None",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ListComp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class ListComp(ComprehensionScope):\n    \"\"\"Class representing an :class:`ast.ListComp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('[thing for thing in things if thing]')\n    >>> node\n    <ListComp l.1 at 0x7f23b2e418d0>\n    \"\"\"\n    _astroid_fields = (\"elt\", \"generators\")\n    _other_other_fields = (\"locals\",)\n    elt = None",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "Lambda",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class Lambda(_base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG):\n    \"\"\"Class representing an :class:`ast.Lambda` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('lambda arg: arg + 1')\n    >>> node\n    <Lambda.<lambda> l.1 at 0x7f23b2e41518>\n    \"\"\"\n    _astroid_fields = (\"args\", \"body\")\n    _other_other_fields = (\"locals\",)\n    name = \"<lambda>\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "FunctionDef",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class FunctionDef(_base_nodes.MultiLineBlockNode, _base_nodes.Statement, Lambda):\n    \"\"\"Class representing an :class:`ast.FunctionDef`.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    ... def my_func(arg):\n    ...     return arg + 1\n    ... ''')\n    >>> node\n    <FunctionDef.my_func l.2 at 0x7f23b2e71e10>\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "AsyncFunctionDef",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class AsyncFunctionDef(FunctionDef):\n    \"\"\"Class representing an :class:`ast.FunctionDef` node.\n    A :class:`AsyncFunctionDef` is an asynchronous function\n    created with the `async` keyword.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        async for thing in things:\n            print(thing)\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ClassDef",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "class ClassDef(\n    _base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.ClassDef` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    class Thing:\n        def my_meth(self, arg):\n            return arg + self.offset\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "clean_typing_generic_mro",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "def clean_typing_generic_mro(sequences: list[list[ClassDef]]) -> None:\n    \"\"\"A class can inherit from typing.Generic directly, as base,\n    and as base of bases. The merged MRO must however only contain the last entry.\n    To prepare for _c3_merge, remove some typing.Generic entries from\n    sequences if multiple are present.\n    This method will check if Generic is in inferred_bases and also\n    part of bases_mro. If true, remove it from inferred_bases\n    as well as its entry the bases_mro.\n    Format sequences: [[self]] + bases_mro + [inferred_bases]\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "clean_duplicates_mro",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "def clean_duplicates_mro(sequences, cls, context):\n    for sequence in sequences:\n        names = [\n            (node.lineno, node.qname()) if node.name else None for node in sequence\n        ]\n        last_index = dict(map(reversed, enumerate(names)))\n        if names and names[0] is not None and last_index[names[0]] != 0:\n            raise DuplicateBasesError(\n                message=\"Duplicates found in MROs {mros} for {cls!r}.\",\n                mros=sequences,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "function_to_method",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "def function_to_method(n, klass):\n    if isinstance(n, FunctionDef):\n        if n.type == \"classmethod\":\n            return bases.BoundMethod(n, klass)\n        if n.type == \"property\":\n            return n\n        if n.type != \"staticmethod\":\n            return bases.UnboundMethod(n)\n    return n\nclass Module(LocalsDictNodeNG):",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "get_wrapping_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "def get_wrapping_class(node):\n    \"\"\"Get the class that wraps the given node.\n    We consider that a class wraps a node if the class\n    is a parent for the said node.\n    :returns: The class that wraps the given node\n    :rtype: ClassDef or None\n    \"\"\"\n    klass = node.frame(future=True)\n    while klass is not None and not isinstance(klass, ClassDef):\n        if klass.parent is None:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "ITER_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "ITER_METHODS = (\"__iter__\", \"__getitem__\")\nEXCEPTION_BASE_CLASSES = frozenset({\"Exception\", \"BaseException\"})\nobjects = util.lazy_import(\"objects\")\nBUILTIN_DESCRIPTORS = frozenset(\n    {\"classmethod\", \"staticmethod\", \"builtins.classmethod\", \"builtins.staticmethod\"}\n)\n_T = TypeVar(\"_T\")\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from http://www.python.org/download/releases/2.3/mro/.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "EXCEPTION_BASE_CLASSES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "EXCEPTION_BASE_CLASSES = frozenset({\"Exception\", \"BaseException\"})\nobjects = util.lazy_import(\"objects\")\nBUILTIN_DESCRIPTORS = frozenset(\n    {\"classmethod\", \"staticmethod\", \"builtins.classmethod\", \"builtins.staticmethod\"}\n)\n_T = TypeVar(\"_T\")\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "objects",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "objects = util.lazy_import(\"objects\")\nBUILTIN_DESCRIPTORS = frozenset(\n    {\"classmethod\", \"staticmethod\", \"builtins.classmethod\", \"builtins.staticmethod\"}\n)\n_T = TypeVar(\"_T\")\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n    \"\"\"\n    result = []",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "BUILTIN_DESCRIPTORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "BUILTIN_DESCRIPTORS = frozenset(\n    {\"classmethod\", \"staticmethod\", \"builtins.classmethod\", \"builtins.staticmethod\"}\n)\n_T = TypeVar(\"_T\")\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n    \"\"\"\n    result = []\n    while True:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "peekOfCode": "_T = TypeVar(\"_T\")\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n    \"\"\"\n    result = []\n    while True:\n        sequences = [s for s in sequences if s]  # purge empty sequences\n        if not sequences:\n            return result",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.scoped_nodes",
        "documentation": {}
    },
    {
        "label": "builtin_lookup",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.utils",
        "description": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.utils",
        "peekOfCode": "def builtin_lookup(name: str) -> tuple[nodes.Module, Sequence[nodes.NodeNG]]:\n    \"\"\"Lookup a name in the builtin module.\n    Return the list of matching statements and the ast for the builtin module\n    \"\"\"\n    manager = AstroidManager()\n    try:\n        _builtin_astroid = manager.builtins_module\n    except KeyError:\n        # User manipulated the astroid cache directly! Rebuild everything.\n        manager.clear_cache()",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.scoped_nodes.utils",
        "documentation": {}
    },
    {
        "label": "Statement",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class Statement(NodeNG):\n    \"\"\"Statement node adding a few attributes.\n    NOTE: This class is part of the public API of 'astroid.nodes'.\n    \"\"\"\n    is_statement = True\n    \"\"\"Whether this node indicates a statement.\"\"\"\n    def next_sibling(self):\n        \"\"\"The next sibling statement node.\n        :returns: The next sibling statement node.\n        :rtype: NodeNG or None",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "NoChildrenNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class NoChildrenNode(NodeNG):\n    \"\"\"Base nodes for nodes with no children, e.g. Pass.\"\"\"\n    def get_children(self) -> Iterator[NodeNG]:\n        yield from ()\nclass FilterStmtsBaseNode(NodeNG):\n    \"\"\"Base node for statement filtering and assignment type.\"\"\"\n    def _get_filtered_stmts(self, _, node, _stmts, mystmt: Statement | None):\n        \"\"\"Method used in _filter_stmts to get statements and trigger break.\"\"\"\n        if self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keep",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "FilterStmtsBaseNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class FilterStmtsBaseNode(NodeNG):\n    \"\"\"Base node for statement filtering and assignment type.\"\"\"\n    def _get_filtered_stmts(self, _, node, _stmts, mystmt: Statement | None):\n        \"\"\"Method used in _filter_stmts to get statements and trigger break.\"\"\"\n        if self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keep\n            # current node (gen exp, list comp)\n            return [node], True\n        return _stmts, False\n    def assign_type(self):",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "AssignTypeNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class AssignTypeNode(NodeNG):\n    \"\"\"Base node for nodes that can 'assign' such as AnnAssign.\"\"\"\n    def assign_type(self):\n        return self\n    def _get_filtered_stmts(self, lookup_node, node, _stmts, mystmt: Statement | None):\n        \"\"\"Method used in filter_stmts.\"\"\"\n        if self is mystmt:\n            return _stmts, True\n        if self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keep",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ParentAssignNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class ParentAssignNode(AssignTypeNode):\n    \"\"\"Base node for nodes whose assign_type is determined by the parent node.\"\"\"\n    def assign_type(self):\n        return self.parent.assign_type()\nclass ImportNode(FilterStmtsBaseNode, NoChildrenNode, Statement):\n    \"\"\"Base node for From and Import Nodes.\"\"\"\n    modname: str | None\n    \"\"\"The module that is being imported from.\n    This is ``None`` for relative imports.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "ImportNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class ImportNode(FilterStmtsBaseNode, NoChildrenNode, Statement):\n    \"\"\"Base node for From and Import Nodes.\"\"\"\n    modname: str | None\n    \"\"\"The module that is being imported from.\n    This is ``None`` for relative imports.\n    \"\"\"\n    names: list[tuple[str, str | None]]\n    \"\"\"What is being imported from the module.\n    Each entry is a :class:`tuple` of the name being imported,\n    and the alias that the name is assigned to (if any).",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "MultiLineBlockNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class MultiLineBlockNode(NodeNG):\n    \"\"\"Base node for multi-line blocks, e.g. For and FunctionDef.\n    Note that this does not apply to every node with a `body` field.\n    For instance, an If node has a multi-line body, but the body of an\n    IfExpr is not multi-line, and hence cannot contain Return nodes,\n    Assign nodes, etc.\n    \"\"\"\n    _multi_line_block_fields: ClassVar[tuple[str, ...]] = ()\n    @cached_property\n    def _multi_line_blocks(self):",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "MultiLineWithElseBlockNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "description": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "peekOfCode": "class MultiLineWithElseBlockNode(MultiLineBlockNode):\n    \"\"\"Base node for multi-line blocks that can have else statements.\"\"\"\n    @cached_property\n    def blockstart_tolineno(self):\n        return self.lineno\n    def _elsed_block_range(self, lineno, orelse, last=None):\n        \"\"\"Handle block line numbers range for try/finally, for, if and while\n        statements.\n        \"\"\"\n        if lineno == self.fromlineno:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes._base_nodes",
        "documentation": {}
    },
    {
        "label": "AsStringVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "description": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "peekOfCode": "class AsStringVisitor:\n    \"\"\"Visitor to render an Astroid node as a valid python code string\"\"\"\n    def __init__(self, indent: str = \"    \"):\n        self.indent: str = indent\n    def __call__(self, node) -> str:\n        \"\"\"Makes this visitor behave as a simple function\"\"\"\n        return node.accept(self).replace(DOC_NEWLINE, \"\\n\")\n    def _docs_dedent(self, doc_node: Const | None) -> str:\n        \"\"\"Stop newlines in docs being indented by self._stmt_list\"\"\"\n        if not doc_node:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "documentation": {}
    },
    {
        "label": "DOC_NEWLINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "description": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "peekOfCode": "DOC_NEWLINE = \"\\0\"\n# Visitor pattern require argument all the time and is not better with staticmethod\n# noinspection PyUnusedLocal,PyMethodMayBeStatic\nclass AsStringVisitor:\n    \"\"\"Visitor to render an Astroid node as a valid python code string\"\"\"\n    def __init__(self, indent: str = \"    \"):\n        self.indent: str = indent\n    def __call__(self, node) -> str:\n        \"\"\"Makes this visitor behave as a simple function\"\"\"\n        return node.accept(self).replace(DOC_NEWLINE, \"\\n\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "documentation": {}
    },
    {
        "label": "to_code",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "description": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "peekOfCode": "to_code = AsStringVisitor(\"    \")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.as_string",
        "documentation": {}
    },
    {
        "label": "OP_PRECEDENCE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.const",
        "description": "__pypackages__.3.10.lib.astroid.nodes.const",
        "peekOfCode": "OP_PRECEDENCE = {\n    op: precedence\n    for precedence, ops in enumerate(\n        [\n            [\"Lambda\"],  # lambda x: x + 1\n            [\"IfExp\"],  # 1 if True else 2\n            [\"or\"],\n            [\"and\"],\n            [\"not\"],\n            [\"Compare\"],  # in, not in, is, is not, <, <=, >, >=, !=, ==",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.const",
        "documentation": {}
    },
    {
        "label": "BaseContainer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class BaseContainer(_base_nodes.ParentAssignNode, Instance, metaclass=abc.ABCMeta):\n    \"\"\"Base class for Set, FrozenSet, Tuple and List.\"\"\"\n    _astroid_fields = (\"elts\",)\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "LookupMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class LookupMixIn(NodeNG):\n    \"\"\"Mixin to look up a name in the right scope.\"\"\"\n    @lru_cache()  # noqa\n    def lookup(self, name: str) -> tuple[LocalsDictNodeNG, list[NodeNG]]:\n        \"\"\"Lookup where the given variable is assigned.\n        The lookup starts from self's scope. If self is not a frame itself\n        and the name is found in the inner frame locals, statements will be\n        filtered to remove ignorable statements according to self's location.\n        :param name: The name of the variable to find assignments for.\n        :returns: The scope node and the list of assignments associated to the",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignName",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AssignName(_base_nodes.NoChildrenNode, LookupMixIn, _base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to a name.\n    An :class:`AssignName` is the name of something that is assigned to.\n    This includes variables defined in a function signature or in a loop.\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    >>> list(node.get_children())\n    [<AssignName.variable l.1 at 0x7effe1db8748>, <Call l.1 at 0x7effe1db8630>]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "DelName",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class DelName(_base_nodes.NoChildrenNode, LookupMixIn, _base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of a name.\n    A :class:`DelName` is the name of something that is deleted.\n    >>> import astroid\n    >>> node = astroid.extract_node(\"del variable #@\")\n    >>> list(node.get_children())\n    [<DelName.variable l.1 at 0x7effe1da4d30>]\n    >>> list(node.get_children())[0].as_string()\n    'variable'\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Name",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Name(_base_nodes.NoChildrenNode, LookupMixIn):\n    \"\"\"Class representing an :class:`ast.Name` node.\n    A :class:`Name` node is something that is named, but not covered by\n    :class:`AssignName` or :class:`DelName`.\n    >>> import astroid\n    >>> node = astroid.extract_node('range(10)')\n    >>> node\n    <Call l.1 at 0x7effe1db8710>\n    >>> list(node.get_children())\n    [<Name.range l.1 at 0x7effe1db86a0>, <Const.int l.1 at 0x7effe1db8518>]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Arguments",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Arguments(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing an :class:`ast.arguments` node.\n    An :class:`Arguments` node represents that arguments in a\n    function definition.\n    >>> import astroid\n    >>> node = astroid.extract_node('def foo(bar): pass')\n    >>> node\n    <FunctionDef.foo l.1 at 0x7effe1db8198>\n    >>> node.args\n    <Arguments l.1 at 0x7effe1db82e8>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignAttr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AssignAttr(_base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to an attribute.\n    >>> import astroid\n    >>> node = astroid.extract_node('self.attribute = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1d521d0>\n    >>> list(node.get_children())\n    [<AssignAttr.attribute l.1 at 0x7effe1d52320>, <Call l.1 at 0x7effe1d522e8>]\n    >>> list(node.get_children())[0].as_string()\n    'self.attribute'",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Assert",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Assert(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assert` node.\n    An :class:`Assert` node represents an assert statement.\n    >>> import astroid\n    >>> node = astroid.extract_node('assert len(things) == 10, \"Not enough things\"')\n    >>> node\n    <Assert l.1 at 0x7effe1d527b8>\n    \"\"\"\n    _astroid_fields = (\"test\", \"fail\")\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Assign",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Assign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assign` node.\n    An :class:`Assign` is a statement where something is explicitly\n    asssigned to.\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    \"\"\"\n    _astroid_fields = (\"targets\", \"value\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AnnAssign",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AnnAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.AnnAssign` node.\n    An :class:`AnnAssign` is an assignment with a type annotation.\n    >>> import astroid\n    >>> node = astroid.extract_node('variable: List[int] = range(10)')\n    >>> node\n    <AnnAssign l.1 at 0x7effe1d4c630>\n    \"\"\"\n    _astroid_fields = (\"target\", \"annotation\", \"value\")\n    _other_fields = (\"simple\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AugAssign",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AugAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.AugAssign` node.\n    An :class:`AugAssign` is an assignment paired with an operator.\n    >>> import astroid\n    >>> node = astroid.extract_node('variable += 1')\n    >>> node\n    <AugAssign l.1 at 0x7effe1db4d68>\n    \"\"\"\n    _astroid_fields = (\"target\", \"value\")\n    _other_fields = (\"op\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "BinOp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class BinOp(NodeNG):\n    \"\"\"Class representing an :class:`ast.BinOp` node.\n    A :class:`BinOp` node is an application of a binary operator.\n    >>> import astroid\n    >>> node = astroid.extract_node('a + b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e8cfd0>\n    \"\"\"\n    _astroid_fields = (\"left\", \"right\")\n    _other_fields = (\"op\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "BoolOp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class BoolOp(NodeNG):\n    \"\"\"Class representing an :class:`ast.BoolOp` node.\n    A :class:`BoolOp` is an application of a boolean operator.\n    >>> import astroid\n    >>> node = astroid.extract_node('a and b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e71c50>\n    \"\"\"\n    _astroid_fields = (\"values\",)\n    _other_fields = (\"op\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Break",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Break(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Break` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('break')\n    >>> node\n    <Break l.1 at 0x7f23b2e9e5c0>\n    \"\"\"\nclass Call(NodeNG):\n    \"\"\"Class representing an :class:`ast.Call` node.\n    A :class:`Call` node is a call to a function, method, etc.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Call",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Call(NodeNG):\n    \"\"\"Class representing an :class:`ast.Call` node.\n    A :class:`Call` node is a call to a function, method, etc.\n    >>> import astroid\n    >>> node = astroid.extract_node('function()')\n    >>> node\n    <Call l.1 at 0x7f23b2e71eb8>\n    \"\"\"\n    _astroid_fields = (\"func\", \"args\", \"keywords\")\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Compare",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Compare(NodeNG):\n    \"\"\"Class representing an :class:`ast.Compare` node.\n    A :class:`Compare` node indicates a comparison.\n    >>> import astroid\n    >>> node = astroid.extract_node('a <= b <= c')\n    >>> node\n    <Compare l.1 at 0x7f23b2e9e6d8>\n    >>> node.ops\n    [('<=', <Name.b l.1 at 0x7f23b2e9e2b0>), ('<=', <Name.c l.1 at 0x7f23b2e9e390>)]\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Comprehension",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Comprehension(NodeNG):\n    \"\"\"Class representing an :class:`ast.comprehension` node.\n    A :class:`Comprehension` indicates the loop inside any type of\n    comprehension including generator expressions.\n    >>> import astroid\n    >>> node = astroid.extract_node('[x for x in some_values]')\n    >>> list(node.get_children())\n    [<Name.x l.1 at 0x7f23b2e352b0>, <Comprehension l.1 at 0x7f23b2e35320>]\n    >>> list(node.get_children())[1].as_string()\n    'for x in some_values'",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Const",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Const(_base_nodes.NoChildrenNode, Instance):\n    \"\"\"Class representing any constant including num, str, bool, None, bytes.\n    >>> import astroid\n    >>> node = astroid.extract_node('(5, \"This is a string.\", True, None, b\"bytes\")')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e358d0>\n    >>> list(node.get_children())\n    [<Const.int l.1 at 0x7f23b2e35940>,\n    <Const.str l.1 at 0x7f23b2e35978>,\n    <Const.bool l.1 at 0x7f23b2e359b0>,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Continue",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Continue(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Continue` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('continue')\n    >>> node\n    <Continue l.1 at 0x7f23b2e35588>\n    \"\"\"\nclass Decorators(NodeNG):\n    \"\"\"A node representing a list of decorators.\n    A :class:`Decorators` is the decorators that are applied to",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Decorators",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Decorators(NodeNG):\n    \"\"\"A node representing a list of decorators.\n    A :class:`Decorators` is the decorators that are applied to\n    a method or function.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    @property\n    def my_property(self):\n        return 3\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "DelAttr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class DelAttr(_base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of an attribute.\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    >>> list(node.get_children())[0]\n    <DelAttr.attr l.1 at 0x7f23b2e411d0>\n    \"\"\"\n    _astroid_fields = (\"expr\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Delete",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Delete(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Delete` node.\n    A :class:`Delete` is a ``del`` statement this is deleting something.\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    \"\"\"\n    _astroid_fields = (\"targets\",)\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Dict(NodeNG, Instance):\n    \"\"\"Class representing an :class:`ast.Dict` node.\n    A :class:`Dict` is a dictionary that is created with ``{}`` syntax.\n    >>> import astroid\n    >>> node = astroid.extract_node('{1: \"1\"}')\n    >>> node\n    <Dict.dict l.1 at 0x7f23b2e35cc0>\n    \"\"\"\n    _astroid_fields = (\"items\",)\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Expr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Expr(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Expr` node.\n    An :class:`Expr` is any expression that does not have its value used or\n    stored.\n    >>> import astroid\n    >>> node = astroid.extract_node('method()')\n    >>> node\n    <Call l.1 at 0x7f23b2e352b0>\n    >>> node.parent\n    <Expr l.1 at 0x7f23b2e35278>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Ellipsis",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Ellipsis(_base_nodes.NoChildrenNode):  # pylint: disable=redefined-builtin\n    \"\"\"Class representing an :class:`ast.Ellipsis` node.\n    An :class:`Ellipsis` is the ``...`` syntax.\n    Deprecated since v2.6.0 - Use :class:`Const` instead.\n    Will be removed with the release v2.7.0\n    \"\"\"\nclass EmptyNode(_base_nodes.NoChildrenNode):\n    \"\"\"Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`.\"\"\"\n    object = None\n    def has_underlying_object(self) -> bool:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "EmptyNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class EmptyNode(_base_nodes.NoChildrenNode):\n    \"\"\"Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`.\"\"\"\n    object = None\n    def has_underlying_object(self) -> bool:\n        return self.object is not None and self.object is not _EMPTY_OBJECT_MARKER\nclass ExceptHandler(\n    _base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.ExceptHandler`. node.\n    An :class:`ExceptHandler` is an ``except`` block on a try-except.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "ExceptHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class ExceptHandler(\n    _base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.ExceptHandler`. node.\n    An :class:`ExceptHandler` is an ``except`` block on a try-except.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "ExtSlice",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class ExtSlice(NodeNG):\n    \"\"\"Class representing an :class:`ast.ExtSlice` node.\n    An :class:`ExtSlice` is a complex slice expression.\n    Deprecated since v2.6.0 - Now part of the :class:`Subscript` node.\n    Will be removed with the release of v2.7.0\n    \"\"\"\nclass For(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "For",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class For(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.For` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('for thing in things: print(thing)')\n    >>> node\n    <For l.1 at 0x7f23b2e8cf28>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AsyncFor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AsyncFor(For):\n    \"\"\"Class representing an :class:`ast.AsyncFor` node.\n    An :class:`AsyncFor` is an asynchronous :class:`For` built with\n    the ``async`` keyword.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        async for thing in things:\n            print(thing)\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Await",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Await(NodeNG):\n    \"\"\"Class representing an :class:`ast.Await` node.\n    An :class:`Await` is the ``await`` keyword.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        await other_func()\n    ''')\n    >>> node\n    <AsyncFunctionDef.func l.2 at 0x7f23b2e41748>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "ImportFrom",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class ImportFrom(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.ImportFrom` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('from my_package import my_module')\n    >>> node\n    <ImportFrom l.1 at 0x7f23b2e415c0>\n    \"\"\"\n    _other_fields = (\"modname\", \"names\", \"level\")\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Attribute(NodeNG):\n    \"\"\"Class representing an :class:`ast.Attribute` node.\"\"\"\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n    @decorators.deprecate_default_argument_values(attrname=\"str\")\n    def __init__(\n        self,\n        attrname: str | None = None,\n        lineno: int | None = None,\n        col_offset: int | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Global(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Global` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('global a_global')\n    >>> node\n    <Global l.1 at 0x7f23b2e9de10>\n    \"\"\"\n    _other_fields = (\"names\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "If",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class If(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.If` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('if condition: print(True)')\n    >>> node\n    <If l.1 at 0x7f23b2e9dd30>\n    \"\"\"\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    _multi_line_block_fields = (\"body\", \"orelse\")\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "IfExp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class IfExp(NodeNG):\n    \"\"\"Class representing an :class:`ast.IfExp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('value if condition else other')\n    >>> node\n    <IfExp l.1 at 0x7f23b2e9dbe0>\n    \"\"\"\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Import",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Import(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.Import` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('import astroid')\n    >>> node\n    <Import l.1 at 0x7f23b2e4e5c0>\n    \"\"\"\n    _other_fields = (\"names\",)\n    @decorators.deprecate_default_argument_values(names=\"list[tuple[str, str | None]]\")\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Index",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Index(NodeNG):\n    \"\"\"Class representing an :class:`ast.Index` node.\n    An :class:`Index` is a simple subscript.\n    Deprecated since v2.6.0 - Now part of the :class:`Subscript` node.\n    Will be removed with the release of v2.7.0\n    \"\"\"\nclass Keyword(NodeNG):\n    \"\"\"Class representing an :class:`ast.keyword` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('function(a_kwarg=True)')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Keyword",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Keyword(NodeNG):\n    \"\"\"Class representing an :class:`ast.keyword` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('function(a_kwarg=True)')\n    >>> node\n    <Call l.1 at 0x7f23b2e9e320>\n    >>> node.keywords\n    [<Keyword l.1 at 0x7f23b2e9e9b0>]\n    \"\"\"\n    _astroid_fields = (\"value\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class List(BaseContainer):\n    \"\"\"Class representing an :class:`ast.List` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('[1, 2, 3]')\n    >>> node\n    <List.list l.1 at 0x7f23b2e9e128>\n    \"\"\"\n    _other_fields = (\"ctx\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Nonlocal",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Nonlocal(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Nonlocal` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    def function():\n        nonlocal var\n    ''')\n    >>> node\n    <FunctionDef.function l.2 at 0x7f23b2e9e208>\n    >>> node.body[0]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Pass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Pass` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('pass')\n    >>> node\n    <Pass l.1 at 0x7f23b2e9e748>\n    \"\"\"\nclass Raise(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Raise` node.\n    >>> import astroid",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Raise",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Raise(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Raise` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('raise RuntimeError(\"Something bad happened!\")')\n    >>> node\n    <Raise l.1 at 0x7f23b2e9e828>\n    \"\"\"\n    _astroid_fields = (\"exc\", \"cause\")\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Return",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Return(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Return` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('return True')\n    >>> node\n    <Return l.1 at 0x7f23b8211908>\n    \"\"\"\n    _astroid_fields = (\"value\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Set(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Set` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('{1, 2, 3}')\n    >>> node\n    <Set.set l.1 at 0x7f23b2e71d68>\n    \"\"\"\n    infer_unary_op: ClassVar[InferUnaryOp[Set]]\n    def pytype(self) -> Literal[\"builtins.set\"]:\n        \"\"\"Get the name of the type that this node represents.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Slice",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Slice(NodeNG):\n    \"\"\"Class representing an :class:`ast.Slice` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    >>> node.slice\n    <Slice l.1 at 0x7f23b2e71e80>\n    \"\"\"\n    _astroid_fields = (\"lower\", \"upper\", \"step\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Starred",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Starred(_base_nodes.ParentAssignNode):\n    \"\"\"Class representing an :class:`ast.Starred` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('*args')\n    >>> node\n    <Starred l.1 at 0x7f23b2e41978>\n    \"\"\"\n    _astroid_fields = (\"value\",)\n    _other_fields = (\"ctx\",)\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Subscript",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Subscript(NodeNG):\n    \"\"\"Class representing an :class:`ast.Subscript` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    \"\"\"\n    _astroid_fields = (\"value\", \"slice\")\n    _other_fields = (\"ctx\",)\n    infer_lhs: ClassVar[InferLHS[Subscript]]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class TryExcept(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.TryExcept` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:\n            print(\"Error!\")\n        ''')\n    >>> node",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "TryFinally",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class TryFinally(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.TryFinally` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    try:\n        do_something()\n    except Exception as error:\n        print(\"Error!\")\n    finally:\n        print(\"Cleanup!\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Tuple(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Tuple` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('(1, 2, 3)')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e41780>\n    \"\"\"\n    _other_fields = (\"ctx\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "UnaryOp",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class UnaryOp(NodeNG):\n    \"\"\"Class representing an :class:`ast.UnaryOp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('-5')\n    >>> node\n    <UnaryOp l.1 at 0x7f23b2e4e198>\n    \"\"\"\n    _astroid_fields = (\"operand\",)\n    _other_fields = (\"op\",)\n    @decorators.deprecate_default_argument_values(op=\"str\")",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "While",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class While(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.While` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    while condition():\n        print(\"True\")\n    ''')\n    >>> node\n    <While l.2 at 0x7f23b2e4e390>\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "With",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class With(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.With` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    with open(file_path) as file_:\n        print(file_.read())",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AsyncWith",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class AsyncWith(With):\n    \"\"\"Asynchronous ``with`` built with the ``async`` keyword.\"\"\"\nclass Yield(NodeNG):\n    \"\"\"Class representing an :class:`ast.Yield` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('yield True')\n    >>> node\n    <Yield l.1 at 0x7f23b2e4e5f8>\n    \"\"\"\n    _astroid_fields = (\"value\",)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Yield",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Yield(NodeNG):\n    \"\"\"Class representing an :class:`ast.Yield` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('yield True')\n    >>> node\n    <Yield l.1 at 0x7f23b2e4e5f8>\n    \"\"\"\n    _astroid_fields = (\"value\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "YieldFrom",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class YieldFrom(Yield):  # TODO value is required, not optional\n    \"\"\"Class representing an :class:`ast.YieldFrom` node.\"\"\"\nclass DictUnpack(_base_nodes.NoChildrenNode):\n    \"\"\"Represents the unpacking of dicts into dicts using :pep:`448`.\"\"\"\nclass FormattedValue(NodeNG):\n    \"\"\"Class representing an :class:`ast.FormattedValue` node.\n    Represents a :pep:`498` format string.\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "DictUnpack",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class DictUnpack(_base_nodes.NoChildrenNode):\n    \"\"\"Represents the unpacking of dicts into dicts using :pep:`448`.\"\"\"\nclass FormattedValue(NodeNG):\n    \"\"\"Class representing an :class:`ast.FormattedValue` node.\n    Represents a :pep:`498` format string.\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    >>> node.values",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "FormattedValue",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class FormattedValue(NodeNG):\n    \"\"\"Class representing an :class:`ast.FormattedValue` node.\n    Represents a :pep:`498` format string.\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    >>> node.values\n    [<Const.str l.1 at 0x7f23b2e4eda0>, <FormattedValue l.1 at 0x7f23b2e4edd8>]\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "JoinedStr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class JoinedStr(NodeNG):\n    \"\"\"Represents a list of string expressions to be joined.\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n    _astroid_fields = (\"values\",)\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "NamedExpr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class NamedExpr(_base_nodes.AssignTypeNode):\n    \"\"\"Represents the assignment from the assignment expression\n    >>> import astroid\n    >>> module = astroid.parse('if a := 1: pass')\n    >>> module.body[0].test\n    <NamedExpr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n    _astroid_fields = (\"target\", \"value\")\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Unknown",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Unknown(_base_nodes.AssignTypeNode):\n    \"\"\"This node represents a node in a constructed AST where\n    introspection is not possible.  At the moment, it's only used in\n    the args attribute of FunctionDef nodes where function signature\n    introspection failed.\n    \"\"\"\n    name = \"Unknown\"\n    def qname(self) -> Literal[\"Unknown\"]:\n        return \"Unknown\"\n    def _infer(self, context: InferenceContext | None = None, **kwargs):",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "EvaluatedObject",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class EvaluatedObject(NodeNG):\n    \"\"\"Contains an object that has already been inferred\n    This class is useful to pre-evaluate a particular node,\n    with the resulting class acting as the non-evaluated node.\n    \"\"\"\n    name = \"EvaluatedObject\"\n    _astroid_fields = (\"original\",)\n    _other_fields = (\"value\",)\n    def __init__(\n        self, original: NodeNG, value: NodeNG | type[util.Uninferable]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Match(_base_nodes.Statement):\n    \"\"\"Class representing a :class:`ast.Match` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n        case _:\n            ...\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class Pattern(NodeNG):\n    \"\"\"Base class for all Pattern nodes.\"\"\"\nclass MatchCase(_base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.match_case` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchCase",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchCase(_base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.match_case` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0]\n    <MatchCase l.3 at 0x10c24e590>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchValue",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchValue(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchValue` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchValue l.3 at 0x10c24e200>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchSingleton",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchSingleton(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSingleton` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case True:\n            ...\n        case False:\n            ...\n        case None:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchSequence",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchSequence(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSequence` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, 2]:\n            ...\n        case (1, 2, *_):\n            ...\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchMapping",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchMapping(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchMapping` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case {1: \"Hello\", 2: \"World\", 3: _, **rest}:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchMapping l.3 at 0x10c8a8850>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchClass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchClass(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchClass` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case Point2D(0, 0):\n            ...\n        case Point3D(x=0, y=0, z=0):\n            ...\n    ''')",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchStar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchStar(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchStar` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, *_]:\n            ...\n    ''')\n    >>> node.cases[0].pattern.patterns[1]\n    <MatchStar l.3 at 0x10ca809a0>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchAs",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchAs(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchAs` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, a]:\n            ...\n        case {'key': b}:\n            ...\n        case Point2D(0, 0) as c:",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "MatchOr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "class MatchOr(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchOr` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 400 | 401 | 402:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchOr l.3 at 0x10d0b0b50>",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "unpack_infer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "def unpack_infer(stmt, context: InferenceContext | None = None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"\n    if isinstance(stmt, (List, Tuple)):\n        for elt in stmt.elts:\n            if elt is util.Uninferable:\n                yield elt\n                continue\n            yield from unpack_infer(elt, context)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "are_exclusive",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "def are_exclusive(stmt1, stmt2, exceptions: list[str] | None = None) -> bool:\n    \"\"\"return true if the two given statements are mutually exclusive\n    `exceptions` may be a list of exception names. If specified, discard If\n    branches and check one of the statement is in an exception handler catching\n    one of the given exceptions.\n    algorithm :\n     1) index stmt1's parents\n     2) climb among stmt2's parents until we find a common parent\n     3) if the common parent is a If or TryExcept statement, look if nodes are\n        in exclusive branches",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "const_factory",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "def const_factory(value: Any) -> ConstFactoryResult:\n    \"\"\"Return an astroid node for a python value.\"\"\"\n    assert not isinstance(value, NodeNG)\n    # This only handles instances of the CONST types. Any\n    # subclasses get inferred as EmptyNode.\n    # TODO: See if we should revisit these with the normal builder.\n    if value.__class__ not in CONST_CLS:\n        node = EmptyNode()\n        node.object = value\n        return node",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "_NodesT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "_NodesT = TypeVar(\"_NodesT\", bound=NodeNG)\n_BadOpMessageT = TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\nAssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\nAssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[typing.List[int]],\n    ],",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "_BadOpMessageT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "_BadOpMessageT = TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\nAssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\nAssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[typing.List[int]],\n    ],\n    Any,",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignedStmtsPossibleNode",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "AssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\nAssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[typing.List[int]],\n    ],\n    Any,\n]",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "AssignedStmtsCall",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "AssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[typing.List[int]],\n    ],\n    Any,\n]\nInferBinaryOperation = Callable[",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "InferBinaryOperation",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "InferBinaryOperation = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    typing.Generator[Union[InferenceResult, _BadOpMessageT], None, None],\n]\nInferLHS = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    typing.Generator[InferenceResult, None, Optional[InferenceErrorInfo]],\n]\nInferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]\n@decorators.raise_if_nothing_inferred",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "InferLHS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "InferLHS = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    typing.Generator[InferenceResult, None, Optional[InferenceErrorInfo]],\n]\nInferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]\n@decorators.raise_if_nothing_inferred\ndef unpack_infer(stmt, context: InferenceContext | None = None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "InferUnaryOp",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "InferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]\n@decorators.raise_if_nothing_inferred\ndef unpack_infer(stmt, context: InferenceContext | None = None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"\n    if isinstance(stmt, (List, Tuple)):\n        for elt in stmt.elts:\n            if elt is util.Uninferable:\n                yield elt",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "_SLICE_SENTINEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "peekOfCode": "_SLICE_SENTINEL = object()\ndef _slice_value(index, context: InferenceContext | None = None):\n    \"\"\"Get the value of the given slice index.\"\"\"\n    if isinstance(index, Const):\n        if isinstance(index.value, (int, type(None))):\n            return index.value\n    elif index is None:\n        return None\n    else:\n        # Try to infer what the index actually is.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_classes",
        "documentation": {}
    },
    {
        "label": "NodeNG",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "peekOfCode": "class NodeNG:\n    \"\"\"A node of the new Abstract Syntax Tree (AST).\n    This is the base class for all Astroid node classes.\n    \"\"\"\n    is_statement: ClassVar[bool] = False\n    \"\"\"Whether this node indicates a statement.\"\"\"\n    optional_assign: ClassVar[\n        bool\n    ] = False  # True for For (and for Comprehension if py <3.0)\n    \"\"\"Whether this node optionally assigns a variable.",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "_NodesT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "peekOfCode": "_NodesT = TypeVar(\"_NodesT\", bound=\"NodeNG\")\n_NodesT2 = TypeVar(\"_NodesT2\", bound=\"NodeNG\")\n_NodesT3 = TypeVar(\"_NodesT3\", bound=\"NodeNG\")\nSkipKlassT = Union[None, Type[\"NodeNG\"], Tuple[Type[\"NodeNG\"], ...]]\nclass NodeNG:\n    \"\"\"A node of the new Abstract Syntax Tree (AST).\n    This is the base class for all Astroid node classes.\n    \"\"\"\n    is_statement: ClassVar[bool] = False\n    \"\"\"Whether this node indicates a statement.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "_NodesT2",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "peekOfCode": "_NodesT2 = TypeVar(\"_NodesT2\", bound=\"NodeNG\")\n_NodesT3 = TypeVar(\"_NodesT3\", bound=\"NodeNG\")\nSkipKlassT = Union[None, Type[\"NodeNG\"], Tuple[Type[\"NodeNG\"], ...]]\nclass NodeNG:\n    \"\"\"A node of the new Abstract Syntax Tree (AST).\n    This is the base class for all Astroid node classes.\n    \"\"\"\n    is_statement: ClassVar[bool] = False\n    \"\"\"Whether this node indicates a statement.\"\"\"\n    optional_assign: ClassVar[",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "_NodesT3",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "peekOfCode": "_NodesT3 = TypeVar(\"_NodesT3\", bound=\"NodeNG\")\nSkipKlassT = Union[None, Type[\"NodeNG\"], Tuple[Type[\"NodeNG\"], ...]]\nclass NodeNG:\n    \"\"\"A node of the new Abstract Syntax Tree (AST).\n    This is the base class for all Astroid node classes.\n    \"\"\"\n    is_statement: ClassVar[bool] = False\n    \"\"\"Whether this node indicates a statement.\"\"\"\n    optional_assign: ClassVar[\n        bool",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "SkipKlassT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "description": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "peekOfCode": "SkipKlassT = Union[None, Type[\"NodeNG\"], Tuple[Type[\"NodeNG\"], ...]]\nclass NodeNG:\n    \"\"\"A node of the new Abstract Syntax Tree (AST).\n    This is the base class for all Astroid node classes.\n    \"\"\"\n    is_statement: ClassVar[bool] = False\n    \"\"\"Whether this node indicates a statement.\"\"\"\n    optional_assign: ClassVar[\n        bool\n    ] = False  # True for For (and for Comprehension if py <3.0)",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.node_ng",
        "documentation": {}
    },
    {
        "label": "Position",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.nodes.utils",
        "description": "__pypackages__.3.10.lib.astroid.nodes.utils",
        "peekOfCode": "class Position(NamedTuple):\n    \"\"\"Position with line and column information.\"\"\"\n    lineno: int\n    col_offset: int\n    end_lineno: int\n    end_col_offset: int",
        "detail": "__pypackages__.3.10.lib.astroid.nodes.utils",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid._ast",
        "description": "__pypackages__.3.10.lib.astroid._ast",
        "peekOfCode": "class FunctionType(NamedTuple):\n    argtypes: list[ast.expr]\n    returns: ast.expr\nclass ParserModule(NamedTuple):\n    module: types.ModuleType\n    unary_op_classes: dict[type[ast.unaryop], str]\n    cmp_op_classes: dict[type[ast.cmpop], str]\n    bool_op_classes: dict[type[ast.boolop], str]\n    bin_op_classes: dict[type[ast.operator], str]\n    context_classes: dict[type[ast.expr_context], Context]",
        "detail": "__pypackages__.3.10.lib.astroid._ast",
        "documentation": {}
    },
    {
        "label": "ParserModule",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid._ast",
        "description": "__pypackages__.3.10.lib.astroid._ast",
        "peekOfCode": "class ParserModule(NamedTuple):\n    module: types.ModuleType\n    unary_op_classes: dict[type[ast.unaryop], str]\n    cmp_op_classes: dict[type[ast.cmpop], str]\n    bool_op_classes: dict[type[ast.boolop], str]\n    bin_op_classes: dict[type[ast.operator], str]\n    context_classes: dict[type[ast.expr_context], Context]\n    def parse(self, string: str, type_comments: bool = True) -> ast.Module:\n        parse_func: Callable[[str], ast.Module]\n        if self.module is _ast_py3:",
        "detail": "__pypackages__.3.10.lib.astroid._ast",
        "documentation": {}
    },
    {
        "label": "parse_function_type_comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid._ast",
        "description": "__pypackages__.3.10.lib.astroid._ast",
        "peekOfCode": "def parse_function_type_comment(type_comment: str) -> FunctionType | None:\n    \"\"\"Given a correct type comment, obtain a FunctionType object.\"\"\"\n    if _ast_py3 is None:\n        return None\n    func_type = _ast_py3.parse(type_comment, \"<type_comment>\", \"func_type\")  # type: ignore[attr-defined]\n    return FunctionType(argtypes=func_type.argtypes, returns=func_type.returns)\ndef get_parser_module(type_comments: bool = True) -> ParserModule:\n    parser_module = ast\n    if type_comments and _ast_py3:\n        parser_module = _ast_py3",
        "detail": "__pypackages__.3.10.lib.astroid._ast",
        "documentation": {}
    },
    {
        "label": "get_parser_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid._ast",
        "description": "__pypackages__.3.10.lib.astroid._ast",
        "peekOfCode": "def get_parser_module(type_comments: bool = True) -> ParserModule:\n    parser_module = ast\n    if type_comments and _ast_py3:\n        parser_module = _ast_py3\n    unary_op_classes = _unary_operators_from_module(parser_module)\n    cmp_op_classes = _compare_operators_from_module(parser_module)\n    bool_op_classes = _bool_operators_from_module(parser_module)\n    bin_op_classes = _binary_operators_from_module(parser_module)\n    context_classes = _contexts_from_module(parser_module)\n    return ParserModule(",
        "detail": "__pypackages__.3.10.lib.astroid._ast",
        "documentation": {}
    },
    {
        "label": "CacheManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid._cache",
        "description": "__pypackages__.3.10.lib.astroid._cache",
        "peekOfCode": "class CacheManager:\n    \"\"\"Manager of caches, to be used as a singleton.\"\"\"\n    def __init__(self) -> None:\n        self.dict_caches: list[dict[Any, Any]] = []\n    def clear_all_caches(self) -> None:\n        \"\"\"Clear all caches.\"\"\"\n        for dict_cache in self.dict_caches:\n            dict_cache.clear()\n    def add_dict_cache(self, cache: dict[Any, Any]) -> None:\n        \"\"\"Add a dictionary cache to the manager.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid._cache",
        "documentation": {}
    },
    {
        "label": "CACHE_MANAGER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid._cache",
        "description": "__pypackages__.3.10.lib.astroid._cache",
        "peekOfCode": "CACHE_MANAGER = CacheManager()",
        "detail": "__pypackages__.3.10.lib.astroid._cache",
        "documentation": {}
    },
    {
        "label": "CallSite",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.arguments",
        "description": "__pypackages__.3.10.lib.astroid.arguments",
        "peekOfCode": "class CallSite:\n    \"\"\"Class for understanding arguments passed into a call site.\n    It needs a call context, which contains the arguments and the\n    keyword arguments that were passed into a given call site.\n    In order to infer what an argument represents, call :meth:`infer_argument`\n    with the corresponding function node and the argument name.\n    :param callcontext:\n        An instance of :class:`astroid.context.CallContext`, that holds\n        the arguments for the call site.\n    :param argument_context_map:",
        "detail": "__pypackages__.3.10.lib.astroid.arguments",
        "documentation": {}
    },
    {
        "label": "MANAGER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.astroid_manager",
        "description": "__pypackages__.3.10.lib.astroid.astroid_manager",
        "peekOfCode": "MANAGER = AstroidManager()",
        "detail": "__pypackages__.3.10.lib.astroid.astroid_manager",
        "documentation": {}
    },
    {
        "label": "Proxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class Proxy:\n    \"\"\"A simple proxy object.\n    Note:\n    Subclasses of this object will need a custom __getattr__\n    if new instance attributes are created. See the Const class\n    \"\"\"\n    _proxied: nodes.ClassDef | nodes.Lambda | Proxy | None = (\n        None  # proxied object may be set by class or by instance\n    )\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "BaseInstance",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class BaseInstance(Proxy):\n    \"\"\"An instance base class, which provides lookup methods for potential\n    instances.\n    \"\"\"\n    special_attributes = None\n    def display_type(self) -> str:\n        return \"Instance of\"\n    def getattr(self, name, context: InferenceContext | None = None, lookupclass=True):\n        try:\n            values = self._proxied.instance_attr(name, context)",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "Instance",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class Instance(BaseInstance):\n    \"\"\"A special node representing a class instance.\"\"\"\n    _proxied: nodes.ClassDef\n    # pylint: disable=unnecessary-lambda\n    special_attributes = lazy_descriptor(lambda: objectmodel.InstanceModel())\n    def __init__(self, proxied: nodes.ClassDef | None) -> None:\n        super().__init__(proxied)\n    infer_binary_op: ClassVar[InferBinaryOp[Instance]]\n    def __repr__(self) -> str:\n        return \"<Instance of {}.{} at 0x{}>\".format(",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "UnboundMethod",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class UnboundMethod(Proxy):\n    \"\"\"A special node representing a method not bound to an instance.\"\"\"\n    # pylint: disable=unnecessary-lambda\n    special_attributes = lazy_descriptor(lambda: objectmodel.UnboundMethodModel())\n    def __repr__(self) -> str:\n        frame = self._proxied.parent.frame(future=True)\n        return \"<{} {} of {} at 0x{}\".format(\n            self.__class__.__name__, self._proxied.name, frame.qname(), id(self)\n        )\n    def implicit_parameters(self) -> Literal[0]:",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "BoundMethod",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class BoundMethod(UnboundMethod):\n    \"\"\"A special node representing a method bound to an instance.\"\"\"\n    # pylint: disable=unnecessary-lambda\n    special_attributes = lazy_descriptor(lambda: objectmodel.BoundMethodModel())\n    def __init__(self, proxy, bound):\n        super().__init__(proxy)\n        self.bound = bound\n    def implicit_parameters(self) -> Literal[0, 1]:\n        if self.name == \"__new__\":\n            # __new__ acts as a classmethod but the class argument is not implicit.",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class Generator(BaseInstance):\n    \"\"\"A special node representing a generator.\n    Proxied class is set once for all in raw_building.\n    \"\"\"\n    _proxied: nodes.ClassDef\n    special_attributes = lazy_descriptor(objectmodel.GeneratorModel)\n    def __init__(\n        self, parent=None, generator_initial_context: InferenceContext | None = None\n    ):\n        super().__init__()",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class AsyncGenerator(Generator):\n    \"\"\"Special node representing an async generator.\"\"\"\n    def pytype(self) -> Literal[\"builtins.async_generator\"]:\n        return \"builtins.async_generator\"\n    def display_type(self) -> str:\n        return \"AsyncGenerator\"\n    def __repr__(self) -> str:\n        return f\"<AsyncGenerator({self._proxied.name}) l.{self.lineno} at 0x{id(self)}>\"\n    def __str__(self) -> str:\n        return f\"AsyncGenerator({self._proxied.name})\"",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "UnionType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "class UnionType(BaseInstance):\n    \"\"\"Special node representing new style typing unions.\n    Proxied class is set once for all in raw_building.\n    \"\"\"\n    _proxied: nodes.ClassDef\n    def __init__(\n        self,\n        left: UnionType | nodes.ClassDef | nodes.Const,\n        right: UnionType | nodes.ClassDef | nodes.Const,\n        parent: nodes.NodeNG | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "objectmodel",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "objectmodel = lazy_import(\"interpreter.objectmodel\")\nhelpers = lazy_import(\"helpers\")\nmanager = lazy_import(\"manager\")\n# TODO: check if needs special treatment\nBOOL_SPECIAL_METHOD = \"__bool__\"\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nPROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "helpers",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "helpers = lazy_import(\"helpers\")\nmanager = lazy_import(\"manager\")\n# TODO: check if needs special treatment\nBOOL_SPECIAL_METHOD = \"__bool__\"\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nPROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order\n# to see if a method is a property or not. This should be",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "manager",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "manager = lazy_import(\"manager\")\n# TODO: check if needs special treatment\nBOOL_SPECIAL_METHOD = \"__bool__\"\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nPROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order\n# to see if a method is a property or not. This should be\n# pretty reliable and fast, the alternative being to check each",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "BOOL_SPECIAL_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "BOOL_SPECIAL_METHOD = \"__bool__\"\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nPROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order\n# to see if a method is a property or not. This should be\n# pretty reliable and fast, the alternative being to check each\n# decorator to see if its a real property-like descriptor, which\n# can be too complicated.",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "BUILTINS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "BUILTINS = \"builtins\"  # TODO Remove in 2.8\nPROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order\n# to see if a method is a property or not. This should be\n# pretty reliable and fast, the alternative being to check each\n# decorator to see if its a real property-like descriptor, which\n# can be too complicated.\n# Also, these aren't qualified, because each project can",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "PROPERTIES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "PROPERTIES = {\"builtins.property\", \"abc.abstractproperty\"}\nif PY310_PLUS:\n    PROPERTIES.add(\"enum.property\")\n# List of possible property names. We use this list in order\n# to see if a method is a property or not. This should be\n# pretty reliable and fast, the alternative being to check each\n# decorator to see if its a real property-like descriptor, which\n# can be too complicated.\n# Also, these aren't qualified, because each project can\n# define them, we shouldn't expect to know every possible",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "POSSIBLE_PROPERTIES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.bases",
        "description": "__pypackages__.3.10.lib.astroid.bases",
        "peekOfCode": "POSSIBLE_PROPERTIES = {\n    \"cached_property\",\n    \"cachedproperty\",\n    \"lazyproperty\",\n    \"lazy_property\",\n    \"reify\",\n    \"lazyattribute\",\n    \"lazy_attribute\",\n    \"LazyProperty\",\n    \"lazy\",",
        "detail": "__pypackages__.3.10.lib.astroid.bases",
        "documentation": {}
    },
    {
        "label": "AstroidBuilder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "class AstroidBuilder(raw_building.InspectBuilder):\n    \"\"\"Class for building an astroid tree from source code or from a live module.\n    The param *manager* specifies the manager class which should be used.\n    If no manager is given, then the default one will be used. The\n    param *apply_transforms* determines if the transforms should be\n    applied after the tree was built from source or from a live object,\n    by default being True.\n    \"\"\"\n    def __init__(\n        self, manager: AstroidManager | None = None, apply_transforms: bool = True",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "open_source_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "def open_source_file(filename: str) -> tuple[TextIOWrapper, str, str]:\n    # pylint: disable=consider-using-with\n    with open(filename, \"rb\") as byte_stream:\n        encoding = detect_encoding(byte_stream.readline)[0]\n    stream = open(filename, newline=None, encoding=encoding)\n    data = stream.read()\n    return stream, encoding, data\ndef _can_assign_attr(node: nodes.ClassDef, attrname: str | None) -> bool:\n    try:\n        slots = node.slots()",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "build_namespace_package_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "def build_namespace_package_module(name: str, path: Sequence[str]) -> nodes.Module:\n    # TODO: Typing: Remove the cast to list and just update typing to accept Sequence\n    return nodes.Module(name, path=list(path), package=True)\ndef parse(\n    code: str,\n    module_name: str = \"\",\n    path: str | None = None,\n    apply_transforms: bool = True,\n) -> nodes.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it.",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "def parse(\n    code: str,\n    module_name: str = \"\",\n    path: str | None = None,\n    apply_transforms: bool = True,\n) -> nodes.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it.\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "extract_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "def extract_node(code: str, module_name: str = \"\") -> nodes.NodeNG | list[nodes.NodeNG]:\n    \"\"\"Parses some Python code as a module and extracts a designated AST node.\n    Statements:\n     To extract one or more statement nodes, append #@ to the end of the line\n     Examples:\n       >>> def x():\n       >>>   def y():\n       >>>     return 1 #@\n       The return statement will be extracted.\n       >>> class X(object):",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "_TRANSIENT_FUNCTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "_TRANSIENT_FUNCTION = \"__\"\n# The comment used to select a statement to be extracted\n# when calling extract_node.\n_STATEMENT_SELECTOR = \"#@\"\nMISPLACED_TYPE_ANNOTATION_ERROR = \"misplaced type annotation\"\ndef open_source_file(filename: str) -> tuple[TextIOWrapper, str, str]:\n    # pylint: disable=consider-using-with\n    with open(filename, \"rb\") as byte_stream:\n        encoding = detect_encoding(byte_stream.readline)[0]\n    stream = open(filename, newline=None, encoding=encoding)",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "_STATEMENT_SELECTOR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "_STATEMENT_SELECTOR = \"#@\"\nMISPLACED_TYPE_ANNOTATION_ERROR = \"misplaced type annotation\"\ndef open_source_file(filename: str) -> tuple[TextIOWrapper, str, str]:\n    # pylint: disable=consider-using-with\n    with open(filename, \"rb\") as byte_stream:\n        encoding = detect_encoding(byte_stream.readline)[0]\n    stream = open(filename, newline=None, encoding=encoding)\n    data = stream.read()\n    return stream, encoding, data\ndef _can_assign_attr(node: nodes.ClassDef, attrname: str | None) -> bool:",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "MISPLACED_TYPE_ANNOTATION_ERROR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.builder",
        "description": "__pypackages__.3.10.lib.astroid.builder",
        "peekOfCode": "MISPLACED_TYPE_ANNOTATION_ERROR = \"misplaced type annotation\"\ndef open_source_file(filename: str) -> tuple[TextIOWrapper, str, str]:\n    # pylint: disable=consider-using-with\n    with open(filename, \"rb\") as byte_stream:\n        encoding = detect_encoding(byte_stream.readline)[0]\n    stream = open(filename, newline=None, encoding=encoding)\n    data = stream.read()\n    return stream, encoding, data\ndef _can_assign_attr(node: nodes.ClassDef, attrname: str | None) -> bool:\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.builder",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "class Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3\n# TODO Remove in 3.0 in favor of Context\nLoad = Context.Load\nStore = Context.Store\nDel = Context.Del\nASTROID_INSTALL_DIRECTORY = Path(__file__).parent\nBRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PY38 = sys.version_info[:2] == (3, 8)\nPY38_PLUS = sys.version_info >= (3, 8)\nPY39_PLUS = sys.version_info >= (3, 9)\nPY310_PLUS = sys.version_info >= (3, 10)\nPY311_PLUS = sys.version_info >= (3, 11)\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PY38_PLUS = sys.version_info >= (3, 8)\nPY39_PLUS = sys.version_info >= (3, 9)\nPY310_PLUS = sys.version_info >= (3, 10)\nPY311_PLUS = sys.version_info >= (3, 11)\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PY39_PLUS = sys.version_info >= (3, 9)\nPY310_PLUS = sys.version_info >= (3, 10)\nPY311_PLUS = sys.version_info >= (3, 11)\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PY310_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PY310_PLUS = sys.version_info >= (3, 10)\nPY311_PLUS = sys.version_info >= (3, 11)\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PY311_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PY311_PLUS = sys.version_info >= (3, 11)\nBUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "BUILTINS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "BUILTINS = \"builtins\"  # TODO Remove in 2.8\nWIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "WIN32",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "WIN32 = sys.platform == \"win32\"\nIS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3\n# TODO Remove in 3.0 in favor of Context",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "IS_PYPY = sys.implementation.name == \"pypy\"\nIS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3\n# TODO Remove in 3.0 in favor of Context\nLoad = Context.Load",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "IS_JYTHON",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "IS_JYTHON = sys.implementation.name == \"jython\"\n# pylint: disable-next=no-member\nPYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3\n# TODO Remove in 3.0 in favor of Context\nLoad = Context.Load\nStore = Context.Store",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "PYPY_7_3_11_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "PYPY_7_3_11_PLUS = IS_PYPY and sys.pypy_version_info >= (7, 3, 11)  # type: ignore[attr-defined]\nclass Context(enum.Enum):\n    Load = 1\n    Store = 2\n    Del = 3\n# TODO Remove in 3.0 in favor of Context\nLoad = Context.Load\nStore = Context.Store\nDel = Context.Del\nASTROID_INSTALL_DIRECTORY = Path(__file__).parent",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "Load",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "Load = Context.Load\nStore = Context.Store\nDel = Context.Del\nASTROID_INSTALL_DIRECTORY = Path(__file__).parent\nBRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"\n_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "Store",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "Store = Context.Store\nDel = Context.Del\nASTROID_INSTALL_DIRECTORY = Path(__file__).parent\nBRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"\n_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "Del",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "Del = Context.Del\nASTROID_INSTALL_DIRECTORY = Path(__file__).parent\nBRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"\n_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "ASTROID_INSTALL_DIRECTORY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "ASTROID_INSTALL_DIRECTORY = Path(__file__).parent\nBRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"\n_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "BRAIN_MODULES_DIRECTORY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "BRAIN_MODULES_DIRECTORY = ASTROID_INSTALL_DIRECTORY / \"brain\"\n_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "_EMPTY_OBJECT_MARKER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.const",
        "description": "__pypackages__.3.10.lib.astroid.const",
        "peekOfCode": "_EMPTY_OBJECT_MARKER = object()",
        "detail": "__pypackages__.3.10.lib.astroid.const",
        "documentation": {}
    },
    {
        "label": "Constraint",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.constraint",
        "description": "__pypackages__.3.10.lib.astroid.constraint",
        "peekOfCode": "class Constraint(ABC):\n    \"\"\"Represents a single constraint on a variable.\"\"\"\n    def __init__(self, node: nodes.NodeNG, negate: bool) -> None:\n        self.node = node\n        \"\"\"The node that this constraint applies to.\"\"\"\n        self.negate = negate\n        \"\"\"True if this constraint is negated. E.g., \"is not\" instead of \"is\".\"\"\"\n    @classmethod\n    @abstractmethod\n    def match(",
        "detail": "__pypackages__.3.10.lib.astroid.constraint",
        "documentation": {}
    },
    {
        "label": "NoneConstraint",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.constraint",
        "description": "__pypackages__.3.10.lib.astroid.constraint",
        "peekOfCode": "class NoneConstraint(Constraint):\n    \"\"\"Represents an \"is None\" or \"is not None\" constraint.\"\"\"\n    CONST_NONE: nodes.Const = nodes.Const(None)\n    @classmethod\n    def match(\n        cls: type[Self], node: _NameNodes, expr: nodes.NodeNG, negate: bool = False\n    ) -> Self | None:\n        \"\"\"Return a new constraint for node matched from expr, if expr matches\n        the constraint pattern.\n        Negate the constraint based on the value of negate.",
        "detail": "__pypackages__.3.10.lib.astroid.constraint",
        "documentation": {}
    },
    {
        "label": "get_constraints",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.constraint",
        "description": "__pypackages__.3.10.lib.astroid.constraint",
        "peekOfCode": "def get_constraints(\n    expr: _NameNodes, frame: nodes.LocalsDictNodeNG\n) -> dict[nodes.If, set[Constraint]]:\n    \"\"\"Returns the constraints for the given expression.\n    The returned dictionary maps the node where the constraint was generated to the\n    corresponding constraint(s).\n    Constraints are computed statically by analysing the code surrounding expr.\n    Currently this only supports constraints generated from if conditions.\n    \"\"\"\n    current_node: nodes.NodeNG | None = expr",
        "detail": "__pypackages__.3.10.lib.astroid.constraint",
        "documentation": {}
    },
    {
        "label": "_NameNodes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.constraint",
        "description": "__pypackages__.3.10.lib.astroid.constraint",
        "peekOfCode": "_NameNodes = Union[nodes.AssignAttr, nodes.Attribute, nodes.AssignName, nodes.Name]\nclass Constraint(ABC):\n    \"\"\"Represents a single constraint on a variable.\"\"\"\n    def __init__(self, node: nodes.NodeNG, negate: bool) -> None:\n        self.node = node\n        \"\"\"The node that this constraint applies to.\"\"\"\n        self.negate = negate\n        \"\"\"True if this constraint is negated. E.g., \"is not\" instead of \"is\".\"\"\"\n    @classmethod\n    @abstractmethod",
        "detail": "__pypackages__.3.10.lib.astroid.constraint",
        "documentation": {}
    },
    {
        "label": "ALL_CONSTRAINT_CLASSES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.constraint",
        "description": "__pypackages__.3.10.lib.astroid.constraint",
        "peekOfCode": "ALL_CONSTRAINT_CLASSES = frozenset((NoneConstraint,))\n\"\"\"All supported constraint types.\"\"\"\ndef _matches(node1: nodes.NodeNG | bases.Proxy, node2: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the two nodes match.\"\"\"\n    if isinstance(node1, nodes.Name) and isinstance(node2, nodes.Name):\n        return node1.name == node2.name\n    if isinstance(node1, nodes.Attribute) and isinstance(node2, nodes.Attribute):\n        return node1.attrname == node2.attrname and _matches(node1.expr, node2.expr)\n    if isinstance(node1, nodes.Const) and isinstance(node2, nodes.Const):\n        return node1.value == node2.value",
        "detail": "__pypackages__.3.10.lib.astroid.constraint",
        "documentation": {}
    },
    {
        "label": "InferenceContext",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.context",
        "description": "__pypackages__.3.10.lib.astroid.context",
        "peekOfCode": "class InferenceContext:\n    \"\"\"Provide context for inference.\n    Store already inferred nodes to save time\n    Account for already visited nodes to stop infinite recursion\n    \"\"\"\n    __slots__ = (\n        \"path\",\n        \"lookupname\",\n        \"callcontext\",\n        \"boundnode\",",
        "detail": "__pypackages__.3.10.lib.astroid.context",
        "documentation": {}
    },
    {
        "label": "CallContext",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.context",
        "description": "__pypackages__.3.10.lib.astroid.context",
        "peekOfCode": "class CallContext:\n    \"\"\"Holds information for a call site.\"\"\"\n    __slots__ = (\"args\", \"keywords\", \"callee\")\n    def __init__(\n        self,\n        args: list[NodeNG],\n        keywords: list[Keyword] | None = None,\n        callee: NodeNG | None = None,\n    ):\n        self.args = args  # Call positional arguments",
        "detail": "__pypackages__.3.10.lib.astroid.context",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.context",
        "description": "__pypackages__.3.10.lib.astroid.context",
        "peekOfCode": "def copy_context(context: InferenceContext | None) -> InferenceContext:\n    \"\"\"Clone a context if given, or return a fresh context.\"\"\"\n    if context is not None:\n        return context.clone()\n    return InferenceContext()\ndef bind_context_to_node(context: InferenceContext | None, node) -> InferenceContext:\n    \"\"\"Give a context a boundnode\n    to retrieve the correct function name or attribute value\n    with from further inference.\n    Do not use an existing context since the boundnode could then",
        "detail": "__pypackages__.3.10.lib.astroid.context",
        "documentation": {}
    },
    {
        "label": "bind_context_to_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.context",
        "description": "__pypackages__.3.10.lib.astroid.context",
        "peekOfCode": "def bind_context_to_node(context: InferenceContext | None, node) -> InferenceContext:\n    \"\"\"Give a context a boundnode\n    to retrieve the correct function name or attribute value\n    with from further inference.\n    Do not use an existing context since the boundnode could then\n    be incorrectly propagated higher up in the call stack.\n    :param node: Node to do name lookups from\n    :type node NodeNG:\n    :returns: A new context\n    :rtype: InferenceContext",
        "detail": "__pypackages__.3.10.lib.astroid.context",
        "documentation": {}
    },
    {
        "label": "_InferenceCache",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.context",
        "description": "__pypackages__.3.10.lib.astroid.context",
        "peekOfCode": "_InferenceCache = Dict[\n    Tuple[\"NodeNG\", Optional[str], Optional[str], Optional[str]], Sequence[\"NodeNG\"]\n]\n_INFERENCE_CACHE: _InferenceCache = {}\ndef _invalidate_cache() -> None:\n    _INFERENCE_CACHE.clear()\nclass InferenceContext:\n    \"\"\"Provide context for inference.\n    Store already inferred nodes to save time\n    Account for already visited nodes to stop infinite recursion",
        "detail": "__pypackages__.3.10.lib.astroid.context",
        "documentation": {}
    },
    {
        "label": "cachedproperty",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "class cachedproperty:\n    \"\"\"Provides a cached property equivalent to the stacking of\n    @cached and @property, but more efficient.\n    After first usage, the <property_name> becomes part of the object's\n    __dict__. Doing:\n      del obj.<property_name> empties the cache.\n    Idea taken from the pyramid_ framework and the mercurial_ project.\n    .. _pyramid: http://pypi.python.org/pypi/pyramid\n    .. _mercurial: http://pypi.python.org/pypi/Mercurial\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "cached",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "def cached(func, instance, args, kwargs):\n    \"\"\"Simple decorator to cache result of method calls without args.\"\"\"\n    cache = getattr(instance, \"__cache\", None)\n    if cache is None:\n        instance.__cache = cache = {}\n        _cache.CACHE_MANAGER.add_dict_cache(cache)\n    try:\n        return cache[func]\n    except KeyError:\n        cache[func] = result = func(*args, **kwargs)",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "path_wrapper",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "def path_wrapper(func):\n    \"\"\"Return the given infer function wrapped to handle the path.\n    Used to stop inference if the node has already been looked\n    at for a given `InferenceContext` to prevent infinite recursion\n    \"\"\"\n    @functools.wraps(func)\n    def wrapped(\n        node, context: InferenceContext | None = None, _func=func, **kwargs\n    ) -> Generator:\n        \"\"\"Wrapper function handling context.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "yes_if_nothing_inferred",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "def yes_if_nothing_inferred(func, instance, args, kwargs):\n    generator = func(*args, **kwargs)\n    try:\n        yield next(generator)\n    except StopIteration:\n        # generator is empty\n        yield util.Uninferable\n        return\n    yield from generator\n@wrapt.decorator",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "raise_if_nothing_inferred",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "def raise_if_nothing_inferred(func, instance, args, kwargs):\n    generator = func(*args, **kwargs)\n    try:\n        yield next(generator)\n    except StopIteration as error:\n        # generator is empty\n        if error.args:\n            # pylint: disable=not-a-mapping\n            raise InferenceError(**error.args[0]) from error\n        raise InferenceError(",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "_R",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "_R = TypeVar(\"_R\")\n_P = ParamSpec(\"_P\")\n@wrapt.decorator\ndef cached(func, instance, args, kwargs):\n    \"\"\"Simple decorator to cache result of method calls without args.\"\"\"\n    cache = getattr(instance, \"__cache\", None)\n    if cache is None:\n        instance.__cache = cache = {}\n        _cache.CACHE_MANAGER.add_dict_cache(cache)\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "_P",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.decorators",
        "description": "__pypackages__.3.10.lib.astroid.decorators",
        "peekOfCode": "_P = ParamSpec(\"_P\")\n@wrapt.decorator\ndef cached(func, instance, args, kwargs):\n    \"\"\"Simple decorator to cache result of method calls without args.\"\"\"\n    cache = getattr(instance, \"__cache\", None)\n    if cache is None:\n        instance.__cache = cache = {}\n        _cache.CACHE_MANAGER.add_dict_cache(cache)\n    try:\n        return cache[func]",
        "detail": "__pypackages__.3.10.lib.astroid.decorators",
        "documentation": {}
    },
    {
        "label": "AstroidError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidError(Exception):\n    \"\"\"Base exception class for all astroid related exceptions.\n    AstroidError and its subclasses are structured, intended to hold\n    objects representing state when the exception is thrown.  Field\n    values are passed to the constructor as keyword-only arguments.\n    Each subclass has its own set of standard fields, but use your\n    best judgment to decide whether a specific exception instance\n    needs more or fewer fields for debugging.  Field values may be\n    used to lazily generate the error message: self.message.format()\n    will be called with the field names and values supplied as keyword",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidBuildingError(AstroidError):\n    \"\"\"Exception class when we are unable to build an astroid representation.\n    Standard attributes:\n        modname: Name of the module that AST construction failed for.\n        error: Exception raised during construction.\n    \"\"\"\n    def __init__(\n        self,\n        message: str = \"Failed to import module {modname}.\",\n        modname: str | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidImportError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidImportError(AstroidBuildingError):\n    \"\"\"Exception class used when a module can't be imported by astroid.\"\"\"\nclass TooManyLevelsError(AstroidImportError):\n    \"\"\"Exception class which is raised when a relative import was beyond the top-level.\n    Standard attributes:\n        level: The level which was attempted.\n        name: the name of the module on which the relative import was attempted.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "TooManyLevelsError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class TooManyLevelsError(AstroidImportError):\n    \"\"\"Exception class which is raised when a relative import was beyond the top-level.\n    Standard attributes:\n        level: The level which was attempted.\n        name: the name of the module on which the relative import was attempted.\n    \"\"\"\n    def __init__(\n        self,\n        message: str = \"Relative import with too many levels \"\n        \"({level}) for module {name!r}\",",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidSyntaxError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidSyntaxError(AstroidBuildingError):\n    \"\"\"Exception class used when a module can't be parsed.\"\"\"\n    def __init__(\n        self,\n        message: str,\n        modname: str | None,\n        error: Exception,\n        path: str | None,\n        source: str | None = None,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDefault",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class NoDefault(AstroidError):\n    \"\"\"Raised by function's `default_value` method when an argument has\n    no default value.\n    Standard attributes:\n        func: Function node.\n        name: Name of argument without a default.\n    \"\"\"\n    def __init__(\n        self,\n        message: str = \"{func!r} has no default for {name!r}.\",",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "ResolveError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class ResolveError(AstroidError):\n    \"\"\"Base class of astroid resolution/inference error.\n    ResolveError is not intended to be raised.\n    Standard attributes:\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(\n        self, message: str = \"\", context: InferenceContext | None = None, **kws: Any\n    ) -> None:\n        self.context = context",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "MroError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class MroError(ResolveError):\n    \"\"\"Error raised when there is a problem with method resolution of a class.\n    Standard attributes:\n        mros: A sequence of sequences containing ClassDef nodes.\n        cls: ClassDef node whose MRO resolution failed.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(\n        self,\n        message: str,",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "DuplicateBasesError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class DuplicateBasesError(MroError):\n    \"\"\"Error raised when there are duplicate bases in the same class bases.\"\"\"\nclass InconsistentMroError(MroError):\n    \"\"\"Error raised when a class's MRO is inconsistent.\"\"\"\nclass SuperError(ResolveError):\n    \"\"\"Error raised when there is a problem with a *super* call.\n    Standard attributes:\n        *super_*: The Super instance that raised the exception.\n        context: InferenceContext object.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InconsistentMroError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class InconsistentMroError(MroError):\n    \"\"\"Error raised when a class's MRO is inconsistent.\"\"\"\nclass SuperError(ResolveError):\n    \"\"\"Error raised when there is a problem with a *super* call.\n    Standard attributes:\n        *super_*: The Super instance that raised the exception.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(self, message: str, super_: objects.Super, **kws: Any) -> None:\n        self.super_ = super_",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "SuperError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class SuperError(ResolveError):\n    \"\"\"Error raised when there is a problem with a *super* call.\n    Standard attributes:\n        *super_*: The Super instance that raised the exception.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(self, message: str, super_: objects.Super, **kws: Any) -> None:\n        self.super_ = super_\n        super().__init__(message, **kws)\n    def __str__(self) -> str:",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class InferenceError(ResolveError):  # pylint: disable=too-many-instance-attributes\n    \"\"\"Raised when we are unable to infer a node.\n    Standard attributes:\n        node: The node inference was called on.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        message: str = \"Inference failed for {node!r}.\",\n        node: nodes.NodeNG | bases.Instance | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NameInferenceError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class NameInferenceError(InferenceError):\n    \"\"\"Raised when a name lookup fails, corresponds to NameError.\n    Standard attributes:\n        name: The name for which lookup failed, as a string.\n        scope: The node representing the scope in which the lookup occurred.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(\n        self,\n        message: str = \"{name!r} not found in {scope!r}.\",",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AttributeInferenceError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AttributeInferenceError(ResolveError):\n    \"\"\"Raised when an attribute lookup fails, corresponds to AttributeError.\n    Standard attributes:\n        target: The node for which lookup failed.\n        attribute: The attribute for which lookup failed, as a string.\n        context: InferenceContext object.\n    \"\"\"\n    def __init__(\n        self,\n        message: str = \"{attribute!r} not found on {target!r}.\",",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UseInferenceDefault",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class UseInferenceDefault(Exception):\n    \"\"\"Exception to be raised in custom inference function to indicate that it\n    should go back to the default behaviour.\n    \"\"\"\nclass _NonDeducibleTypeHierarchy(Exception):\n    \"\"\"Raised when is_subtype / is_supertype can't deduce the relation between two\n    types.\n    \"\"\"\nclass AstroidIndexError(AstroidError):\n    \"\"\"Raised when an Indexable / Mapping does not have an index / key.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "_NonDeducibleTypeHierarchy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class _NonDeducibleTypeHierarchy(Exception):\n    \"\"\"Raised when is_subtype / is_supertype can't deduce the relation between two\n    types.\n    \"\"\"\nclass AstroidIndexError(AstroidError):\n    \"\"\"Raised when an Indexable / Mapping does not have an index / key.\"\"\"\n    def __init__(\n        self,\n        message: str = \"\",\n        node: nodes.NodeNG | bases.Instance | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidIndexError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidIndexError(AstroidError):\n    \"\"\"Raised when an Indexable / Mapping does not have an index / key.\"\"\"\n    def __init__(\n        self,\n        message: str = \"\",\n        node: nodes.NodeNG | bases.Instance | None = None,\n        index: nodes.Subscript | None = None,\n        context: InferenceContext | None = None,\n        **kws: Any,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidTypeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidTypeError(AstroidError):\n    \"\"\"Raised when a TypeError would be expected in Python code.\"\"\"\n    def __init__(\n        self,\n        message: str = \"\",\n        node: nodes.NodeNG | bases.Instance | None = None,\n        index: nodes.Subscript | None = None,\n        context: InferenceContext | None = None,\n        **kws: Any,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidValueError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class AstroidValueError(AstroidError):\n    \"\"\"Raised when a ValueError would be expected in Python code.\"\"\"\nclass InferenceOverwriteError(AstroidError):\n    \"\"\"Raised when an inference tip is overwritten.\n    Currently only used for debugging.\n    \"\"\"\nclass ParentMissingError(AstroidError):\n    \"\"\"Raised when a node which is expected to have a parent attribute is missing one.\n    Standard attributes:\n        target: The node for which the parent lookup failed.",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "InferenceOverwriteError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class InferenceOverwriteError(AstroidError):\n    \"\"\"Raised when an inference tip is overwritten.\n    Currently only used for debugging.\n    \"\"\"\nclass ParentMissingError(AstroidError):\n    \"\"\"Raised when a node which is expected to have a parent attribute is missing one.\n    Standard attributes:\n        target: The node for which the parent lookup failed.\n    \"\"\"\n    def __init__(self, target: nodes.NodeNG) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "ParentMissingError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class ParentMissingError(AstroidError):\n    \"\"\"Raised when a node which is expected to have a parent attribute is missing one.\n    Standard attributes:\n        target: The node for which the parent lookup failed.\n    \"\"\"\n    def __init__(self, target: nodes.NodeNG) -> None:\n        self.target = target\n        super().__init__(message=f\"Parent not found on {target!r}.\")\nclass StatementMissing(ParentMissingError):\n    \"\"\"Raised when a call to node.statement() does not return a node.",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "StatementMissing",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "class StatementMissing(ParentMissingError):\n    \"\"\"Raised when a call to node.statement() does not return a node.\n    This is because a node in the chain does not have a parent attribute\n    and therefore does not return a node for statement().\n    Standard attributes:\n        target: The node for which the parent lookup failed.\n    \"\"\"\n    def __init__(self, target: nodes.NodeNG) -> None:\n        super(ParentMissingError, self).__init__(\n            message=f\"Statement not found on {target!r}\"",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "__all__ = (\n    \"AstroidBuildingError\",\n    \"AstroidBuildingException\",\n    \"AstroidError\",\n    \"AstroidImportError\",\n    \"AstroidIndexError\",\n    \"AstroidSyntaxError\",\n    \"AstroidTypeError\",\n    \"AstroidValueError\",\n    \"AttributeInferenceError\",",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "OperationError",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "OperationError = util.BadOperationMessage\nUnaryOperationError = util.BadUnaryOperationMessage\nBinaryOperationError = util.BadBinaryOperationMessage\nSuperArgumentTypeError = SuperError\nUnresolvableName = NameInferenceError\nNotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UnaryOperationError",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "UnaryOperationError = util.BadUnaryOperationMessage\nBinaryOperationError = util.BadBinaryOperationMessage\nSuperArgumentTypeError = SuperError\nUnresolvableName = NameInferenceError\nNotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "BinaryOperationError",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "BinaryOperationError = util.BadBinaryOperationMessage\nSuperArgumentTypeError = SuperError\nUnresolvableName = NameInferenceError\nNotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "SuperArgumentTypeError",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "SuperArgumentTypeError = SuperError\nUnresolvableName = NameInferenceError\nNotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "UnresolvableName",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "UnresolvableName = NameInferenceError\nNotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "NotFoundError",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "NotFoundError = AttributeInferenceError\nAstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "AstroidBuildingException",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.exceptions",
        "description": "__pypackages__.3.10.lib.astroid.exceptions",
        "peekOfCode": "AstroidBuildingException = AstroidBuildingError",
        "detail": "__pypackages__.3.10.lib.astroid.exceptions",
        "documentation": {}
    },
    {
        "label": "object_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def object_type(\n    node: SuccessfulInferenceResult, context: InferenceContext | None = None\n) -> InferenceResult | None:\n    \"\"\"Obtain the type of the given node.\n    This is used to implement the ``type`` builtin, which means that it's\n    used for inferring type calls, as well as used in a couple of other places\n    in the inference.\n    The node will be inferred first, so this function can support all\n    sorts of objects, as long as they support inference.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "object_isinstance",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def object_isinstance(node, class_or_seq, context: InferenceContext | None = None):\n    \"\"\"Check if a node 'isinstance' any node in class_or_seq.\n    :param node: A given node\n    :param class_or_seq: Union[nodes.NodeNG, Sequence[nodes.NodeNG]]\n    :rtype: bool\n    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n    \"\"\"\n    obj_type = object_type(node, context)\n    if obj_type is util.Uninferable:\n        return util.Uninferable",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "object_issubclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def object_issubclass(node, class_or_seq, context: InferenceContext | None = None):\n    \"\"\"Check if a type is a subclass of any node in class_or_seq.\n    :param node: A given node\n    :param class_or_seq: Union[Nodes.NodeNG, Sequence[nodes.NodeNG]]\n    :rtype: bool\n    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n    :raises AstroidError: if the type of the given node cannot be inferred\n        or its type's mro doesn't work\n    \"\"\"\n    if not isinstance(node, nodes.ClassDef):",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def safe_infer(\n    node: nodes.NodeNG | bases.Proxy, context: InferenceContext | None = None\n) -> InferenceResult | None:\n    \"\"\"Return the inferred value for the given node.\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred).\n    \"\"\"\n    try:\n        inferit = node.infer(context=context)\n        value = next(inferit)",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "has_known_bases",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def has_known_bases(klass, context: InferenceContext | None = None) -> bool:\n    \"\"\"Return whether all base classes of a class could be inferred.\"\"\"\n    try:\n        return klass._all_bases_known\n    except AttributeError:\n        pass\n    for base in klass.bases:\n        result = safe_infer(base, context=context)\n        # TODO: check for A->B->A->B pattern in class structure too?\n        if (",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "is_subtype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def is_subtype(type1, type2) -> bool:\n    \"\"\"Check if *type1* is a subtype of *type2*.\"\"\"\n    return _type_check(type1=type2, type2=type1)\ndef is_supertype(type1, type2) -> bool:\n    \"\"\"Check if *type2* is a supertype of *type1*.\"\"\"\n    return _type_check(type1, type2)\ndef class_instance_as_index(node: SuccessfulInferenceResult) -> nodes.Const | None:\n    \"\"\"Get the value as an index for the given instance.\n    If an instance provides an __index__ method, then it can\n    be used in some scenarios where an integer is expected,",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "is_supertype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def is_supertype(type1, type2) -> bool:\n    \"\"\"Check if *type2* is a supertype of *type1*.\"\"\"\n    return _type_check(type1, type2)\ndef class_instance_as_index(node: SuccessfulInferenceResult) -> nodes.Const | None:\n    \"\"\"Get the value as an index for the given instance.\n    If an instance provides an __index__ method, then it can\n    be used in some scenarios where an integer is expected,\n    for instance when multiplying or subscripting a list.\n    \"\"\"\n    context = InferenceContext()",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "class_instance_as_index",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def class_instance_as_index(node: SuccessfulInferenceResult) -> nodes.Const | None:\n    \"\"\"Get the value as an index for the given instance.\n    If an instance provides an __index__ method, then it can\n    be used in some scenarios where an integer is expected,\n    for instance when multiplying or subscripting a list.\n    \"\"\"\n    context = InferenceContext()\n    try:\n        for inferred in node.igetattr(\"__index__\", context=context):\n            if not isinstance(inferred, bases.BoundMethod):",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "object_len",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.helpers",
        "description": "__pypackages__.3.10.lib.astroid.helpers",
        "peekOfCode": "def object_len(node, context: InferenceContext | None = None):\n    \"\"\"Infer length of given node object.\n    :param Union[nodes.ClassDef, nodes.Instance] node:\n    :param node: Node to infer length of\n    :raises AstroidTypeError: If an invalid node is returned\n        from __len__ method or no __len__ method exists\n    :raises InferenceError: If the given node cannot be inferred\n        or if multiple nodes are inferred or if the code executed in python\n        would result in a infinite recursive check for length\n    :rtype int: Integer length of node",
        "detail": "__pypackages__.3.10.lib.astroid.helpers",
        "documentation": {}
    },
    {
        "label": "infer_end",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_end(\n    self: _T, context: InferenceContext | None = None, **kwargs: Any\n) -> Iterator[_T]:\n    \"\"\"Inference's end for nodes that yield themselves on inference.\n    These are objects for which inference does not have any semantic,\n    such as Module or Consts.\n    \"\"\"\n    yield self\n# We add ignores to all assignments to methods\n# See https://github.com/python/mypy/issues/2427",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_sequence",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_sequence(\n    self: _BaseContainerT,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Iterator[_BaseContainerT]:\n    has_starred_named_expr = any(\n        isinstance(e, (nodes.Starred, nodes.NamedExpr)) for e in self.elts\n    )\n    if has_starred_named_expr:\n        values = _infer_sequence_helper(self, context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_map",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_map(\n    self: nodes.Dict, context: InferenceContext | None = None\n) -> Iterator[nodes.Dict]:\n    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n        yield self\n    else:\n        items = _infer_map(self, context)\n        new_seq = type(self)(self.lineno, self.col_offset, self.parent)\n        new_seq.postinit(list(items.items()))\n        yield new_seq",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_name(\n    self: nodes.Name | nodes.AssignName,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Infer a Name: use name lookup rules.\"\"\"\n    frame, stmts = self.lookup(self.name)\n    if not stmts:\n        # Try to see if the name is enclosed in a nested function\n        # and use the higher (first function) scope for searching.",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_call(\n    self: nodes.Call, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n    callcontext = copy_context(context)\n    callcontext.boundnode = None\n    if context is not None:\n        callcontext.extra_context = _populate_context_lookup(self, context.clone())\n    for callee in self.func.infer(context):\n        if callee is util.Uninferable:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_import(\n    self: nodes.Import,\n    context: InferenceContext | None = None,\n    asname: bool = True,\n    **kwargs: Any,\n) -> Generator[nodes.Module, None, None]:\n    \"\"\"Infer an Import node: return the imported module/object.\"\"\"\n    context = context or InferenceContext()\n    name = context.lookupname\n    if name is None:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_import_from",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_import_from(\n    self: nodes.ImportFrom,\n    context: InferenceContext | None = None,\n    asname: bool = True,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"\n    context = context or InferenceContext()\n    name = context.lookupname\n    if name is None:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_attribute",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_attribute(\n    self: nodes.Attribute | nodes.AssignAttr,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer an Attribute node by using getattr on the associated object.\"\"\"\n    for owner in self.expr.infer(context):\n        if owner is util.Uninferable:\n            yield owner\n            continue",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_global",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_global(\n    self: nodes.Global, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if context is None or context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    try:\n        return bases._infer_stmts(self.root().getattr(context.lookupname), context)\n    except AttributeInferenceError as error:\n        raise InferenceError(\n            str(error), target=self, attribute=context.lookupname, context=context",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_subscript",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_subscript(\n    self: nodes.Subscript, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n    \"\"\"Inference for subscripts.\n    We're understanding if the index is a Const\n    or a slice, passing the result of inference\n    to the value's `getitem` method, which should\n    handle each supported index type accordingly.\n    \"\"\"\n    found_one = False",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_unaryop",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_unaryop(\n    self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n    yield from _filter_operation_errors(\n        self, _infer_unaryop, context, util.BadUnaryOperationMessage\n    )\n    return InferenceErrorInfo(node=self, context=context)\nnodes.UnaryOp._infer_unaryop = _infer_unaryop\nnodes.UnaryOp._infer = infer_unaryop",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_binop",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_binop(\n    self: nodes.BinOp, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    return _filter_operation_errors(\n        self, _infer_binop, context, util.BadBinaryOperationMessage\n    )\nnodes.BinOp._infer_binop = _infer_binop\nnodes.BinOp._infer = infer_binop\nCOMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n    \"==\": operator.eq,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_augassign",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_augassign(\n    self: nodes.AugAssign, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    return _filter_operation_errors(\n        self, _infer_augassign, context, util.BadBinaryOperationMessage\n    )\nnodes.AugAssign._infer_augassign = _infer_augassign\nnodes.AugAssign._infer = infer_augassign\n# End of binary operation inference.\n@decorators.raise_if_nothing_inferred",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_arguments",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_arguments(\n    self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if context is None or context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    return protocols._arguments_infer_argname(self, context.lookupname, context)\nnodes.Arguments._infer = infer_arguments  # type: ignore[assignment]\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_assign(",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_assign",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_assign(\n    self: nodes.AssignName | nodes.AssignAttr,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Infer a AssignName/AssignAttr: need to inspect the RHS part of the\n    assign node.\n    \"\"\"\n    if isinstance(self.parent, nodes.AugAssign):\n        return self.parent.infer(context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_empty_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_empty_node(\n    self: nodes.EmptyNode, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if not self.has_underlying_object():\n        yield util.Uninferable\n    else:\n        try:\n            yield from AstroidManager().infer_ast_from_something(\n                self.object, context=context\n            )",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_ifexp",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_ifexp(\n    self: nodes.IfExp, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Support IfExp inference.\n    If we can't infer the truthiness of the condition, we default\n    to inferring both branches. Otherwise, we infer either branch\n    depending on the condition.\n    \"\"\"\n    both_branches = False\n    # We use two separate contexts for evaluating lhs and rhs because",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "infer_functiondef",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "def infer_functiondef(\n    self: _FunctionDefT, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[Property | _FunctionDefT, None, InferenceErrorInfo]:\n    if not self.decorators or not bases._is_property(self):\n        yield self\n        return InferenceErrorInfo(node=self, context=context)\n    # When inferring a property, we instantiate a new `objects.Property` object,\n    # which in turn, because it inherits from `FunctionDef`, sets itself in the locals\n    # of the wrapping frame. This means that every time we infer a property, the locals\n    # are mutated with a new instance of the property. To avoid this, we detect this",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "objects",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "objects = util.lazy_import(\"objects\")\n_T = TypeVar(\"_T\")\n_BaseContainerT = TypeVar(\"_BaseContainerT\", bound=nodes.BaseContainer)\n_FunctionDefT = TypeVar(\"_FunctionDefT\", bound=nodes.FunctionDef)\nGetFlowFactory = typing.Callable[\n    [\n        InferenceResult,\n        Optional[InferenceResult],\n        Union[nodes.AugAssign, nodes.BinOp],\n        InferenceResult,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "_T = TypeVar(\"_T\")\n_BaseContainerT = TypeVar(\"_BaseContainerT\", bound=nodes.BaseContainer)\n_FunctionDefT = TypeVar(\"_FunctionDefT\", bound=nodes.FunctionDef)\nGetFlowFactory = typing.Callable[\n    [\n        InferenceResult,\n        Optional[InferenceResult],\n        Union[nodes.AugAssign, nodes.BinOp],\n        InferenceResult,\n        Optional[InferenceResult],",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "_BaseContainerT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "_BaseContainerT = TypeVar(\"_BaseContainerT\", bound=nodes.BaseContainer)\n_FunctionDefT = TypeVar(\"_FunctionDefT\", bound=nodes.FunctionDef)\nGetFlowFactory = typing.Callable[\n    [\n        InferenceResult,\n        Optional[InferenceResult],\n        Union[nodes.AugAssign, nodes.BinOp],\n        InferenceResult,\n        Optional[InferenceResult],\n        InferenceContext,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "_FunctionDefT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "_FunctionDefT = TypeVar(\"_FunctionDefT\", bound=nodes.FunctionDef)\nGetFlowFactory = typing.Callable[\n    [\n        InferenceResult,\n        Optional[InferenceResult],\n        Union[nodes.AugAssign, nodes.BinOp],\n        InferenceResult,\n        Optional[InferenceResult],\n        InferenceContext,\n        InferenceContext,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "GetFlowFactory",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "GetFlowFactory = typing.Callable[\n    [\n        InferenceResult,\n        Optional[InferenceResult],\n        Union[nodes.AugAssign, nodes.BinOp],\n        InferenceResult,\n        Optional[InferenceResult],\n        InferenceContext,\n        InferenceContext,\n    ],",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Module._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Module._infer = infer_end\nnodes.ClassDef._infer = infer_end\nnodes.Lambda._infer = infer_end  # type: ignore[assignment]\nnodes.Const._infer = infer_end  # type: ignore[assignment]\nnodes.Slice._infer = infer_end  # type: ignore[assignment]\ndef _infer_sequence_helper(\n    node: _BaseContainerT, context: InferenceContext | None = None\n) -> list[SuccessfulInferenceResult]:\n    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n    values = []",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.ClassDef._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.ClassDef._infer = infer_end\nnodes.Lambda._infer = infer_end  # type: ignore[assignment]\nnodes.Const._infer = infer_end  # type: ignore[assignment]\nnodes.Slice._infer = infer_end  # type: ignore[assignment]\ndef _infer_sequence_helper(\n    node: _BaseContainerT, context: InferenceContext | None = None\n) -> list[SuccessfulInferenceResult]:\n    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n    values = []\n    for elt in node.elts:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Lambda._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Lambda._infer = infer_end  # type: ignore[assignment]\nnodes.Const._infer = infer_end  # type: ignore[assignment]\nnodes.Slice._infer = infer_end  # type: ignore[assignment]\ndef _infer_sequence_helper(\n    node: _BaseContainerT, context: InferenceContext | None = None\n) -> list[SuccessfulInferenceResult]:\n    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n    values = []\n    for elt in node.elts:\n        if isinstance(elt, nodes.Starred):",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Const._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Const._infer = infer_end  # type: ignore[assignment]\nnodes.Slice._infer = infer_end  # type: ignore[assignment]\ndef _infer_sequence_helper(\n    node: _BaseContainerT, context: InferenceContext | None = None\n) -> list[SuccessfulInferenceResult]:\n    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n    values = []\n    for elt in node.elts:\n        if isinstance(elt, nodes.Starred):\n            starred = helpers.safe_infer(elt.value, context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Slice._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Slice._infer = infer_end  # type: ignore[assignment]\ndef _infer_sequence_helper(\n    node: _BaseContainerT, context: InferenceContext | None = None\n) -> list[SuccessfulInferenceResult]:\n    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n    values = []\n    for elt in node.elts:\n        if isinstance(elt, nodes.Starred):\n            starred = helpers.safe_infer(elt.value, context)\n            if not starred:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.List._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.List._infer = infer_sequence  # type: ignore[assignment]\nnodes.Tuple._infer = infer_sequence  # type: ignore[assignment]\nnodes.Set._infer = infer_sequence  # type: ignore[assignment]\ndef infer_map(\n    self: nodes.Dict, context: InferenceContext | None = None\n) -> Iterator[nodes.Dict]:\n    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n        yield self\n    else:\n        items = _infer_map(self, context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Tuple._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Tuple._infer = infer_sequence  # type: ignore[assignment]\nnodes.Set._infer = infer_sequence  # type: ignore[assignment]\ndef infer_map(\n    self: nodes.Dict, context: InferenceContext | None = None\n) -> Iterator[nodes.Dict]:\n    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n        yield self\n    else:\n        items = _infer_map(self, context)\n        new_seq = type(self)(self.lineno, self.col_offset, self.parent)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Set._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Set._infer = infer_sequence  # type: ignore[assignment]\ndef infer_map(\n    self: nodes.Dict, context: InferenceContext | None = None\n) -> Iterator[nodes.Dict]:\n    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n        yield self\n    else:\n        items = _infer_map(self, context)\n        new_seq = type(self)(self.lineno, self.col_offset, self.parent)\n        new_seq.postinit(list(items.items()))",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Dict._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Dict._infer = infer_map  # type: ignore[assignment]\ndef _higher_function_scope(node: nodes.NodeNG) -> nodes.FunctionDef | None:\n    \"\"\"Search for the first function which encloses the given\n    scope. This can be used for looking up in that function's\n    scope, in case looking up in a lower scope for a particular\n    name fails.\n    :param node: A scope node.\n    :returns:\n        ``None``, if no parent function scope was found,\n        otherwise an instance of :class:`astroid.nodes.scoped_nodes.Function`,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Name._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Name._infer = decorators.raise_if_nothing_inferred(\n    decorators.path_wrapper(infer_name)\n)\nnodes.AssignName.infer_lhs = infer_name  # won't work with a path wrapper\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_call(\n    self: nodes.Call, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AssignName.infer_lhs",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AssignName.infer_lhs = infer_name  # won't work with a path wrapper\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_call(\n    self: nodes.Call, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n    callcontext = copy_context(context)\n    callcontext.boundnode = None\n    if context is not None:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Call._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Call._infer = infer_call  # type: ignore[assignment]\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_import(\n    self: nodes.Import,\n    context: InferenceContext | None = None,\n    asname: bool = True,\n    **kwargs: Any,\n) -> Generator[nodes.Module, None, None]:\n    \"\"\"Infer an Import node: return the imported module/object.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Import._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Import._infer = infer_import\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_import_from(\n    self: nodes.ImportFrom,\n    context: InferenceContext | None = None,\n    asname: bool = True,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.ImportFrom._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.ImportFrom._infer = infer_import_from  # type: ignore[assignment]\ndef infer_attribute(\n    self: nodes.Attribute | nodes.AssignAttr,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer an Attribute node by using getattr on the associated object.\"\"\"\n    for owner in self.expr.infer(context):\n        if owner is util.Uninferable:\n            yield owner",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Attribute._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Attribute._infer = decorators.raise_if_nothing_inferred(\n    decorators.path_wrapper(infer_attribute)\n)\n# won't work with a path wrapper\nnodes.AssignAttr.infer_lhs = decorators.raise_if_nothing_inferred(infer_attribute)\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_global(\n    self: nodes.Global, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AssignAttr.infer_lhs",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AssignAttr.infer_lhs = decorators.raise_if_nothing_inferred(infer_attribute)\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_global(\n    self: nodes.Global, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if context is None or context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    try:\n        return bases._infer_stmts(self.root().getattr(context.lookupname), context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Global._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Global._infer = infer_global  # type: ignore[assignment]\n_SUBSCRIPT_SENTINEL = object()\ndef infer_subscript(\n    self: nodes.Subscript, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n    \"\"\"Inference for subscripts.\n    We're understanding if the index is a Const\n    or a slice, passing the result of inference\n    to the value's `getitem` method, which should\n    handle each supported index type accordingly.",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "_SUBSCRIPT_SENTINEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "_SUBSCRIPT_SENTINEL = object()\ndef infer_subscript(\n    self: nodes.Subscript, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n    \"\"\"Inference for subscripts.\n    We're understanding if the index is a Const\n    or a slice, passing the result of inference\n    to the value's `getitem` method, which should\n    handle each supported index type accordingly.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Subscript._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Subscript._infer = decorators.raise_if_nothing_inferred(  # type: ignore[assignment]\n    decorators.path_wrapper(infer_subscript)\n)\nnodes.Subscript.infer_lhs = decorators.raise_if_nothing_inferred(infer_subscript)\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef _infer_boolop(\n    self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n    \"\"\"Infer a boolean operation (and / or / not).",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Subscript.infer_lhs",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Subscript.infer_lhs = decorators.raise_if_nothing_inferred(infer_subscript)\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef _infer_boolop(\n    self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n    \"\"\"Infer a boolean operation (and / or / not).\n    The function will calculate the boolean operation\n    for all pairs generated through inference for each component\n    node.",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.BoolOp._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.BoolOp._infer = _infer_boolop\n# UnaryOp, BinOp and AugAssign inferences\ndef _filter_operation_errors(\n    self: _T,\n    infer_callable: Callable[\n        [_T, InferenceContext | None],\n        Generator[InferenceResult | util.BadOperationMessage, None, None],\n    ],\n    context: InferenceContext | None,\n    error: type[util.BadOperationMessage],",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.UnaryOp._infer_unaryop",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.UnaryOp._infer_unaryop = _infer_unaryop\nnodes.UnaryOp._infer = infer_unaryop\ndef _is_not_implemented(const) -> bool:\n    \"\"\"Check if the given const node is NotImplemented.\"\"\"\n    return isinstance(const, nodes.Const) and const.value is NotImplemented\ndef _infer_old_style_string_formatting(\n    instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n) -> tuple[type[util.Uninferable] | nodes.Const]:\n    \"\"\"Infer the result of '\"string\" % ...'.\n    TODO: Instead of returning Uninferable we should rely",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.UnaryOp._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.UnaryOp._infer = infer_unaryop\ndef _is_not_implemented(const) -> bool:\n    \"\"\"Check if the given const node is NotImplemented.\"\"\"\n    return isinstance(const, nodes.Const) and const.value is NotImplemented\ndef _infer_old_style_string_formatting(\n    instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n) -> tuple[type[util.Uninferable] | nodes.Const]:\n    \"\"\"Infer the result of '\"string\" % ...'.\n    TODO: Instead of returning Uninferable we should rely\n    on the call to '%' to see if the result is actually uninferable.",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.BinOp._infer_binop",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.BinOp._infer_binop = _infer_binop\nnodes.BinOp._infer = infer_binop\nCOMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"in\": lambda a, b: a in b,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.BinOp._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.BinOp._infer = infer_binop\nCOMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"in\": lambda a, b: a in b,\n    \"not in\": lambda a, b: a not in b,",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "UNINFERABLE_OPS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "UNINFERABLE_OPS = {\n    \"is\",\n    \"is not\",\n}\ndef _to_literal(node: nodes.NodeNG) -> Any:\n    # Can raise SyntaxError or ValueError from ast.literal_eval\n    # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n    # Is this the stupidest idea or the simplest idea?\n    return ast.literal_eval(node.as_string())\ndef _do_compare(",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Compare._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Compare._infer = _infer_compare  # type: ignore[assignment]\ndef _infer_augassign(\n    self: nodes.AugAssign, context: InferenceContext | None = None\n) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n    \"\"\"Inference logic for augmented binary operations.\"\"\"\n    context = context or InferenceContext()\n    rhs_context = context.clone()\n    lhs_iter = self.target.infer_lhs(context=context)\n    rhs_iter = self.value.infer(context=rhs_context)\n    for lhs, rhs in itertools.product(lhs_iter, rhs_iter):",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AugAssign._infer_augassign",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AugAssign._infer_augassign = _infer_augassign\nnodes.AugAssign._infer = infer_augassign\n# End of binary operation inference.\n@decorators.raise_if_nothing_inferred\ndef infer_arguments(\n    self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if context is None or context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    return protocols._arguments_infer_argname(self, context.lookupname, context)",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AugAssign._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AugAssign._infer = infer_augassign\n# End of binary operation inference.\n@decorators.raise_if_nothing_inferred\ndef infer_arguments(\n    self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if context is None or context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    return protocols._arguments_infer_argname(self, context.lookupname, context)\nnodes.Arguments._infer = infer_arguments  # type: ignore[assignment]",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.Arguments._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.Arguments._infer = infer_arguments  # type: ignore[assignment]\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_assign(\n    self: nodes.AssignName | nodes.AssignAttr,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, None]:\n    \"\"\"Infer a AssignName/AssignAttr: need to inspect the RHS part of the\n    assign node.",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AssignName._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AssignName._infer = infer_assign\nnodes.AssignAttr._infer = infer_assign\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_empty_node(\n    self: nodes.EmptyNode, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if not self.has_underlying_object():\n        yield util.Uninferable\n    else:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.AssignAttr._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.AssignAttr._infer = infer_assign\n@decorators.raise_if_nothing_inferred\n@decorators.path_wrapper\ndef infer_empty_node(\n    self: nodes.EmptyNode, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[InferenceResult, None, None]:\n    if not self.has_underlying_object():\n        yield util.Uninferable\n    else:\n        try:",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.EmptyNode._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.EmptyNode._infer = infer_empty_node  # type: ignore[assignment]\ndef _populate_context_lookup(call: nodes.Call, context: InferenceContext | None):\n    # Allows context to be saved for later\n    # for inference inside a function\n    context_lookup: dict[InferenceResult, InferenceContext] = {}\n    if context is None:\n        return context_lookup\n    for arg in call.args:\n        if isinstance(arg, nodes.Starred):\n            context_lookup[arg.value] = context",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.IfExp._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.IfExp._infer = infer_ifexp  # type: ignore[assignment]\ndef infer_functiondef(\n    self: _FunctionDefT, context: InferenceContext | None = None, **kwargs: Any\n) -> Generator[Property | _FunctionDefT, None, InferenceErrorInfo]:\n    if not self.decorators or not bases._is_property(self):\n        yield self\n        return InferenceErrorInfo(node=self, context=context)\n    # When inferring a property, we instantiate a new `objects.Property` object,\n    # which in turn, because it inherits from `FunctionDef`, sets itself in the locals\n    # of the wrapping frame. This means that every time we infer a property, the locals",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "nodes.FunctionDef._infer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference",
        "description": "__pypackages__.3.10.lib.astroid.inference",
        "peekOfCode": "nodes.FunctionDef._infer = infer_functiondef",
        "detail": "__pypackages__.3.10.lib.astroid.inference",
        "documentation": {}
    },
    {
        "label": "clear_inference_tip_cache",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference_tip",
        "description": "__pypackages__.3.10.lib.astroid.inference_tip",
        "peekOfCode": "def clear_inference_tip_cache() -> None:\n    \"\"\"Clear the inference tips cache.\"\"\"\n    _cache.clear()\n@wrapt.decorator\ndef _inference_tip_cached(\n    func: InferFn, instance: None, args: typing.Any, kwargs: typing.Any\n) -> Iterator[InferOptions]:\n    \"\"\"Cache decorator used for inference tips.\"\"\"\n    node = args[0]\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "inference_tip",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.inference_tip",
        "description": "__pypackages__.3.10.lib.astroid.inference_tip",
        "peekOfCode": "def inference_tip(infer_function: InferFn, raise_on_overwrite: bool = False) -> InferFn:\n    \"\"\"Given an instance specific inference function, return a function to be\n    given to AstroidManager().register_transform to set this inference function.\n    :param bool raise_on_overwrite: Raise an `InferenceOverwriteError`\n        if the inference tip will overwrite another. Used for debugging\n    Typical usage\n    .. sourcecode:: python\n       AstroidManager().register_transform(Call, inference_tip(infer_named_tuple),\n                                  predicate)\n    .. Note::",
        "detail": "__pypackages__.3.10.lib.astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "InferOptions",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.inference_tip",
        "description": "__pypackages__.3.10.lib.astroid.inference_tip",
        "peekOfCode": "InferOptions = typing.Union[\n    NodeNG, bases.Instance, bases.UnboundMethod, typing.Type[util.Uninferable]\n]\n_cache: dict[tuple[InferFn, NodeNG], list[InferOptions] | None] = {}\ndef clear_inference_tip_cache() -> None:\n    \"\"\"Clear the inference tips cache.\"\"\"\n    _cache.clear()\n@wrapt.decorator\ndef _inference_tip_cached(\n    func: InferFn, instance: None, args: typing.Any, kwargs: typing.Any",
        "detail": "__pypackages__.3.10.lib.astroid.inference_tip",
        "documentation": {}
    },
    {
        "label": "AstroidManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.manager",
        "description": "__pypackages__.3.10.lib.astroid.manager",
        "peekOfCode": "class AstroidManager:\n    \"\"\"Responsible to build astroid from files or modules.\n    Use the Borg (singleton) pattern.\n    \"\"\"\n    name = \"astroid loader\"\n    brain: AstroidManagerBrain = {\n        \"astroid_cache\": {},\n        \"_mod_file_cache\": {},\n        \"_failed_import_hooks\": [],\n        \"always_load_extensions\": False,",
        "detail": "__pypackages__.3.10.lib.astroid.manager",
        "documentation": {}
    },
    {
        "label": "safe_repr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.manager",
        "description": "__pypackages__.3.10.lib.astroid.manager",
        "peekOfCode": "def safe_repr(obj: Any) -> str:\n    try:\n        return repr(obj)\n    except Exception:  # pylint: disable=broad-except\n        return \"???\"\nclass AstroidManager:\n    \"\"\"Responsible to build astroid from files or modules.\n    Use the Borg (singleton) pattern.\n    \"\"\"\n    name = \"astroid loader\"",
        "detail": "__pypackages__.3.10.lib.astroid.manager",
        "documentation": {}
    },
    {
        "label": "ZIP_IMPORT_EXTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.manager",
        "description": "__pypackages__.3.10.lib.astroid.manager",
        "peekOfCode": "ZIP_IMPORT_EXTS = (\".zip\", \".egg\", \".whl\", \".pyz\", \".pyzw\")\ndef safe_repr(obj: Any) -> str:\n    try:\n        return repr(obj)\n    except Exception:  # pylint: disable=broad-except\n        return \"???\"\nclass AstroidManager:\n    \"\"\"Responsible to build astroid from files or modules.\n    Use the Borg (singleton) pattern.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.manager",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.mixins",
        "description": "__pypackages__.3.10.lib.astroid.mixins",
        "peekOfCode": "__all__ = (\n    \"AssignTypeMixin\",\n    \"BlockRangeMixIn\",\n    \"FilterStmtsMixin\",\n    \"ImportFromMixin\",\n    \"MultiLineBlockMixin\",\n    \"NoChildrenMixin\",\n    \"ParentAssignTypeMixin\",\n)\nwarnings.warn(",
        "detail": "__pypackages__.3.10.lib.astroid.mixins",
        "documentation": {}
    },
    {
        "label": "NoSourceFile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "class NoSourceFile(Exception):\n    \"\"\"Exception raised when we are not able to get a python\n    source file for a precompiled file.\n    \"\"\"\ndef _normalize_path(path: str) -> str:\n    \"\"\"Resolve symlinks in path and convert to absolute path.\n    Note that environment variables and ~ in the path need to be expanded in\n    advance.\n    This can be cached by using _cache_normalize_path.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "load_module_from_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def load_module_from_name(dotted_name: str) -> types.ModuleType:\n    \"\"\"Load a Python module from its name.\n    :type dotted_name: str\n    :param dotted_name: python name of a module or package\n    :raise ImportError: if the module or package is not found\n    :rtype: module\n    :return: the loaded module\n    \"\"\"\n    try:\n        return sys.modules[dotted_name]",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "load_module_from_modpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def load_module_from_modpath(parts: Sequence[str]) -> types.ModuleType:\n    \"\"\"Load a python module from its split name.\n    :param parts:\n      python name of a module or package split on '.'\n    :raise ImportError: if the module or package is not found\n    :return: the loaded module\n    \"\"\"\n    return load_module_from_name(\".\".join(parts))\ndef load_module_from_file(filepath: str) -> types.ModuleType:\n    \"\"\"Load a Python module from it's path.",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "load_module_from_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def load_module_from_file(filepath: str) -> types.ModuleType:\n    \"\"\"Load a Python module from it's path.\n    :type filepath: str\n    :param filepath: path to the python module or package\n    :raise ImportError: if the module or package is not found\n    :rtype: module\n    :return: the loaded module\n    \"\"\"\n    modpath = modpath_from_file(filepath)\n    return load_module_from_modpath(modpath)",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "check_modpath_has_init",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def check_modpath_has_init(path: str, mod_path: list[str]) -> bool:\n    \"\"\"Check there are some __init__.py all along the way.\"\"\"\n    modpath: list[str] = []\n    for part in mod_path:\n        modpath.append(part)\n        path = os.path.join(path, part)\n        if not _has_init(path):\n            old_namespace = util.is_namespace(\".\".join(modpath))\n            if not old_namespace:\n                return False",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "modpath_from_file_with_callback",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def modpath_from_file_with_callback(\n    filename: str,\n    path: Sequence[str] | None = None,\n    is_package_cb: Callable[[str, list[str]], bool] | None = None,\n) -> list[str]:\n    filename = os.path.expanduser(_path_from_filename(filename))\n    paths_to_check = sys.path.copy()\n    if path:\n        paths_to_check += path\n    for pathname in itertools.chain(",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "modpath_from_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def modpath_from_file(filename: str, path: Sequence[str] | None = None) -> list[str]:\n    \"\"\"Get the corresponding split module's name from a filename.\n    This function will return the name of a module or package split on `.`.\n    :type filename: str\n    :param filename: file's path for which we want the module's name\n    :type Optional[List[str]] path:\n      Optional list of path where the module or package should be\n      searched (use sys.path if nothing or None is given)\n    :raise ImportError:\n      if the corresponding module's name has not been found",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "file_from_modpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def file_from_modpath(\n    modpath: list[str],\n    path: Sequence[str] | None = None,\n    context_file: str | None = None,\n) -> str | None:\n    return file_info_from_modpath(modpath, path, context_file).location\ndef file_info_from_modpath(\n    modpath: list[str],\n    path: Sequence[str] | None = None,\n    context_file: str | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "file_info_from_modpath",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def file_info_from_modpath(\n    modpath: list[str],\n    path: Sequence[str] | None = None,\n    context_file: str | None = None,\n) -> spec.ModuleSpec:\n    \"\"\"Given a mod path (i.e. split module / package name), return the\n    corresponding file.\n    Giving priority to source file over precompiled file if it exists.\n    :param modpath:\n      split module's name (i.e name of a module or package split",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "get_module_part",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def get_module_part(dotted_name: str, context_file: str | None = None) -> str:\n    \"\"\"Given a dotted name return the module part of the name :\n    >>> get_module_part('astroid.as_string.dump')\n    'astroid.as_string'\n    :param dotted_name: full name of the identifier we are interested in\n    :param context_file:\n      context file to consider, necessary if the identifier has been\n      introduced using a relative import unresolvable in the actual\n      context (i.e. modutils)\n    :raise ImportError: if there is no such module in the directory",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "get_module_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def get_module_files(\n    src_directory: str, blacklist: Sequence[str], list_all: bool = False\n) -> list[str]:\n    \"\"\"Given a package directory return a list of all available python\n    module's files in the package and its subpackages.\n    :param src_directory:\n      path of the directory corresponding to the package\n    :param blacklist: iterable\n      list of files or directories to ignore.\n    :param list_all:",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "get_source_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def get_source_file(filename: str, include_no_ext: bool = False) -> str:\n    \"\"\"Given a python module's file name return the matching source file\n    name (the filename will be returned identically if it's already an.\n    absolute path to a python source file...)\n    :param filename: python module's file name\n    :raise NoSourceFile: if no source file exists on the file system\n    :return: the absolute path of the source file if it exists\n    \"\"\"\n    filename = os.path.abspath(_path_from_filename(filename))\n    base, orig_ext = os.path.splitext(filename)",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_python_source",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_python_source(filename: str | None) -> bool:\n    \"\"\"Return: True if the filename is a python source file.\"\"\"\n    if not filename:\n        return False\n    return os.path.splitext(filename)[1][1:] in PY_SOURCE_EXTS\ndef is_standard_module(modname: str, std_path: Iterable[str] | None = None) -> bool:\n    \"\"\"Try to guess if a module is a standard python module (by default,\n    see `std_path` parameter's description).\n    :param modname: name of the module we are interested in\n    :param std_path: list of path considered has standard",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_standard_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_standard_module(modname: str, std_path: Iterable[str] | None = None) -> bool:\n    \"\"\"Try to guess if a module is a standard python module (by default,\n    see `std_path` parameter's description).\n    :param modname: name of the module we are interested in\n    :param std_path: list of path considered has standard\n    :return:\n      true if the module:\n      - is located on the path listed in one of the directory in `std_path`\n      - is a built-in module\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_relative",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_relative(modname: str, from_file: str) -> bool:\n    \"\"\"Return true if the given module name is relative to the given\n    file name.\n    :param modname: name of the module we are interested in\n    :param from_file:\n      path of the module from which modname has been imported\n    :return:\n      true if the module has been imported relatively to `from_file`\n    \"\"\"\n    if not os.path.isdir(from_file):",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_namespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_namespace(specobj: spec.ModuleSpec) -> bool:\n    return specobj.type == spec.ModuleType.PY_NAMESPACE\ndef is_directory(specobj: spec.ModuleSpec) -> bool:\n    return specobj.type == spec.ModuleType.PKG_DIRECTORY\ndef is_module_name_part_of_extension_package_whitelist(\n    module_name: str, package_whitelist: set[str]\n) -> bool:\n    \"\"\"\n    Returns True if one part of the module name is in the package whitelist.\n    >>> is_module_name_part_of_extension_package_whitelist('numpy.core.umath', {'numpy'})",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_directory",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_directory(specobj: spec.ModuleSpec) -> bool:\n    return specobj.type == spec.ModuleType.PKG_DIRECTORY\ndef is_module_name_part_of_extension_package_whitelist(\n    module_name: str, package_whitelist: set[str]\n) -> bool:\n    \"\"\"\n    Returns True if one part of the module name is in the package whitelist.\n    >>> is_module_name_part_of_extension_package_whitelist('numpy.core.umath', {'numpy'})\n    True\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "is_module_name_part_of_extension_package_whitelist",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "def is_module_name_part_of_extension_package_whitelist(\n    module_name: str, package_whitelist: set[str]\n) -> bool:\n    \"\"\"\n    Returns True if one part of the module name is in the package whitelist.\n    >>> is_module_name_part_of_extension_package_whitelist('numpy.core.umath', {'numpy'})\n    True\n    \"\"\"\n    parts = module_name.split(\".\")\n    return any(",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "logger = logging.getLogger(__name__)\nif sys.platform.startswith(\"win\"):\n    PY_SOURCE_EXTS = (\"py\", \"pyw\")\n    PY_COMPILED_EXTS = (\"dll\", \"pyd\")\nelse:\n    PY_SOURCE_EXTS = (\"py\",)\n    PY_COMPILED_EXTS = (\"so\",)\n# TODO: Adding `platstdlib` is a fix for a workaround in virtualenv. At some point we should\n# revisit whether this is still necessary. See https://github.com/PyCQA/astroid/pull/1323.\nSTD_LIB_DIRS = {sysconfig.get_path(\"stdlib\"), sysconfig.get_path(\"platstdlib\")}",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "STD_LIB_DIRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "STD_LIB_DIRS = {sysconfig.get_path(\"stdlib\"), sysconfig.get_path(\"platstdlib\")}\nif os.name == \"nt\":\n    STD_LIB_DIRS.add(os.path.join(sys.prefix, \"dlls\"))\n    try:\n        # real_prefix is defined when running inside virtual environments,\n        # created with the **virtualenv** library.\n        # Deprecated in virtualenv==16.7.9\n        # See: https://github.com/pypa/virtualenv/issues/1622\n        STD_LIB_DIRS.add(os.path.join(sys.real_prefix, \"dlls\"))  # type: ignore[attr-defined]\n    except AttributeError:",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "EXT_LIB_DIRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "EXT_LIB_DIRS = {sysconfig.get_path(\"purelib\"), sysconfig.get_path(\"platlib\")}\nBUILTIN_MODULES = dict.fromkeys(sys.builtin_module_names, True)\nclass NoSourceFile(Exception):\n    \"\"\"Exception raised when we are not able to get a python\n    source file for a precompiled file.\n    \"\"\"\ndef _normalize_path(path: str) -> str:\n    \"\"\"Resolve symlinks in path and convert to absolute path.\n    Note that environment variables and ~ in the path need to be expanded in\n    advance.",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "BUILTIN_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.modutils",
        "description": "__pypackages__.3.10.lib.astroid.modutils",
        "peekOfCode": "BUILTIN_MODULES = dict.fromkeys(sys.builtin_module_names, True)\nclass NoSourceFile(Exception):\n    \"\"\"Exception raised when we are not able to get a python\n    source file for a precompiled file.\n    \"\"\"\ndef _normalize_path(path: str) -> str:\n    \"\"\"Resolve symlinks in path and convert to absolute path.\n    Note that environment variables and ~ in the path need to be expanded in\n    advance.\n    This can be cached by using _cache_normalize_path.",
        "detail": "__pypackages__.3.10.lib.astroid.modutils",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class FrozenSet(node_classes.BaseContainer):\n    \"\"\"Class representing a FrozenSet composite node.\"\"\"\n    def pytype(self) -> Literal[\"builtins.frozenset\"]:\n        return \"builtins.frozenset\"\n    def _infer(self, context: InferenceContext | None = None, **kwargs: Any):\n        yield self\n    @cached_property\n    def _proxied(self):  # pylint: disable=method-hidden\n        ast_builtins = AstroidManager().builtins_module\n        return ast_builtins.getattr(\"frozenset\")[0]",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "Super",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class Super(node_classes.NodeNG):\n    \"\"\"Proxy class over a super call.\n    This class offers almost the same behaviour as Python's super,\n    which is MRO lookups for retrieving attributes from the parents.\n    The *mro_pointer* is the place in the MRO from where we should\n    start looking, not counting it. *mro_type* is the object which\n    provides the MRO, it can be both a type or an instance.\n    *self_class* is the class where the super call is, while\n    *scope* is the function where the super call is.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "ExceptionInstance",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class ExceptionInstance(bases.Instance):\n    \"\"\"Class for instances of exceptions.\n    It has special treatment for some of the exceptions's attributes,\n    which are transformed at runtime into certain concrete objects, such as\n    the case of .args.\n    \"\"\"\n    @cached_property\n    def special_attributes(self):\n        qname = self.qname()\n        instance = objectmodel.BUILTIN_EXCEPTIONS.get(",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "DictInstance",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class DictInstance(bases.Instance):\n    \"\"\"Special kind of instances for dictionaries.\n    This instance knows the underlying object model of the dictionaries, which means\n    that methods such as .values or .items can be properly inferred.\n    \"\"\"\n    # pylint: disable=unnecessary-lambda\n    special_attributes = util.lazy_descriptor(lambda: objectmodel.DictModel())\n# Custom objects tailored for dictionaries, which are used to\n# disambiguate between the types of Python 2 dict's method returns\n# and Python 3 (where they return set like objects).",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "DictItems",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class DictItems(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass DictKeys(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass DictValues(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass PartialFunction(scoped_nodes.FunctionDef):",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "DictKeys",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class DictKeys(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass DictValues(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass PartialFunction(scoped_nodes.FunctionDef):\n    \"\"\"A class representing partial function obtained via functools.partial.\"\"\"\n    @decorators.deprecate_arguments(doc=\"Use the postinit arg 'doc_node' instead\")\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "DictValues",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class DictValues(bases.Proxy):\n    __str__ = node_classes.NodeNG.__str__\n    __repr__ = node_classes.NodeNG.__repr__\nclass PartialFunction(scoped_nodes.FunctionDef):\n    \"\"\"A class representing partial function obtained via functools.partial.\"\"\"\n    @decorators.deprecate_arguments(doc=\"Use the postinit arg 'doc_node' instead\")\n    def __init__(\n        self, call, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        # TODO: Pass end_lineno and end_col_offset as well",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "PartialFunction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class PartialFunction(scoped_nodes.FunctionDef):\n    \"\"\"A class representing partial function obtained via functools.partial.\"\"\"\n    @decorators.deprecate_arguments(doc=\"Use the postinit arg 'doc_node' instead\")\n    def __init__(\n        self, call, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        # TODO: Pass end_lineno and end_col_offset as well\n        super().__init__(name, lineno=lineno, col_offset=col_offset, parent=None)\n        # Assigned directly to prevent triggering the DeprecationWarning.\n        self._doc = doc",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "Property",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "class Property(scoped_nodes.FunctionDef):\n    \"\"\"Class representing a Python property.\"\"\"\n    @decorators.deprecate_arguments(doc=\"Use the postinit arg 'doc_node' instead\")\n    def __init__(\n        self, function, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        self.function = function\n        super().__init__(name, lineno=lineno, col_offset=col_offset, parent=parent)\n        # Assigned directly to prevent triggering the DeprecationWarning.\n        self._doc = doc",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "objectmodel",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "objectmodel = util.lazy_import(\"interpreter.objectmodel\")\nif sys.version_info >= (3, 8):\n    from functools import cached_property\n    from typing import Literal\nelse:\n    from typing_extensions import Literal\n    from astroid.decorators import cachedproperty as cached_property\n_T = TypeVar(\"_T\")\nclass FrozenSet(node_classes.BaseContainer):\n    \"\"\"Class representing a FrozenSet composite node.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "_T = TypeVar(\"_T\")\nclass FrozenSet(node_classes.BaseContainer):\n    \"\"\"Class representing a FrozenSet composite node.\"\"\"\n    def pytype(self) -> Literal[\"builtins.frozenset\"]:\n        return \"builtins.frozenset\"\n    def _infer(self, context: InferenceContext | None = None, **kwargs: Any):\n        yield self\n    @cached_property\n    def _proxied(self):  # pylint: disable=method-hidden\n        ast_builtins = AstroidManager().builtins_module",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "node_classes.Dict.__bases__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.objects",
        "description": "__pypackages__.3.10.lib.astroid.objects",
        "peekOfCode": "node_classes.Dict.__bases__ = (node_classes.NodeNG, DictInstance)\nclass Property(scoped_nodes.FunctionDef):\n    \"\"\"Class representing a Python property.\"\"\"\n    @decorators.deprecate_arguments(doc=\"Use the postinit arg 'doc_node' instead\")\n    def __init__(\n        self, function, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        self.function = function\n        super().__init__(name, lineno=lineno, col_offset=col_offset, parent=parent)\n        # Assigned directly to prevent triggering the DeprecationWarning.",
        "detail": "__pypackages__.3.10.lib.astroid.objects",
        "documentation": {}
    },
    {
        "label": "const_infer_binary_op",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def const_infer_binary_op(\n    self: nodes.Const,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    operator: str,\n    other: InferenceResult,\n    context: InferenceContext,\n    _: SuccessfulInferenceResult,\n) -> Generator[ConstFactoryResult | type[util.Uninferable], None, None]:\n    not_implemented = nodes.Const(NotImplemented)\n    if isinstance(other, nodes.Const):",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "tl_infer_binary_op",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def tl_infer_binary_op(\n    self: _TupleListNodeT,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    operator: str,\n    other: InferenceResult,\n    context: InferenceContext,\n    method: SuccessfulInferenceResult,\n) -> Generator[_TupleListNodeT | nodes.Const | type[util.Uninferable], None, None]:\n    \"\"\"Infer a binary operation on a tuple or list.\n    The instance on which the binary operation is performed is a tuple",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "instance_class_infer_binary_op",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def instance_class_infer_binary_op(\n    self: bases.Instance | nodes.ClassDef,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    operator: str,\n    other: InferenceResult,\n    context: InferenceContext,\n    method: SuccessfulInferenceResult,\n) -> Generator[InferenceResult, None, None]:\n    return method.infer_call_result(self, context)\nbases.Instance.infer_binary_op = instance_class_infer_binary_op",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "for_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def for_assigned_stmts(\n    self: nodes.For | nodes.Comprehension,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if isinstance(self, nodes.AsyncFor) or getattr(self, \"is_async\", False):\n        # Skip inferring of async code for now\n        return {\n            \"node\": self,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "sequence_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def sequence_assigned_stmts(\n    self: nodes.Tuple | nodes.List,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if assign_path is None:\n        assign_path = []\n    try:\n        index = self.elts.index(node)  # type: ignore[arg-type]",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "assend_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def assend_assigned_stmts(\n    self: nodes.AssignName | nodes.AssignAttr,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    return self.parent.assigned_stmts(node=self, context=context)\nnodes.AssignName.assigned_stmts = assend_assigned_stmts\nnodes.AssignAttr.assigned_stmts = assend_assigned_stmts\ndef _arguments_infer_argname(",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "arguments_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def arguments_assigned_stmts(\n    self: nodes.Arguments,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    try:\n        node_name = node.name  # type: ignore[union-attr]\n    except AttributeError:\n        # Added to handle edge cases where node.name is not defined.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "assign_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def assign_assigned_stmts(\n    self: nodes.AugAssign | nodes.Assign | nodes.AnnAssign,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if not assign_path:\n        yield self.value\n        return None\n    yield from _resolve_assignment_parts(",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "assign_annassigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def assign_annassigned_stmts(\n    self: nodes.AnnAssign,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    for inferred in assign_assigned_stmts(self, node, context, assign_path):\n        if inferred is None:\n            yield util.Uninferable\n        else:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "excepthandler_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def excepthandler_assigned_stmts(\n    self: nodes.ExceptHandler,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    for assigned in node_classes.unpack_infer(self.type):\n        if isinstance(assigned, nodes.ClassDef):\n            assigned = objects.ExceptionInstance(assigned)\n        yield assigned",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "with_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def with_assigned_stmts(\n    self: nodes.With,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    \"\"\"Infer names and other nodes from a *with* statement.\n    This enables only inference for name binding in a *with* statement.\n    For instance, in the following code, inferring `func` will return\n    the `ContextManager` class, not whatever ``__enter__`` returns.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "named_expr_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def named_expr_assigned_stmts(\n    self: nodes.NamedExpr,\n    node: node_classes.AssignedStmtsPossibleNode,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    \"\"\"Infer names and other nodes from an assignment expression.\"\"\"\n    if self.target == node:\n        yield from self.value.infer(context=context)\n    else:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "starred_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def starred_assigned_stmts(  # noqa: C901\n    self: nodes.Starred,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    \"\"\"\n    Arguments:\n        self: nodes.Starred\n        node: a node related to the current underlying Node.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "match_mapping_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def match_mapping_assigned_stmts(\n    self: nodes.MatchMapping,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.\n    \"\"\"\n    return",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "match_star_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def match_star_assigned_stmts(\n    self: nodes.MatchStar,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.\n    \"\"\"\n    return",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "match_as_assigned_stmts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "def match_as_assigned_stmts(\n    self: nodes.MatchAs,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Infer MatchAs as the Match subject if it's the only MatchCase pattern\n    else raise StopIteration to yield Uninferable.\n    \"\"\"\n    if (",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "raw_building",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "raw_building = util.lazy_import(\"raw_building\")\nobjects = util.lazy_import(\"objects\")\n_TupleListNodeT = TypeVar(\"_TupleListNodeT\", nodes.Tuple, nodes.List)\ndef _reflected_name(name) -> str:\n    return \"__r\" + name[2:]\ndef _augmented_name(name) -> str:\n    return \"__i\" + name[2:]\n_CONTEXTLIB_MGR = \"contextlib.contextmanager\"\nBIN_OP_METHOD = {\n    \"+\": \"__add__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "objects",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "objects = util.lazy_import(\"objects\")\n_TupleListNodeT = TypeVar(\"_TupleListNodeT\", nodes.Tuple, nodes.List)\ndef _reflected_name(name) -> str:\n    return \"__r\" + name[2:]\ndef _augmented_name(name) -> str:\n    return \"__i\" + name[2:]\n_CONTEXTLIB_MGR = \"contextlib.contextmanager\"\nBIN_OP_METHOD = {\n    \"+\": \"__add__\",\n    \"-\": \"__sub__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "_TupleListNodeT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "_TupleListNodeT = TypeVar(\"_TupleListNodeT\", nodes.Tuple, nodes.List)\ndef _reflected_name(name) -> str:\n    return \"__r\" + name[2:]\ndef _augmented_name(name) -> str:\n    return \"__i\" + name[2:]\n_CONTEXTLIB_MGR = \"contextlib.contextmanager\"\nBIN_OP_METHOD = {\n    \"+\": \"__add__\",\n    \"-\": \"__sub__\",\n    \"/\": \"__truediv__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "_CONTEXTLIB_MGR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "_CONTEXTLIB_MGR = \"contextlib.contextmanager\"\nBIN_OP_METHOD = {\n    \"+\": \"__add__\",\n    \"-\": \"__sub__\",\n    \"/\": \"__truediv__\",\n    \"//\": \"__floordiv__\",\n    \"*\": \"__mul__\",\n    \"**\": \"__pow__\",\n    \"%\": \"__mod__\",\n    \"&\": \"__and__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "BIN_OP_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "BIN_OP_METHOD = {\n    \"+\": \"__add__\",\n    \"-\": \"__sub__\",\n    \"/\": \"__truediv__\",\n    \"//\": \"__floordiv__\",\n    \"*\": \"__mul__\",\n    \"**\": \"__pow__\",\n    \"%\": \"__mod__\",\n    \"&\": \"__and__\",\n    \"|\": \"__or__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "REFLECTED_BIN_OP_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "REFLECTED_BIN_OP_METHOD = {\n    key: _reflected_name(value) for (key, value) in BIN_OP_METHOD.items()\n}\nAUGMENTED_OP_METHOD = {\n    key + \"=\": _augmented_name(value) for (key, value) in BIN_OP_METHOD.items()\n}\nUNARY_OP_METHOD = {\n    \"+\": \"__pos__\",\n    \"-\": \"__neg__\",\n    \"~\": \"__invert__\",",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "AUGMENTED_OP_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "AUGMENTED_OP_METHOD = {\n    key + \"=\": _augmented_name(value) for (key, value) in BIN_OP_METHOD.items()\n}\nUNARY_OP_METHOD = {\n    \"+\": \"__pos__\",\n    \"-\": \"__neg__\",\n    \"~\": \"__invert__\",\n    \"not\": None,  # XXX not '__nonzero__'\n}\n_UNARY_OPERATORS: dict[str, Callable[[Any], Any]] = {",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "UNARY_OP_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "UNARY_OP_METHOD = {\n    \"+\": \"__pos__\",\n    \"-\": \"__neg__\",\n    \"~\": \"__invert__\",\n    \"not\": None,  # XXX not '__nonzero__'\n}\n_UNARY_OPERATORS: dict[str, Callable[[Any], Any]] = {\n    \"+\": operator_mod.pos,\n    \"-\": operator_mod.neg,\n    \"~\": operator_mod.invert,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Tuple.infer_unary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Tuple.infer_unary_op = lambda self, op: _infer_unary_op(tuple(self.elts), op)\nnodes.List.infer_unary_op = lambda self, op: _infer_unary_op(self.elts, op)\nnodes.Set.infer_unary_op = lambda self, op: _infer_unary_op(set(self.elts), op)\nnodes.Const.infer_unary_op = lambda self, op: _infer_unary_op(self.value, op)\nnodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n# Binary operations\nBIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.List.infer_unary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.List.infer_unary_op = lambda self, op: _infer_unary_op(self.elts, op)\nnodes.Set.infer_unary_op = lambda self, op: _infer_unary_op(set(self.elts), op)\nnodes.Const.infer_unary_op = lambda self, op: _infer_unary_op(self.value, op)\nnodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n# Binary operations\nBIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,\n    \"//\": lambda a, b: a // b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Set.infer_unary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Set.infer_unary_op = lambda self, op: _infer_unary_op(set(self.elts), op)\nnodes.Const.infer_unary_op = lambda self, op: _infer_unary_op(self.value, op)\nnodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n# Binary operations\nBIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,\n    \"//\": lambda a, b: a // b,\n    \"*\": lambda a, b: a * b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Const.infer_unary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Const.infer_unary_op = lambda self, op: _infer_unary_op(self.value, op)\nnodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n# Binary operations\nBIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,\n    \"//\": lambda a, b: a // b,\n    \"*\": lambda a, b: a * b,\n    \"**\": lambda a, b: a**b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Dict.infer_unary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n# Binary operations\nBIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,\n    \"//\": lambda a, b: a // b,\n    \"*\": lambda a, b: a * b,\n    \"**\": lambda a, b: a**b,\n    \"%\": lambda a, b: a % b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "BIN_OP_IMPL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "BIN_OP_IMPL = {\n    \"+\": lambda a, b: a + b,\n    \"-\": lambda a, b: a - b,\n    \"/\": lambda a, b: a / b,\n    \"//\": lambda a, b: a // b,\n    \"*\": lambda a, b: a * b,\n    \"**\": lambda a, b: a**b,\n    \"%\": lambda a, b: a % b,\n    \"&\": lambda a, b: a & b,\n    \"|\": lambda a, b: a | b,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Const.infer_binary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Const.infer_binary_op = const_infer_binary_op\ndef _multiply_seq_by_int(\n    self: _TupleListNodeT,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    other: nodes.Const,\n    context: InferenceContext,\n) -> _TupleListNodeT:\n    node = self.__class__(parent=opnode)\n    filtered_elts = (\n        helpers.safe_infer(elt, context) or util.Uninferable",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Tuple.infer_binary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Tuple.infer_binary_op = tl_infer_binary_op\nnodes.List.infer_binary_op = tl_infer_binary_op\n@decorators.yes_if_nothing_inferred\ndef instance_class_infer_binary_op(\n    self: bases.Instance | nodes.ClassDef,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    operator: str,\n    other: InferenceResult,\n    context: InferenceContext,\n    method: SuccessfulInferenceResult,",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.List.infer_binary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.List.infer_binary_op = tl_infer_binary_op\n@decorators.yes_if_nothing_inferred\ndef instance_class_infer_binary_op(\n    self: bases.Instance | nodes.ClassDef,\n    opnode: nodes.AugAssign | nodes.BinOp,\n    operator: str,\n    other: InferenceResult,\n    context: InferenceContext,\n    method: SuccessfulInferenceResult,\n) -> Generator[InferenceResult, None, None]:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "bases.Instance.infer_binary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "bases.Instance.infer_binary_op = instance_class_infer_binary_op\nnodes.ClassDef.infer_binary_op = instance_class_infer_binary_op\n# assignment ##################################################################\n\"\"\"The assigned_stmts method is responsible to return the assigned statement\n(e.g. not inferred) according to the assignment type.\nThe `assign_path` argument is used to record the lhs path of the original node.\nFor instance if we want assigned statements for 'c' in 'a, (b,c)', assign_path\nwill be [1, 1] once arrived to the Assign node.\nThe `context` argument is the current inference context which should be given\nto any intermediary inference necessary.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.ClassDef.infer_binary_op",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.ClassDef.infer_binary_op = instance_class_infer_binary_op\n# assignment ##################################################################\n\"\"\"The assigned_stmts method is responsible to return the assigned statement\n(e.g. not inferred) according to the assignment type.\nThe `assign_path` argument is used to record the lhs path of the original node.\nFor instance if we want assigned statements for 'c' in 'a, (b,c)', assign_path\nwill be [1, 1] once arrived to the Assign node.\nThe `context` argument is the current inference context which should be given\nto any intermediary inference necessary.\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.For.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.For.assigned_stmts = for_assigned_stmts\nnodes.Comprehension.assigned_stmts = for_assigned_stmts\ndef sequence_assigned_stmts(\n    self: nodes.Tuple | nodes.List,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if assign_path is None:\n        assign_path = []",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Comprehension.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Comprehension.assigned_stmts = for_assigned_stmts\ndef sequence_assigned_stmts(\n    self: nodes.Tuple | nodes.List,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if assign_path is None:\n        assign_path = []\n    try:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Tuple.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Tuple.assigned_stmts = sequence_assigned_stmts\nnodes.List.assigned_stmts = sequence_assigned_stmts\ndef assend_assigned_stmts(\n    self: nodes.AssignName | nodes.AssignAttr,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    return self.parent.assigned_stmts(node=self, context=context)\nnodes.AssignName.assigned_stmts = assend_assigned_stmts",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.List.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.List.assigned_stmts = sequence_assigned_stmts\ndef assend_assigned_stmts(\n    self: nodes.AssignName | nodes.AssignAttr,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    return self.parent.assigned_stmts(node=self, context=context)\nnodes.AssignName.assigned_stmts = assend_assigned_stmts\nnodes.AssignAttr.assigned_stmts = assend_assigned_stmts",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.AssignName.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.AssignName.assigned_stmts = assend_assigned_stmts\nnodes.AssignAttr.assigned_stmts = assend_assigned_stmts\ndef _arguments_infer_argname(\n    self, name: str | None, context: InferenceContext\n) -> Generator[InferenceResult, None, None]:\n    # arguments information may be missing, in which case we can't do anything\n    # more\n    if not (self.arguments or self.vararg or self.kwarg):\n        yield util.Uninferable\n        return",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.AssignAttr.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.AssignAttr.assigned_stmts = assend_assigned_stmts\ndef _arguments_infer_argname(\n    self, name: str | None, context: InferenceContext\n) -> Generator[InferenceResult, None, None]:\n    # arguments information may be missing, in which case we can't do anything\n    # more\n    if not (self.arguments or self.vararg or self.kwarg):\n        yield util.Uninferable\n        return\n    functype = self.parent.type",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Arguments.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Arguments.assigned_stmts = arguments_assigned_stmts\n@decorators.raise_if_nothing_inferred\ndef assign_assigned_stmts(\n    self: nodes.AugAssign | nodes.Assign | nodes.AnnAssign,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    if not assign_path:\n        yield self.value",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Assign.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Assign.assigned_stmts = assign_assigned_stmts\nnodes.AnnAssign.assigned_stmts = assign_annassigned_stmts\nnodes.AugAssign.assigned_stmts = assign_assigned_stmts\ndef _resolve_assignment_parts(parts, assign_path, context):\n    \"\"\"Recursive function to resolve multiple assignments.\"\"\"\n    assign_path = assign_path[:]\n    index = assign_path.pop(0)\n    for part in parts:\n        assigned = None\n        if isinstance(part, nodes.Dict):",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.AnnAssign.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.AnnAssign.assigned_stmts = assign_annassigned_stmts\nnodes.AugAssign.assigned_stmts = assign_assigned_stmts\ndef _resolve_assignment_parts(parts, assign_path, context):\n    \"\"\"Recursive function to resolve multiple assignments.\"\"\"\n    assign_path = assign_path[:]\n    index = assign_path.pop(0)\n    for part in parts:\n        assigned = None\n        if isinstance(part, nodes.Dict):\n            # A dictionary in an iterating context",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.AugAssign.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.AugAssign.assigned_stmts = assign_assigned_stmts\ndef _resolve_assignment_parts(parts, assign_path, context):\n    \"\"\"Recursive function to resolve multiple assignments.\"\"\"\n    assign_path = assign_path[:]\n    index = assign_path.pop(0)\n    for part in parts:\n        assigned = None\n        if isinstance(part, nodes.Dict):\n            # A dictionary in an iterating context\n            try:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.ExceptHandler.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.ExceptHandler.assigned_stmts = excepthandler_assigned_stmts\ndef _infer_context_manager(self, mgr, context):\n    try:\n        inferred = next(mgr.infer(context=context))\n    except StopIteration as e:\n        raise InferenceError(node=mgr) from e\n    if isinstance(inferred, bases.Generator):\n        # Check if it is decorated with contextlib.contextmanager.\n        func = inferred.parent\n        if not func.decorators:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.With.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.With.assigned_stmts = with_assigned_stmts\n@decorators.raise_if_nothing_inferred\ndef named_expr_assigned_stmts(\n    self: nodes.NamedExpr,\n    node: node_classes.AssignedStmtsPossibleNode,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    \"\"\"Infer names and other nodes from an assignment expression.\"\"\"\n    if self.target == node:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.NamedExpr.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.NamedExpr.assigned_stmts = named_expr_assigned_stmts\n@decorators.yes_if_nothing_inferred\ndef starred_assigned_stmts(  # noqa: C901\n    self: nodes.Starred,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: InferenceContext | None = None,\n    assign_path: list[int] | None = None,\n) -> Any:\n    \"\"\"\n    Arguments:",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.Starred.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.Starred.assigned_stmts = starred_assigned_stmts\n@decorators.yes_if_nothing_inferred\ndef match_mapping_assigned_stmts(\n    self: nodes.MatchMapping,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.MatchMapping.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.MatchMapping.assigned_stmts = match_mapping_assigned_stmts\n@decorators.yes_if_nothing_inferred\ndef match_star_assigned_stmts(\n    self: nodes.MatchStar,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.MatchStar.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.MatchStar.assigned_stmts = match_star_assigned_stmts\n@decorators.yes_if_nothing_inferred\ndef match_as_assigned_stmts(\n    self: nodes.MatchAs,\n    node: nodes.AssignName,\n    context: InferenceContext | None = None,\n    assign_path: None = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Infer MatchAs as the Match subject if it's the only MatchCase pattern\n    else raise StopIteration to yield Uninferable.",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "nodes.MatchAs.assigned_stmts",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.protocols",
        "description": "__pypackages__.3.10.lib.astroid.protocols",
        "peekOfCode": "nodes.MatchAs.assigned_stmts = match_as_assigned_stmts",
        "detail": "__pypackages__.3.10.lib.astroid.protocols",
        "documentation": {}
    },
    {
        "label": "InspectBuilder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "class InspectBuilder:\n    \"\"\"class for building nodes from living object\n    this is actually a really minimal representation, including only Module,\n    FunctionDef and ClassDef nodes and some others as guessed.\n    \"\"\"\n    def __init__(self, manager_instance: AstroidManager | None = None) -> None:\n        self._manager = manager_instance or AstroidManager()\n        self._done: dict[types.ModuleType | type, nodes.Module | nodes.ClassDef] = {}\n        self._module: types.ModuleType\n    def inspect_build(",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "attach_dummy_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def attach_dummy_node(node, name: str, runtime_object=_EMPTY_OBJECT_MARKER) -> None:\n    \"\"\"create a dummy node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    enode = nodes.EmptyNode()\n    enode.object = runtime_object\n    _attach_local_node(node, enode, name)\ndef attach_const_node(node, name: str, value) -> None:\n    \"\"\"create a Const node and register it in the locals of the given\n    node with the specified name",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "attach_const_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def attach_const_node(node, name: str, value) -> None:\n    \"\"\"create a Const node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    if name not in node.special_attributes:\n        _attach_local_node(node, nodes.const_factory(value), name)\ndef attach_import_node(node, modname: str, membername: str) -> None:\n    \"\"\"create a ImportFrom node and register it in the locals of the given\n    node with the specified name\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "attach_import_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def attach_import_node(node, modname: str, membername: str) -> None:\n    \"\"\"create a ImportFrom node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    from_node = nodes.ImportFrom(modname, [(membername, None)])\n    _attach_local_node(node, from_node, membername)\ndef build_module(name: str, doc: str | None = None) -> nodes.Module:\n    \"\"\"create and initialize an astroid Module node\"\"\"\n    node = nodes.Module(name, pure_python=False, package=False)\n    node.postinit(",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "build_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def build_module(name: str, doc: str | None = None) -> nodes.Module:\n    \"\"\"create and initialize an astroid Module node\"\"\"\n    node = nodes.Module(name, pure_python=False, package=False)\n    node.postinit(\n        body=[],\n        doc_node=nodes.Const(value=doc) if doc else None,\n    )\n    return node\ndef build_class(\n    name: str, basenames: Iterable[str] = (), doc: str | None = None",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "build_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def build_class(\n    name: str, basenames: Iterable[str] = (), doc: str | None = None\n) -> nodes.ClassDef:\n    \"\"\"Create and initialize an astroid ClassDef node.\"\"\"\n    node = nodes.ClassDef(name)\n    node.postinit(\n        bases=[nodes.Name(name=base, parent=node) for base in basenames],\n        body=[],\n        decorators=None,\n        doc_node=nodes.Const(value=doc) if doc else None,",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "build_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def build_function(\n    name: str,\n    args: list[str] | None = None,\n    posonlyargs: list[str] | None = None,\n    defaults: list[Any] | None = None,\n    doc: str | None = None,\n    kwonlyargs: list[str] | None = None,\n) -> nodes.FunctionDef:\n    \"\"\"create and initialize an astroid FunctionDef node\"\"\"\n    # first argument is now a list of decorators",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "build_from_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def build_from_import(fromname: str, names: list[str]) -> nodes.ImportFrom:\n    \"\"\"create and initialize an astroid ImportFrom import statement\"\"\"\n    return nodes.ImportFrom(fromname, [(name, None) for name in names])\ndef register_arguments(func: nodes.FunctionDef, args: list | None = None) -> None:\n    \"\"\"add given arguments to local\n    args is a list that may contains nested lists\n    (i.e. def func(a, (b, c, d)): ...)\n    \"\"\"\n    # If no args are passed in, get the args from the function.\n    if args is None:",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "register_arguments",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def register_arguments(func: nodes.FunctionDef, args: list | None = None) -> None:\n    \"\"\"add given arguments to local\n    args is a list that may contains nested lists\n    (i.e. def func(a, (b, c, d)): ...)\n    \"\"\"\n    # If no args are passed in, get the args from the function.\n    if args is None:\n        if func.args.vararg:\n            func.set_local(func.args.vararg, func.args)\n        if func.args.kwarg:",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "object_build_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def object_build_class(\n    node: nodes.Module | nodes.ClassDef, member: type, localname: str\n) -> nodes.ClassDef:\n    \"\"\"create astroid for a living class object\"\"\"\n    basenames = [base.__name__ for base in member.__bases__]\n    return _base_class_object_build(node, member, basenames, localname=localname)\ndef _get_args_info_from_callable(\n    member: _FunctionTypes,\n) -> tuple[list[str], list[str], list[Any], list[str]]:\n    \"\"\"Returns args, posonlyargs, defaults, kwonlyargs.",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "object_build_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def object_build_function(\n    node: nodes.Module | nodes.ClassDef, member: _FunctionTypes, localname: str\n) -> None:\n    \"\"\"create astroid for a living function object\"\"\"\n    args, posonlyargs, defaults, kwonlyargs = _get_args_info_from_callable(member)\n    func = build_function(\n        getattr(member, \"__name__\", None) or localname,\n        args,\n        posonlyargs,\n        defaults,",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "object_build_datadescriptor",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def object_build_datadescriptor(\n    node: nodes.Module | nodes.ClassDef, member: type, name: str\n) -> nodes.ClassDef:\n    \"\"\"create astroid for a living data descriptor object\"\"\"\n    return _base_class_object_build(node, member, [], name)\ndef object_build_methoddescriptor(\n    node: nodes.Module | nodes.ClassDef,\n    member: _FunctionTypes,\n    localname: str,\n) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "object_build_methoddescriptor",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "def object_build_methoddescriptor(\n    node: nodes.Module | nodes.ClassDef,\n    member: _FunctionTypes,\n    localname: str,\n) -> None:\n    \"\"\"create astroid for a living method descriptor object\"\"\"\n    # FIXME get arguments ?\n    func = build_function(\n        getattr(member, \"__name__\", None) or localname, doc=member.__doc__\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "logger = logging.getLogger(__name__)\n_FunctionTypes = Union[\n    types.FunctionType,\n    types.MethodType,\n    types.BuiltinFunctionType,\n    types.WrapperDescriptorType,\n    types.MethodDescriptorType,\n    types.ClassMethodDescriptorType,\n]\n# the keys of CONST_CLS eg python builtin types",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "_FunctionTypes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "_FunctionTypes = Union[\n    types.FunctionType,\n    types.MethodType,\n    types.BuiltinFunctionType,\n    types.WrapperDescriptorType,\n    types.MethodDescriptorType,\n    types.ClassMethodDescriptorType,\n]\n# the keys of CONST_CLS eg python builtin types\n_CONSTANTS = tuple(node_classes.CONST_CLS)",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "_CONSTANTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "_CONSTANTS = tuple(node_classes.CONST_CLS)\n_BUILTINS = vars(builtins)\nTYPE_NONE = type(None)\nTYPE_NOTIMPLEMENTED = type(NotImplemented)\nTYPE_ELLIPSIS = type(...)\ndef _attach_local_node(parent, node, name: str) -> None:\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\ndef _add_dunder_class(func, member) -> None:\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "_BUILTINS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "_BUILTINS = vars(builtins)\nTYPE_NONE = type(None)\nTYPE_NOTIMPLEMENTED = type(NotImplemented)\nTYPE_ELLIPSIS = type(...)\ndef _attach_local_node(parent, node, name: str) -> None:\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\ndef _add_dunder_class(func, member) -> None:\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"\n    python_cls = member.__class__",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "TYPE_NONE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "TYPE_NONE = type(None)\nTYPE_NOTIMPLEMENTED = type(NotImplemented)\nTYPE_ELLIPSIS = type(...)\ndef _attach_local_node(parent, node, name: str) -> None:\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\ndef _add_dunder_class(func, member) -> None:\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"\n    python_cls = member.__class__\n    cls_name = getattr(python_cls, \"__name__\", None)",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "TYPE_NOTIMPLEMENTED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "TYPE_NOTIMPLEMENTED = type(NotImplemented)\nTYPE_ELLIPSIS = type(...)\ndef _attach_local_node(parent, node, name: str) -> None:\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\ndef _add_dunder_class(func, member) -> None:\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"\n    python_cls = member.__class__\n    cls_name = getattr(python_cls, \"__name__\", None)\n    if not cls_name:",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "TYPE_ELLIPSIS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.raw_building",
        "description": "__pypackages__.3.10.lib.astroid.raw_building",
        "peekOfCode": "TYPE_ELLIPSIS = type(...)\ndef _attach_local_node(parent, node, name: str) -> None:\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\ndef _add_dunder_class(func, member) -> None:\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"\n    python_cls = member.__class__\n    cls_name = getattr(python_cls, \"__name__\", None)\n    if not cls_name:\n        return",
        "detail": "__pypackages__.3.10.lib.astroid.raw_building",
        "documentation": {}
    },
    {
        "label": "TreeRebuilder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "class TreeRebuilder:\n    \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n    def __init__(\n        self,\n        manager: AstroidManager,\n        parser_module: ParserModule | None = None,\n        data: str | None = None,\n    ) -> None:\n        self._manager = manager\n        self._data = data.split(\"\\n\") if data else None",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "T_Doc",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "T_Doc = TypeVar(\n    \"T_Doc\",\n    \"ast.Module\",\n    \"ast.ClassDef\",\n    Union[\"ast.FunctionDef\", \"ast.AsyncFunctionDef\"],\n)\n_FunctionT = TypeVar(\"_FunctionT\", nodes.FunctionDef, nodes.AsyncFunctionDef)\n_ForT = TypeVar(\"_ForT\", nodes.For, nodes.AsyncFor)\n_WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\nNodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "_FunctionT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "_FunctionT = TypeVar(\"_FunctionT\", nodes.FunctionDef, nodes.AsyncFunctionDef)\n_ForT = TypeVar(\"_ForT\", nodes.For, nodes.AsyncFor)\n_WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\nNodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n# noinspection PyMethodMayBeStatic\nclass TreeRebuilder:\n    \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n    def __init__(\n        self,\n        manager: AstroidManager,",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "_ForT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "_ForT = TypeVar(\"_ForT\", nodes.For, nodes.AsyncFor)\n_WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\nNodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n# noinspection PyMethodMayBeStatic\nclass TreeRebuilder:\n    \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n    def __init__(\n        self,\n        manager: AstroidManager,\n        parser_module: ParserModule | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "_WithT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "_WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\nNodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n# noinspection PyMethodMayBeStatic\nclass TreeRebuilder:\n    \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n    def __init__(\n        self,\n        manager: AstroidManager,\n        parser_module: ParserModule | None = None,\n        data: str | None = None,",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "NodesWithDocsType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.rebuilder",
        "description": "__pypackages__.3.10.lib.astroid.rebuilder",
        "peekOfCode": "NodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n# noinspection PyMethodMayBeStatic\nclass TreeRebuilder:\n    \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n    def __init__(\n        self,\n        manager: AstroidManager,\n        parser_module: ParserModule | None = None,\n        data: str | None = None,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.astroid.rebuilder",
        "documentation": {}
    },
    {
        "label": "require_version",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.test_utils",
        "description": "__pypackages__.3.10.lib.astroid.test_utils",
        "peekOfCode": "def require_version(minver: str = \"0.0.0\", maxver: str = \"4.0.0\") -> Callable:\n    \"\"\"Compare version of python interpreter to the given one and skips the test if older.\"\"\"\n    def parse(python_version: str) -> tuple[int, ...]:\n        try:\n            return tuple(int(v) for v in python_version.split(\".\"))\n        except ValueError as e:\n            msg = f\"{python_version} is not a correct version : should be X.Y[.Z].\"\n            raise ValueError(msg) from e\n    min_version = parse(minver)\n    max_version = parse(maxver)",
        "detail": "__pypackages__.3.10.lib.astroid.test_utils",
        "documentation": {}
    },
    {
        "label": "get_name_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.test_utils",
        "description": "__pypackages__.3.10.lib.astroid.test_utils",
        "peekOfCode": "def get_name_node(start_from, name, index=0):\n    return [n for n in start_from.nodes_of_class(nodes.Name) if n.name == name][index]\n@contextlib.contextmanager\ndef enable_warning(warning):\n    warnings.simplefilter(\"always\", warning)\n    try:\n        yield\n    finally:\n        # Reset it to default value, so it will take\n        # into account the values from the -W flag.",
        "detail": "__pypackages__.3.10.lib.astroid.test_utils",
        "documentation": {}
    },
    {
        "label": "enable_warning",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.test_utils",
        "description": "__pypackages__.3.10.lib.astroid.test_utils",
        "peekOfCode": "def enable_warning(warning):\n    warnings.simplefilter(\"always\", warning)\n    try:\n        yield\n    finally:\n        # Reset it to default value, so it will take\n        # into account the values from the -W flag.\n        warnings.simplefilter(\"default\", warning)\ndef brainless_manager():\n    m = manager.AstroidManager()",
        "detail": "__pypackages__.3.10.lib.astroid.test_utils",
        "documentation": {}
    },
    {
        "label": "brainless_manager",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.test_utils",
        "description": "__pypackages__.3.10.lib.astroid.test_utils",
        "peekOfCode": "def brainless_manager():\n    m = manager.AstroidManager()\n    # avoid caching into the AstroidManager borg since we get problems\n    # with other tests :\n    m.__dict__ = {}\n    m._failed_import_hooks = []\n    m.astroid_cache = {}\n    m._mod_file_cache = {}\n    m._transform = transforms.TransformVisitor()\n    m.extension_package_whitelist = set()",
        "detail": "__pypackages__.3.10.lib.astroid.test_utils",
        "documentation": {}
    },
    {
        "label": "TransformVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.transforms",
        "description": "__pypackages__.3.10.lib.astroid.transforms",
        "peekOfCode": "class TransformVisitor:\n    \"\"\"A visitor for handling transforms.\n    The standard approach of using it is to call\n    :meth:`~visit` with an *astroid* module and the class\n    will take care of the rest, walking the tree and running the\n    transforms for each encountered node.\n    Based on its usage in AstroidManager.brain, it should not be reinstantiated.\n    \"\"\"\n    def __init__(self):\n        self.transforms = collections.defaultdict(list)",
        "detail": "__pypackages__.3.10.lib.astroid.transforms",
        "documentation": {}
    },
    {
        "label": "InferenceErrorInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "class InferenceErrorInfo(TypedDict):\n    \"\"\"Store additional Inference error information\n    raised with StopIteration exception.\n    \"\"\"\n    node: nodes.NodeNG\n    context: InferenceContext | None\nInferFn = Callable[..., Any]\nclass AstroidManagerBrain(TypedDict):\n    \"\"\"Dictionary to store relevant information for a AstroidManager class.\"\"\"\n    astroid_cache: dict[str, nodes.Module]",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "AstroidManagerBrain",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "class AstroidManagerBrain(TypedDict):\n    \"\"\"Dictionary to store relevant information for a AstroidManager class.\"\"\"\n    astroid_cache: dict[str, nodes.Module]\n    _mod_file_cache: dict[\n        tuple[str, str | None], spec.ModuleSpec | exceptions.AstroidImportError\n    ]\n    _failed_import_hooks: list[Callable[[str], nodes.Module]]\n    always_load_extensions: bool\n    optimize_ast: bool\n    extension_package_whitelist: set[str]",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "_NodesT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "_NodesT = TypeVar(\"_NodesT\", bound=\"nodes.NodeNG\")\nclass InferenceErrorInfo(TypedDict):\n    \"\"\"Store additional Inference error information\n    raised with StopIteration exception.\n    \"\"\"\n    node: nodes.NodeNG\n    context: InferenceContext | None\nInferFn = Callable[..., Any]\nclass AstroidManagerBrain(TypedDict):\n    \"\"\"Dictionary to store relevant information for a AstroidManager class.\"\"\"",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferFn",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "InferFn = Callable[..., Any]\nclass AstroidManagerBrain(TypedDict):\n    \"\"\"Dictionary to store relevant information for a AstroidManager class.\"\"\"\n    astroid_cache: dict[str, nodes.Module]\n    _mod_file_cache: dict[\n        tuple[str, str | None], spec.ModuleSpec | exceptions.AstroidImportError\n    ]\n    _failed_import_hooks: list[Callable[[str], nodes.Module]]\n    always_load_extensions: bool\n    optimize_ast: bool",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferenceResult",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "InferenceResult = Union[\"nodes.NodeNG\", \"type[util.Uninferable]\", \"bases.Proxy\"]\nSuccessfulInferenceResult = Union[\"nodes.NodeNG\", \"bases.Proxy\"]\nConstFactoryResult = Union[\n    \"nodes.List\",\n    \"nodes.Set\",\n    \"nodes.Tuple\",\n    \"nodes.Dict\",\n    \"nodes.Const\",\n    \"nodes.EmptyNode\",\n]",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "SuccessfulInferenceResult",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "SuccessfulInferenceResult = Union[\"nodes.NodeNG\", \"bases.Proxy\"]\nConstFactoryResult = Union[\n    \"nodes.List\",\n    \"nodes.Set\",\n    \"nodes.Tuple\",\n    \"nodes.Dict\",\n    \"nodes.Const\",\n    \"nodes.EmptyNode\",\n]\nInferBinaryOp = Callable[",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "ConstFactoryResult",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "ConstFactoryResult = Union[\n    \"nodes.List\",\n    \"nodes.Set\",\n    \"nodes.Tuple\",\n    \"nodes.Dict\",\n    \"nodes.Const\",\n    \"nodes.EmptyNode\",\n]\nInferBinaryOp = Callable[\n    [",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "InferBinaryOp",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.astroid.typing",
        "description": "__pypackages__.3.10.lib.astroid.typing",
        "peekOfCode": "InferBinaryOp = Callable[\n    [\n        Union[_NodesT, \"bases.Instance\"],\n        Union[\"nodes.AugAssign\", \"nodes.BinOp\"],\n        str,\n        InferenceResult,\n        \"InferenceContext\",\n        SuccessfulInferenceResult,\n    ],\n    Generator[InferenceResult, None, None],",
        "detail": "__pypackages__.3.10.lib.astroid.typing",
        "documentation": {}
    },
    {
        "label": "Uninferable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "class Uninferable:\n    \"\"\"Special inference object, which is returned when inference fails.\"\"\"\n    def __repr__(self) -> str:\n        return \"Uninferable\"\n    __str__ = __repr__\n    def __getattribute__(self, name: str) -> Any:\n        if name == \"next\":\n            raise AttributeError(\"next method should not be called\")\n        if name.startswith(\"__\") and name.endswith(\"__\"):\n            return object.__getattribute__(self, name)",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "BadOperationMessage",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "class BadOperationMessage:\n    \"\"\"Object which describes a TypeError occurred somewhere in the inference chain.\n    This is not an exception, but a container object which holds the types and\n    the error which occurred.\n    \"\"\"\nclass BadUnaryOperationMessage(BadOperationMessage):\n    \"\"\"Object which describes operational failures on UnaryOps.\"\"\"\n    def __init__(self, operand, op, error):\n        self.operand = operand\n        self.op = op",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "BadUnaryOperationMessage",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "class BadUnaryOperationMessage(BadOperationMessage):\n    \"\"\"Object which describes operational failures on UnaryOps.\"\"\"\n    def __init__(self, operand, op, error):\n        self.operand = operand\n        self.op = op\n        self.error = error\n    @property\n    def _object_type_helper(self):\n        helpers = lazy_import(\"helpers\")\n        return helpers.object_type",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "BadBinaryOperationMessage",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "class BadBinaryOperationMessage(BadOperationMessage):\n    \"\"\"Object which describes type errors for BinOps.\"\"\"\n    def __init__(self, left_type, op, right_type):\n        self.left_type = left_type\n        self.right_type = right_type\n        self.op = op\n    def __str__(self) -> str:\n        msg = \"unsupported operand type(s) for {}: {!r} and {!r}\"\n        return msg.format(self.op, self.left_type.name, self.right_type.name)\ndef _instancecheck(cls, other) -> bool:",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "lazy_descriptor",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "def lazy_descriptor(obj):\n    class DescriptorProxy(lazy_object_proxy.Proxy):\n        def __get__(self, instance, owner=None):\n            return self.__class__.__get__(self, instance)\n    return DescriptorProxy(obj)\ndef lazy_import(module_name: str) -> lazy_object_proxy.Proxy:\n    return lazy_object_proxy.Proxy(\n        lambda: importlib.import_module(\".\" + module_name, \"astroid\")\n    )\n@object.__new__",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "lazy_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "def lazy_import(module_name: str) -> lazy_object_proxy.Proxy:\n    return lazy_object_proxy.Proxy(\n        lambda: importlib.import_module(\".\" + module_name, \"astroid\")\n    )\n@object.__new__\nclass Uninferable:\n    \"\"\"Special inference object, which is returned when inference fails.\"\"\"\n    def __repr__(self) -> str:\n        return \"Uninferable\"\n    __str__ = __repr__",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "proxy_alias",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "def proxy_alias(alias_name, node_type):\n    \"\"\"Get a Proxy from the given name to the given node type.\"\"\"\n    proxy = type(\n        alias_name,\n        (lazy_object_proxy.Proxy,),\n        {\n            \"__class__\": object.__dict__[\"__class__\"],\n            \"__instancecheck__\": _instancecheck,\n        },\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "check_warnings_filter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.astroid.util",
        "description": "__pypackages__.3.10.lib.astroid.util",
        "peekOfCode": "def check_warnings_filter() -> bool:\n    \"\"\"Return True if any other than the default DeprecationWarning filter is enabled.\n    https://docs.python.org/3/library/warnings.html#default-warning-filter\n    \"\"\"\n    return any(\n        issubclass(DeprecationWarning, filter[2])\n        and filter[0] != \"ignore\"\n        and filter[3] != \"__main__\"\n        for filter in warnings.filters\n    )",
        "detail": "__pypackages__.3.10.lib.astroid.util",
        "documentation": {}
    },
    {
        "label": "cmp_using",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._cmp",
        "description": "__pypackages__.3.10.lib.attr._cmp",
        "peekOfCode": "def cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._cmp",
        "documentation": {}
    },
    {
        "label": "_operation_names",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._cmp",
        "description": "__pypackages__.3.10.lib.attr._cmp",
        "peekOfCode": "_operation_names = {\"eq\": \"==\", \"lt\": \"<\", \"le\": \"<=\", \"gt\": \">\", \"ge\": \">=\"}\ndef cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):",
        "detail": "__pypackages__.3.10.lib.attr._cmp",
        "documentation": {}
    },
    {
        "label": "_AnnotationExtractor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "class _AnnotationExtractor:\n    \"\"\"\n    Extract type annotations from a callable, returning None whenever there\n    is none.\n    \"\"\"\n    __slots__ = [\"sig\"]\n    def __init__(self, callable):\n        try:\n            self.sig = inspect.signature(callable)\n        except (ValueError, TypeError):  # inspect failed",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "just_warn",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "def just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )\nclass _AnnotationExtractor:\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "make_set_closure_cell",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "def make_set_closure_cell():\n    \"\"\"Return a function of two arguments (cell, value) which sets\n    the value stored in the closure cell `cell` to `value`.\n    \"\"\"\n    # pypy makes this easy. (It also supports the logic below, but\n    # why not do the easy/fast thing?)\n    if PYPY:\n        def set_closure_cell(cell, value):\n            cell.__setstate__((value,))\n        return set_closure_cell",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "PYPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "PYPY = platform.python_implementation() == \"PyPy\"\nPY310 = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "PY310",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "PY310 = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "PY_3_12_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "PY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )\nclass _AnnotationExtractor:",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "set_closure_cell",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "set_closure_cell = make_set_closure_cell()\n# Thread-local global to track attrs instances which are already being repr'd.\n# This is needed because there is no other (thread-safe) way to pass info\n# about the instances that are already being repr'd through the call stack\n# in order to ensure we don't perform infinite recursion.\n#\n# For instance, if an instance contains a dict which contains that instance,\n# we need to know that we're already repr'ing the outside instance from within\n# the dict's repr() call.\n#",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "repr_context",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._compat",
        "description": "__pypackages__.3.10.lib.attr._compat",
        "peekOfCode": "repr_context = threading.local()",
        "detail": "__pypackages__.3.10.lib.attr._compat",
        "documentation": {}
    },
    {
        "label": "set_run_validators",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._config",
        "description": "__pypackages__.3.10.lib.attr._config",
        "peekOfCode": "def set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")\n    global _run_validators",
        "detail": "__pypackages__.3.10.lib.attr._config",
        "documentation": {}
    },
    {
        "label": "get_run_validators",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._config",
        "description": "__pypackages__.3.10.lib.attr._config",
        "peekOfCode": "def get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`\n        instead.\n    \"\"\"\n    return _run_validators",
        "detail": "__pypackages__.3.10.lib.attr._config",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._config",
        "description": "__pypackages__.3.10.lib.attr._config",
        "peekOfCode": "__all__ = [\"set_run_validators\", \"get_run_validators\"]\n_run_validators = True\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):",
        "detail": "__pypackages__.3.10.lib.attr._config",
        "documentation": {}
    },
    {
        "label": "_run_validators",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._config",
        "description": "__pypackages__.3.10.lib.attr._config",
        "peekOfCode": "_run_validators = True\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")",
        "detail": "__pypackages__.3.10.lib.attr._config",
        "documentation": {}
    },
    {
        "label": "asdict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a dict.",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "astuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a tuple.\n    Optionally recurse into other ``attrs``-decorated classes.",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "has",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def has(cls):\n    \"\"\"\n    Check whether *cls* is a class with ``attrs`` attributes.\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :rtype: bool\n    \"\"\"\n    return getattr(cls, \"__attrs_attrs__\", None) is not None\ndef assoc(inst, **changes):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "assoc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n    :return: A copy of inst with *changes* incorporated.\n    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n        be found on *cls*.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def evolve(inst, **changes):\n    \"\"\"\n    Create a new instance, based on *inst* with *changes* applied.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n    :return: A copy of inst with *changes* incorporated.\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "resolve_types",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._funcs",
        "description": "__pypackages__.3.10.lib.attr._funcs",
        "peekOfCode": "def resolve_types(cls, globalns=None, localns=None, attribs=None):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only\n    use them for static type checking.\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, e.g. if the name only exists\n    inside a method, you may pass *globalns* or *localns* to specify other\n    dictionaries in which to look up these names. See the docs of",
        "detail": "__pypackages__.3.10.lib.attr._funcs",
        "documentation": {}
    },
    {
        "label": "_Nothing",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n    NOTHING = enum.auto()\n    def __repr__(self):",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_CacheHashWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since ``None``\n    is the default value for uncalculated hashes, whenever this is copied,\n    the copy's value for the hash should automatically reset.\n    See GH #613 for more details.\n    \"\"\"\n    def __reduce__(self, _none_constructor=type(None), _args=()):",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_ClassBuilder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class _ClassBuilder:\n    \"\"\"\n    Iteratively build *one* class.\n    \"\"\"\n    __slots__ = (\n        \"_attr_names\",\n        \"_attrs\",\n        \"_base_attr_map\",\n        \"_base_names\",\n        \"_cache_hash\",",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class Attribute:\n    \"\"\"\n    *Read-only* representation of an attribute.\n    The class has *all* arguments of `attr.ib` (except for ``factory``\n    which is only syntactic sugar for ``default=Factory(...)`` plus the\n    following:\n    - ``name`` (`str`): The name of the attribute.\n    - ``alias`` (`str`): The __init__ parameter name of the attribute, after\n      any explicit overrides and default private-attribute-name handling.\n    - ``inherited`` (`bool`): Whether or not that attribute has been inherited",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_CountingAttr",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve\n    the order in which the attributes have been defined.\n    *Internal* data structure of the attrs library.  Running into is most\n    likely the result of a bug like a forgotten `@attr.s` decorator.\n    \"\"\"\n    __slots__ = (\n        \"counter\",\n        \"_default\",",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "Factory",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class Factory:\n    \"\"\"\n    Stores a factory callable.\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n    :param callable factory: A callable that takes either none or exactly one\n        mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.\n    .. versionadded:: 17.1.0  *takes_self*",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_AndValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "class _AndValidator:\n    \"\"\"\n    Compose many validators to a single one.\n    \"\"\"\n    _validators = attrib()\n    def __call__(self, inst, attr, value):\n        for v in self._validators:\n            v(inst, attr, value)\ndef and_(*validators):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "attrib",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "attrs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def fields(cls):\n    \"\"\"\n    Return the tuple of ``attrs`` attributes for a class.\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n    :rtype: tuple (with name accessors) of `attrs.Attribute`",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "fields_dict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n    keys are the attribute names.\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n    :rtype: dict\n    .. versionadded:: 18.1.0",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "validate",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n    Leaves all exceptions through.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n    for a in fields(inst.__class__):\n        v = a.validator",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "make_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n    :param str name: The name for the new class.\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.\n    :type attrs: `list` or `dict`",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "and_",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n    When called on a value, it runs all wrapped validators.\n    :param callables validators: Arbitrary number of validators.\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "def pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n    Type annotations will be inferred from the wrapped converters', if\n    they have any.\n    :param callables converters: Arbitrary number of converters.\n    .. versionadded:: 20.1.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_obj_setattr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_obj_setattr = object.__setattr__\n_init_converter_pat = \"__attr_converter_%s\"\n_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_init_converter_pat",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_init_converter_pat = \"__attr_converter_%s\"\n_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_init_factory_pat",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_classvar_prefixes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)\n_hash_cache_field = \"_attrs_cached_hash\"",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_hash_cache_field",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_hash_cache_field = \"_attrs_cached_hash\"\n_empty_metadata_singleton = types.MappingProxyType({})\n# Unique object for unequivocal getattr() defaults.\n_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_empty_metadata_singleton",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_empty_metadata_singleton = types.MappingProxyType({})\n# Unique object for unequivocal getattr() defaults.\n_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_sentinel",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_ng_default_on_setattr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n    NOTHING = enum.auto()",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "NOTHING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "NOTHING = _Nothing.NOTHING\n\"\"\"\nSentinel to indicate the lack of a value when ``None`` is ambiguous.\n\"\"\"\nclass _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since ``None``\n    is the default value for uncalculated hashes, whenever this is copied,",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_Attributes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_Attributes = _make_attr_tuple_class(\n    \"_Attributes\",\n    [\n        # all attributes to build dunder methods for\n        \"attrs\",\n        # attributes that have been inherited\n        \"base_attrs\",\n        # map inherited attributes to their originating classes\n        \"base_attrs_map\",\n    ],",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_attrs",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_attrs = attrs\n\"\"\"\nInternal alias so we can use it in functions that take an argument called\n*attrs*.\n\"\"\"\ndef _has_frozen_base_class(cls):\n    \"\"\"\n    Check whether *cls* has a frozen ancestor by looking at its\n    __setattr__.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_a",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_a = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=(name != \"metadata\"),",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "Attribute = _add_hash(\n    _add_eq(\n        _add_repr(Attribute, attrs=_a),\n        attrs=[a for a in _a if a.name != \"inherited\"],\n    ),\n    attrs=[a for a in _a if a.hash and a.name != \"inherited\"],\n)\nclass _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_CountingAttr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_CountingAttr = _add_eq(_add_repr(_CountingAttr))\nclass Factory:\n    \"\"\"\n    Stores a factory callable.\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n    :param callable factory: A callable that takes either none or exactly one\n        mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "_f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "_f = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=True,",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "Factory",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._make",
        "description": "__pypackages__.3.10.lib.attr._make",
        "peekOfCode": "Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)\ndef make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n    :param str name: The name for the new class.\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.",
        "detail": "__pypackages__.3.10.lib.attr._make",
        "documentation": {}
    },
    {
        "label": "define",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "def define(\n    maybe_cls=None,\n    *,\n    these=None,\n    repr=None,\n    unsafe_hash=None,\n    hash=None,\n    init=None,\n    slots=True,\n    frozen=False,",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "def field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    converter=None,\n    factory=None,",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "asdict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "def asdict(inst, *, recurse=True, filter=None, value_serializer=None):\n    \"\"\"\n    Same as `attr.asdict`, except that collections types are always retained\n    and dict is always used as *dict_factory*.\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _asdict(\n        inst=inst,\n        recurse=recurse,\n        filter=filter,",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "astuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "def astuple(inst, *, recurse=True, filter=None):\n    \"\"\"\n    Same as `attr.astuple`, except that collections types are always retained\n    and `tuple` is always used as the *tuple_factory*.\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _astuple(\n        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True\n    )",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "mutable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "mutable = define\nfrozen = partial(define, frozen=True, on_setattr=None)\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "frozen",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr._next_gen",
        "description": "__pypackages__.3.10.lib.attr._next_gen",
        "peekOfCode": "frozen = partial(define, frozen=True, on_setattr=None)\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    converter=None,",
        "detail": "__pypackages__.3.10.lib.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "VersionInfo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr._version_info",
        "description": "__pypackages__.3.10.lib.attr._version_info",
        "peekOfCode": "class VersionInfo:\n    \"\"\"\n    A version object that can be compared to tuple of length 1--4:\n    >>> attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\n    True\n    >>> attr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)\n    True\n    >>> vi = attr.VersionInfo(19, 2, 0, \"final\")\n    >>> vi < (19, 1, 1)\n    False",
        "detail": "__pypackages__.3.10.lib.attr._version_info",
        "documentation": {}
    },
    {
        "label": "optional",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.converters",
        "description": "__pypackages__.3.10.lib.attr.converters",
        "peekOfCode": "def optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to ``None``.\n    Type annotations will be inferred from the wrapped converter's, if it\n    has any.\n    :param callable converter: the converter that is used for non-``None``\n        values.\n    .. versionadded:: 17.1.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.converters",
        "documentation": {}
    },
    {
        "label": "default_if_none",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.converters",
        "description": "__pypackages__.3.10.lib.attr.converters",
        "peekOfCode": "def default_if_none(default=NOTHING, factory=None):\n    \"\"\"\n    A converter that allows to replace ``None`` values by *default* or the\n    result of *factory*.\n    :param default: Value to be used if ``None`` is passed. Passing an instance\n       of `attrs.Factory` is supported, however the ``takes_self`` option\n       is *not*.\n    :param callable factory: A callable that takes no parameters whose result\n       is used if ``None`` is passed.\n    :raises TypeError: If **neither** *default* or *factory* is passed.",
        "detail": "__pypackages__.3.10.lib.attr.converters",
        "documentation": {}
    },
    {
        "label": "to_bool",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.converters",
        "description": "__pypackages__.3.10.lib.attr.converters",
        "peekOfCode": "def to_bool(val):\n    \"\"\"\n    Convert \"boolean\" strings (e.g., from env. vars.) to real booleans.\n    Values mapping to :code:`True`:\n    - :code:`True`\n    - :code:`\"true\"` / :code:`\"t\"`\n    - :code:`\"yes\"` / :code:`\"y\"`\n    - :code:`\"on\"`\n    - :code:`\"1\"`\n    - :code:`1`",
        "detail": "__pypackages__.3.10.lib.attr.converters",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr.converters",
        "description": "__pypackages__.3.10.lib.attr.converters",
        "peekOfCode": "__all__ = [\n    \"default_if_none\",\n    \"optional\",\n    \"pipe\",\n    \"to_bool\",\n]\ndef optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to ``None``.",
        "detail": "__pypackages__.3.10.lib.attr.converters",
        "documentation": {}
    },
    {
        "label": "FrozenError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class FrozenError(AttributeError):\n    \"\"\"\n    A frozen/immutable instance or attribute have been attempted to be\n    modified.\n    It mirrors the behavior of ``namedtuples`` by using the same error message\n    and subclassing `AttributeError`.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    msg = \"can't set attribute\"\n    args = [msg]",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class FrozenInstanceError(FrozenError):\n    \"\"\"\n    A frozen instance has been attempted to be modified.\n    .. versionadded:: 16.1.0\n    \"\"\"\nclass FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "FrozenAttributeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"\nclass AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An ``attrs`` function couldn't find an attribute that the user asked for.\n    .. versionadded:: 16.2.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "AttrsAttributeNotFoundError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An ``attrs`` function couldn't find an attribute that the user asked for.\n    .. versionadded:: 16.2.0\n    \"\"\"\nclass NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-``attrs`` class has been passed into an ``attrs`` function.\n    .. versionadded:: 16.2.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "NotAnAttrsClassError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-``attrs`` class has been passed into an ``attrs`` function.\n    .. versionadded:: 16.2.0\n    \"\"\"\nclass DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set using ``attr.ib()`` and is attempted to be reset\n    using the decorator.\n    .. versionadded:: 17.1.0",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "DefaultAlreadySetError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set using ``attr.ib()`` and is attempted to be reset\n    using the decorator.\n    .. versionadded:: 17.1.0\n    \"\"\"\nclass UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n    annotation.",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "UnannotatedAttributeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n    annotation.\n    .. versionadded:: 17.3.0\n    \"\"\"\nclass PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an ``attrs`` feature that requires a newer Python\n    version.",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "PythonTooOldError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an ``attrs`` feature that requires a newer Python\n    version.\n    .. versionadded:: 18.2.0\n    \"\"\"\nclass NotCallableError(TypeError):\n    \"\"\"\n    A ``attr.ib()`` requiring a callable has been set with a value\n    that is not callable.",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "NotCallableError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.exceptions",
        "description": "__pypackages__.3.10.lib.attr.exceptions",
        "peekOfCode": "class NotCallableError(TypeError):\n    \"\"\"\n    A ``attr.ib()`` requiring a callable has been set with a value\n    that is not callable.\n    .. versionadded:: 19.2.0\n    \"\"\"\n    def __init__(self, msg, value):\n        super(TypeError, self).__init__(msg, value)\n        self.msg = msg\n        self.value = value",
        "detail": "__pypackages__.3.10.lib.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "include",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.filters",
        "description": "__pypackages__.3.10.lib.attr.filters",
        "peekOfCode": "def include(*what):\n    \"\"\"\n    Include *what*.\n    :param what: What to include.\n    :type what: `list` of `type` or `attrs.Attribute`\\\\ s\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n    def include_(attribute, value):\n        return value.__class__ in cls or attribute in attrs",
        "detail": "__pypackages__.3.10.lib.attr.filters",
        "documentation": {}
    },
    {
        "label": "exclude",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.filters",
        "description": "__pypackages__.3.10.lib.attr.filters",
        "peekOfCode": "def exclude(*what):\n    \"\"\"\n    Exclude *what*.\n    :param what: What to exclude.\n    :type what: `list` of classes or `attrs.Attribute`\\\\ s.\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n    def exclude_(attribute, value):\n        return value.__class__ not in cls and attribute not in attrs",
        "detail": "__pypackages__.3.10.lib.attr.filters",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.setters",
        "description": "__pypackages__.3.10.lib.attr.setters",
        "peekOfCode": "def pipe(*setters):\n    \"\"\"\n    Run all *setters* and return the return value of the last one.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    def wrapped_pipe(instance, attrib, new_value):\n        rv = new_value\n        for setter in setters:\n            rv = setter(instance, attrib, rv)\n        return rv",
        "detail": "__pypackages__.3.10.lib.attr.setters",
        "documentation": {}
    },
    {
        "label": "frozen",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.setters",
        "description": "__pypackages__.3.10.lib.attr.setters",
        "peekOfCode": "def frozen(_, __, ___):\n    \"\"\"\n    Prevent an attribute to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    raise FrozenAttributeError()\ndef validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n    .. versionadded:: 20.1.0",
        "detail": "__pypackages__.3.10.lib.attr.setters",
        "documentation": {}
    },
    {
        "label": "validate",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.setters",
        "description": "__pypackages__.3.10.lib.attr.setters",
        "peekOfCode": "def validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    if _config._run_validators is False:\n        return new_value\n    v = attrib.validator\n    if not v:\n        return new_value",
        "detail": "__pypackages__.3.10.lib.attr.setters",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.setters",
        "description": "__pypackages__.3.10.lib.attr.setters",
        "peekOfCode": "def convert(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n    result.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    c = attrib.converter\n    if c:\n        return c(new_value)\n    return new_value",
        "detail": "__pypackages__.3.10.lib.attr.setters",
        "documentation": {}
    },
    {
        "label": "NO_OP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr.setters",
        "description": "__pypackages__.3.10.lib.attr.setters",
        "peekOfCode": "NO_OP = object()",
        "detail": "__pypackages__.3.10.lib.attr.setters",
        "documentation": {}
    },
    {
        "label": "_InstanceOfValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _InstanceOfValidator:\n    type = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not isinstance(value, self.type):\n            raise TypeError(\n                \"'{name}' must be {type!r} (got {value!r} that is a \"\n                \"{actual!r}).\".format(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MatchesReValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _MatchesReValidator:\n    pattern = attrib()\n    match_func = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.match_func(value):\n            raise ValueError(\n                \"'{name}' must match regex {pattern!r}\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_ProvidesValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _ProvidesValidator:\n    interface = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.interface.providedBy(value):\n            raise TypeError(\n                \"'{name}' must provide {interface!r} which {value!r} \"\n                \"doesn't.\".format(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_OptionalValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _OptionalValidator:\n    validator = attrib()\n    def __call__(self, inst, attr, value):\n        if value is None:\n            return\n        self.validator(inst, attr, value)\n    def __repr__(self):\n        return \"<optional validator for {what} or None>\".format(\n            what=repr(self.validator)\n        )",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_InValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _InValidator:\n    options = attrib()\n    def __call__(self, inst, attr, value):\n        try:\n            in_options = value in self.options\n        except TypeError:  # e.g. `1 in \"abc\"`\n            in_options = False\n        if not in_options:\n            raise ValueError(\n                \"'{name}' must be in {options!r} (got {value!r})\".format(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_IsCallableValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _IsCallableValidator:\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not callable(value):\n            message = (\n                \"'{name}' must be callable \"\n                \"(got {value!r} that is a {actual!r}).\"\n            )",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_DeepIterable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _DeepIterable:\n    member_validator = attrib(validator=is_callable())\n    iterable_validator = attrib(\n        default=None, validator=optional(is_callable())\n    )\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.iterable_validator is not None:",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_DeepMapping",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _DeepMapping:\n    key_validator = attrib(validator=is_callable())\n    value_validator = attrib(validator=is_callable())\n    mapping_validator = attrib(default=None, validator=optional(is_callable()))\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.mapping_validator is not None:\n            self.mapping_validator(inst, attr, value)",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_NumberValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _NumberValidator:\n    bound = attrib()\n    compare_op = attrib()\n    compare_func = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.compare_func(value, self.bound):\n            raise ValueError(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MaxLengthValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _MaxLengthValidator:\n    max_length = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) > self.max_length:\n            raise ValueError(\n                \"Length of '{name}' must be <= {max}: {len}\".format(\n                    name=attr.name, max=self.max_length, len=len(value)",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MinLengthValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _MinLengthValidator:\n    min_length = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) < self.min_length:\n            raise ValueError(\n                \"Length of '{name}' must be => {min}: {len}\".format(\n                    name=attr.name, min=self.min_length, len=len(value)",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_SubclassOfValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _SubclassOfValidator:\n    type = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not issubclass(value, self.type):\n            raise TypeError(\n                \"'{name}' must be a subclass of {type!r} \"\n                \"(got {value!r}).\".format(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "_NotValidator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "class _NotValidator:\n    validator = attrib()\n    msg = attrib(\n        converter=default_if_none(\n            \"not_ validator child '{validator!r}' \"\n            \"did not raise a captured error\"\n        )\n    )\n    exc_types = attrib(\n        validator=deep_iterable(",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "set_disabled",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def set_disabled(disabled):\n    \"\"\"\n    Globally disable or enable running validators.\n    By default, they are run.\n    :param disabled: If ``True``, disable running all validators.\n    :type disabled: bool\n    .. warning::\n        This function is not thread-safe!\n    .. versionadded:: 21.3.0\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "get_disabled",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def get_disabled():\n    \"\"\"\n    Return a bool indicating whether validators are currently disabled or not.\n    :return: ``True`` if validators are currently disabled.\n    :rtype: bool\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return not get_run_validators()\n@contextmanager\ndef disabled():",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "disabled",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def disabled():\n    \"\"\"\n    Context manager that disables running validators within its context.\n    .. warning::\n        This context manager is not thread-safe!\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(False)\n    try:\n        yield",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "instance_of",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def instance_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n    :param type: The type to check for.\n    :type type: type or tuple of type\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "matches_re",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def matches_re(regex, flags=0, func=None):\n    r\"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string that doesn't match *regex*.\n    :param regex: a regex string or precompiled pattern to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param callable func: which underlying `re` function to call. Valid options\n        are `re.fullmatch`, `re.search`, and `re.match`; the default ``None``\n        means `re.fullmatch`. For performance reasons, the pattern is always",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "provides",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def provides(interface):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with an object that does not provide the requested *interface* (checks are\n    performed using ``interface.providedBy(value)`` (see `zope.interface\n    <https://zopeinterface.readthedocs.io/en/latest/>`_).\n    :param interface: The interface to check for.\n    :type interface: ``zope.interface.Interface``\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected interface, and the",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "optional",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def optional(validator):\n    \"\"\"\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to ``None`` in addition to satisfying the requirements of\n    the sub-validator.\n    :param validator: A validator (or a list of validators) that is used for\n        non-``None`` values.\n    :type validator: callable or `list` of callables.\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "in_",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def in_(options):\n    \"\"\"\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attrs.Attribute`), the expected options, and the value it\n       got.",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "is_callable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def is_callable():\n    \"\"\"\n    A validator that raises a `attr.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n    .. versionadded:: 19.1.0\n    :raises `attr.exceptions.NotCallableError`: With a human readable error\n        message containing the attribute (`attrs.Attribute`) name,\n        and the value it got.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "deep_iterable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def deep_iterable(member_validator, iterable_validator=None):\n    \"\"\"\n    A validator that performs deep validation of an iterable.\n    :param member_validator: Validator(s) to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n    .. versionadded:: 19.1.0\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    if isinstance(member_validator, (list, tuple)):",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "deep_mapping",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def deep_mapping(key_validator, value_validator, mapping_validator=None):\n    \"\"\"\n    A validator that performs deep validation of a dictionary.\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n    .. versionadded:: 19.1.0\n    :raises TypeError: if any sub-validators fail\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "lt",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def lt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number larger or equal to *val*.\n    :param val: Exclusive upper bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<\", operator.lt)\ndef le(val):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "le",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def le(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number greater than *val*.\n    :param val: Inclusive upper bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<=\", operator.le)\ndef ge(val):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "ge",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def ge(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller than *val*.\n    :param val: Inclusive lower bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">=\", operator.ge)\ndef gt(val):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "gt",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def gt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller or equal to *val*.\n    :param val: Exclusive lower bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">\", operator.gt)\n@attrs(repr=False, frozen=True, slots=True)\nclass _MaxLengthValidator:",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "max_len",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def max_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is longer than *length*.\n    :param int length: Maximum length of the string or iterable\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _MaxLengthValidator(length)\n@attrs(repr=False, frozen=True, slots=True)\nclass _MinLengthValidator:",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "min_len",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def min_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is shorter than *length*.\n    :param int length: Minimum length of the string or iterable\n    .. versionadded:: 22.1.0\n    \"\"\"\n    return _MinLengthValidator(length)\n@attrs(repr=False, slots=True, hash=True)\nclass _SubclassOfValidator:",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "not_",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):\n    \"\"\"\n    A validator that wraps and logically 'inverts' the validator passed to it.\n    It will raise a `ValueError` if the provided validator *doesn't* raise a\n    `ValueError` or `TypeError` (by default), and will suppress the exception\n    if the provided validator *does*.\n    Intended to be used with existing validators to compose logic without\n    needing to create inverted variants, for example, ``not_(in_(...))``.\n    :param validator: A validator to be logically inverted.\n    :param msg: Message to raise if validator fails.",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.attr.validators",
        "description": "__pypackages__.3.10.lib.attr.validators",
        "peekOfCode": "__all__ = [\n    \"and_\",\n    \"deep_iterable\",\n    \"deep_mapping\",\n    \"disabled\",\n    \"ge\",\n    \"get_disabled\",\n    \"gt\",\n    \"in_\",\n    \"instance_of\",",
        "detail": "__pypackages__.3.10.lib.attr.validators",
        "documentation": {}
    },
    {
        "label": "raise_check",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def raise_check(func, **kwds):\n    try:\n        with capture('stdout') as out:\n            check(func, **kwds)\n    except Exception:\n        e = sys.exc_info()[1]\n        raise AssertionError(str(e))\n    else:\n        assert 'Traceback' not in out.getvalue()\n    finally:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "test_simple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def test_simple(verbose=None):\n    raise_check(f, verbose=verbose)\ndef test_recurse(verbose=None):\n    raise_check(f, recurse=True, verbose=verbose)\ndef test_byref(verbose=None):\n    raise_check(f, byref=True, verbose=verbose)\ndef test_protocol(verbose=None):\n    raise_check(f, protocol=True, verbose=verbose)\ndef test_python(verbose=None):\n    raise_check(f, python=None, verbose=verbose)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "test_recurse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def test_recurse(verbose=None):\n    raise_check(f, recurse=True, verbose=verbose)\ndef test_byref(verbose=None):\n    raise_check(f, byref=True, verbose=verbose)\ndef test_protocol(verbose=None):\n    raise_check(f, protocol=True, verbose=verbose)\ndef test_python(verbose=None):\n    raise_check(f, python=None, verbose=verbose)\n#TODO: test incompatible versions\n#TODO: test dump failure",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "test_byref",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def test_byref(verbose=None):\n    raise_check(f, byref=True, verbose=verbose)\ndef test_protocol(verbose=None):\n    raise_check(f, protocol=True, verbose=verbose)\ndef test_python(verbose=None):\n    raise_check(f, python=None, verbose=verbose)\n#TODO: test incompatible versions\n#TODO: test dump failure\n#TODO: test load failure\nif __name__ == '__main__':",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "test_protocol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def test_protocol(verbose=None):\n    raise_check(f, protocol=True, verbose=verbose)\ndef test_python(verbose=None):\n    raise_check(f, python=None, verbose=verbose)\n#TODO: test incompatible versions\n#TODO: test dump failure\n#TODO: test load failure\nif __name__ == '__main__':\n    test_simple()\n    test_recurse()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "test_python",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "def test_python(verbose=None):\n    raise_check(f, python=None, verbose=verbose)\n#TODO: test incompatible versions\n#TODO: test dump failure\n#TODO: test load failure\nif __name__ == '__main__':\n    test_simple()\n    test_recurse()\n    test_byref()\n    test_protocol()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_check",
        "description": "__pypackages__.3.10.lib.dill.tests.test_check",
        "peekOfCode": "f = lambda x:x**2\ndef test_simple(verbose=None):\n    raise_check(f, verbose=verbose)\ndef test_recurse(verbose=None):\n    raise_check(f, recurse=True, verbose=verbose)\ndef test_byref(verbose=None):\n    raise_check(f, byref=True, verbose=verbose)\ndef test_protocol(verbose=None):\n    raise_check(f, protocol=True, verbose=verbose)\ndef test_python(verbose=None):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_check",
        "documentation": {}
    },
    {
        "label": "_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class _class:\n    def _method(self):\n        pass\n    def ok(self):\n        return True\nclass _class2:\n    def __call__(self):\n        pass\n    def ok(self):\n        return True",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "_class2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class _class2:\n    def __call__(self):\n        pass\n    def ok(self):\n        return True\nclass _newclass(object):\n    def _method(self):\n        pass\n    def ok(self):\n        return True",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "_newclass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class _newclass(object):\n    def _method(self):\n        pass\n    def ok(self):\n        return True\nclass _newclass2(object):\n    def __call__(self):\n        pass\n    def ok(self):\n        return True",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "_newclass2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class _newclass2(object):\n    def __call__(self):\n        pass\n    def ok(self):\n        return True\nclass _meta(type):\n    pass\ndef __call__(self):\n    pass\ndef ok(self):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "_meta",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class _meta(type):\n    pass\ndef __call__(self):\n    pass\ndef ok(self):\n    return True\n_mclass = _meta(\"_mclass\", (object,), {\"__call__\": __call__, \"ok\": ok})\ndel __call__\ndel ok\no = _class()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Y",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "class Y(object):\n  __slots__ = ('y', '__weakref__')\n  def __init__(self, y):\n    self.y = y\nvalue = 123\ny = Y(value)\ndef test_slots():\n    assert dill.pickles(Y)\n    assert dill.pickles(y)\n    assert dill.pickles(Y.y)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "ok",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def ok(self):\n    return True\n_mclass = _meta(\"_mclass\", (object,), {\"__call__\": __call__, \"ok\": ok})\ndel __call__\ndel ok\no = _class()\noc = _class2()\nn = _newclass()\nnc = _newclass2()\nm = _mclass()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_class_instances",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)\n    assert dill.pickles(nc)\n    assert dill.pickles(m)\ndef test_class_objects():\n    clslist = [_class,_class2,_newclass,_newclass2,_mclass]\n    objlist = [o,oc,n,nc,m]\n    _clslist = [dill.dumps(obj) for obj in clslist]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_class_objects",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_class_objects():\n    clslist = [_class,_class2,_newclass,_newclass2,_mclass]\n    objlist = [o,oc,n,nc,m]\n    _clslist = [dill.dumps(obj) for obj in clslist]\n    _objlist = [dill.dumps(obj) for obj in objlist]\n    for obj in clslist:\n        globals().pop(obj.__name__)\n    del clslist\n    for obj in ['o','oc','n','nc']:\n        globals().pop(obj)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_specialtypes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_specialtypes():\n    assert dill.pickles(type(None))\n    assert dill.pickles(type(NotImplemented))\n    assert dill.pickles(type(Ellipsis))\nfrom collections import namedtuple\nZ = namedtuple(\"Z\", ['a','b'])\nZi = Z(0,1)\nX = namedtuple(\"Y\", ['a','b'])\nX.__name__ = \"X\"\nX.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_namedtuple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))\n    assert Xi == dill.loads(dill.dumps(Xi))\n    assert Bad is not dill.loads(dill.dumps(Bad))\n    assert Bad._fields == dill.loads(dill.dumps(Bad))._fields\n    assert tuple(Badi) == tuple(dill.loads(dill.dumps(Badi)))\n    class A:\n        class B(namedtuple(\"B\", [\"one\", \"two\"])):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_dtype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_dtype():\n    try:\n        import numpy as np\n        dti = np.dtype('int')\n        assert np.dtype == dill.copy(np.dtype)\n        assert dti == dill.copy(dti)\n    except ImportError: pass\ndef test_array_nested():\n    try:\n        import numpy as np",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_array_nested",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_array_nested():\n    try:\n        import numpy as np\n        x = np.array([1])\n        y = (x,)\n        assert y == dill.copy(y)\n    except ImportError: pass\ndef test_array_subclass():\n    try:\n        import numpy as np",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_array_subclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_array_subclass():\n    try:\n        import numpy as np\n        class TestArray(np.ndarray):\n            def __new__(cls, input_array, color):\n                obj = np.asarray(input_array).view(cls)\n                obj.color = color\n                return obj\n            def __array_finalize__(self, obj):\n                if obj is None:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_method_decorator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_method_decorator():\n    class A(object):\n      @classmethod\n      def test(cls):\n        pass\n    a = A()\n    res = dill.dumps(a)\n    new_obj = dill.loads(res)\n    new_obj.__class__.test()\n# test slots",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_slots",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_slots():\n    assert dill.pickles(Y)\n    assert dill.pickles(y)\n    assert dill.pickles(Y.y)\n    assert dill.copy(y).y == value\ndef test_attr():\n    import attr\n    @attr.s\n    class A:\n        a = attr.ib()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_attr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_attr():\n    import attr\n    @attr.s\n    class A:\n        a = attr.ib()\n    v = A(1)\n    assert dill.copy(v) == v\ndef test_metaclass():\n    class metaclass_with_new(type):\n        def __new__(mcls, name, bases, ns, **kwds):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_metaclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "def test_metaclass():\n    class metaclass_with_new(type):\n        def __new__(mcls, name, bases, ns, **kwds):\n            cls = super().__new__(mcls, name, bases, ns, **kwds)\n            assert mcls is not None\n            assert cls.method(mcls)\n            return cls\n        def method(cls, mcls):\n            return isinstance(cls, mcls)\n    l = locals()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "dill.settings['recurse'] = True\n# test classdefs\nclass _class:\n    def _method(self):\n        pass\n    def ok(self):\n        return True\nclass _class2:\n    def __call__(self):\n        pass",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "_mclass",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "_mclass = _meta(\"_mclass\", (object,), {\"__call__\": __call__, \"ok\": ok})\ndel __call__\ndel ok\no = _class()\noc = _class2()\nn = _newclass()\nnc = _newclass2()\nm = _mclass()\n# test pickles for class instances\ndef test_class_instances():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "o",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "o = _class()\noc = _class2()\nn = _newclass()\nnc = _newclass2()\nm = _mclass()\n# test pickles for class instances\ndef test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "oc",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "oc = _class2()\nn = _newclass()\nnc = _newclass2()\nm = _mclass()\n# test pickles for class instances\ndef test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)\n    assert dill.pickles(nc)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "n = _newclass()\nnc = _newclass2()\nm = _mclass()\n# test pickles for class instances\ndef test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)\n    assert dill.pickles(nc)\n    assert dill.pickles(m)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "nc",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "nc = _newclass2()\nm = _mclass()\n# test pickles for class instances\ndef test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)\n    assert dill.pickles(nc)\n    assert dill.pickles(m)\ndef test_class_objects():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "m = _mclass()\n# test pickles for class instances\ndef test_class_instances():\n    assert dill.pickles(o)\n    assert dill.pickles(oc)\n    assert dill.pickles(n)\n    assert dill.pickles(nc)\n    assert dill.pickles(m)\ndef test_class_objects():\n    clslist = [_class,_class2,_newclass,_newclass2,_mclass]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "Z = namedtuple(\"Z\", ['a','b'])\nZi = Z(0,1)\nX = namedtuple(\"Y\", ['a','b'])\nX.__name__ = \"X\"\nX.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle\nXi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Zi",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "Zi = Z(0,1)\nX = namedtuple(\"Y\", ['a','b'])\nX.__name__ = \"X\"\nX.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle\nXi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "X = namedtuple(\"Y\", ['a','b'])\nX.__name__ = \"X\"\nX.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle\nXi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "X.__name__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "X.__name__ = \"X\"\nX.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle\nXi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "X.__qualname__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "X.__qualname__ = \"X\" #XXX: name must 'match' or fails to pickle\nXi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))\n    assert Xi == dill.loads(dill.dumps(Xi))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Xi",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "Xi = X(0,1)\nBad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))\n    assert Xi == dill.loads(dill.dumps(Xi))\n    assert Bad is not dill.loads(dill.dumps(Bad))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Bad",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "Bad = namedtuple(\"FakeName\", ['a','b'])\nBadi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))\n    assert Xi == dill.loads(dill.dumps(Xi))\n    assert Bad is not dill.loads(dill.dumps(Bad))\n    assert Bad._fields == dill.loads(dill.dumps(Bad))._fields",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "Badi",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "Badi = Bad(0,1)\n# test namedtuple\ndef test_namedtuple():\n    assert Z is dill.loads(dill.dumps(Z))\n    assert Zi == dill.loads(dill.dumps(Zi))\n    assert X is dill.loads(dill.dumps(X))\n    assert Xi == dill.loads(dill.dumps(Xi))\n    assert Bad is not dill.loads(dill.dumps(Bad))\n    assert Bad._fields == dill.loads(dill.dumps(Bad))._fields\n    assert tuple(Badi) == tuple(dill.loads(dill.dumps(Badi)))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "value",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "value = 123\ny = Y(value)\ndef test_slots():\n    assert dill.pickles(Y)\n    assert dill.pickles(y)\n    assert dill.pickles(Y.y)\n    assert dill.copy(y).y == value\ndef test_attr():\n    import attr\n    @attr.s",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "description": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "peekOfCode": "y = Y(value)\ndef test_slots():\n    assert dill.pickles(Y)\n    assert dill.pickles(y)\n    assert dill.pickles(Y.y)\n    assert dill.copy(y).y == value\ndef test_attr():\n    import attr\n    @attr.s\n    class A:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_classdef",
        "documentation": {}
    },
    {
        "label": "test_dataclasses",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_dataclasses",
        "description": "__pypackages__.3.10.lib.dill.tests.test_dataclasses",
        "peekOfCode": "def test_dataclasses():\n    # Issue #500\n    @dataclasses.dataclass\n    class A:\n        x: int\n        y: str\n    @dataclasses.dataclass\n    class B:\n        a: A\n    a = A(1, \"test\")",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_dataclasses",
        "documentation": {}
    },
    {
        "label": "_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "class _class:\n    def _method(self):\n        pass\n    def ok(self):\n        return True\ndef test_globals():\n    def f():\n        a\n        def g():\n            b",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "class Foo(object):\n    def __init__(self):\n        pass\n    def __getstate__(self):\n        bar[0] = bar[0]+1\n        return {}\n    def __setstate__(self, data):\n        pass\nf = Foo()\ndef test_getstate():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_bad_things",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_bad_things():\n    f = inspect.currentframe()\n    assert baditems(f) == [f]\n    #assert baditems(globals()) == [f] #XXX\n    assert badobjects(f) is f\n    assert badtypes(f) == type(f)\n    assert type(errors(f)) is TypeError\n    d = badtypes(f, 1)\n    assert isinstance(d, dict)\n    assert list(badobjects(f, 1).keys()) == list(d.keys())",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_parent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_parent():\n    x = [4,5,6,7]\n    listiter = iter(x)\n    obj = parent(listiter, list)\n    assert obj is x\n    if IS_PYPY: assert parent(obj, int) is None\n    else: assert parent(obj, int) is x[-1] # python oddly? finds last int\n    assert at(id(at)) is at\na, b, c = 1, 2, 3\ndef squared(x):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def squared(x):\n  return a+x**2\ndef foo(x):\n  def bar(y):\n    return squared(x)+y\n  return bar\nclass _class:\n    def _method(self):\n        pass\n    def ok(self):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "foo",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def foo(x):\n  def bar(y):\n    return squared(x)+y\n  return bar\nclass _class:\n    def _method(self):\n        pass\n    def ok(self):\n        return True\ndef test_globals():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_globals",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_globals():\n    def f():\n        a\n        def g():\n            b\n            def h():\n                c\n    assert globalvars(f) == dict(a=1, b=2, c=3)\n    res = globalvars(foo, recurse=True)\n    assert set(res) == set(['squared', 'a'])",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_getstate",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_getstate():\n    from dill import dumps, loads\n    dumps(f)\n    b = bar[0]\n    dumps(lambda: f, recurse=False) # doesn't call __getstate__\n    assert bar[0] == b\n    dumps(lambda: f, recurse=True) # calls __getstate__\n    assert bar[0] == b + 1\n#97 serialize lambdas in test files\ndef test_deleted():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_deleted",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_deleted():\n    global sin\n    from dill import dumps, loads\n    from math import sin, pi\n    def sinc(x):\n        return sin(x)/x\n    settings['recurse'] = True\n    _sinc = dumps(sinc)\n    sin = globals().pop('sin')\n    sin = 1",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_lambdify",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "def test_lambdify():\n    try:\n        from sympy import symbols, lambdify\n    except ImportError:\n        return\n    settings['recurse'] = True\n    x = symbols(\"x\")\n    y = x**2\n    f = lambdify([x], y)\n    z = min",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "bar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "bar = [0]\nclass Foo(object):\n    def __init__(self):\n        pass\n    def __getstate__(self):\n        bar[0] = bar[0]+1\n        return {}\n    def __setstate__(self, data):\n        pass\nf = Foo()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "description": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "peekOfCode": "f = Foo()\ndef test_getstate():\n    from dill import dumps, loads\n    dumps(f)\n    b = bar[0]\n    dumps(lambda: f, recurse=False) # doesn't call __getstate__\n    assert bar[0] == b\n    dumps(lambda: f, recurse=True) # calls __getstate__\n    assert bar[0] == b + 1\n#97 serialize lambdas in test files",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_detect",
        "documentation": {}
    },
    {
        "label": "test_dictproxy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "description": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "peekOfCode": "def test_dictproxy():\n    assert dill.copy(DictProxyType({'a': 2}))\ndef test_dictviews():\n    x = {'a': 1}\n    assert dill.copy(x.keys())\n    assert dill.copy(x.values())\n    assert dill.copy(x.items())\ndef test_dictproxy_trick():\n    if not OLD310 and MAPPING_PROXY_TRICK:\n        x = {'a': 1}",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "documentation": {}
    },
    {
        "label": "test_dictviews",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "description": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "peekOfCode": "def test_dictviews():\n    x = {'a': 1}\n    assert dill.copy(x.keys())\n    assert dill.copy(x.values())\n    assert dill.copy(x.items())\ndef test_dictproxy_trick():\n    if not OLD310 and MAPPING_PROXY_TRICK:\n        x = {'a': 1}\n        all_views = (x.values(), x.items(), x.keys(), x)\n        seperate_views = dill.copy(all_views)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "documentation": {}
    },
    {
        "label": "test_dictproxy_trick",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "description": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "peekOfCode": "def test_dictproxy_trick():\n    if not OLD310 and MAPPING_PROXY_TRICK:\n        x = {'a': 1}\n        all_views = (x.values(), x.items(), x.keys(), x)\n        seperate_views = dill.copy(all_views)\n        new_x = seperate_views[-1]\n        new_x['b'] = 2\n        new_x['c'] = 1\n        assert len(new_x) == 3 and len(x) == 1\n        assert len(seperate_views[0]) == 3 and len(all_views[0]) == 1",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_dictviews",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "description": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "peekOfCode": "class A:\n    pass\ndef test_diff():\n    a = A()\n    b = A()\n    c = A()\n    a.a = b\n    b.a = c\n    diff.memorise(a)\n    assert not diff.has_changed(a)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "documentation": {}
    },
    {
        "label": "test_diff",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "description": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "peekOfCode": "def test_diff():\n    a = A()\n    b = A()\n    c = A()\n    a.a = b\n    b.a = c\n    diff.memorise(a)\n    assert not diff.has_changed(a)\n    c.a = 1\n    assert diff.has_changed(a)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "description": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "peekOfCode": "IS_PYPY = not hasattr(sys, 'getrefcount')\nclass A:\n    pass\ndef test_diff():\n    a = A()\n    b = A()\n    c = A()\n    a.a = b\n    b.a = c\n    diff.memorise(a)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_diff",
        "documentation": {}
    },
    {
        "label": "my_fn",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "description": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "peekOfCode": "def my_fn(x):\n    return x * 17\ndef test_extend():\n    obj = lambda : my_fn(34)\n    assert obj() == 578\n    obj_io = StringIO()\n    pickler = pickle.Pickler(obj_io)\n    pickler.dump(obj)\n    obj_str = obj_io.getvalue()\n    obj2_io = StringIO(obj_str)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "documentation": {}
    },
    {
        "label": "test_extend",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "description": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "peekOfCode": "def test_extend():\n    obj = lambda : my_fn(34)\n    assert obj() == 578\n    obj_io = StringIO()\n    pickler = pickle.Pickler(obj_io)\n    pickler.dump(obj)\n    obj_str = obj_io.getvalue()\n    obj2_io = StringIO(obj_str)\n    unpickler = pickle.Unpickler(obj2_io)\n    obj2 = unpickler.load()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "documentation": {}
    },
    {
        "label": "test_isdill",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "description": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "peekOfCode": "def test_isdill():\n    obj_io = StringIO()\n    pickler = pickle.Pickler(obj_io)\n    assert pickle._dill.is_dill(pickler) is True\n    pickler = pickle._dill.StockPickler(obj_io)\n    assert pickle._dill.is_dill(pickler) is False\n    try:\n        import multiprocess as mp\n        pickler = mp.reduction.ForkingPickler(obj_io)\n        assert pickle._dill.is_dill(pickler, child=True) is True",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_extendpickle",
        "documentation": {}
    },
    {
        "label": "get_fun_with_strftime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "def get_fun_with_strftime():\n    def fun_with_strftime():\n        import datetime\n        return datetime.datetime.strptime(\"04-01-1943\", \"%d-%m-%Y\").strftime(\n            \"%Y-%m-%d %H:%M:%S\"\n        )\n    return fun_with_strftime\ndef get_fun_with_strftime2():\n    import datetime\n    return datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "get_fun_with_strftime2",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "def get_fun_with_strftime2():\n    import datetime\n    return datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')\ndef test_doc_dill_issue_219():\n    back_fn = dill.loads(dill.dumps(get_fun_with_strftime()))\n    assert back_fn() == \"1943-01-04 00:00:00\"\n    dupl = dill.loads(dill.dumps(get_fun_with_strftime2))\n    assert dupl() == get_fun_with_strftime2()\ndef get_fun_with_internal_import():\n    def fun_with_import():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "test_doc_dill_issue_219",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "def test_doc_dill_issue_219():\n    back_fn = dill.loads(dill.dumps(get_fun_with_strftime()))\n    assert back_fn() == \"1943-01-04 00:00:00\"\n    dupl = dill.loads(dill.dumps(get_fun_with_strftime2))\n    assert dupl() == get_fun_with_strftime2()\ndef get_fun_with_internal_import():\n    def fun_with_import():\n        import re\n        return re.compile(\"$\")\n    return fun_with_import",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "get_fun_with_internal_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "def get_fun_with_internal_import():\n    def fun_with_import():\n        import re\n        return re.compile(\"$\")\n    return fun_with_import\ndef test_method_with_internal_import_should_work():\n    import re\n    back_fn = dill.loads(dill.dumps(get_fun_with_internal_import()))\n    import inspect\n    if hasattr(inspect, 'getclosurevars'):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "test_method_with_internal_import_should_work",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "def test_method_with_internal_import_should_work():\n    import re\n    back_fn = dill.loads(dill.dumps(get_fun_with_internal_import()))\n    import inspect\n    if hasattr(inspect, 'getclosurevars'):\n        vars = inspect.getclosurevars(back_fn)\n        assert vars.globals == {}\n        assert vars.nonlocals == {}\n    assert back_fn() == re.compile(\"$\")\n    assert \"__builtins__\" in back_fn.__globals__",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "description": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "peekOfCode": "dill.settings['recurse'] = True\ndef get_fun_with_strftime():\n    def fun_with_strftime():\n        import datetime\n        return datetime.datetime.strptime(\"04-01-1943\", \"%d-%m-%Y\").strftime(\n            \"%Y-%m-%d %H:%M:%S\"\n        )\n    return fun_with_strftime\ndef get_fun_with_strftime2():\n    import datetime",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_fglobals",
        "documentation": {}
    },
    {
        "label": "write_randomness",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()\n    f = open(fname, \"r\")\n    contents = f.read()\n    f.close()\n    return contents\ndef trunc_file():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "trunc_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def trunc_file():\n    open(fname, \"w\").close()\ndef throws(op, args, exc):\n    try:\n        op(*args)\n    except type(exc):\n        return sys.exc_info()[1].args == exc.args\n    else:\n        return False\ndef teardown_module():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "throws",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def throws(op, args, exc):\n    try:\n        op(*args)\n    except type(exc):\n        return sys.exc_info()[1].args == exc.args\n    else:\n        return False\ndef teardown_module():\n    if os.path.exists(fname):\n        os.remove(fname)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "teardown_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def teardown_module():\n    if os.path.exists(fname):\n        os.remove(fname)\ndef bench(strictio, fmode, skippypy):\n    import platform\n    if skippypy and platform.python_implementation() == 'PyPy':\n        # Skip for PyPy...\n        return\n    # file exists, with same contents\n    # read",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "bench",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def bench(strictio, fmode, skippypy):\n    import platform\n    if skippypy and platform.python_implementation() == 'PyPy':\n        # Skip for PyPy...\n        return\n    # file exists, with same contents\n    # read\n    write_randomness()\n    f = open(fname, \"r\")\n    _f = dill.loads(dill.dumps(f, fmode=fmode))#, strictio=strictio))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "test_nostrictio_handlefmode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def test_nostrictio_handlefmode():\n    bench(False, dill.HANDLE_FMODE, False)\n    teardown_module()\ndef test_nostrictio_filefmode():\n    bench(False, dill.FILE_FMODE, False)\n    teardown_module()\ndef test_nostrictio_contentsfmode():\n    bench(False, dill.CONTENTS_FMODE, True)\n    teardown_module()\n#bench(True, dill.HANDLE_FMODE, False)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "test_nostrictio_filefmode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def test_nostrictio_filefmode():\n    bench(False, dill.FILE_FMODE, False)\n    teardown_module()\ndef test_nostrictio_contentsfmode():\n    bench(False, dill.CONTENTS_FMODE, True)\n    teardown_module()\n#bench(True, dill.HANDLE_FMODE, False)\n#bench(True, dill.FILE_FMODE, False)\n#bench(True, dill.CONTENTS_FMODE, True)\nif __name__ == '__main__':",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "test_nostrictio_contentsfmode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "def test_nostrictio_contentsfmode():\n    bench(False, dill.CONTENTS_FMODE, True)\n    teardown_module()\n#bench(True, dill.HANDLE_FMODE, False)\n#bench(True, dill.FILE_FMODE, False)\n#bench(True, dill.CONTENTS_FMODE, True)\nif __name__ == '__main__':\n    test_nostrictio_handlefmode()\n    test_nostrictio_filefmode()\n    test_nostrictio_contentsfmode()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "dill.settings['recurse'] = True\nfname = \"_test_file.txt\"\nrand_chars = list(string.ascii_letters) + [\"\\n\"] * 40  # bias newline\nbuffer_error = ValueError(\"invalid buffer size\")\ndne_error = FileNotFoundError(\"[Errno 2] No such file or directory: '%s'\" % fname)\ndef write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "fname",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "fname = \"_test_file.txt\"\nrand_chars = list(string.ascii_letters) + [\"\\n\"] * 40  # bias newline\nbuffer_error = ValueError(\"invalid buffer size\")\ndne_error = FileNotFoundError(\"[Errno 2] No such file or directory: '%s'\" % fname)\ndef write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()\n    f = open(fname, \"r\")",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "rand_chars",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "rand_chars = list(string.ascii_letters) + [\"\\n\"] * 40  # bias newline\nbuffer_error = ValueError(\"invalid buffer size\")\ndne_error = FileNotFoundError(\"[Errno 2] No such file or directory: '%s'\" % fname)\ndef write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()\n    f = open(fname, \"r\")\n    contents = f.read()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "buffer_error",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "buffer_error = ValueError(\"invalid buffer size\")\ndne_error = FileNotFoundError(\"[Errno 2] No such file or directory: '%s'\" % fname)\ndef write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()\n    f = open(fname, \"r\")\n    contents = f.read()\n    f.close()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "dne_error",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_file",
        "description": "__pypackages__.3.10.lib.dill.tests.test_file",
        "peekOfCode": "dne_error = FileNotFoundError(\"[Errno 2] No such file or directory: '%s'\" % fname)\ndef write_randomness(number=200):\n    f = open(fname, \"w\")\n    for i in range(number):\n        f.write(random.choice(rand_chars))\n    f.close()\n    f = open(fname, \"r\")\n    contents = f.read()\n    f.close()\n    return contents",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_file",
        "documentation": {}
    },
    {
        "label": "function_a",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_a(a):\n    return a\ndef function_b(b, b1):\n    return b + b1\ndef function_c(c, c1=1):\n    return c + c1\ndef function_d(d, d1, d2=1):\n    \"\"\"doc string\"\"\"\n    return d + d1 + d2\nfunction_d.__module__ = 'a module'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_b",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_b(b, b1):\n    return b + b1\ndef function_c(c, c1=1):\n    return c + c1\ndef function_d(d, d1, d2=1):\n    \"\"\"doc string\"\"\"\n    return d + d1 + d2\nfunction_d.__module__ = 'a module'\nexec('''\ndef function_e(e, *e1, e2=1, e3=2):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_c",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_c(c, c1=1):\n    return c + c1\ndef function_d(d, d1, d2=1):\n    \"\"\"doc string\"\"\"\n    return d + d1 + d2\nfunction_d.__module__ = 'a module'\nexec('''\ndef function_e(e, *e1, e2=1, e3=2):\n    return e + sum(e1) + e2 + e3''')\nglobalvar = 0",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_d",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_d(d, d1, d2=1):\n    \"\"\"doc string\"\"\"\n    return d + d1 + d2\nfunction_d.__module__ = 'a module'\nexec('''\ndef function_e(e, *e1, e2=1, e3=2):\n    return e + sum(e1) + e2 + e3''')\nglobalvar = 0\n@functools.lru_cache(None)\ndef function_with_cache(x):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_e",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_e(e, *e1, e2=1, e3=2):\n    return e + sum(e1) + e2 + e3''')\nglobalvar = 0\n@functools.lru_cache(None)\ndef function_with_cache(x):\n    global globalvar\n    globalvar += x\n    return globalvar\ndef function_with_unassigned_variable():\n    if False:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_with_cache",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_with_cache(x):\n    global globalvar\n    globalvar += x\n    return globalvar\ndef function_with_unassigned_variable():\n    if False:\n        value = None\n    return (lambda: value)\ndef test_issue_510():\n    # A very bizzare use of functions and methods that pickle doesn't get",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_with_unassigned_variable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def function_with_unassigned_variable():\n    if False:\n        value = None\n    return (lambda: value)\ndef test_issue_510():\n    # A very bizzare use of functions and methods that pickle doesn't get\n    # correctly for odd reasons.\n    class Foo:\n        def __init__(self):\n                def f2(self):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "test_issue_510",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def test_issue_510():\n    # A very bizzare use of functions and methods that pickle doesn't get\n    # correctly for odd reasons.\n    class Foo:\n        def __init__(self):\n                def f2(self):\n                        return self\n                self.f2 = f2.__get__(self)\n    import dill, pickletools\n    f = Foo()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "test_functions",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def test_functions():\n    dumped_func_a = dill.dumps(function_a)\n    assert dill.loads(dumped_func_a)(0) == 0\n    dumped_func_b = dill.dumps(function_b)\n    assert dill.loads(dumped_func_b)(1,2) == 3\n    dumped_func_c = dill.dumps(function_c)\n    assert dill.loads(dumped_func_c)(1) == 2\n    assert dill.loads(dumped_func_c)(1, 2) == 3\n    dumped_func_d = dill.dumps(function_d)\n    assert dill.loads(dumped_func_d).__doc__ == function_d.__doc__",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "test_code_object",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "def test_code_object():\n    from dill._dill import ALL_CODE_PARAMS, CODE_PARAMS, CODE_VERSION, _create_code\n    code = function_c.__code__\n    LNOTAB = getattr(code, 'co_lnotab', b'')\n    fields = {f: getattr(code, 'co_'+f) for f in CODE_PARAMS}\n    fields.setdefault('posonlyargcount', 0)         # python >= 3.8\n    fields.setdefault('lnotab', LNOTAB)             # python <= 3.9\n    fields.setdefault('linetable', b'')             # python >= 3.10\n    fields.setdefault('qualname', fields['name'])   # python >= 3.11\n    fields.setdefault('exceptiontable', b'')        # python >= 3.11",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "dill.settings['recurse'] = True\ndef function_a(a):\n    return a\ndef function_b(b, b1):\n    return b + b1\ndef function_c(c, c1=1):\n    return c + c1\ndef function_d(d, d1, d2=1):\n    \"\"\"doc string\"\"\"\n    return d + d1 + d2",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "function_d.__module__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "function_d.__module__ = 'a module'\nexec('''\ndef function_e(e, *e1, e2=1, e3=2):\n    return e + sum(e1) + e2 + e3''')\nglobalvar = 0\n@functools.lru_cache(None)\ndef function_with_cache(x):\n    global globalvar\n    globalvar += x\n    return globalvar",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "globalvar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "globalvar = 0\n@functools.lru_cache(None)\ndef function_with_cache(x):\n    global globalvar\n    globalvar += x\n    return globalvar\ndef function_with_unassigned_variable():\n    if False:\n        value = None\n    return (lambda: value)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "dumped_func_e",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "peekOfCode": "dumped_func_e = dill.dumps(function_e)\nassert dill.loads(dumped_func_e)(1, 2) == 6\nassert dill.loads(dumped_func_e)(1, 2, 3) == 9\nassert dill.loads(dumped_func_e)(1, 2, e2=3) == 8\nassert dill.loads(dumped_func_e)(1, 2, e2=3, e3=4) == 10\nassert dill.loads(dumped_func_e)(1, 2, 3, e2=4) == 12\nassert dill.loads(dumped_func_e)(1, 2, 3, e2=4, e3=5) == 15''')\ndef test_code_object():\n    from dill._dill import ALL_CODE_PARAMS, CODE_PARAMS, CODE_VERSION, _create_code\n    code = function_c.__code__",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functions",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "peekOfCode": "def f(a, b, c):  # without keywords\n    pass\ndef g(a, b, c=2):  # with keywords\n    pass\ndef h(a=1, b=2, c=3):  # without args\n    pass\ndef test_functools():\n    fp = functools.partial(f, 1, 2)\n    gp = functools.partial(g, 1, c=2)\n    hp = functools.partial(h, 1, c=2)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "peekOfCode": "def g(a, b, c=2):  # with keywords\n    pass\ndef h(a=1, b=2, c=3):  # without args\n    pass\ndef test_functools():\n    fp = functools.partial(f, 1, 2)\n    gp = functools.partial(g, 1, c=2)\n    hp = functools.partial(h, 1, c=2)\n    bp = functools.partial(int, base=2)\n    assert dill.pickles(fp, safe=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "peekOfCode": "def h(a=1, b=2, c=3):  # without args\n    pass\ndef test_functools():\n    fp = functools.partial(f, 1, 2)\n    gp = functools.partial(g, 1, c=2)\n    hp = functools.partial(h, 1, c=2)\n    bp = functools.partial(int, base=2)\n    assert dill.pickles(fp, safe=True)\n    assert dill.pickles(gp, safe=True)\n    assert dill.pickles(hp, safe=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "documentation": {}
    },
    {
        "label": "test_functools",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "peekOfCode": "def test_functools():\n    fp = functools.partial(f, 1, 2)\n    gp = functools.partial(g, 1, c=2)\n    hp = functools.partial(h, 1, c=2)\n    bp = functools.partial(int, base=2)\n    assert dill.pickles(fp, safe=True)\n    assert dill.pickles(gp, safe=True)\n    assert dill.pickles(hp, safe=True)\n    assert dill.pickles(bp, safe=True)\nif __name__ == '__main__':",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "description": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "peekOfCode": "dill.settings['recurse'] = True\ndef f(a, b, c):  # without keywords\n    pass\ndef g(a, b, c=2):  # with keywords\n    pass\ndef h(a=1, b=2, c=3):  # without args\n    pass\ndef test_functools():\n    fp = functools.partial(f, 1, 2)\n    gp = functools.partial(g, 1, c=2)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_functors",
        "documentation": {}
    },
    {
        "label": "test_logging",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "description": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "peekOfCode": "def test_logging(should_trace):\n    buffer = StringIO()\n    handler = logging.StreamHandler(buffer)\n    logger.addHandler(handler)\n    try:\n        dill.dumps(test_obj)\n        if should_trace:\n            regex = re.compile(r'(\\S*┬ \\w.*[^)]'              # begin pickling object\n                               r'|│*└ # \\w.* \\[\\d+ (\\wi)?B])' # object written (with size)\n                               )",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "documentation": {}
    },
    {
        "label": "test_trace_to_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "description": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "peekOfCode": "def test_trace_to_file(stream_trace):\n    file = tempfile.NamedTemporaryFile(mode='r')\n    with detect.trace(file.name, mode='w'):\n        dill.dumps(test_obj)\n    file_trace = file.read()\n    file.close()\n    # Apparently, objects can change location in memory...\n    reghex = re.compile(r'0x[0-9A-Za-z]+')\n    file_trace, stream_trace = reghex.sub('0x', file_trace), reghex.sub('0x', stream_trace)\n    # PyPy prints dictionary contents with repr(dict)...",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "documentation": {}
    },
    {
        "label": "test_obj",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "description": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "peekOfCode": "test_obj = {'a': (1, 2), 'b': object(), 'f': lambda x: x**2, 'big': list(range(10))}\ndef test_logging(should_trace):\n    buffer = StringIO()\n    handler = logging.StreamHandler(buffer)\n    logger.addHandler(handler)\n    try:\n        dill.dumps(test_obj)\n        if should_trace:\n            regex = re.compile(r'(\\S*┬ \\w.*[^)]'              # begin pickling object\n                               r'|│*└ # \\w.* \\[\\d+ (\\wi)?B])' # object written (with size)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_logger",
        "documentation": {}
    },
    {
        "label": "wtf",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def wtf(x,y,z):\n  def zzz():\n    return x\n  def yyy():\n    return y\n  def xxx():\n    return z\n  return zzz,yyy\ndef quad(a=1, b=1, c=0):\n  inverted = [False]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "quad",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def quad(a=1, b=1, c=0):\n  inverted = [False]\n  def invert():\n    inverted[0] = not inverted[0]\n  def dec(f):\n    def func(*args, **kwds):\n      x = f(*args, **kwds)\n      if inverted[0]: x = -x\n      return a*x**2 + b*x + c\n    func.__wrapped__ = f",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "double_add",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def double_add(*args):\n  return sum(args)\nfx = sum([1,2,3])\n### to make it interesting...\ndef quad_factory(a=1,b=1,c=0):\n  def dec(f):\n    def func(*args,**kwds):\n      fx = f(*args,**kwds)\n      return a*fx**2 + b*fx + c\n    return func",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "quad_factory",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def quad_factory(a=1,b=1,c=0):\n  def dec(f):\n    def func(*args,**kwds):\n      fx = f(*args,**kwds)\n      return a*fx**2 + b*fx + c\n    return func\n  return dec\n@quad_factory(a=0,b=4,c=0)\ndef quadish(x):\n  return x+1",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "quadish",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def quadish(x):\n  return x+1\nquadratic = quad_factory()\ndef doubler(f):\n  def inner(*args, **kwds):\n    fx = f(*args, **kwds)\n    return 2*fx\n  return inner\n@doubler\ndef quadruple(x):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "doubler",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def doubler(f):\n  def inner(*args, **kwds):\n    fx = f(*args, **kwds)\n    return 2*fx\n  return inner\n@doubler\ndef quadruple(x):\n  return 2*x\ndef test_mixins():\n  # test mixins",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "quadruple",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def quadruple(x):\n  return 2*x\ndef test_mixins():\n  # test mixins\n  assert double_add(1,2,3) == 2*fx\n  double_add.invert()\n  assert double_add(1,2,3) == -2*fx\n  _d = dill.copy(double_add)\n  assert _d(1,2,3) == -2*fx\n #_d.invert() #FIXME: fails seemingly randomly",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "test_mixins",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "def test_mixins():\n  # test mixins\n  assert double_add(1,2,3) == 2*fx\n  double_add.invert()\n  assert double_add(1,2,3) == -2*fx\n  _d = dill.copy(double_add)\n  assert _d(1,2,3) == -2*fx\n #_d.invert() #FIXME: fails seemingly randomly\n #assert _d(1,2,3) == 2*fx\n  assert _d.__wrapped__(1,2,3) == fx",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "dill.settings['recurse'] = True\ndef wtf(x,y,z):\n  def zzz():\n    return x\n  def yyy():\n    return y\n  def xxx():\n    return z\n  return zzz,yyy\ndef quad(a=1, b=1, c=0):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "fx",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "fx = sum([1,2,3])\n### to make it interesting...\ndef quad_factory(a=1,b=1,c=0):\n  def dec(f):\n    def func(*args,**kwds):\n      fx = f(*args,**kwds)\n      return a*fx**2 + b*fx + c\n    return func\n  return dec\n@quad_factory(a=0,b=4,c=0)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "quadratic",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "description": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "peekOfCode": "quadratic = quad_factory()\ndef doubler(f):\n  def inner(*args, **kwds):\n    fx = f(*args, **kwds)\n    return 2*fx\n  return inner\n@doubler\ndef quadruple(x):\n  return 2*x\ndef test_mixins():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_mixins",
        "documentation": {}
    },
    {
        "label": "test_attributes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "def test_attributes():\n   #assert hasattr(module, \"a\") and module.a == 1234  #FIXME: -m dill.tests\n    assert module.double_add(1, 2, 3) == 2 * module.fx\n# Restart, and test use_diff\nreload(module)\ntry:\n    dill.use_diff()\n    module.a = 1234\n    pik_mod = dill.dumps(module)\n    module.a = 0",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "get_lambda",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "def get_lambda(str, **kwarg):\n    return eval(str, kwarg, None)\nobj = get_lambda('lambda x: math.exp(x)', math=math)\ndef test_module_is_none():\n    assert obj.__module__ is None\n    assert dill.copy(obj)(3) == obj(3)\nif __name__ == '__main__':\n    test_attributes()\n    test_diff_attributes()\n    test_module_is_none()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "test_module_is_none",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "def test_module_is_none():\n    assert obj.__module__ is None\n    assert dill.copy(obj)(3) == obj(3)\nif __name__ == '__main__':\n    test_attributes()\n    test_diff_attributes()\n    test_module_is_none()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "dill.settings['recurse'] = True\ncached = (module.__cached__ if hasattr(module, \"__cached__\")\n          else module.__file__.split(\".\", 1)[0] + \".pyc\")\nmodule.a = 1234\npik_mod = dill.dumps(module)\nmodule.a = 0\n# remove module\ndel sys.modules[module.__name__]\ndel module\nmodule = dill.loads(pik_mod)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "cached",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "cached = (module.__cached__ if hasattr(module, \"__cached__\")\n          else module.__file__.split(\".\", 1)[0] + \".pyc\")\nmodule.a = 1234\npik_mod = dill.dumps(module)\nmodule.a = 0\n# remove module\ndel sys.modules[module.__name__]\ndel module\nmodule = dill.loads(pik_mod)\ndef test_attributes():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "module.a",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "module.a = 1234\npik_mod = dill.dumps(module)\nmodule.a = 0\n# remove module\ndel sys.modules[module.__name__]\ndel module\nmodule = dill.loads(pik_mod)\ndef test_attributes():\n   #assert hasattr(module, \"a\") and module.a == 1234  #FIXME: -m dill.tests\n    assert module.double_add(1, 2, 3) == 2 * module.fx",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "pik_mod",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "pik_mod = dill.dumps(module)\nmodule.a = 0\n# remove module\ndel sys.modules[module.__name__]\ndel module\nmodule = dill.loads(pik_mod)\ndef test_attributes():\n   #assert hasattr(module, \"a\") and module.a == 1234  #FIXME: -m dill.tests\n    assert module.double_add(1, 2, 3) == 2 * module.fx\n# Restart, and test use_diff",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "module.a",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "module.a = 0\n# remove module\ndel sys.modules[module.__name__]\ndel module\nmodule = dill.loads(pik_mod)\ndef test_attributes():\n   #assert hasattr(module, \"a\") and module.a == 1234  #FIXME: -m dill.tests\n    assert module.double_add(1, 2, 3) == 2 * module.fx\n# Restart, and test use_diff\nreload(module)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "module",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "module = dill.loads(pik_mod)\ndef test_attributes():\n   #assert hasattr(module, \"a\") and module.a == 1234  #FIXME: -m dill.tests\n    assert module.double_add(1, 2, 3) == 2 * module.fx\n# Restart, and test use_diff\nreload(module)\ntry:\n    dill.use_diff()\n    module.a = 1234\n    pik_mod = dill.dumps(module)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "pycache",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "pycache = os.path.join(os.path.dirname(module.__file__), \"__pycache__\")\nif os.path.exists(pycache) and not os.listdir(pycache):\n    os.removedirs(pycache)\n# test when module is None\nimport math\ndef get_lambda(str, **kwarg):\n    return eval(str, kwarg, None)\nobj = get_lambda('lambda x: math.exp(x)', math=math)\ndef test_module_is_none():\n    assert obj.__module__ is None",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_module",
        "description": "__pypackages__.3.10.lib.dill.tests.test_module",
        "peekOfCode": "obj = get_lambda('lambda x: math.exp(x)', math=math)\ndef test_module_is_none():\n    assert obj.__module__ is None\n    assert dill.copy(obj)(3) == obj(3)\nif __name__ == '__main__':\n    test_attributes()\n    test_diff_attributes()\n    test_module_is_none()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_module",
        "documentation": {}
    },
    {
        "label": "SomeUnreferencedUnpicklableClass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "class SomeUnreferencedUnpicklableClass(object):\n    def __reduce__(self):\n        raise Exception\nunpicklable = SomeUnreferencedUnpicklableClass()\n# This works fine outside of Doctest:\ndef test_normal():\n    serialized = dill.dumps(lambda x: x)\n# should not try to pickle unpicklable object in __globals__\ndef tests():\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def f(func):\n  def w(*args):\n    return f(*args)\n  return w\n@f\ndef f2(): pass\n# check when __main__ and on import\ndef test_decorated():\n  assert dill.pickles(f2)\nimport doctest",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "f2",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def f2(): pass\n# check when __main__ and on import\ndef test_decorated():\n  assert dill.pickles(f2)\nimport doctest\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nclass SomeUnreferencedUnpicklableClass(object):\n    def __reduce__(self):\n        raise Exception",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "test_decorated",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def test_decorated():\n  assert dill.pickles(f2)\nimport doctest\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nclass SomeUnreferencedUnpicklableClass(object):\n    def __reduce__(self):\n        raise Exception\nunpicklable = SomeUnreferencedUnpicklableClass()\n# This works fine outside of Doctest:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "test_normal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def test_normal():\n    serialized = dill.dumps(lambda x: x)\n# should not try to pickle unpicklable object in __globals__\ndef tests():\n    \"\"\"\n    >>> serialized = dill.dumps(lambda x: x)\n    \"\"\"\n    return\n#print(\"\\n\\nRunning Doctest:\")\ndef test_doctest():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "tests",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def tests():\n    \"\"\"\n    >>> serialized = dill.dumps(lambda x: x)\n    \"\"\"\n    return\n#print(\"\\n\\nRunning Doctest:\")\ndef test_doctest():\n    doctest.testmod()\nif __name__ == '__main__':\n    test_decorated()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "test_doctest",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "def test_doctest():\n    doctest.testmod()\nif __name__ == '__main__':\n    test_decorated()\n    test_normal()\n    test_doctest()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "dill.settings['recurse'] = True\ndef f(func):\n  def w(*args):\n    return f(*args)\n  return w\n@f\ndef f2(): pass\n# check when __main__ and on import\ndef test_decorated():\n  assert dill.pickles(f2)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "unpicklable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "description": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "peekOfCode": "unpicklable = SomeUnreferencedUnpicklableClass()\n# This works fine outside of Doctest:\ndef test_normal():\n    serialized = dill.dumps(lambda x: x)\n# should not try to pickle unpicklable object in __globals__\ndef tests():\n    \"\"\"\n    >>> serialized = dill.dumps(lambda x: x)\n    \"\"\"\n    return",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_moduledict",
        "documentation": {}
    },
    {
        "label": "cadder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "class cadder(object):\n    def __init__(self, augend):\n        self.augend = augend\n        self.zero = [0]\n    def __call__(self, addend):\n        return addend + self.augend + self.zero[0]\n# rewrite again, but as an old-style class\nclass c2adder:\n    def __init__(self, augend):\n        self.augend = augend",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "c2adder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "class c2adder:\n    def __init__(self, augend):\n        self.augend = augend\n        self.zero = [0]\n    def __call__(self, addend):\n        return addend + self.augend + self.zero[0]\n# some basic class stuff\nclass basic(object):\n    pass\nclass basic2:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "basic",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "class basic(object):\n    pass\nclass basic2:\n    pass\nx = 5\ny = 1\ndef test_basic():\n    a = [0, 1, 2]\n    pa = pickle.dumps(a)\n    pmath = pickle.dumps(math) #XXX: FAILS in pickle",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "basic2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "class basic2:\n    pass\nx = 5\ny = 1\ndef test_basic():\n    a = [0, 1, 2]\n    pa = pickle.dumps(a)\n    pmath = pickle.dumps(math) #XXX: FAILS in pickle\n    pmap = pickle.dumps(map)\n    # ...",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "adder",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def adder(augend):\n    zero = [0]\n    def inner(addend):\n        return addend + augend + zero[0]\n    return inner\n# rewrite the nested function using a class: standard pickle should work here.\nclass cadder(object):\n    def __init__(self, augend):\n        self.augend = augend\n        self.zero = [0]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_basic",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_basic():\n    a = [0, 1, 2]\n    pa = pickle.dumps(a)\n    pmath = pickle.dumps(math) #XXX: FAILS in pickle\n    pmap = pickle.dumps(map)\n    # ...\n    la = pickle.loads(pa)\n    lmath = pickle.loads(pmath)\n    lmap = pickle.loads(pmap)\n    assert list(map(math.sin, a)) == list(lmap(lmath.sin, la))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_basic_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_basic_class():\n    pbasic2 = pickle.dumps(basic2)\n    _pbasic2 = pickle.loads(pbasic2)()\n    pbasic = pickle.dumps(basic)\n    _pbasic = pickle.loads(pbasic)()\ndef test_c2adder():\n    pc2adder = pickle.dumps(c2adder)\n    pc2add5 = pickle.loads(pc2adder)(x)\n    assert pc2add5(y) == x+y\ndef test_pickled_cadder():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_c2adder",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_c2adder():\n    pc2adder = pickle.dumps(c2adder)\n    pc2add5 = pickle.loads(pc2adder)(x)\n    assert pc2add5(y) == x+y\ndef test_pickled_cadder():\n    pcadder = pickle.dumps(cadder)\n    pcadd5 = pickle.loads(pcadder)(x)\n    assert pcadd5(y) == x+y\ndef test_raw_adder_and_inner():\n    add5 = adder(x)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_pickled_cadder",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_pickled_cadder():\n    pcadder = pickle.dumps(cadder)\n    pcadd5 = pickle.loads(pcadder)(x)\n    assert pcadd5(y) == x+y\ndef test_raw_adder_and_inner():\n    add5 = adder(x)\n    assert add5(y) == x+y\ndef test_pickled_adder():\n    padder = pickle.dumps(adder)\n    padd5 = pickle.loads(padder)(x)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_raw_adder_and_inner",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_raw_adder_and_inner():\n    add5 = adder(x)\n    assert add5(y) == x+y\ndef test_pickled_adder():\n    padder = pickle.dumps(adder)\n    padd5 = pickle.loads(padder)(x)\n    assert padd5(y) == x+y\ndef test_pickled_inner():\n    add5 = adder(x)\n    pinner = pickle.dumps(add5) #XXX: FAILS in pickle",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_pickled_adder",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_pickled_adder():\n    padder = pickle.dumps(adder)\n    padd5 = pickle.loads(padder)(x)\n    assert padd5(y) == x+y\ndef test_pickled_inner():\n    add5 = adder(x)\n    pinner = pickle.dumps(add5) #XXX: FAILS in pickle\n    p5add = pickle.loads(pinner)\n    assert p5add(y) == x+y\ndef test_moduledict_where_not_main():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_pickled_inner",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_pickled_inner():\n    add5 = adder(x)\n    pinner = pickle.dumps(add5) #XXX: FAILS in pickle\n    p5add = pickle.loads(pinner)\n    assert p5add(y) == x+y\ndef test_moduledict_where_not_main():\n    try:\n        from . import test_moduledict\n    except ImportError:\n        import test_moduledict",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_moduledict_where_not_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "def test_moduledict_where_not_main():\n    try:\n        from . import test_moduledict\n    except ImportError:\n        import test_moduledict\n    name = 'test_moduledict.py'\n    if os.path.exists(name) and os.path.exists(name+'c'):\n        os.remove(name+'c')\n    if os.path.exists(name) and hasattr(test_moduledict, \"__cached__\") \\\n       and os.path.exists(test_moduledict.__cached__):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "pickle.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "pickle.settings['recurse'] = True\n# the nested function: pickle should fail here, but dill is ok.\ndef adder(augend):\n    zero = [0]\n    def inner(addend):\n        return addend + augend + zero[0]\n    return inner\n# rewrite the nested function using a class: standard pickle should work here.\nclass cadder(object):\n    def __init__(self, augend):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "x = 5\ny = 1\ndef test_basic():\n    a = [0, 1, 2]\n    pa = pickle.dumps(a)\n    pmath = pickle.dumps(math) #XXX: FAILS in pickle\n    pmap = pickle.dumps(map)\n    # ...\n    la = pickle.loads(pa)\n    lmath = pickle.loads(pmath)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "description": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "peekOfCode": "y = 1\ndef test_basic():\n    a = [0, 1, 2]\n    pa = pickle.dumps(a)\n    pmath = pickle.dumps(math) #XXX: FAILS in pickle\n    pmap = pickle.dumps(map)\n    # ...\n    la = pickle.loads(pa)\n    lmath = pickle.loads(pmath)\n    lmap = pickle.loads(pmap)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "class _class:\n    def _method(self):\n        pass\n# objects that *fail* if imported\nspecial = {}\nspecial['LambdaType'] = _lambda = lambda x: lambda y: x\nspecial['MethodType'] = _method = _class()._method\nspecial['UnboundMethodType'] = _class._method\nobjects.update(special)\ndef pickles(name, exact=False):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "pickles",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "def pickles(name, exact=False):\n    \"\"\"quick check if object pickles with dill\"\"\"\n    obj = objects[name]\n    try:\n        pik = pickle.loads(pickle.dumps(obj))\n        if exact:\n            try:\n                assert pik == obj\n            except AssertionError:\n                assert type(obj) == type(pik)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "test_objects",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "def test_objects():\n    for member in objects.keys():\n       #pickles(member, exact=True)\n        pickles(member, exact=False)\nif __name__ == '__main__':\n    import warnings\n    warnings.simplefilter('ignore')\n    test_objects()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "pickle.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "pickle.settings['recurse'] = True\n#pickle.detect.trace(True)\n#import pickle\n# get all objects for testing\nfrom dill import load_types, objects, extend\nload_types(pickleable=True,unpickleable=False)\n# uncomment the next two lines to test cloudpickle\n#extend(False)\n#import cloudpickle as pickle\n# helper objects",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "special",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "special = {}\nspecial['LambdaType'] = _lambda = lambda x: lambda y: x\nspecial['MethodType'] = _method = _class()._method\nspecial['UnboundMethodType'] = _class._method\nobjects.update(special)\ndef pickles(name, exact=False):\n    \"\"\"quick check if object pickles with dill\"\"\"\n    obj = objects[name]\n    try:\n        pik = pickle.loads(pickle.dumps(obj))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "special['LambdaType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "special['LambdaType'] = _lambda = lambda x: lambda y: x\nspecial['MethodType'] = _method = _class()._method\nspecial['UnboundMethodType'] = _class._method\nobjects.update(special)\ndef pickles(name, exact=False):\n    \"\"\"quick check if object pickles with dill\"\"\"\n    obj = objects[name]\n    try:\n        pik = pickle.loads(pickle.dumps(obj))\n        if exact:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "special['MethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "special['MethodType'] = _method = _class()._method\nspecial['UnboundMethodType'] = _class._method\nobjects.update(special)\ndef pickles(name, exact=False):\n    \"\"\"quick check if object pickles with dill\"\"\"\n    obj = objects[name]\n    try:\n        pik = pickle.loads(pickle.dumps(obj))\n        if exact:\n            try:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "special['UnboundMethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "description": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "peekOfCode": "special['UnboundMethodType'] = _class._method\nobjects.update(special)\ndef pickles(name, exact=False):\n    \"\"\"quick check if object pickles with dill\"\"\"\n    obj = objects[name]\n    try:\n        pik = pickle.loads(pickle.dumps(obj))\n        if exact:\n            try:\n                assert pik == obj",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_objects",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "description": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "peekOfCode": "class Foo(object):\n    def __init__(self):\n        self._data = 1\n    def _get_data(self):\n        return self._data\n    def _set_data(self, x):\n        self._data = x\n    data = property(_get_data, _set_data)\ndef test_data_not_none():\n    FooS = dill.copy(Foo)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "documentation": {}
    },
    {
        "label": "test_data_not_none",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "description": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "peekOfCode": "def test_data_not_none():\n    FooS = dill.copy(Foo)\n    assert FooS.data.fget is not None\n    assert FooS.data.fset is not None\n    assert FooS.data.fdel is None\ndef test_data_unchanged():\n    FooS = dill.copy(Foo)\n    try:\n        res = FooS().data\n    except Exception:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "documentation": {}
    },
    {
        "label": "test_data_unchanged",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "description": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "peekOfCode": "def test_data_unchanged():\n    FooS = dill.copy(Foo)\n    try:\n        res = FooS().data\n    except Exception:\n        e = sys.exc_info()[1]\n        raise AssertionError(str(e))\n    else:\n        assert res == 1\ndef test_data_changed():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "documentation": {}
    },
    {
        "label": "test_data_changed",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "description": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "peekOfCode": "def test_data_changed():\n    FooS = dill.copy(Foo)\n    try:\n        f = FooS()\n        f.data = 1024\n        res = f.data\n    except Exception:\n        e = sys.exc_info()[1]\n        raise AssertionError(str(e))\n    else:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "description": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "peekOfCode": "dill.settings['recurse'] = True\nclass Foo(object):\n    def __init__(self):\n        self._data = 1\n    def _get_data(self):\n        return self._data\n    def _set_data(self, x):\n        self._data = x\n    data = property(_get_data, _set_data)\ndef test_data_not_none():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_properties",
        "documentation": {}
    },
    {
        "label": "test_pycapsule",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_pycapsule",
        "description": "__pypackages__.3.10.lib.dill.tests.test_pycapsule",
        "peekOfCode": "test_pycapsule = None\nif dill._dill._testcapsule is not None:\n    import ctypes\n    def test_pycapsule():\n        name = ctypes.create_string_buffer(b'dill._testcapsule')\n        capsule = dill._dill._PyCapsule_New(\n            ctypes.cast(dill._dill._PyCapsule_New, ctypes.c_void_p),\n            name,\n            None\n        )",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_pycapsule",
        "documentation": {}
    },
    {
        "label": "obj1",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class obj1(object):\n    def __init__(self):\n        super(obj1, self).__init__()\nclass obj2(object):\n    def __init__(self):\n        super(obj2, self).__init__()\nclass obj3(object):\n    super_ = super\n    def __init__(self):\n        obj3.super_(obj3, self).__init__()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "obj2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class obj2(object):\n    def __init__(self):\n        super(obj2, self).__init__()\nclass obj3(object):\n    super_ = super\n    def __init__(self):\n        obj3.super_(obj3, self).__init__()\ndef test_super():\n    assert copy(obj1(), byref=True)\n    assert copy(obj1(), byref=True, recurse=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "obj3",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class obj3(object):\n    super_ = super\n    def __init__(self):\n        obj3.super_(obj3, self).__init__()\ndef test_super():\n    assert copy(obj1(), byref=True)\n    assert copy(obj1(), byref=True, recurse=True)\n    assert copy(obj1(), recurse=True)\n    assert copy(obj1())\n    assert copy(obj2(), byref=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "Machine",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class Machine(object):\n    def __init__(self):\n        self.child = Model()\n        self.trigger = partial(get_trigger, self)\n        self.child.trigger = partial(get_trigger, self.child)\nclass Model(object):\n    pass\ndef test_partial():\n    assert copy(Machine(), byref=True)\n    assert copy(Machine(), byref=True, recurse=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class Model(object):\n    pass\ndef test_partial():\n    assert copy(Machine(), byref=True)\n    assert copy(Machine(), byref=True, recurse=True)\n    assert copy(Machine(), recurse=True)\n    assert copy(Machine())\nclass Machine2(object):\n    def __init__(self):\n        self.go = partial(self.member, self)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "Machine2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class Machine2(object):\n    def __init__(self):\n        self.go = partial(self.member, self)\n    def member(self, model):\n        pass\nclass SubMachine(Machine2):\n    def __init__(self):\n        super(SubMachine, self).__init__()\ndef test_partials():\n    assert copy(SubMachine(), byref=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "SubMachine",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class SubMachine(Machine2):\n    def __init__(self):\n        super(SubMachine, self).__init__()\ndef test_partials():\n    assert copy(SubMachine(), byref=True)\n    assert copy(SubMachine(), byref=True, recurse=True)\n    assert copy(SubMachine(), recurse=True)\n    assert copy(SubMachine())\nclass obj4(object):\n    def __init__(self):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "obj4",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "class obj4(object):\n    def __init__(self):\n        super(obj4, self).__init__()\n        a = self\n        class obj5(object):\n            def __init__(self):\n                super(obj5, self).__init__()\n                self.a = a\n        self.b = obj5()\ndef test_circular_reference():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def copy(obj, byref=False, recurse=False):\n    if byref:\n        try:\n            return dill.copy(obj, byref=byref, recurse=recurse)\n        except Exception:\n            pass\n        else:\n            raise AssertionError('Copy of %s with byref=True should have given a warning!' % (obj,))\n        warnings.simplefilter('ignore')\n        val = dill.copy(obj, byref=byref, recurse=recurse)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_super",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_super():\n    assert copy(obj1(), byref=True)\n    assert copy(obj1(), byref=True, recurse=True)\n    assert copy(obj1(), recurse=True)\n    assert copy(obj1())\n    assert copy(obj2(), byref=True)\n    assert copy(obj2(), byref=True, recurse=True)\n    assert copy(obj2(), recurse=True)\n    assert copy(obj2())\n    assert copy(obj3(), byref=True)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "get_trigger",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def get_trigger(model):\n    pass\nclass Machine(object):\n    def __init__(self):\n        self.child = Model()\n        self.trigger = partial(get_trigger, self)\n        self.child.trigger = partial(get_trigger, self.child)\nclass Model(object):\n    pass\ndef test_partial():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_partial",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_partial():\n    assert copy(Machine(), byref=True)\n    assert copy(Machine(), byref=True, recurse=True)\n    assert copy(Machine(), recurse=True)\n    assert copy(Machine())\nclass Machine2(object):\n    def __init__(self):\n        self.go = partial(self.member, self)\n    def member(self, model):\n        pass",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_partials",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_partials():\n    assert copy(SubMachine(), byref=True)\n    assert copy(SubMachine(), byref=True, recurse=True)\n    assert copy(SubMachine(), recurse=True)\n    assert copy(SubMachine())\nclass obj4(object):\n    def __init__(self):\n        super(obj4, self).__init__()\n        a = self\n        class obj5(object):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_circular_reference",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_circular_reference():\n    assert copy(obj4())\n    obj4_copy = dill.loads(dill.dumps(obj4()))\n    assert type(obj4_copy) is type(obj4_copy).__init__.__closure__[0].cell_contents\n    assert type(obj4_copy.b) is type(obj4_copy.b).__init__.__closure__[0].cell_contents\ndef f():\n    def g():\n       return g\n    return g\ndef test_function_cells():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def f():\n    def g():\n       return g\n    return g\ndef test_function_cells():\n    assert copy(f())\ndef fib(n):\n    assert n >= 0\n    if n <= 1:\n        return n",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_function_cells",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_function_cells():\n    assert copy(f())\ndef fib(n):\n    assert n >= 0\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\ndef test_recursive_function():\n    global fib",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def fib(n):\n    assert n >= 0\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\ndef test_recursive_function():\n    global fib\n    fib2 = copy(fib, recurse=True)\n    fib3 = copy(fib)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_recursive_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_recursive_function():\n    global fib\n    fib2 = copy(fib, recurse=True)\n    fib3 = copy(fib)\n    fib4 = fib\n    del fib\n    assert fib2(5) == 5\n    for _fib in (fib3, fib4):\n        try:\n            _fib(5)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "collection_function_recursion",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def collection_function_recursion():\n    d = {}\n    def g():\n        return d\n    d['g'] = g\n    return g\ndef test_collection_function_recursion():\n    g = copy(collection_function_recursion())\n    assert g()['g'] is g\nif __name__ == '__main__':",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "test_collection_function_recursion",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "description": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "peekOfCode": "def test_collection_function_recursion():\n    g = copy(collection_function_recursion())\n    assert g()['g'] is g\nif __name__ == '__main__':\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        test_super()\n        test_partial()\n        test_partials()\n        test_circular_reference()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_recursive",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "def check(d, ok=True):\n    res = []\n    for k,v in d.items():\n        try:\n            z = dill.copy(v)\n            if ok: res.append(k)\n        except:\n            if not ok: res.append(k)\n    return res\nfails = check(failures)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "fails",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "fails = check(failures)\ntry:\n    assert not bool(fails)\nexcept AssertionError as e:\n    print(\"FAILS: %s\" % fails)\n    raise e from None\nregister = check(registered, ok=False)\ntry:\n    assert not bool(register)\nexcept AssertionError as e:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "register = check(registered, ok=False)\ntry:\n    assert not bool(register)\nexcept AssertionError as e:\n    print(\"REGISTER: %s\" % register)\n    raise e from None\nsuccess = check(succeeds, ok=False)\ntry:\n    assert not bool(success)\nexcept AssertionError as e:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "success = check(succeeds, ok=False)\ntry:\n    assert not bool(success)\nexcept AssertionError as e:\n    print(\"SUCCESS: %s\" % success)\n    raise e from None\nimport builtins\nimport types\nq = dill._dill._reverse_typemap\np = {k:v for k,v in q.items() if k not in vars(builtins) and k not in vars(types)}",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "q = dill._dill._reverse_typemap\np = {k:v for k,v in q.items() if k not in vars(builtins) and k not in vars(types)}\ndiff = set(p.keys()).difference(registered.keys())\ntry:\n    assert not bool(diff)\nexcept AssertionError as e:\n    print(\"DIFF: %s\" % diff)\n    raise e from None\nmiss = set(registered.keys()).difference(p.keys())\ntry:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "p = {k:v for k,v in q.items() if k not in vars(builtins) and k not in vars(types)}\ndiff = set(p.keys()).difference(registered.keys())\ntry:\n    assert not bool(diff)\nexcept AssertionError as e:\n    print(\"DIFF: %s\" % diff)\n    raise e from None\nmiss = set(registered.keys()).difference(p.keys())\ntry:\n    assert not bool(miss)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "diff",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "diff = set(p.keys()).difference(registered.keys())\ntry:\n    assert not bool(diff)\nexcept AssertionError as e:\n    print(\"DIFF: %s\" % diff)\n    raise e from None\nmiss = set(registered.keys()).difference(p.keys())\ntry:\n    assert not bool(miss)\nexcept AssertionError as e:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "miss",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "description": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "peekOfCode": "miss = set(registered.keys()).difference(p.keys())\ntry:\n    assert not bool(miss)\nexcept AssertionError as e:\n    print(\"MISS: %s\" % miss)\n    raise e from None",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_registered",
        "documentation": {}
    },
    {
        "label": "RestrictedType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "description": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "peekOfCode": "class RestrictedType:\n    def __bool__(*args, **kwargs):\n        raise Exception('Restricted function')\n    __eq__ = __lt__ = __le__ = __ne__ = __gt__ = __ge__ = __hash__ = __bool__\nglob_obj = RestrictedType()\ndef restricted_func():\n    a = glob_obj\ndef test_function_with_restricted_object():\n    deserialized = dill.loads(dill.dumps(restricted_func, recurse=True))\nif __name__ == '__main__':",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "documentation": {}
    },
    {
        "label": "restricted_func",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "description": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "peekOfCode": "def restricted_func():\n    a = glob_obj\ndef test_function_with_restricted_object():\n    deserialized = dill.loads(dill.dumps(restricted_func, recurse=True))\nif __name__ == '__main__':\n    test_function_with_restricted_object()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "documentation": {}
    },
    {
        "label": "test_function_with_restricted_object",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "description": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "peekOfCode": "def test_function_with_restricted_object():\n    deserialized = dill.loads(dill.dumps(restricted_func, recurse=True))\nif __name__ == '__main__':\n    test_function_with_restricted_object()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "documentation": {}
    },
    {
        "label": "glob_obj",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "description": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "peekOfCode": "glob_obj = RestrictedType()\ndef restricted_func():\n    a = glob_obj\ndef test_function_with_restricted_object():\n    deserialized = dill.loads(dill.dumps(restricted_func, recurse=True))\nif __name__ == '__main__':\n    test_function_with_restricted_object()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_restricted",
        "documentation": {}
    },
    {
        "label": "_d",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "class _d(object):\n  def _method(self):\n    pass\nfrom dill import objects\nfrom dill import load_types\nload_types(pickleable=True,unpickleable=False)\n_newclass = objects['ClassObjectType']\n# some clean-up #FIXME: should happen internal to dill\nobjects['TemporaryFileType'].close()\nobjects['TextWrapperType'].close()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "test_dict_contents",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "def test_dict_contents():\n  c = type.__dict__\n  for i,j in c.items():\n   #try:\n    ok = dill.pickles(j)\n   #except Exception:\n   #  print (\"FAIL: %s with %s\" % (i, dill.detect.errors(j)))\n    if verbose: print (\"%s: %s, %s\" % (ok, type(j), j))\n    assert ok\n  if verbose: print (\"\")",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "test_class_descriptors",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "def test_class_descriptors():\n  d = _d.__dict__\n  for i in d.values():\n    ok = dill.pickles(i)\n    if verbose: print (\"%s: %s, %s\" % (ok, type(i), i))\n    assert ok\n  if verbose: print (\"\")\n  od = _newclass.__dict__\n  for i in od.values():\n    ok = dill.pickles(i)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "test_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "def test_class():\n  o = _d()\n  oo = _newclass()\n  ok = dill.pickles(o)\n  if verbose: print (\"%s: %s, %s\" % (ok, type(o), o))\n  assert ok\n  ok = dill.pickles(oo)\n  if verbose: print (\"%s: %s, %s\" % (ok, type(oo), oo))\n  assert ok\n  if verbose: print (\"\")",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "test_frame_related",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "def test_frame_related():\n  g = _g(1)\n  f = g.gi_frame\n  e,t = _f()\n  _is = lambda ok: ok\n  ok = dill.pickles(f)\n  if verbose: print (\"%s: %s, %s\" % (ok, type(f), f))\n  assert not ok\n  ok = dill.pickles(g)\n  if verbose: print (\"%s: %s, %s\" % (ok, type(g), g))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "test_typing",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "def test_typing():\n  import typing\n  x = typing.Any\n  assert x == dill.copy(x)\n  x = typing.Dict[int, str]\n  assert x == dill.copy(x)\n  x = typing.List[int]\n  assert x == dill.copy(x)\n  x = typing.Tuple[int, str]\n  assert x == dill.copy(x)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "dill.settings['recurse'] = True\nverbose = False\ndef test_dict_contents():\n  c = type.__dict__\n  for i,j in c.items():\n   #try:\n    ok = dill.pickles(j)\n   #except Exception:\n   #  print (\"FAIL: %s with %s\" % (i, dill.detect.errors(j)))\n    if verbose: print (\"%s: %s, %s\" % (ok, type(j), j))",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "verbose = False\ndef test_dict_contents():\n  c = type.__dict__\n  for i,j in c.items():\n   #try:\n    ok = dill.pickles(j)\n   #except Exception:\n   #  print (\"FAIL: %s with %s\" % (i, dill.detect.errors(j)))\n    if verbose: print (\"%s: %s, %s\" % (ok, type(j), j))\n    assert ok",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "_newclass",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "description": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "peekOfCode": "_newclass = objects['ClassObjectType']\n# some clean-up #FIXME: should happen internal to dill\nobjects['TemporaryFileType'].close()\nobjects['TextWrapperType'].close()\nobjects['BufferedRandomType'].close()\nobjects['BufferedReaderType'].close()\nobjects['BufferedWriterType'].close()\nobjects['FileType'].close()\ndel objects\n# getset_descriptor for new-style classes (fails on '_method', if not __main__)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_selected",
        "documentation": {}
    },
    {
        "label": "Person",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)\nclass CalendarSubclass(Calendar):\n    def weekdays(self):\n        return [day_name[i] for i in self.iterweekdays()]\ncal = CalendarSubclass()\nselfref = __main__",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "CalendarSubclass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "class CalendarSubclass(Calendar):\n    def weekdays(self):\n        return [day_name[i] for i in self.iterweekdays()]\ncal = CalendarSubclass()\nselfref = __main__\n# Setup global namespace for session saving tests.\nclass TestNamespace:\n    test_globals = globals().copy()\n    def __init__(self, **extra):\n        self.extra = extra",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "class TestNamespace:\n    test_globals = globals().copy()\n    def __init__(self, **extra):\n        self.extra = extra\n    def __enter__(self):\n        self.backup = globals().copy()\n        globals().clear()\n        globals().update(self.test_globals)\n        globals().update(self.extra)\n        return self",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def squared(x): return x**2\ncubed = lambda x: x**3\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)\nclass CalendarSubclass(Calendar):\n    def weekdays(self):\n        return [day_name[i] for i in self.iterweekdays()]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "test_session_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def test_session_main(refimported):\n    \"\"\"test dump/load_module() for __main__, both in this process and in a subprocess\"\"\"\n    extra_objects = {}\n    if refimported:\n        # Test unpickleable imported object in main.\n        from sys import flags\n        extra_objects['flags'] = flags\n    with TestNamespace(**extra_objects) as ns:\n        try:\n            # Test session loading in a new session.",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "test_session_other",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def test_session_other():\n    \"\"\"test dump/load_module() for a module other than __main__\"\"\"\n    import test_classdef as module\n    atexit.register(_clean_up_cache, module)\n    module.selfref = module\n    dict_objects = [obj for obj in module.__dict__.keys() if not obj.startswith('__')]\n    session_buffer = BytesIO()\n    dill.dump_module(session_buffer, module)\n    for obj in dict_objects:\n        del module.__dict__[obj]",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "test_runtime_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def test_runtime_module():\n    from types import ModuleType\n    modname = '__runtime__'\n    runtime = ModuleType(modname)\n    runtime.x = 42\n    mod = dill.session._stash_modules(runtime)\n    if mod is not runtime:\n        print(\"There are objects to save by referenece that shouldn't be:\",\n              mod.__dill_imported, mod.__dill_imported_as, mod.__dill_imported_top_level,\n              file=sys.stderr)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "test_refimported_imported_as",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def test_refimported_imported_as():\n    import collections\n    import concurrent.futures\n    import types\n    import typing\n    mod = sys.modules['__test__'] = types.ModuleType('__test__')\n    dill.executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)\n    mod.Dict = collections.UserDict             # select by type\n    mod.AsyncCM = typing.AsyncContextManager    # select by __module__\n    mod.thread_exec = dill.executor             # select by __module__ with regex",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "test_load_module_asdict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "def test_load_module_asdict():\n    with TestNamespace():\n        session_buffer = BytesIO()\n        dill.dump_module(session_buffer)\n        global empty, names, x, y\n        x = y = 0  # change x and create y\n        del empty\n        globals_state = globals().copy()\n        session_buffer.seek(0)\n        main_vars = dill.load_module_asdict(session_buffer)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "session_file",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "session_file = os.path.join(os.path.dirname(__file__), 'session-refimported-%s.pkl')\n###################\n#  Child process  #\n###################\ndef _error_line(error, obj, refimported):\n    import traceback\n    line = traceback.format_exc().splitlines()[-2].replace('[obj]', '['+repr(obj)+']')\n    return \"while testing (with refimported=%s):  %s\" % (refimported, line.lstrip())\nif __name__ == '__main__' and len(sys.argv) >= 3 and sys.argv[1] == '--child':\n    # Test session loading in a fresh interpreter session.",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "x = 17\nempty = None\nnames = ['Alice', 'Bob', 'Carol']\ndef squared(x): return x**2\ncubed = lambda x: x**3\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "empty",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "empty = None\nnames = ['Alice', 'Bob', 'Carol']\ndef squared(x): return x**2\ncubed = lambda x: x**3\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)\nclass CalendarSubclass(Calendar):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "names = ['Alice', 'Bob', 'Carol']\ndef squared(x): return x**2\ncubed = lambda x: x**3\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)\nclass CalendarSubclass(Calendar):\n    def weekdays(self):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "cubed",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "cubed = lambda x: x**3\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\nperson = Person(names[0], x)\nclass CalendarSubclass(Calendar):\n    def weekdays(self):\n        return [day_name[i] for i in self.iterweekdays()]\ncal = CalendarSubclass()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "person",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "person = Person(names[0], x)\nclass CalendarSubclass(Calendar):\n    def weekdays(self):\n        return [day_name[i] for i in self.iterweekdays()]\ncal = CalendarSubclass()\nselfref = __main__\n# Setup global namespace for session saving tests.\nclass TestNamespace:\n    test_globals = globals().copy()\n    def __init__(self, **extra):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "cal",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "cal = CalendarSubclass()\nselfref = __main__\n# Setup global namespace for session saving tests.\nclass TestNamespace:\n    test_globals = globals().copy()\n    def __init__(self, **extra):\n        self.extra = extra\n    def __enter__(self):\n        self.backup = globals().copy()\n        globals().clear()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "selfref",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_session",
        "description": "__pypackages__.3.10.lib.dill.tests.test_session",
        "peekOfCode": "selfref = __main__\n# Setup global namespace for session saving tests.\nclass TestNamespace:\n    test_globals = globals().copy()\n    def __init__(self, **extra):\n        self.extra = extra\n    def __enter__(self):\n        self.backup = globals().copy()\n        globals().clear()\n        globals().update(self.test_globals)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_session",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "class Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "Bar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "class Bar:\n  pass\n_bar = Bar()\n                       # inspect.getsourcelines # dill.source.getblocks\ndef test_getsource():\n  assert getsource(f) == 'f = lambda x: x**2\\n'\n  assert getsource(g) == 'def g(x): return f(x) - x\\n'\n  assert getsource(h) == 'def h(x):\\n  def g(x): return x\\n  return g(x) - x\\n'\n  assert getname(f) == 'f'\n  assert getname(g) == 'g'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x\nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def h(x):\n  def g(x): return x\n  return g(x) - x\nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n                       # inspect.getsourcelines # dill.source.getblocks\ndef test_getsource():\n  assert getsource(f) == 'f = lambda x: x**2\\n'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_getsource",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_getsource():\n  assert getsource(f) == 'f = lambda x: x**2\\n'\n  assert getsource(g) == 'def g(x): return f(x) - x\\n'\n  assert getsource(h) == 'def h(x):\\n  def g(x): return x\\n  return g(x) - x\\n'\n  assert getname(f) == 'f'\n  assert getname(g) == 'g'\n  assert getname(h) == 'h'\n  assert _wrap(f)(4) == 16\n  assert _wrap(g)(4) == 12\n  assert _wrap(h)(4) == 0",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_itself",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_itself():\n  assert likely_import(likely_import)=='from dill.source import likely_import\\n'\n# builtin functions and objects\ndef test_builtin():\n  assert likely_import(pow) == 'pow\\n'\n  assert likely_import(100) == '100\\n'\n  assert likely_import(True) == 'True\\n'\n  assert likely_import(pow, explicit=True) == 'from builtins import pow\\n'\n  assert likely_import(100, explicit=True) == '100\\n'\n  assert likely_import(True, explicit=True) == 'True\\n'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_builtin",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_builtin():\n  assert likely_import(pow) == 'pow\\n'\n  assert likely_import(100) == '100\\n'\n  assert likely_import(True) == 'True\\n'\n  assert likely_import(pow, explicit=True) == 'from builtins import pow\\n'\n  assert likely_import(100, explicit=True) == '100\\n'\n  assert likely_import(True, explicit=True) == 'True\\n'\n  # this is kinda BS... you can't import a None\n  assert likely_import(None) == 'None\\n'\n  assert likely_import(None, explicit=True) == 'None\\n'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_imported",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_imported():\n  from math import sin\n  assert likely_import(sin) == 'from math import sin\\n'\n# interactively defined functions\ndef test_dynamic():\n  assert likely_import(add) == 'from %s import add\\n' % __name__\n  # interactive lambdas\n  assert likely_import(squared) == 'from %s import squared\\n' % __name__\n# classes and class instances\ndef test_classes():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_dynamic",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_dynamic():\n  assert likely_import(add) == 'from %s import add\\n' % __name__\n  # interactive lambdas\n  assert likely_import(squared) == 'from %s import squared\\n' % __name__\n# classes and class instances\ndef test_classes():\n  from io import BytesIO as StringIO\n  y = \"from _io import BytesIO\\n\"\n  x = y if (IS_PYPY or sys.hexversion >= PY310b) else \"from io import BytesIO\\n\"\n  s = StringIO()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_classes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_classes():\n  from io import BytesIO as StringIO\n  y = \"from _io import BytesIO\\n\"\n  x = y if (IS_PYPY or sys.hexversion >= PY310b) else \"from io import BytesIO\\n\"\n  s = StringIO()\n  assert likely_import(StringIO) == x\n  assert likely_import(s) == y\n  # interactively defined classes and class instances\n  assert likely_import(Foo) == 'from %s import Foo\\n' % __name__\n  assert likely_import(_foo) == 'from %s import Foo\\n' % __name__",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_importable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_importable():\n  assert getimportable(add) == 'from %s import add\\n' % __name__\n  assert getimportable(squared) == 'from %s import squared\\n' % __name__\n  assert getimportable(Foo) == 'from %s import Foo\\n' % __name__\n  assert getimportable(Foo.bar) == 'from %s import bar\\n' % __name__\n  assert getimportable(_foo.bar) == 'from %s import bar\\n' % __name__\n  assert getimportable(None) == 'None\\n'\n  assert getimportable(100) == '100\\n'\n  assert getimportable(add, byname=False) == 'def add(x,y):\\n  return x+y\\n'\n  assert getimportable(squared, byname=False) == 'squared = lambda x:x**2\\n'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_numpy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_numpy():\n  try:\n    from numpy import array\n    x = array([1,2,3])\n    assert getimportable(x) == 'from numpy import array\\narray([1, 2, 3])\\n'\n    assert getimportable(array) == 'from %s import array\\n' % array.__module__\n    assert getimportable(x, byname=False) == 'from numpy import array\\narray([1, 2, 3])\\n'\n    assert getimportable(array, byname=False) == 'from %s import array\\n' % array.__module__\n  except ImportError: pass\n#NOTE: if before likely_import(pow), will cause pow to throw AssertionError",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "test_foo",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "def test_foo():\n  assert getimportable(_foo, byname=False).startswith(\"import dill\\nclass Foo(object):\\n  def bar(self, x):\\n    return x*x+x\\ndill.loads(\")\nif __name__ == '__main__':\n    test_getsource()\n    test_itself()\n    test_builtin()\n    test_imported()\n    test_dynamic()\n    test_classes()\n    test_importable()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "PY310b",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "PY310b = 0x30a00b1\nf = lambda x: x**2\ndef g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x\nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "f = lambda x: x**2\ndef g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x\nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "_foo",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n                       # inspect.getsourcelines # dill.source.getblocks\ndef test_getsource():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "squared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n                       # inspect.getsourcelines # dill.source.getblocks\ndef test_getsource():\n  assert getsource(f) == 'f = lambda x: x**2\\n'\n  assert getsource(g) == 'def g(x): return f(x) - x\\n'\n  assert getsource(h) == 'def h(x):\\n  def g(x): return x\\n  return g(x) - x\\n'\n  assert getname(f) == 'f'",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "_bar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_source",
        "description": "__pypackages__.3.10.lib.dill.tests.test_source",
        "peekOfCode": "_bar = Bar()\n                       # inspect.getsourcelines # dill.source.getblocks\ndef test_getsource():\n  assert getsource(f) == 'f = lambda x: x**2\\n'\n  assert getsource(g) == 'def g(x): return f(x) - x\\n'\n  assert getsource(h) == 'def h(x):\\n  def g(x): return x\\n  return g(x) - x\\n'\n  assert getname(f) == 'f'\n  assert getname(g) == 'g'\n  assert getname(h) == 'h'\n  assert _wrap(f)(4) == 16",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_source",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "class Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "Bar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "class Bar:\n  pass\n_bar = Bar()\n# test function-type objects that take 2 args\ndef test_two_arg_functions():\n  for obj in [add]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj(4,2) == obj(4,2)\n# test function-type objects that take 1 arg",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_code_to_tempfile",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_code_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        pyfile = dump_source(f, alias='_f')\n        _f = load_source(pyfile)\n        assert _f(4) == f(4)\n# source code to stream\ndef test_code_to_stream():\n    pyfile = dumpIO_source(f, alias='_f')\n    _f = loadIO_source(pyfile)\n    assert _f(4) == f(4)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_code_to_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_code_to_stream():\n    pyfile = dumpIO_source(f, alias='_f')\n    _f = loadIO_source(pyfile)\n    assert _f(4) == f(4)\n# pickle to tempfile\ndef test_pickle_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        dumpfile = dump(x)\n        _x = load(dumpfile)\n        assert _x == x",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_pickle_to_tempfile",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_pickle_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        dumpfile = dump(x)\n        _x = load(dumpfile)\n        assert _x == x\n# pickle to stream\ndef test_pickle_to_stream():\n    dumpfile = dumpIO(x)\n    _x = loadIO(dumpfile)\n    assert _x == x",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_pickle_to_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_pickle_to_stream():\n    dumpfile = dumpIO(x)\n    _x = loadIO(dumpfile)\n    assert _x == x\n### now testing the objects ###\nf = lambda x: x**2\ndef g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x ",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x \nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def h(x):\n  def g(x): return x\n  return g(x) - x \nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n# test function-type objects that take 2 args\ndef test_two_arg_functions():\n  for obj in [add]:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_two_arg_functions",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_two_arg_functions():\n  for obj in [add]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj(4,2) == obj(4,2)\n# test function-type objects that take 1 arg\ndef test_one_arg_functions():\n  for obj in [g, h, squared]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_one_arg_functions",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_one_arg_functions():\n  for obj in [g, h, squared]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj(4) == obj(4)\n# test instance-type objects\n#for obj in [_bar, _foo]:\n#  pyfile = dumpIO_source(obj, alias='_obj')\n#  _obj = loadIO_source(pyfile)\n#  assert type(_obj) == type(obj)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "test_the_rest",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "def test_the_rest():\n  for obj in [Bar, Foo, Foo.bar, _foo.bar]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj.__name__ == obj.__name__\nif __name__ == '__main__':\n    test_code_to_tempfile()\n    test_code_to_stream()\n    test_pickle_to_tempfile()\n    test_pickle_to_stream()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "WINDOWS = sys.platform[:3] == 'win'\nf = lambda x: x**2\nx = [1,2,3,4,5]\n# source code to tempfile\ndef test_code_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        pyfile = dump_source(f, alias='_f')\n        _f = load_source(pyfile)\n        assert _f(4) == f(4)\n# source code to stream",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "f = lambda x: x**2\nx = [1,2,3,4,5]\n# source code to tempfile\ndef test_code_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        pyfile = dump_source(f, alias='_f')\n        _f = load_source(pyfile)\n        assert _f(4) == f(4)\n# source code to stream\ndef test_code_to_stream():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "x = [1,2,3,4,5]\n# source code to tempfile\ndef test_code_to_tempfile():\n    if not WINDOWS:  #see: https://bugs.python.org/issue14243\n        pyfile = dump_source(f, alias='_f')\n        _f = load_source(pyfile)\n        assert _f(4) == f(4)\n# source code to stream\ndef test_code_to_stream():\n    pyfile = dumpIO_source(f, alias='_f')",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "f = lambda x: x**2\ndef g(x): return f(x) - x\ndef h(x):\n  def g(x): return x\n  return g(x) - x \nclass Foo(object):\n  def bar(self, x):\n    return x*x+x\n_foo = Foo()\ndef add(x,y):",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "_foo",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "_foo = Foo()\ndef add(x,y):\n  return x+y\n# yes, same as 'f', but things are tricky when it comes to pointers\nsquared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n# test function-type objects that take 2 args\ndef test_two_arg_functions():",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "squared = lambda x:x**2\nclass Bar:\n  pass\n_bar = Bar()\n# test function-type objects that take 2 args\ndef test_two_arg_functions():\n  for obj in [add]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj(4,2) == obj(4,2)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "_bar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "description": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "peekOfCode": "_bar = Bar()\n# test function-type objects that take 2 args\ndef test_two_arg_functions():\n  for obj in [add]:\n    pyfile = dumpIO_source(obj, alias='_obj')\n    _obj = loadIO_source(pyfile)\n    assert _obj(4,2) == obj(4,2)\n# test function-type objects that take 1 arg\ndef test_one_arg_functions():\n  for obj in [g, h, squared]:",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_temp",
        "documentation": {}
    },
    {
        "label": "_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "description": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "peekOfCode": "class _class:\n    def _method(self):\n        pass\nclass _callable_class:\n    def __call__(self):\n        pass\ndef _function():\n    pass\ndef test_weakref():\n    o = _class()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "documentation": {}
    },
    {
        "label": "_callable_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "description": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "peekOfCode": "class _callable_class:\n    def __call__(self):\n        pass\ndef _function():\n    pass\ndef test_weakref():\n    o = _class()\n    oc = _callable_class()\n    f = _function\n    x = _class",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "documentation": {}
    },
    {
        "label": "test_weakref",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "description": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "peekOfCode": "def test_weakref():\n    o = _class()\n    oc = _callable_class()\n    f = _function\n    x = _class\n    # ReferenceType\n    r = weakref.ref(o)\n    d_r = weakref.ref(_class())\n    fr = weakref.ref(f)\n    xr = weakref.ref(x)",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "documentation": {}
    },
    {
        "label": "test_dictproxy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "description": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "peekOfCode": "def test_dictproxy():\n    from dill._dill import DictProxyType\n    try:\n        m = DictProxyType({\"foo\": \"bar\"})\n    except Exception:\n        m = type.__dict__\n    mp = dill.copy(m)   \n    assert mp.items() == m.items()\nif __name__ == '__main__':\n    test_weakref()",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "documentation": {}
    },
    {
        "label": "dill.settings['recurse']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "description": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "peekOfCode": "dill.settings['recurse'] = True\nimport weakref\nclass _class:\n    def _method(self):\n        pass\nclass _callable_class:\n    def __call__(self):\n        pass\ndef _function():\n    pass",
        "detail": "__pypackages__.3.10.lib.dill.tests.test_weakref",
        "documentation": {}
    },
    {
        "label": "get_attrs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def get_attrs(obj):\n    \"\"\"\n    Gets all the attributes of an object though its __dict__ or return None\n    \"\"\"\n    if type(obj) in builtins_types \\\n       or type(obj) is type and obj in builtins_types:\n        return\n    return getattr(obj, '__dict__', None)\ndef get_seq(obj, cache={str: False, frozenset: False, list: True, set: True,\n                        dict: True, tuple: True, type: False,",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "get_seq",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def get_seq(obj, cache={str: False, frozenset: False, list: True, set: True,\n                        dict: True, tuple: True, type: False,\n                        types.ModuleType: False, types.FunctionType: False,\n                        types.BuiltinFunctionType: False}):\n    \"\"\"\n    Gets all the items in a sequence or return None\n    \"\"\"\n    try:\n        o_type = obj.__class__\n    except AttributeError:",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "memorise",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def memorise(obj, force=False):\n    \"\"\"\n    Adds an object to the memo, and recursively adds all the objects\n    attributes, and if it is a container, its items. Use force=True to update\n    an object already in the memo. Updating is not recursively done.\n    \"\"\"\n    obj_id = id(obj)\n    if obj_id in memo and not force or obj_id in dont_memo:\n        return\n    id_ = id",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "release_gone",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def release_gone():\n    itop, mp, src = id_to_obj.pop, memo.pop, getrefcount\n    [(itop(id_), mp(id_)) for id_, obj in list(id_to_obj.items())\n     if src(obj) < 4] #XXX: correct for pypy?\ndef whats_changed(obj, seen=None, simple=False, first=True):\n    \"\"\"\n    Check an object against the memo. Returns a list in the form\n    (attribute changes, container changed). Attribute changes is a dict of\n    attribute name to attribute value. container changed is a boolean.\n    If simple is true, just returns a boolean. None for either item means",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "whats_changed",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def whats_changed(obj, seen=None, simple=False, first=True):\n    \"\"\"\n    Check an object against the memo. Returns a list in the form\n    (attribute changes, container changed). Attribute changes is a dict of\n    attribute name to attribute value. container changed is a boolean.\n    If simple is true, just returns a boolean. None for either item means\n    that it has not been checked yet\n    \"\"\"\n    # Special cases\n    if first:",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "has_changed",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "def has_changed(*args, **kwds):\n    kwds['simple'] = True  # ignore simple if passed in\n    return whats_changed(*args, **kwds)\n__import__ = __import__\ndef _imp(*args, **kwds):\n    \"\"\"\n    Replaces the default __import__, to allow a module to be memorised\n    before the user can change it\n    \"\"\"\n    before = set(sys.modules.keys())",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "getrefcount",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "getrefcount = getattr(sys, 'getrefcount', lambda x:0)\n# memo of objects indexed by id to a tuple (attributes, sequence items)\n# attributes is a dict indexed by attribute name to attribute id\n# sequence items is either a list of ids, of a dictionary of keys to ids\nmemo = {}\nid_to_obj = {}\n# types that cannot have changing attributes\nbuiltins_types = set((str, list, dict, set, frozenset, int))\ndont_memo = set(id(i) for i in (memo, sys.modules, sys.path_importer_cache,\n             os.environ, id_to_obj))",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "memo",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "memo = {}\nid_to_obj = {}\n# types that cannot have changing attributes\nbuiltins_types = set((str, list, dict, set, frozenset, int))\ndont_memo = set(id(i) for i in (memo, sys.modules, sys.path_importer_cache,\n             os.environ, id_to_obj))\ndef get_attrs(obj):\n    \"\"\"\n    Gets all the attributes of an object though its __dict__ or return None\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "id_to_obj",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "id_to_obj = {}\n# types that cannot have changing attributes\nbuiltins_types = set((str, list, dict, set, frozenset, int))\ndont_memo = set(id(i) for i in (memo, sys.modules, sys.path_importer_cache,\n             os.environ, id_to_obj))\ndef get_attrs(obj):\n    \"\"\"\n    Gets all the attributes of an object though its __dict__ or return None\n    \"\"\"\n    if type(obj) in builtins_types \\",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "builtins_types",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "builtins_types = set((str, list, dict, set, frozenset, int))\ndont_memo = set(id(i) for i in (memo, sys.modules, sys.path_importer_cache,\n             os.environ, id_to_obj))\ndef get_attrs(obj):\n    \"\"\"\n    Gets all the attributes of an object though its __dict__ or return None\n    \"\"\"\n    if type(obj) in builtins_types \\\n       or type(obj) is type and obj in builtins_types:\n        return",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "dont_memo",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "dont_memo = set(id(i) for i in (memo, sys.modules, sys.path_importer_cache,\n             os.environ, id_to_obj))\ndef get_attrs(obj):\n    \"\"\"\n    Gets all the attributes of an object though its __dict__ or return None\n    \"\"\"\n    if type(obj) in builtins_types \\\n       or type(obj) is type and obj in builtins_types:\n        return\n    return getattr(obj, '__dict__', None)",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "__import__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "__import__ = __import__\ndef _imp(*args, **kwds):\n    \"\"\"\n    Replaces the default __import__, to allow a module to be memorised\n    before the user can change it\n    \"\"\"\n    before = set(sys.modules.keys())\n    mod = __import__(*args, **kwds)\n    after = set(sys.modules.keys()).difference(before)\n    for m in after:",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "builtins.__import__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.__diff",
        "description": "__pypackages__.3.10.lib.dill.__diff",
        "peekOfCode": "builtins.__import__ = _imp\nif hasattr(builtins, \"_\"):\n    del builtins._\n# memorise all already imported modules. This implies that this must be\n# imported first for any changes to be recorded\nfor mod in list(sys.modules.values()):\n    memorise(mod)\nrelease_gone()",
        "detail": "__pypackages__.3.10.lib.dill.__diff",
        "documentation": {}
    },
    {
        "label": "Sentinel",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class Sentinel(object):\n    \"\"\"\n    Create a unique sentinel object that is pickled as a constant.\n    \"\"\"\n    def __init__(self, name, module_name=None):\n        self.name = name\n        if module_name is None:\n            # Use the calling frame's module\n            self.__module__ = inspect.currentframe().f_back.f_globals['__name__']\n        else:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "MetaCatchingDict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class MetaCatchingDict(dict):\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n    def __missing__(self, key):\n        if issubclass(key, type):\n            return save_type\n        else:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "PickleWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class PickleWarning(Warning, PickleError):\n    pass\nclass PicklingWarning(PickleWarning, PicklingError):\n    pass\nclass UnpicklingWarning(PickleWarning, UnpicklingError):\n    pass\n### Extend the Picklers\nclass Pickler(StockPickler):\n    \"\"\"python's Pickler extended to interpreter sessions\"\"\"\n    dispatch = MetaCatchingDict(StockPickler.dispatch.copy())",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "PicklingWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class PicklingWarning(PickleWarning, PicklingError):\n    pass\nclass UnpicklingWarning(PickleWarning, UnpicklingError):\n    pass\n### Extend the Picklers\nclass Pickler(StockPickler):\n    \"\"\"python's Pickler extended to interpreter sessions\"\"\"\n    dispatch = MetaCatchingDict(StockPickler.dispatch.copy())\n    _session = False\n    from .settings import settings",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "UnpicklingWarning",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class UnpicklingWarning(PickleWarning, UnpicklingError):\n    pass\n### Extend the Picklers\nclass Pickler(StockPickler):\n    \"\"\"python's Pickler extended to interpreter sessions\"\"\"\n    dispatch = MetaCatchingDict(StockPickler.dispatch.copy())\n    _session = False\n    from .settings import settings\n    def __init__(self, file, *args, **kwds):\n        settings = Pickler.settings",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "Pickler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class Pickler(StockPickler):\n    \"\"\"python's Pickler extended to interpreter sessions\"\"\"\n    dispatch = MetaCatchingDict(StockPickler.dispatch.copy())\n    _session = False\n    from .settings import settings\n    def __init__(self, file, *args, **kwds):\n        settings = Pickler.settings\n        _byref = kwds.pop('byref', None)\n       #_strictio = kwds.pop('strictio', None)\n        _fmode = kwds.pop('fmode', None)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "Unpickler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class Unpickler(StockUnpickler):\n    \"\"\"python's Unpickler extended to interpreter sessions and more types\"\"\"\n    from .settings import settings\n    _session = False\n    def find_class(self, module, name):\n        if (module, name) == ('__builtin__', '__main__'):\n            return self._main.__dict__ #XXX: above set w/save_module_dict\n        elif (module, name) == ('__builtin__', 'NoneType'):\n            return type(None) #XXX: special case: NoneType missing\n        if module == 'dill.dill': module = 'dill._dill'",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class match:\n    \"\"\"\n    Make avaialable a limited structural pattern matching-like syntax for Python < 3.10\n    Patterns can be only tuples (without types) currently.\n    Inspired by the package pattern-matching-PEP634.\n    Usage:\n    >>> with match(args) as m:\n    >>>     if   m.case(('x', 'y')):\n    >>>         # use m.x and m.y\n    >>>     elif m.case(('x', 'y', 'z')):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_itemgetter_helper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class _itemgetter_helper(object):\n    def __init__(self):\n        self.items = []\n    def __getitem__(self, item):\n        self.items.append(item)\n        return\nclass _attrgetter_helper(object):\n    def __init__(self, attrs, index=None):\n        self.attrs = attrs\n        self.index = index",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_attrgetter_helper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class _attrgetter_helper(object):\n    def __init__(self, attrs, index=None):\n        self.attrs = attrs\n        self.index = index\n    def __getattribute__(self, attr):\n        attrs = object.__getattribute__(self, \"attrs\")\n        index = object.__getattribute__(self, \"index\")\n        if index is None:\n            index = len(attrs)\n            attrs.append(attr)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_dictproxy_helper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "class _dictproxy_helper(dict):\n   def __ror__(self, a):\n        return a\n_dictproxy_helper_instance = _dictproxy_helper()\n__d = {}\ntry:\n    # In CPython 3.9 and later, this trick can be used to exploit the\n    # implementation of the __or__ function of MappingProxyType to get the true\n    # mapping referenced by the proxy. It may work for other implementations,\n    # but is not guaranteed.",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "get_file_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def get_file_type(*args, **kwargs):\n    open = kwargs.pop(\"open\", __builtin__.open)\n    f = open(os.devnull, *args, **kwargs)\n    t = type(f)\n    f.close()\n    return t\nFileType = get_file_type('rb', buffering=0)\nTextWrapperType = get_file_type('r', buffering=-1)\nBufferedRandomType = get_file_type('r+b', buffering=-1)\nBufferedReaderType = get_file_type('rb', buffering=-1)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def copy(obj, *args, **kwds):\n    \"\"\"\n    Use pickling to 'copy' an object (i.e. `loads(dumps(obj))`).\n    See :func:`dumps` and :func:`loads` for keyword arguments.\n    \"\"\"\n    ignore = kwds.pop('ignore', Unpickler.settings['ignore'])\n    return loads(dumps(obj, *args, **kwds), ignore=ignore)\ndef dump(obj, file, protocol=None, byref=None, fmode=None, recurse=None, **kwds):#, strictio=None):\n    \"\"\"\n    Pickle an object to a file.",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def dump(obj, file, protocol=None, byref=None, fmode=None, recurse=None, **kwds):#, strictio=None):\n    \"\"\"\n    Pickle an object to a file.\n    See :func:`dumps` for keyword arguments.\n    \"\"\"\n    from .settings import settings\n    protocol = settings['protocol'] if protocol is None else int(protocol)\n    _kwds = kwds.copy()\n    _kwds.update(dict(byref=byref, fmode=fmode, recurse=recurse))\n    Pickler(file, protocol, **_kwds).dump(obj)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "dumps",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def dumps(obj, protocol=None, byref=None, fmode=None, recurse=None, **kwds):#, strictio=None):\n    \"\"\"\n    Pickle an object to a string.\n    *protocol* is the pickler protocol, as defined for Python *pickle*.\n    If *byref=True*, then dill behaves a lot more like pickle as certain\n    objects (like modules) are pickled by reference as opposed to attempting\n    to pickle the object itself.\n    If *recurse=True*, then objects referred to in the global dictionary\n    are recursively traced and pickled, instead of the default behavior\n    of attempting to store the entire global dictionary. This is needed for",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def load(file, ignore=None, **kwds):\n    \"\"\"\n    Unpickle an object from a file.\n    See :func:`loads` for keyword arguments.\n    \"\"\"\n    return Unpickler(file, ignore=ignore, **kwds).load()\ndef loads(str, ignore=None, **kwds):\n    \"\"\"\n    Unpickle an object from a string.\n    If *ignore=False* then objects whose class is defined in the module",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "loads",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def loads(str, ignore=None, **kwds):\n    \"\"\"\n    Unpickle an object from a string.\n    If *ignore=False* then objects whose class is defined in the module\n    *__main__* are updated to reference the existing class in *__main__*,\n    otherwise they are left to refer to the reconstructed type, which may\n    be different.\n    Default values for keyword arguments can be set in :mod:`dill.settings`.\n    \"\"\"\n    file = StringIO(str)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "dispatch_table",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def dispatch_table():\n    \"\"\"get the dispatch table of registered types\"\"\"\n    return Pickler.dispatch\n'''\npickle_dispatch_copy = StockPickler.dispatch.copy()\ndef pickle(t, func):\n    \"\"\"expose dispatch table for user-created extensions\"\"\"\n    Pickler.dispatch[t] = func\n    return\ndef register(t):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def pickle(t, func):\n    \"\"\"expose dispatch table for user-created extensions\"\"\"\n    Pickler.dispatch[t] = func\n    return\ndef register(t):\n    \"\"\"register type to Pickler's dispatch table \"\"\"\n    def proxy(func):\n        Pickler.dispatch[t] = func\n        return func\n    return proxy",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def register(t):\n    \"\"\"register type to Pickler's dispatch table \"\"\"\n    def proxy(func):\n        Pickler.dispatch[t] = func\n        return func\n    return proxy\ndef _revert_extension():\n    \"\"\"drop dill-registered types from pickle's dispatch table\"\"\"\n    for type, func in list(StockPickler.dispatch.items()):\n        if func.__module__ == __name__:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "use_diff",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def use_diff(on=True):\n    \"\"\"\n    Reduces size of pickles by only including object which have changed.\n    Decreases pickle size but increases CPU time needed.\n    Also helps avoid some unpicklable objects.\n    MUST be called at start of script, otherwise changes will not be recorded.\n    \"\"\"\n    global _use_diff, diff\n    _use_diff = on\n    if _use_diff and diff is None:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_code",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_code(pickler, obj):\n    logger.trace(pickler, \"Co: %s\", obj)\n    if hasattr(obj, \"co_endlinetable\"): # python 3.11a (20 args)\n        args = (\n            obj.co_lnotab, # for < python 3.10 [not counted in args]\n            obj.co_argcount, obj.co_posonlyargcount,\n            obj.co_kwonlyargcount, obj.co_nlocals, obj.co_stacksize,\n            obj.co_flags, obj.co_code, obj.co_consts, obj.co_names,\n            obj.co_varnames, obj.co_filename, obj.co_name, obj.co_qualname,\n            obj.co_firstlineno, obj.co_linetable, obj.co_endlinetable,",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_module_dict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_module_dict(pickler, obj):\n    if is_dill(pickler, child=False) and obj == pickler._main.__dict__ and \\\n            not (pickler._session and pickler._first_pass):\n        logger.trace(pickler, \"D1: %s\", _repr_dict(obj)) # obj\n        pickler.write(bytes('c__builtin__\\n__main__\\n', 'UTF-8'))\n        logger.trace(pickler, \"# D1\")\n    elif (not is_dill(pickler, child=False)) and (obj == _main_module.__dict__):\n        logger.trace(pickler, \"D3: %s\", _repr_dict(obj)) # obj\n        pickler.write(bytes('c__main__\\n__dict__\\n', 'UTF-8'))  #XXX: works in general?\n        logger.trace(pickler, \"# D3\")",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_classobj",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_classobj(pickler, obj): #FIXME: enable pickler._byref\n    if not _locate_function(obj, pickler):\n        logger.trace(pickler, \"C1: %s\", obj)\n        pickler.save_reduce(ClassType, (obj.__name__, obj.__bases__,\n                                        obj.__dict__), obj=obj)\n                                       #XXX: or obj.__dict__.copy()), obj=obj) ?\n        logger.trace(pickler, \"# C1\")\n    else:\n        logger.trace(pickler, \"C2: %s\", obj)\n        name = getattr(obj, '__qualname__', getattr(obj, '__name__', None))",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_generic_alias",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_generic_alias(pickler, obj):\n    args = obj.__args__\n    if type(obj.__reduce__()) is str:\n        logger.trace(pickler, \"Ga0: %s\", obj)\n        StockPickler.save_global(pickler, obj, name=obj.__reduce__())\n        logger.trace(pickler, \"# Ga0\")\n    elif obj.__origin__ is tuple and (not args or args == ((),)):\n        logger.trace(pickler, \"Ga1: %s\", obj)\n        pickler.save_reduce(_create_typing_tuple, (args,), obj=obj)\n        logger.trace(pickler, \"# Ga1\")",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_lock",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_lock(pickler, obj):\n    logger.trace(pickler, \"Lo: %s\", obj)\n    pickler.save_reduce(_create_lock, (obj.locked(),), obj=obj)\n    logger.trace(pickler, \"# Lo\")\n    return\n@register(RLockType)\ndef save_rlock(pickler, obj):\n    logger.trace(pickler, \"RL: %s\", obj)\n    r = obj.__repr__() # don't use _release_save as it unlocks the lock\n    count = int(r.split('count=')[1].split()[0].rstrip('>'))",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_rlock",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_rlock(pickler, obj):\n    logger.trace(pickler, \"RL: %s\", obj)\n    r = obj.__repr__() # don't use _release_save as it unlocks the lock\n    count = int(r.split('count=')[1].split()[0].rstrip('>'))\n    owner = int(r.split('owner=')[1].split()[0])\n    pickler.save_reduce(_create_rlock, (count,owner,), obj=obj)\n    logger.trace(pickler, \"# RL\")\n    return\n#@register(SocketType) #FIXME: causes multiprocess test_pickling FAIL\ndef save_socket(pickler, obj):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_socket",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_socket(pickler, obj):\n    logger.trace(pickler, \"So: %s\", obj)\n    pickler.save_reduce(*reduce_socket(obj))\n    logger.trace(pickler, \"# So\")\n    return\ndef _save_file(pickler, obj, open_):\n    if obj.closed:\n        position = 0\n    else:\n        obj.flush()",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_file(pickler, obj):\n    logger.trace(pickler, \"Fi: %s\", obj)\n    f = _save_file(pickler, obj, open)\n    logger.trace(pickler, \"# Fi\")\n    return f\nif PyTextWrapperType:\n    @register(PyBufferedRandomType)\n    @register(PyBufferedReaderType)\n    @register(PyBufferedWriterType)\n    @register(PyTextWrapperType)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_super",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_super(pickler, obj):\n    logger.trace(pickler, \"Su: %s\", obj)\n    pickler.save_reduce(super, (obj.__thisclass__, obj.__self__), obj=obj)\n    logger.trace(pickler, \"# Su\")\n    return\nif IS_PYPY:\n    @register(MethodType)\n    def save_instancemethod0(pickler, obj):\n        code = getattr(obj.__func__, '__code__', None)\n        if code is not None and type(code) is not CodeType \\",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_cell",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_cell(pickler, obj):\n    try:\n        f = obj.cell_contents\n    except ValueError: # cell is empty\n        logger.trace(pickler, \"Ce3: %s\", obj)\n        # _shims._CELL_EMPTY is defined in _shims.py to support PyPy 2.7.\n        # It unpickles to a sentinel object _dill._CELL_EMPTY, also created in\n        # _shims.py. This object is not present in Python 3 because the cell's\n        # contents can be deleted in newer versions of Python. The reduce object\n        # will instead unpickle to None if unpickled in Python 3.",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_slice",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_slice(pickler, obj):\n    logger.trace(pickler, \"Sl: %s\", obj)\n    pickler.save_reduce(slice, (obj.start, obj.stop, obj.step), obj=obj)\n    logger.trace(pickler, \"# Sl\")\n    return\n@register(XRangeType)\n@register(EllipsisType)\n@register(NotImplementedType)\ndef save_singleton(pickler, obj):\n    logger.trace(pickler, \"Si: %s\", obj)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_singleton",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_singleton(pickler, obj):\n    logger.trace(pickler, \"Si: %s\", obj)\n    pickler.save_reduce(_eval_repr, (obj.__repr__(),), obj=obj)\n    logger.trace(pickler, \"# Si\")\n    return\ndef _proxy_helper(obj): # a dead proxy returns a reference to None\n    \"\"\"get memory address of proxy's reference object\"\"\"\n    _repr = repr(obj)\n    try: _str = str(obj)\n    except ReferenceError: # it's a dead proxy",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_weakref",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_weakref(pickler, obj):\n    refobj = obj()\n    logger.trace(pickler, \"R1: %s\", obj)\n   #refobj = ctypes.pythonapi.PyWeakref_GetObject(obj) # dead returns \"None\"\n    pickler.save_reduce(_create_weakref, (refobj,), obj=obj)\n    logger.trace(pickler, \"# R1\")\n    return\n@register(ProxyType)\n@register(CallableProxyType)\ndef save_weakproxy(pickler, obj):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_weakproxy",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_weakproxy(pickler, obj):\n    # Must do string substitution here and use %r to avoid ReferenceError.\n    logger.trace(pickler, \"R2: %r\" % obj)\n    refobj = _locate_object(_proxy_helper(obj))\n    pickler.save_reduce(_create_weakproxy, (refobj, callable(obj)), obj=obj)\n    logger.trace(pickler, \"# R2\")\n    return\ndef _is_builtin_module(module):\n    if not hasattr(module, \"__file__\"): return True\n    # If a module file name starts with prefix, it should be a builtin",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_module(pickler, obj):\n    if False: #_use_diff:\n        if obj.__name__.split('.', 1)[0] != \"dill\":\n            try:\n                changed = diff.whats_changed(obj, seen=pickler._diff_cache)[0]\n            except RuntimeError:  # not memorised module, probably part of dill\n                pass\n            else:\n                logger.trace(pickler, \"M2: %s with diff\", obj)\n                logger.trace(pickler, \"Diff: %s\", changed.keys())",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_type(pickler, obj, postproc_list=None):\n    if obj in _typemap:\n        logger.trace(pickler, \"T1: %s\", obj)\n        # if obj in _incedental_types:\n        #     warnings.warn('Type %r may only exist on this implementation of Python and cannot be unpickled in other implementations.' % (obj,), PicklingWarning)\n        pickler.save_reduce(_load_type, (_typemap[obj],), obj=obj)\n        logger.trace(pickler, \"# T1\")\n    elif obj.__bases__ == (tuple,) and all([hasattr(obj, attr) for attr in ('_fields','_asdict','_make','_replace')]):\n        # special case: namedtuples\n        logger.trace(pickler, \"T6: %s\", obj)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_property(pickler, obj):\n    logger.trace(pickler, \"Pr: %s\", obj)\n    pickler.save_reduce(property, (obj.fget, obj.fset, obj.fdel, obj.__doc__),\n                        obj=obj)\n    logger.trace(pickler, \"# Pr\")\n@register(staticmethod)\n@register(classmethod)\ndef save_classmethod(pickler, obj):\n    logger.trace(pickler, \"Cm: %s\", obj)\n    orig_func = obj.__func__",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_classmethod",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_classmethod(pickler, obj):\n    logger.trace(pickler, \"Cm: %s\", obj)\n    orig_func = obj.__func__\n    # if type(obj.__dict__) is dict:\n    #     if obj.__dict__:\n    #         state = obj.__dict__\n    #     else:\n    #         state = None\n    # else:\n    #     state = (None, {'__dict__', obj.__dict__})",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "save_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def save_function(pickler, obj):\n    if not _locate_function(obj, pickler):\n        if type(obj.__code__) is not CodeType:\n            # Some PyPy builtin functions have no module name, and thus are not\n            # able to be located\n            module_name = getattr(obj, '__module__', None)\n            if module_name is None:\n                module_name = __builtin__.__name__\n            module = _import_module(module_name, safe=True)\n            _pypy_builtin = False",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "pickles",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def pickles(obj,exact=False,safe=False,**kwds):\n    \"\"\"\n    Quick check if object pickles with dill.\n    If *exact=True* then an equality test is done to check if the reconstructed\n    object matches the original object.\n    If *safe=True* then any exception will raised in copy signal that the\n    object is not picklable, otherwise only pickling errors will be trapped.\n    Additional keyword arguments are as :func:`dumps` and :func:`loads`.\n    \"\"\"\n    if safe: exceptions = (Exception,) # RuntimeError, ValueError",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def check(obj, *args, **kwds):\n    \"\"\"\n    Check pickling of an object across another process.\n    *python* is the path to the python interpreter (defaults to sys.executable)\n    Set *verbose=True* to print the unpickled object in the other process.\n    Additional keyword arguments are as :func:`dumps` and :func:`loads`.\n    \"\"\"\n   # == undocumented ==\n   # python -- the string path or executable name of the selected python\n   # verbose -- if True, be verbose about printing warning messages",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "is_dill",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "def is_dill(pickler, child=None):\n    \"check the dill-ness of your pickler\"\n    if child is False or not hasattr(pickler.__class__, 'mro'):\n        return 'dill' in pickler.__module__\n    return Pickler in pickler.__class__.mro()\ndef _extend():\n    \"\"\"extend pickle with all of dill's registered types\"\"\"\n    # need to have pickle not choke on _main_module?  use is_dill(pickler)\n    for t,func in Pickler.dispatch.items():\n        try:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "__all__ = [\n    'Pickler','Unpickler',\n    'check','copy','dump','dumps','load','loads','pickle','pickles','register',\n    'DEFAULT_PROTOCOL','HIGHEST_PROTOCOL','CONTENTS_FMODE','FILE_FMODE','HANDLE_FMODE',\n    'PickleError','PickleWarning','PicklingError','PicklingWarning','UnpicklingError',\n    'UnpicklingWarning',\n]\n__module__ = 'dill'\nimport warnings\nfrom .logger import adapter as logger",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "__module__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "__module__ = 'dill'\nimport warnings\nfrom .logger import adapter as logger\nfrom .logger import trace as _trace\nimport os\nimport sys\ndiff = None\n_use_diff = False\nOLD38 = (sys.hexversion < 0x3080000)\nOLD39 = (sys.hexversion < 0x3090000)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "diff",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "diff = None\n_use_diff = False\nOLD38 = (sys.hexversion < 0x3080000)\nOLD39 = (sys.hexversion < 0x3090000)\nOLD310 = (sys.hexversion < 0x30a0000)\n#XXX: get types from .objtypes ?\nimport builtins as __builtin__\nfrom pickle import _Pickler as StockPickler, Unpickler as StockUnpickler\nfrom _thread import LockType\nfrom _thread import RLock as RLockType",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_use_diff",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_use_diff = False\nOLD38 = (sys.hexversion < 0x3080000)\nOLD39 = (sys.hexversion < 0x3090000)\nOLD310 = (sys.hexversion < 0x30a0000)\n#XXX: get types from .objtypes ?\nimport builtins as __builtin__\nfrom pickle import _Pickler as StockPickler, Unpickler as StockUnpickler\nfrom _thread import LockType\nfrom _thread import RLock as RLockType\n#from io import IOBase",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "OLD38",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "OLD38 = (sys.hexversion < 0x3080000)\nOLD39 = (sys.hexversion < 0x3090000)\nOLD310 = (sys.hexversion < 0x30a0000)\n#XXX: get types from .objtypes ?\nimport builtins as __builtin__\nfrom pickle import _Pickler as StockPickler, Unpickler as StockUnpickler\nfrom _thread import LockType\nfrom _thread import RLock as RLockType\n#from io import IOBase\nfrom types import CodeType, FunctionType, MethodType, GeneratorType, \\",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "OLD39",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "OLD39 = (sys.hexversion < 0x3090000)\nOLD310 = (sys.hexversion < 0x30a0000)\n#XXX: get types from .objtypes ?\nimport builtins as __builtin__\nfrom pickle import _Pickler as StockPickler, Unpickler as StockUnpickler\nfrom _thread import LockType\nfrom _thread import RLock as RLockType\n#from io import IOBase\nfrom types import CodeType, FunctionType, MethodType, GeneratorType, \\\n    TracebackType, FrameType, ModuleType, BuiltinMethodType",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "OLD310",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "OLD310 = (sys.hexversion < 0x30a0000)\n#XXX: get types from .objtypes ?\nimport builtins as __builtin__\nfrom pickle import _Pickler as StockPickler, Unpickler as StockUnpickler\nfrom _thread import LockType\nfrom _thread import RLock as RLockType\n#from io import IOBase\nfrom types import CodeType, FunctionType, MethodType, GeneratorType, \\\n    TracebackType, FrameType, ModuleType, BuiltinMethodType\nBufferType = memoryview #XXX: unregistered",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "BufferType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "BufferType = memoryview #XXX: unregistered\nClassType = type # no 'old-style' classes\nEllipsisType = type(Ellipsis)\n#FileType = IOBase\nNotImplementedType = type(NotImplemented)\nSliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "ClassType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "ClassType = type # no 'old-style' classes\nEllipsisType = type(Ellipsis)\n#FileType = IOBase\nNotImplementedType = type(NotImplemented)\nSliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "EllipsisType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "EllipsisType = type(Ellipsis)\n#FileType = IOBase\nNotImplementedType = type(NotImplemented)\nSliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "#FileType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "#FileType = IOBase\nNotImplementedType = type(NotImplemented)\nSliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal\nimport gc",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "NotImplementedType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "NotImplementedType = type(NotImplemented)\nSliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal\nimport gc\n# import zlib",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "SliceType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "SliceType = slice\nTypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal\nimport gc\n# import zlib\nfrom weakref import ReferenceType, ProxyType, CallableProxyType",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "TypeType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "TypeType = type # 'new-style' classes #XXX: unregistered\nXRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal\nimport gc\n# import zlib\nfrom weakref import ReferenceType, ProxyType, CallableProxyType\nfrom collections import OrderedDict",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "XRangeType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "XRangeType = range\nfrom types import MappingProxyType as DictProxyType\nfrom pickle import DEFAULT_PROTOCOL, HIGHEST_PROTOCOL, PickleError, PicklingError, UnpicklingError\nimport __main__ as _main_module\nimport marshal\nimport gc\n# import zlib\nfrom weakref import ReferenceType, ProxyType, CallableProxyType\nfrom collections import OrderedDict\nfrom functools import partial",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "GENERATOR_FAIL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "GENERATOR_FAIL = False\nimport importlib.machinery\nEXTENSION_SUFFIXES = tuple(importlib.machinery.EXTENSION_SUFFIXES)\ntry:\n    import ctypes\n    HAS_CTYPES = True\n    # if using `pypy`, pythonapi is not found\n    IS_PYPY = not hasattr(ctypes, 'pythonapi')\nexcept ImportError:\n    HAS_CTYPES = False",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "EXTENSION_SUFFIXES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "EXTENSION_SUFFIXES = tuple(importlib.machinery.EXTENSION_SUFFIXES)\ntry:\n    import ctypes\n    HAS_CTYPES = True\n    # if using `pypy`, pythonapi is not found\n    IS_PYPY = not hasattr(ctypes, 'pythonapi')\nexcept ImportError:\n    HAS_CTYPES = False\n    IS_PYPY = False\nNumpyUfuncType = None",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "NumpyUfuncType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "NumpyUfuncType = None\nNumpyDType = None\nNumpyArrayType = None\ntry:\n    if not importlib.machinery.PathFinder().find_spec('numpy'):\n        raise ImportError(\"No module named 'numpy'\")\n    NumpyUfuncType = True\n    NumpyDType = True\n    NumpyArrayType = True\nexcept ImportError:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "NumpyDType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "NumpyDType = None\nNumpyArrayType = None\ntry:\n    if not importlib.machinery.PathFinder().find_spec('numpy'):\n        raise ImportError(\"No module named 'numpy'\")\n    NumpyUfuncType = True\n    NumpyDType = True\n    NumpyArrayType = True\nexcept ImportError:\n    pass",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "NumpyArrayType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "NumpyArrayType = None\ntry:\n    if not importlib.machinery.PathFinder().find_spec('numpy'):\n        raise ImportError(\"No module named 'numpy'\")\n    NumpyUfuncType = True\n    NumpyDType = True\n    NumpyArrayType = True\nexcept ImportError:\n    pass\ndef __hook__():",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "CellType = type((lambda x: lambda y: x)(0).__closure__[0])\nPartialType = type(partial(int, base=2))\nSuperType = type(super(Exception, TypeError()))\nItemGetterType = type(itemgetter(0))\nAttrGetterType = type(attrgetter('__repr__'))\ntry:\n    from functools import _lru_cache_wrapper as LRUCacheType\nexcept ImportError:\n    LRUCacheType = None\nif not isinstance(LRUCacheType, type):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "PartialType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "PartialType = type(partial(int, base=2))\nSuperType = type(super(Exception, TypeError()))\nItemGetterType = type(itemgetter(0))\nAttrGetterType = type(attrgetter('__repr__'))\ntry:\n    from functools import _lru_cache_wrapper as LRUCacheType\nexcept ImportError:\n    LRUCacheType = None\nif not isinstance(LRUCacheType, type):\n    LRUCacheType = None",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "SuperType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "SuperType = type(super(Exception, TypeError()))\nItemGetterType = type(itemgetter(0))\nAttrGetterType = type(attrgetter('__repr__'))\ntry:\n    from functools import _lru_cache_wrapper as LRUCacheType\nexcept ImportError:\n    LRUCacheType = None\nif not isinstance(LRUCacheType, type):\n    LRUCacheType = None\ndef get_file_type(*args, **kwargs):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "ItemGetterType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "ItemGetterType = type(itemgetter(0))\nAttrGetterType = type(attrgetter('__repr__'))\ntry:\n    from functools import _lru_cache_wrapper as LRUCacheType\nexcept ImportError:\n    LRUCacheType = None\nif not isinstance(LRUCacheType, type):\n    LRUCacheType = None\ndef get_file_type(*args, **kwargs):\n    open = kwargs.pop(\"open\", __builtin__.open)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "AttrGetterType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "AttrGetterType = type(attrgetter('__repr__'))\ntry:\n    from functools import _lru_cache_wrapper as LRUCacheType\nexcept ImportError:\n    LRUCacheType = None\nif not isinstance(LRUCacheType, type):\n    LRUCacheType = None\ndef get_file_type(*args, **kwargs):\n    open = kwargs.pop(\"open\", __builtin__.open)\n    f = open(os.devnull, *args, **kwargs)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "FileType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "FileType = get_file_type('rb', buffering=0)\nTextWrapperType = get_file_type('r', buffering=-1)\nBufferedRandomType = get_file_type('r+b', buffering=-1)\nBufferedReaderType = get_file_type('rb', buffering=-1)\nBufferedWriterType = get_file_type('wb', buffering=-1)\ntry:\n    from _pyio import open as _open\n    PyTextWrapperType = get_file_type('r', buffering=-1, open=_open)\n    PyBufferedRandomType = get_file_type('r+b', buffering=-1, open=_open)\n    PyBufferedReaderType = get_file_type('rb', buffering=-1, open=_open)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "TextWrapperType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "TextWrapperType = get_file_type('r', buffering=-1)\nBufferedRandomType = get_file_type('r+b', buffering=-1)\nBufferedReaderType = get_file_type('rb', buffering=-1)\nBufferedWriterType = get_file_type('wb', buffering=-1)\ntry:\n    from _pyio import open as _open\n    PyTextWrapperType = get_file_type('r', buffering=-1, open=_open)\n    PyBufferedRandomType = get_file_type('r+b', buffering=-1, open=_open)\n    PyBufferedReaderType = get_file_type('rb', buffering=-1, open=_open)\n    PyBufferedWriterType = get_file_type('wb', buffering=-1, open=_open)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "BufferedRandomType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "BufferedRandomType = get_file_type('r+b', buffering=-1)\nBufferedReaderType = get_file_type('rb', buffering=-1)\nBufferedWriterType = get_file_type('wb', buffering=-1)\ntry:\n    from _pyio import open as _open\n    PyTextWrapperType = get_file_type('r', buffering=-1, open=_open)\n    PyBufferedRandomType = get_file_type('r+b', buffering=-1, open=_open)\n    PyBufferedReaderType = get_file_type('rb', buffering=-1, open=_open)\n    PyBufferedWriterType = get_file_type('wb', buffering=-1, open=_open)\nexcept ImportError:",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "BufferedReaderType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "BufferedReaderType = get_file_type('rb', buffering=-1)\nBufferedWriterType = get_file_type('wb', buffering=-1)\ntry:\n    from _pyio import open as _open\n    PyTextWrapperType = get_file_type('r', buffering=-1, open=_open)\n    PyBufferedRandomType = get_file_type('r+b', buffering=-1, open=_open)\n    PyBufferedReaderType = get_file_type('rb', buffering=-1, open=_open)\n    PyBufferedWriterType = get_file_type('wb', buffering=-1, open=_open)\nexcept ImportError:\n    PyTextWrapperType = PyBufferedRandomType = PyBufferedReaderType = PyBufferedWriterType = None",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "BufferedWriterType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "BufferedWriterType = get_file_type('wb', buffering=-1)\ntry:\n    from _pyio import open as _open\n    PyTextWrapperType = get_file_type('r', buffering=-1, open=_open)\n    PyBufferedRandomType = get_file_type('r+b', buffering=-1, open=_open)\n    PyBufferedReaderType = get_file_type('rb', buffering=-1, open=_open)\n    PyBufferedWriterType = get_file_type('wb', buffering=-1, open=_open)\nexcept ImportError:\n    PyTextWrapperType = PyBufferedRandomType = PyBufferedReaderType = PyBufferedWriterType = None\nfrom io import BytesIO as StringIO",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "InputType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "InputType = OutputType = None\nfrom socket import socket as SocketType\n#FIXME: additionally calls ForkingPickler.register several times\nfrom multiprocessing.reduction import _reduce_socket as reduce_socket\ntry:\n    IS_IPYTHON = __IPYTHON__  # is True\n    ExitType = None     # IPython.core.autocall.ExitAutocall\n    singletontypes = ['exit', 'quit', 'get_ipython']\nexcept NameError:\n    IS_IPYTHON = False",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "HANDLE_FMODE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "HANDLE_FMODE = 0\n#: Pickles the file contents, creating a new file if on load the file does\n#: not exist. The position = min(pickled position, EOF) and mode is chosen\n#: as such that \"best\" preserves behavior of the original file.\nCONTENTS_FMODE = 1\n#: Pickles the entire file (handle and contents), preserving mode and position.\nFILE_FMODE = 2\n### Shorthands (modified from python2.5/lib/pickle.py)\ndef copy(obj, *args, **kwds):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "CONTENTS_FMODE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "CONTENTS_FMODE = 1\n#: Pickles the entire file (handle and contents), preserving mode and position.\nFILE_FMODE = 2\n### Shorthands (modified from python2.5/lib/pickle.py)\ndef copy(obj, *args, **kwds):\n    \"\"\"\n    Use pickling to 'copy' an object (i.e. `loads(dumps(obj))`).\n    See :func:`dumps` and :func:`loads` for keyword arguments.\n    \"\"\"\n    ignore = kwds.pop('ignore', Unpickler.settings['ignore'])",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "FILE_FMODE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "FILE_FMODE = 2\n### Shorthands (modified from python2.5/lib/pickle.py)\ndef copy(obj, *args, **kwds):\n    \"\"\"\n    Use pickling to 'copy' an object (i.e. `loads(dumps(obj))`).\n    See :func:`dumps` and :func:`loads` for keyword arguments.\n    \"\"\"\n    ignore = kwds.pop('ignore', Unpickler.settings['ignore'])\n    return loads(dumps(obj, *args, **kwds), ignore=ignore)\ndef dump(obj, file, protocol=None, byref=None, fmode=None, recurse=None, **kwds):#, strictio=None):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "pickle_dispatch_copy",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "pickle_dispatch_copy = StockPickler.dispatch.copy()\ndef pickle(t, func):\n    \"\"\"expose dispatch table for user-created extensions\"\"\"\n    Pickler.dispatch[t] = func\n    return\ndef register(t):\n    \"\"\"register type to Pickler's dispatch table \"\"\"\n    def proxy(func):\n        Pickler.dispatch[t] = func\n        return func",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_reverse_typemap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_reverse_typemap = dict(_create_typemap())\n_reverse_typemap.update({\n    'PartialType': PartialType,\n    'SuperType': SuperType,\n    'ItemGetterType': ItemGetterType,\n    'AttrGetterType': AttrGetterType,\n})\nif sys.hexversion < 0x30800a2:\n    _reverse_typemap.update({\n        'CellType': CellType,",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_incedental_reverse_typemap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_incedental_reverse_typemap = {\n    'FileType': FileType,\n    'BufferedRandomType': BufferedRandomType,\n    'BufferedReaderType': BufferedReaderType,\n    'BufferedWriterType': BufferedWriterType,\n    'TextWrapperType': TextWrapperType,\n    'PyBufferedRandomType': PyBufferedRandomType,\n    'PyBufferedReaderType': PyBufferedReaderType,\n    'PyBufferedWriterType': PyBufferedWriterType,\n    'PyTextWrapperType': PyTextWrapperType,",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_incedental_types",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_incedental_types = set(_incedental_reverse_typemap.values())\ndel x\n_typemap = dict((v, k) for k, v in _reverse_typemap.items())\ndef _unmarshal(string):\n    return marshal.loads(string)\ndef _load_type(name):\n    return _reverse_typemap[name]\ndef _create_type(typeobj, *args):\n    return typeobj(*args)\ndef _create_function(fcode, fglobals, fname=None, fdefaults=None,",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_typemap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_typemap = dict((v, k) for k, v in _reverse_typemap.items())\ndef _unmarshal(string):\n    return marshal.loads(string)\ndef _load_type(name):\n    return _reverse_typemap[name]\ndef _create_type(typeobj, *args):\n    return typeobj(*args)\ndef _create_function(fcode, fglobals, fname=None, fdefaults=None,\n                     fclosure=None, fdict=None, fkwdefaults=None):\n    # same as FunctionType, but enable passing __dict__ to new function,",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "ALL_CODE_PARAMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "ALL_CODE_PARAMS = [\n    # Version     New attribute         CodeType parameters\n    ((3,11,'a'), 'co_endlinetable',    'argcount posonlyargcount kwonlyargcount nlocals stacksize flags code consts names varnames filename name qualname firstlineno linetable endlinetable columntable exceptiontable freevars cellvars'),\n    ((3,11),     'co_exceptiontable',  'argcount posonlyargcount kwonlyargcount nlocals stacksize flags code consts names varnames filename name qualname firstlineno linetable                          exceptiontable freevars cellvars'),\n    ((3,10),     'co_linetable',       'argcount posonlyargcount kwonlyargcount nlocals stacksize flags code consts names varnames filename name          firstlineno linetable                                         freevars cellvars'),\n    ((3,8),      'co_posonlyargcount', 'argcount posonlyargcount kwonlyargcount nlocals stacksize flags code consts names varnames filename name          firstlineno lnotab                                            freevars cellvars'),\n    ((3,7),      'co_kwonlyargcount',  'argcount                 kwonlyargcount nlocals stacksize flags code consts names varnames filename name          firstlineno lnotab                                            freevars cellvars'),\n    ]\nfor version, new_attr, params in ALL_CODE_PARAMS:\n    if hasattr(CodeType, new_attr):",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "ENCODE_PARAMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "ENCODE_PARAMS = set(CODE_PARAMS).intersection(\n        ['code', 'lnotab', 'linetable', 'endlinetable', 'columntable', 'exceptiontable'])\ndef _create_code(*args):\n    if not isinstance(args[0], int): # co_lnotab stored from >= 3.10\n        LNOTAB, *args = args\n    else: # from < 3.10 (or pre-LNOTAB storage)\n        LNOTAB = b''\n    with match(args) as m:\n        # Python 3.11/3.12a (18 members)\n        if m.case((",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_dictproxy_helper_instance",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_dictproxy_helper_instance = _dictproxy_helper()\n__d = {}\ntry:\n    # In CPython 3.9 and later, this trick can be used to exploit the\n    # implementation of the __or__ function of MappingProxyType to get the true\n    # mapping referenced by the proxy. It may work for other implementations,\n    # but is not guaranteed.\n    MAPPING_PROXY_TRICK = __d is (DictProxyType(__d) | _dictproxy_helper_instance)\nexcept Exception:\n    MAPPING_PROXY_TRICK = False",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "__d",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "__d = {}\ntry:\n    # In CPython 3.9 and later, this trick can be used to exploit the\n    # implementation of the __or__ function of MappingProxyType to get the true\n    # mapping referenced by the proxy. It may work for other implementations,\n    # but is not guaranteed.\n    MAPPING_PROXY_TRICK = __d is (DictProxyType(__d) | _dictproxy_helper_instance)\nexcept Exception:\n    MAPPING_PROXY_TRICK = False\ndel __d",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_CELL_REF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_CELL_REF = None\n_CELL_EMPTY = Sentinel('_CELL_EMPTY')\ndef _create_cell(contents=None):\n    if contents is not _CELL_EMPTY:\n        value = contents\n    return (lambda: value).__closure__[0]\ndef _create_weakref(obj, *args):\n    from weakref import ref\n    if obj is None: # it's dead\n        from collections import UserDict",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_CELL_EMPTY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._dill",
        "description": "__pypackages__.3.10.lib.dill._dill",
        "peekOfCode": "_CELL_EMPTY = Sentinel('_CELL_EMPTY')\ndef _create_cell(contents=None):\n    if contents is not _CELL_EMPTY:\n        value = contents\n    return (lambda: value).__closure__[0]\ndef _create_weakref(obj, *args):\n    from weakref import ref\n    if obj is None: # it's dead\n        from collections import UserDict\n        return ref(UserDict(), *args)",
        "detail": "__pypackages__.3.10.lib.dill._dill",
        "documentation": {}
    },
    {
        "label": "_class",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "class _class:\n    def _method(self):\n        pass\n#   @classmethod\n#   def _clsmethod(cls): #XXX: test me\n#       pass\n#   @staticmethod\n#   def _static(self): #XXX: test me\n#       pass\nclass _class2:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_class2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "class _class2:\n    def __call__(self):\n        pass\n_instance2 = _class2()\nclass _newclass(object):\n    def _method(self):\n        pass\n#   @classmethod\n#   def _clsmethod(cls): #XXX: test me\n#       pass",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_newclass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "class _newclass(object):\n    def _method(self):\n        pass\n#   @classmethod\n#   def _clsmethod(cls): #XXX: test me\n#       pass\n#   @staticmethod\n#   def _static(self): #XXX: test me\n#       pass\nclass _newclass2(object):",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_newclass2",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "class _newclass2(object):\n    __slots__ = ['descriptor']\ndef _function(x): yield x\ndef _function2():\n    try: raise\n    except Exception:\n        from sys import exc_info\n        e, er, tb = exc_info()\n        return er, tb\nif HAS_CTYPES:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "__all__ = ['registered','failures','succeeds']\n# helper imports\nimport warnings; warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nimport sys\nimport queue as Queue\nimport dbm as anydbm\nfrom io import BytesIO as StringIO\nimport re\nimport array\nimport collections",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_instance2",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "_instance2 = _class2()\nclass _newclass(object):\n    def _method(self):\n        pass\n#   @classmethod\n#   def _clsmethod(cls): #XXX: test me\n#       pass\n#   @staticmethod\n#   def _static(self): #XXX: test me\n#       pass",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_tmpf",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "_tmpf = tempfile.TemporaryFile('w')\n# objects used by dill for type declaration\nregistered = d = {}\n# objects dill fails to pickle\nfailures = x = {}\n# all other type objects\nsucceeds = a = {}\n# types module (part of CH 8)\na['BooleanType'] = bool(1)\na['BuiltinFunctionType'] = len",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "registered",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "registered = d = {}\n# objects dill fails to pickle\nfailures = x = {}\n# all other type objects\nsucceeds = a = {}\n# types module (part of CH 8)\na['BooleanType'] = bool(1)\na['BuiltinFunctionType'] = len\na['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "failures = x = {}\n# all other type objects\nsucceeds = a = {}\n# types module (part of CH 8)\na['BooleanType'] = bool(1)\na['BuiltinFunctionType'] = len\na['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "succeeds",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "succeeds = a = {}\n# types module (part of CH 8)\na['BooleanType'] = bool(1)\na['BuiltinFunctionType'] = len\na['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['BooleanType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['BooleanType'] = bool(1)\na['BuiltinFunctionType'] = len\na['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['BuiltinFunctionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['BuiltinFunctionType'] = len\na['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['BuiltinMethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['BuiltinMethodType'] = a['BuiltinFunctionType']\na['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['BytesType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['BytesType'] = _bytes = codecs.latin_1_encode('\\x00')[0] # bytes(1)\na['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClassType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClassType'] = _class\na['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ComplexType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ComplexType'] = complex(1)\na['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictType'] = _dict = {}\na['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictionaryType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictionaryType'] = a['DictType']\na['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FloatType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FloatType'] = float(1)\na['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FunctionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FunctionType'] = _function\na['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['InstanceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['InstanceType'] = _instance = _class()\na['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['IntType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['IntType'] = _int = int(1)\na['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ListType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ListType'] = _list = []\na['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['NoneType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['NoneType'] = None\na['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ObjectType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ObjectType'] = object()\na['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['StringType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['StringType'] = _str = str(1)\na['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TupleType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TupleType'] = _tuple = ()\na['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TypeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TypeType'] = type\na['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LongType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LongType'] = _int\na['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['UnicodeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['UnicodeType'] = _str\n# built-in constants (CH 4)\na['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CopyrightType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CopyrightType'] = copyright\n# built-in types (CH 5)\na['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClassObjectType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClassObjectType'] = _newclass # <type 'type'>\na['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClassInstanceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClassInstanceType'] = _newclass() # <type 'class'>\na['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['SetType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['SetType'] = _set = set()\na['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FrozenSetType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FrozenSetType'] = frozenset()\n# built-in exceptions (CH 6)\na['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ExceptionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ExceptionType'] = _exception = _function2()[0]\n# string services (CH 7)\na['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['SREPatternType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['SREPatternType'] = _srepattern = re.compile('')\n# data types (CH 8)\na['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ArrayType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ArrayType'] = array.array(\"f\")\na['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DequeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DequeType'] = collections.deque([0])\na['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DefaultDictType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DefaultDictType'] = collections.defaultdict(_function, _dict)\na['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TZInfoType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TZInfoType'] = datetime.tzinfo()\na['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DateTimeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DateTimeType'] = datetime.datetime.today()\na['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CalendarType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CalendarType'] = calendar.Calendar()\n# numeric and mathematical types (CH 9)\na['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DecimalType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DecimalType'] = decimal.Decimal(1)\na['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CountType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CountType'] = itertools.count(0)\n# data compression and archiving (CH 12)\na['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TarInfoType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TarInfoType'] = tarfile.TarInfo()\n# generic operating system services (CH 15)\na['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LoggerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LoggerType'] = _logger = logging.getLogger()\na['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FormatterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FormatterType'] = logging.Formatter() # pickle ok\na['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FilterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FilterType'] = logging.Filter() # pickle ok\na['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6\n    z['CByteType'] = ctypes.c_byte()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LogRecordType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LogRecordType'] = logging.makeLogRecord(_dict) # pickle ok\na['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6\n    z['CByteType'] = ctypes.c_byte()\n    z['CUByteType'] = ctypes.c_ubyte()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['OptionParserType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['OptionParserType'] = _oparser = optparse.OptionParser() # pickle ok\na['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6\n    z['CByteType'] = ctypes.c_byte()\n    z['CUByteType'] = ctypes.c_ubyte()\n    z['CShortType'] = ctypes.c_short()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['OptionGroupType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['OptionGroupType'] = optparse.OptionGroup(_oparser,\"foo\") # pickle ok\na['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6\n    z['CByteType'] = ctypes.c_byte()\n    z['CUByteType'] = ctypes.c_ubyte()\n    z['CShortType'] = ctypes.c_short()\n    z['CUShortType'] = ctypes.c_ushort()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['OptionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['OptionType'] = optparse.Option('--foo') # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CCharType'] = _cchar = ctypes.c_char()\n    z['CWCharType'] = ctypes.c_wchar() # fail == 2.6\n    z['CByteType'] = ctypes.c_byte()\n    z['CUByteType'] = ctypes.c_ubyte()\n    z['CShortType'] = ctypes.c_short()\n    z['CUShortType'] = ctypes.c_ushort()\n    z['CIntType'] = ctypes.c_int()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ByteArrayType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ByteArrayType'] = bytearray([1])\n# numeric and mathematical types (CH 9)\na['FractionType'] = fractions.Fraction()\na['NumberType'] = numbers.Number()\n# generic operating system services (CH 15)\na['IOBaseType'] = io.IOBase()\na['RawIOBaseType'] = io.RawIOBase()\na['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FractionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FractionType'] = fractions.Fraction()\na['NumberType'] = numbers.Number()\n# generic operating system services (CH 15)\na['IOBaseType'] = io.IOBase()\na['RawIOBaseType'] = io.RawIOBase()\na['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['NumberType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['NumberType'] = numbers.Number()\n# generic operating system services (CH 15)\na['IOBaseType'] = io.IOBase()\na['RawIOBaseType'] = io.RawIOBase()\na['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['IOBaseType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['IOBaseType'] = io.IOBase()\na['RawIOBaseType'] = io.RawIOBase()\na['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RawIOBaseType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RawIOBaseType'] = io.RawIOBase()\na['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()\n    del z",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TextIOBaseType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TextIOBaseType'] = io.TextIOBase()\na['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()\n    del z\nimport argparse",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['BufferedIOBaseType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['BufferedIOBaseType'] = io.BufferedIOBase()\na['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()\n    del z\nimport argparse\n# data types (CH 8)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['UnicodeIOType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['UnicodeIOType'] = TextIO() # the new StringIO\na['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()\n    del z\nimport argparse\n# data types (CH 8)\na['OrderedDictType'] = collections.OrderedDict(_dict)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LoggerAdapterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LoggerAdapterType'] = logging.LoggerAdapter(_logger,_dict) # pickle ok\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CBoolType'] = ctypes.c_bool(1)\n    z['CLongDoubleType'] = ctypes.c_longdouble()\n    del z\nimport argparse\n# data types (CH 8)\na['OrderedDictType'] = collections.OrderedDict(_dict)\na['CounterType'] = collections.Counter(_dict)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['OrderedDictType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['OrderedDictType'] = collections.OrderedDict(_dict)\na['CounterType'] = collections.Counter(_dict)\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CSSizeTType'] = ctypes.c_ssize_t()\n    del z\n# generic operating system services (CH 15)\na['NullHandlerType'] = logging.NullHandler() # pickle ok  # new 2.7\na['ArgParseFileType'] = argparse.FileType() # pickle ok\n# -- pickle fails on all below here -----------------------------------------",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CounterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CounterType'] = collections.Counter(_dict)\nif HAS_CTYPES:\n    z = x if IS_PYPY else a\n    z['CSSizeTType'] = ctypes.c_ssize_t()\n    del z\n# generic operating system services (CH 15)\na['NullHandlerType'] = logging.NullHandler() # pickle ok  # new 2.7\na['ArgParseFileType'] = argparse.FileType() # pickle ok\n# -- pickle fails on all below here -----------------------------------------\n# types module (part of CH 8)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['NullHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['NullHandlerType'] = logging.NullHandler() # pickle ok  # new 2.7\na['ArgParseFileType'] = argparse.FileType() # pickle ok\n# -- pickle fails on all below here -----------------------------------------\n# types module (part of CH 8)\na['CodeType'] = compile('','','exec')\na['DictProxyType'] = type.__dict__\na['DictProxyType2'] = _newclass.__dict__\na['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ArgParseFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ArgParseFileType'] = argparse.FileType() # pickle ok\n# -- pickle fails on all below here -----------------------------------------\n# types module (part of CH 8)\na['CodeType'] = compile('','','exec')\na['DictProxyType'] = type.__dict__\na['DictProxyType2'] = _newclass.__dict__\na['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CodeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CodeType'] = compile('','','exec')\na['DictProxyType'] = type.__dict__\na['DictProxyType2'] = _newclass.__dict__\na['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictProxyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictProxyType'] = type.__dict__\na['DictProxyType2'] = _newclass.__dict__\na['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictProxyType2']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictProxyType2'] = _newclass.__dict__\na['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['EllipsisType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['EllipsisType'] = Ellipsis\na['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClosedFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClosedFileType'] = open(os.devnull, 'wb', buffering=0).close()\na['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['GetSetDescriptorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['GetSetDescriptorType'] = array.array.typecode\na['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LambdaType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LambdaType'] = _lambda = lambda x: lambda y: x #XXX: works when not imported!\na['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MemberDescriptorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MemberDescriptorType'] = _newclass2.descriptor\nif not IS_PYPY:\n    a['MemberDescriptorType2'] = datetime.timedelta.days\na['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MethodType'] = _method = _class()._method #XXX: works when not imported!\na['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ModuleType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ModuleType'] = datetime\na['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['NotImplementedType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['NotImplementedType'] = NotImplemented\na['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['SliceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['SliceType'] = slice(1)\na['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['UnboundMethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['UnboundMethodType'] = _class._method #XXX: works when not imported!\nd['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)\n    d['PyBufferedReaderType'] = _open(os.devnull, 'rb', buffering=-1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['TextWrapperType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['TextWrapperType'] = open(os.devnull, 'r') # same as mode='w','w+','r+'\nd['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)\n    d['PyBufferedReaderType'] = _open(os.devnull, 'rb', buffering=-1)\n    d['PyBufferedWriterType'] = _open(os.devnull, 'wb', buffering=-1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['BufferedRandomType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['BufferedRandomType'] = open(os.devnull, 'r+b') # same as mode='w+b'\nd['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)\n    d['PyBufferedReaderType'] = _open(os.devnull, 'rb', buffering=-1)\n    d['PyBufferedWriterType'] = _open(os.devnull, 'wb', buffering=-1)\nexcept ImportError:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['BufferedReaderType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['BufferedReaderType'] = open(os.devnull, 'rb') # (default: buffering=-1)\nd['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)\n    d['PyBufferedReaderType'] = _open(os.devnull, 'rb', buffering=-1)\n    d['PyBufferedWriterType'] = _open(os.devnull, 'wb', buffering=-1)\nexcept ImportError:\n    pass",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['BufferedWriterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['BufferedWriterType'] = open(os.devnull, 'wb')\ntry: # oddities: deprecated\n    from _pyio import open as _open\n    d['PyTextWrapperType'] = _open(os.devnull, 'r', buffering=-1)\n    d['PyBufferedRandomType'] = _open(os.devnull, 'r+b', buffering=-1)\n    d['PyBufferedReaderType'] = _open(os.devnull, 'rb', buffering=-1)\n    d['PyBufferedWriterType'] = _open(os.devnull, 'wb', buffering=-1)\nexcept ImportError:\n    pass\n# other (concrete) object types",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z = d if sys.hexversion < 0x30800a2 else a\nz['CellType'] = (_lambda)(0).__closure__[0]\ndel z\na['XRangeType'] = _xrange = range(1)\na['MethodDescriptorType'] = type.__dict__['mro']\na['WrapperDescriptorType'] = type.__repr__\n#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z['CellType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z['CellType'] = (_lambda)(0).__closure__[0]\ndel z\na['XRangeType'] = _xrange = range(1)\na['MethodDescriptorType'] = type.__dict__['mro']\na['WrapperDescriptorType'] = type.__repr__\n#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['XRangeType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['XRangeType'] = _xrange = range(1)\na['MethodDescriptorType'] = type.__dict__['mro']\na['WrapperDescriptorType'] = type.__repr__\n#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MethodDescriptorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MethodDescriptorType'] = type.__dict__['mro']\na['WrapperDescriptorType'] = type.__repr__\n#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['WrapperDescriptorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['WrapperDescriptorType'] = type.__repr__\n#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['WrapperDescriptorType2']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['WrapperDescriptorType2'] = type.__dict__['__module__']#XXX: GetSetDescriptor\na['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClassMethodDescriptorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClassMethodDescriptorType'] = type.__dict__['__prepare__']\n# built-in functions (CH 2)\n_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_methodwrap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "_methodwrap = (1).__lt__\na['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MethodWrapperType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MethodWrapperType'] = _methodwrap\na['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['StaticMethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['StaticMethodType'] = staticmethod(_method)\na['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ClassMethodType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ClassMethodType'] = classmethod(_method)\na['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['PropertyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['PropertyType'] = property()\nd['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['SuperType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['SuperType'] = super(Exception, _exception)\n# string services (CH 7)\n_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_in",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "_in = _bytes\na['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['InputType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['InputType'] = _cstrI = StringIO(_in)\na['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['OutputType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['OutputType'] = _cstrO = StringIO()\n# data types (CH 8)\na['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['WeakKeyDictionaryType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['WeakKeyDictionaryType'] = weakref.WeakKeyDictionary()\na['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['WeakValueDictionaryType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['WeakValueDictionaryType'] = weakref.WeakValueDictionary()\na['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ReferenceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ReferenceType'] = weakref.ref(_instance)\na['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DeadReferenceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DeadReferenceType'] = weakref.ref(_class())\na['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ProxyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ProxyType'] = weakref.proxy(_instance)\na['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DeadProxyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DeadProxyType'] = weakref.proxy(_class())\na['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CallableProxyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CallableProxyType'] = weakref.proxy(_instance2)\na['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DeadCallableProxyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DeadCallableProxyType'] = weakref.proxy(_class2())\na['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['QueueType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['QueueType'] = Queue.Queue()\n# numeric and mathematical types (CH 9)\nd['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['PartialType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['PartialType'] = functools.partial(int,base=2)\na['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['IzipType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['IzipType'] = zip('0','1')\na['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')\n    x['CursorType'] = _conn.cursor()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ChainType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ChainType'] = itertools.chain('0','1')\nd['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')\n    x['CursorType'] = _conn.cursor()\na['ShelveType'] = shelve.Shelf({})",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['ItemGetterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['ItemGetterType'] = operator.itemgetter(0)\nd['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')\n    x['CursorType'] = _conn.cursor()\na['ShelveType'] = shelve.Shelf({})\n# data compression and archiving (CH 12)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['AttrGetterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['AttrGetterType'] = operator.attrgetter('__repr__')\n# file and directory access (CH 10)\n_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')\n    x['CursorType'] = _conn.cursor()\na['ShelveType'] = shelve.Shelf({})\n# data compression and archiving (CH 12)\nif HAS_ALL:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "_fileW",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "_fileW = _cstrO\n# data persistence (CH 11)\nif HAS_ALL:\n    x['ConnectionType'] = _conn = sqlite3.connect(':memory:')\n    x['CursorType'] = _conn.cursor()\na['ShelveType'] = shelve.Shelf({})\n# data compression and archiving (CH 12)\nif HAS_ALL:\n    x['BZ2FileType'] = bz2.BZ2File(os.devnull)\n    x['BZ2CompressorType'] = bz2.BZ2Compressor()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ShelveType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ShelveType'] = shelve.Shelf({})\n# data compression and archiving (CH 12)\nif HAS_ALL:\n    x['BZ2FileType'] = bz2.BZ2File(os.devnull)\n    x['BZ2CompressorType'] = bz2.BZ2Compressor()\n    x['BZ2DecompressorType'] = bz2.BZ2Decompressor()\n#x['ZipFileType'] = _zip = zipfile.ZipFile(os.devnull,'w')\n#_zip.write(_tempfile,'x') [causes annoying warning/error printed on import]\n#a['ZipInfoType'] = _zip.getinfo('x')\na['TarFileType'] = tarfile.open(fileobj=_fileW,mode='w')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#x['ZipFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#x['ZipFileType'] = _zip = zipfile.ZipFile(os.devnull,'w')\n#_zip.write(_tempfile,'x') [causes annoying warning/error printed on import]\n#a['ZipInfoType'] = _zip.getinfo('x')\na['TarFileType'] = tarfile.open(fileobj=_fileW,mode='w')\n# file formats (CH 13)\nx['DialectType'] = csv.get_dialect('excel')\na['PackerType'] = xdrlib.Packer()\n# optional operating system services (CH 16)\na['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['ZipInfoType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['ZipInfoType'] = _zip.getinfo('x')\na['TarFileType'] = tarfile.open(fileobj=_fileW,mode='w')\n# file formats (CH 13)\nx['DialectType'] = csv.get_dialect('excel')\na['PackerType'] = xdrlib.Packer()\n# optional operating system services (CH 16)\na['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TarFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TarFileType'] = tarfile.open(fileobj=_fileW,mode='w')\n# file formats (CH 13)\nx['DialectType'] = csv.get_dialect('excel')\na['PackerType'] = xdrlib.Packer()\n# optional operating system services (CH 16)\na['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['DialectType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['DialectType'] = csv.get_dialect('excel')\na['PackerType'] = xdrlib.Packer()\n# optional operating system services (CH 16)\na['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['PackerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['PackerType'] = xdrlib.Packer()\n# optional operating system services (CH 16)\na['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['LockType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['LockType'] = threading.Lock()\na['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RLockType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RLockType'] = threading.RLock()\n# generic operating system services (CH 15) # also closed/open and r/w/etc...\na['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['NamedLoggerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['NamedLoggerType'] = _logger = logging.getLogger(__name__)\n#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython\n    __IPYTHON__ is True # is ipython\nexcept NameError:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['FrozenModuleType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['FrozenModuleType'] = __hello__ #FIXME: prints \"Hello world...\"\n# interprocess communication (CH 17)\nx['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython\n    __IPYTHON__ is True # is ipython\nexcept NameError:\n    # built-in constants (CH 4)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['SocketType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['SocketType'] = _socket = socket.socket()\nx['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython\n    __IPYTHON__ is True # is ipython\nexcept NameError:\n    # built-in constants (CH 4)\n    a['QuitterType'] = quit\n    d['ExitType'] = a['QuitterType']",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['SocketPairType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['SocketPairType'] = socket.socketpair()[0]\n# python runtime services (CH 27)\na['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython\n    __IPYTHON__ is True # is ipython\nexcept NameError:\n    # built-in constants (CH 4)\n    a['QuitterType'] = quit\n    d['ExitType'] = a['QuitterType']\ntry: # numpy #FIXME: slow... 0.05 to 0.1 sec to import numpy",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['GeneratorContextManagerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['GeneratorContextManagerType'] = contextlib.contextmanager(max)([1])\ntry: # ipython\n    __IPYTHON__ is True # is ipython\nexcept NameError:\n    # built-in constants (CH 4)\n    a['QuitterType'] = quit\n    d['ExitType'] = a['QuitterType']\ntry: # numpy #FIXME: slow... 0.05 to 0.1 sec to import numpy\n    from numpy import ufunc as _numpy_ufunc\n    from numpy import array as _numpy_array",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ProductType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ProductType'] = itertools.product('0','1')\n# generic operating system services (CH 15)\na['FileHandlerType'] = logging.FileHandler(os.devnull)\na['RotatingFileHandlerType'] = logging.handlers.RotatingFileHandler(os.devnull)\na['SocketHandlerType'] = logging.handlers.SocketHandler('localhost',514)\na['MemoryHandlerType'] = logging.handlers.MemoryHandler(1)\n# data types (CH 8)\na['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['FileHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['FileHandlerType'] = logging.FileHandler(os.devnull)\na['RotatingFileHandlerType'] = logging.handlers.RotatingFileHandler(os.devnull)\na['SocketHandlerType'] = logging.handlers.SocketHandler('localhost',514)\na['MemoryHandlerType'] = logging.handlers.MemoryHandler(1)\n# data types (CH 8)\na['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RotatingFileHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RotatingFileHandlerType'] = logging.handlers.RotatingFileHandler(os.devnull)\na['SocketHandlerType'] = logging.handlers.SocketHandler('localhost',514)\na['MemoryHandlerType'] = logging.handlers.MemoryHandler(1)\n# data types (CH 8)\na['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['SocketHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['SocketHandlerType'] = logging.handlers.SocketHandler('localhost',514)\na['MemoryHandlerType'] = logging.handlers.MemoryHandler(1)\n# data types (CH 8)\na['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MemoryHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MemoryHandlerType'] = logging.handlers.MemoryHandler(1)\n# data types (CH 8)\na['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['WeakSetType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['WeakSetType'] = weakref.WeakSet() # 2.7\n# generic operating system services (CH 15) [errors when dill is imported]\n#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['ArgumentParserType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['ArgumentParserType'] = _parser = argparse.ArgumentParser('PROG')\n#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['NamespaceType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['NamespaceType'] = _parser.parse_args() # pickle ok\n#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:\na['ListIteratorType'] = iter(_list) # empty vs non-empty",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['SubParsersActionType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['SubParsersActionType'] = _parser.add_subparsers()\n#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:\na['ListIteratorType'] = iter(_list) # empty vs non-empty\na['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['MutuallyExclusiveGroupType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['MutuallyExclusiveGroupType'] = _parser.add_mutually_exclusive_group()\n#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:\na['ListIteratorType'] = iter(_list) # empty vs non-empty\na['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator\na['TupleIteratorType']= iter(_tuple) # empty vs non-empty",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "#a['ArgumentGroupType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "#a['ArgumentGroupType'] = _parser.add_argument_group()\n# -- dill fails in some versions below here ---------------------------------\n# types module (part of CH 8)\nd['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:\na['ListIteratorType'] = iter(_list) # empty vs non-empty\na['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator\na['TupleIteratorType']= iter(_tuple) # empty vs non-empty\na['XRangeIteratorType'] = iter(_xrange) # empty vs non-empty",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['FileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['FileType'] = open(os.devnull, 'rb', buffering=0) # same 'wb','wb+','rb+'\n# built-in functions (CH 2)\n# Iterators:\na['ListIteratorType'] = iter(_list) # empty vs non-empty\na['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator\na['TupleIteratorType']= iter(_tuple) # empty vs non-empty\na['XRangeIteratorType'] = iter(_xrange) # empty vs non-empty\na[\"BytesIteratorType\"] = iter(b'')\na[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ListIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ListIteratorType'] = iter(_list) # empty vs non-empty\na['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator\na['TupleIteratorType']= iter(_tuple) # empty vs non-empty\na['XRangeIteratorType'] = iter(_xrange) # empty vs non-empty\na[\"BytesIteratorType\"] = iter(b'')\na[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['SetIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['SetIteratorType'] = iter(_set) #XXX: empty vs non-empty #FIXME: list_iterator\na['TupleIteratorType']= iter(_tuple) # empty vs non-empty\na['XRangeIteratorType'] = iter(_xrange) # empty vs non-empty\na[\"BytesIteratorType\"] = iter(b'')\na[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['XRangeIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['XRangeIteratorType'] = iter(_xrange) # empty vs non-empty\na[\"BytesIteratorType\"] = iter(b'')\na[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a[\"BytesIteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a[\"BytesIteratorType\"] = iter(b'')\na[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a[\"BytearrayIteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a[\"BytearrayIteratorType\"] = iter(bytearray(b''))\nz = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z = x if IS_PYPY else a\nz[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z[\"CallableIteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z[\"CallableIteratorType\"] = iter(iter, None)\ndel z\nx[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x[\"MemoryIteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x[\"MemoryIteratorType\"] = iter(memoryview(b''))\na[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a[\"ListReverseiteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a[\"ListReverseiteratorType\"] = reversed([])\nX = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "X = a['OrderedDictType']\nd[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d[\"OdictKeysType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d[\"OdictKeysType\"] = X.keys()\nd[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d[\"OdictValuesType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d[\"OdictValuesType\"] = X.values()\nd[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d[\"OdictItemsType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d[\"OdictItemsType\"] = X.items()\na[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())\n    a[\"DictReversevalueiteratorType\"] = reversed({}.values())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a[\"OdictIteratorType\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a[\"OdictIteratorType\"] = iter(X.keys()) #FIXME: list_iterator\ndel X\n#FIXME: list_iterator\na['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())\n    a[\"DictReversevalueiteratorType\"] = reversed({}.values())\n    a[\"DictReverseitemiteratorType\"] = reversed({}.items())",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictionaryItemIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictionaryItemIteratorType'] = iter(type.__dict__.items())\na['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())\n    a[\"DictReversevalueiteratorType\"] = reversed({}.values())\n    a[\"DictReverseitemiteratorType\"] = reversed({}.items())\ntry:\n    import symtable\n    #FIXME: fails to pickle",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictionaryKeyIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictionaryKeyIteratorType'] = iter(type.__dict__.keys())\na['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())\n    a[\"DictReversevalueiteratorType\"] = reversed({}.values())\n    a[\"DictReverseitemiteratorType\"] = reversed({}.items())\ntry:\n    import symtable\n    #FIXME: fails to pickle\n    x[\"SymtableEntryType\"] = symtable.symtable(\"\", \"string\", \"exec\")._table",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['DictionaryValueIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['DictionaryValueIteratorType'] = iter(type.__dict__.values())\nif sys.hexversion >= 0x30800a0:\n    a[\"DictReversekeyiteratorType\"] = reversed({}.keys())\n    a[\"DictReversevalueiteratorType\"] = reversed({}.values())\n    a[\"DictReverseitemiteratorType\"] = reversed({}.items())\ntry:\n    import symtable\n    #FIXME: fails to pickle\n    x[\"SymtableEntryType\"] = symtable.symtable(\"\", \"string\", \"exec\")._table\nexcept ImportError:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['PrettyPrinterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['PrettyPrinterType'] = pprint.PrettyPrinter()\n# numeric and mathematical types (CH 9)\na['CycleType'] = itertools.cycle('0')\n# file and directory access (CH 10)\na['TemporaryFileType'] = _tmpf\n# data compression and archiving (CH 12)\nx['GzipFileType'] = gzip.GzipFile(fileobj=_fileW)\n# generic operating system services (CH 15)\na['StreamHandlerType'] = logging.StreamHandler()\n# numeric and mathematical types (CH 9)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CycleType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CycleType'] = itertools.cycle('0')\n# file and directory access (CH 10)\na['TemporaryFileType'] = _tmpf\n# data compression and archiving (CH 12)\nx['GzipFileType'] = gzip.GzipFile(fileobj=_fileW)\n# generic operating system services (CH 15)\na['StreamHandlerType'] = logging.StreamHandler()\n# numeric and mathematical types (CH 9)\na['PermutationsType'] = itertools.permutations('0')\na['CombinationsType'] = itertools.combinations('0',1)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['TemporaryFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['TemporaryFileType'] = _tmpf\n# data compression and archiving (CH 12)\nx['GzipFileType'] = gzip.GzipFile(fileobj=_fileW)\n# generic operating system services (CH 15)\na['StreamHandlerType'] = logging.StreamHandler()\n# numeric and mathematical types (CH 9)\na['PermutationsType'] = itertools.permutations('0')\na['CombinationsType'] = itertools.combinations('0',1)\na['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['GzipFileType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['GzipFileType'] = gzip.GzipFile(fileobj=_fileW)\n# generic operating system services (CH 15)\na['StreamHandlerType'] = logging.StreamHandler()\n# numeric and mathematical types (CH 9)\na['PermutationsType'] = itertools.permutations('0')\na['CombinationsType'] = itertools.combinations('0',1)\na['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['StreamHandlerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['StreamHandlerType'] = logging.StreamHandler()\n# numeric and mathematical types (CH 9)\na['PermutationsType'] = itertools.permutations('0')\na['CombinationsType'] = itertools.combinations('0',1)\na['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------\n# types module (part of CH 8)\nx['GeneratorType'] = _generator = _function(1) #XXX: priority",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['PermutationsType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['PermutationsType'] = itertools.permutations('0')\na['CombinationsType'] = itertools.combinations('0',1)\na['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------\n# types module (part of CH 8)\nx['GeneratorType'] = _generator = _function(1) #XXX: priority\nx['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CombinationsType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CombinationsType'] = itertools.combinations('0',1)\na['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------\n# types module (part of CH 8)\nx['GeneratorType'] = _generator = _function(1) #XXX: priority\nx['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RepeatType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RepeatType'] = itertools.repeat(0)\na['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------\n# types module (part of CH 8)\nx['GeneratorType'] = _generator = _function(1) #XXX: priority\nx['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types\n# (also: Capsule / CObject ?)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['CompressType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['CompressType'] = itertools.compress('0',[1])\n#XXX: ...and etc\n# -- dill fails on all below here -------------------------------------------\n# types module (part of CH 8)\nx['GeneratorType'] = _generator = _function(1) #XXX: priority\nx['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types\n# (also: Capsule / CObject ?)\n# built-in functions (CH 2)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['GeneratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['GeneratorType'] = _generator = _function(1) #XXX: priority\nx['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types\n# (also: Capsule / CObject ?)\n# built-in functions (CH 2)\n# built-in types (CH 5)\n# string services (CH 7)\nx['StructType'] = struct.Struct('c')\nx['CallableIteratorType'] = _srepattern.finditer('')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['FrameType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['FrameType'] = _generator.gi_frame #XXX: inspect.currentframe()\nx['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types\n# (also: Capsule / CObject ?)\n# built-in functions (CH 2)\n# built-in types (CH 5)\n# string services (CH 7)\nx['StructType'] = struct.Struct('c')\nx['CallableIteratorType'] = _srepattern.finditer('')\nx['SREMatchType'] = _srepattern.match('')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['TracebackType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['TracebackType'] = _function2()[1] #(see: inspect.getouterframes,getframeinfo)\n# other (concrete) object types\n# (also: Capsule / CObject ?)\n# built-in functions (CH 2)\n# built-in types (CH 5)\n# string services (CH 7)\nx['StructType'] = struct.Struct('c')\nx['CallableIteratorType'] = _srepattern.finditer('')\nx['SREMatchType'] = _srepattern.match('')\nx['SREScannerType'] = _srepattern.scanner('')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['StructType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['StructType'] = struct.Struct('c')\nx['CallableIteratorType'] = _srepattern.finditer('')\nx['SREMatchType'] = _srepattern.match('')\nx['SREScannerType'] = _srepattern.scanner('')\nx['StreamReader'] = codecs.StreamReader(_cstrI) #XXX: ... and etc\n# python object persistence (CH 11)\n# x['DbShelveType'] = shelve.open('foo','n')#,protocol=2) #XXX: delete foo\nif HAS_ALL:\n    z = a if IS_PYPY else x\n    z['DbmType'] = dbm.open(_tempfile,'n')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['CallableIteratorType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['CallableIteratorType'] = _srepattern.finditer('')\nx['SREMatchType'] = _srepattern.match('')\nx['SREScannerType'] = _srepattern.scanner('')\nx['StreamReader'] = codecs.StreamReader(_cstrI) #XXX: ... and etc\n# python object persistence (CH 11)\n# x['DbShelveType'] = shelve.open('foo','n')#,protocol=2) #XXX: delete foo\nif HAS_ALL:\n    z = a if IS_PYPY else x\n    z['DbmType'] = dbm.open(_tempfile,'n')\n    del z",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['SREMatchType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['SREMatchType'] = _srepattern.match('')\nx['SREScannerType'] = _srepattern.scanner('')\nx['StreamReader'] = codecs.StreamReader(_cstrI) #XXX: ... and etc\n# python object persistence (CH 11)\n# x['DbShelveType'] = shelve.open('foo','n')#,protocol=2) #XXX: delete foo\nif HAS_ALL:\n    z = a if IS_PYPY else x\n    z['DbmType'] = dbm.open(_tempfile,'n')\n    del z\n# x['DbCursorType'] = _dbcursor = anydbm.open('foo','n') #XXX: delete foo",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['SREScannerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['SREScannerType'] = _srepattern.scanner('')\nx['StreamReader'] = codecs.StreamReader(_cstrI) #XXX: ... and etc\n# python object persistence (CH 11)\n# x['DbShelveType'] = shelve.open('foo','n')#,protocol=2) #XXX: delete foo\nif HAS_ALL:\n    z = a if IS_PYPY else x\n    z['DbmType'] = dbm.open(_tempfile,'n')\n    del z\n# x['DbCursorType'] = _dbcursor = anydbm.open('foo','n') #XXX: delete foo\n# x['DbType'] = _dbcursor.db",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['StreamReader']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['StreamReader'] = codecs.StreamReader(_cstrI) #XXX: ... and etc\n# python object persistence (CH 11)\n# x['DbShelveType'] = shelve.open('foo','n')#,protocol=2) #XXX: delete foo\nif HAS_ALL:\n    z = a if IS_PYPY else x\n    z['DbmType'] = dbm.open(_tempfile,'n')\n    del z\n# x['DbCursorType'] = _dbcursor = anydbm.open('foo','n') #XXX: delete foo\n# x['DbType'] = _dbcursor.db\n# data compression and archiving (CH 12)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['ZlibCompressType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['ZlibCompressType'] = zlib.compressobj()\nx['ZlibDecompressType'] = zlib.decompressobj()\n# file formats (CH 13)\nx['CSVReaderType'] = csv.reader(_cstrI)\nx['CSVWriterType'] = csv.writer(_cstrO)\nx['CSVDictReaderType'] = csv.DictReader(_cstrI)\nx['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['ZlibDecompressType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['ZlibDecompressType'] = zlib.decompressobj()\n# file formats (CH 13)\nx['CSVReaderType'] = csv.reader(_cstrI)\nx['CSVWriterType'] = csv.writer(_cstrO)\nx['CSVDictReaderType'] = csv.DictReader(_cstrI)\nx['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['CSVReaderType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['CSVReaderType'] = csv.reader(_cstrI)\nx['CSVWriterType'] = csv.writer(_cstrO)\nx['CSVDictReaderType'] = csv.DictReader(_cstrI)\nx['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)\nelse:\n    x['HMACType'] = hmac.new(_in, digestmod='md5')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['CSVWriterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['CSVWriterType'] = csv.writer(_cstrO)\nx['CSVDictReaderType'] = csv.DictReader(_cstrI)\nx['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)\nelse:\n    x['HMACType'] = hmac.new(_in, digestmod='md5')\n# generic operating system services (CH 15)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['CSVDictReaderType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['CSVDictReaderType'] = csv.DictReader(_cstrI)\nx['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)\nelse:\n    x['HMACType'] = hmac.new(_in, digestmod='md5')\n# generic operating system services (CH 15)\nif HAS_CURSES: pass",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['CSVDictWriterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['CSVDictWriterType'] = csv.DictWriter(_cstrO,{})\n# cryptographic services (CH 14)\nx['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)\nelse:\n    x['HMACType'] = hmac.new(_in, digestmod='md5')\n# generic operating system services (CH 15)\nif HAS_CURSES: pass\n    #x['CursesWindowType'] = _curwin = curses.initscr() #FIXME: messes up tty",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['HashType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['HashType'] = hashlib.md5()\nif (sys.hexversion < 0x30800a1):\n    x['HMACType'] = hmac.new(_in)\nelse:\n    x['HMACType'] = hmac.new(_in, digestmod='md5')\n# generic operating system services (CH 15)\nif HAS_CURSES: pass\n    #x['CursesWindowType'] = _curwin = curses.initscr() #FIXME: messes up tty\n    #x['CursesTextPadType'] = textpad.Textbox(_curwin)\n    #x['CursesPanelType'] = panel.new_panel(_curwin)",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['MethodCallerType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['MethodCallerType'] = operator.methodcaller('mro') # 2.6\n# built-in types (CH 5)\nx['MemoryType'] = memoryview(_in) # 2.7\nx['MemoryType2'] = memoryview(bytearray(_in)) # 2.7\nd['DictItemsType'] = _dict.items() # 2.7\nd['DictKeysType'] = _dict.keys() # 2.7\nd['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['MemoryType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['MemoryType'] = memoryview(_in) # 2.7\nx['MemoryType2'] = memoryview(bytearray(_in)) # 2.7\nd['DictItemsType'] = _dict.items() # 2.7\nd['DictKeysType'] = _dict.keys() # 2.7\nd['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['MemoryType2']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['MemoryType2'] = memoryview(bytearray(_in)) # 2.7\nd['DictItemsType'] = _dict.items() # 2.7\nd['DictKeysType'] = _dict.keys() # 2.7\nd['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['DictItemsType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['DictItemsType'] = _dict.items() # 2.7\nd['DictKeysType'] = _dict.keys() # 2.7\nd['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['DictKeysType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['DictKeysType'] = _dict.keys() # 2.7\nd['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "d['DictValuesType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "d['DictValuesType'] = _dict.values() # 2.7\n# generic operating system services (CH 15)\na['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RawTextHelpFormatterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RawTextHelpFormatterType'] = argparse.RawTextHelpFormatter('PROG')\na['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['RawDescriptionHelpFormatterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['RawDescriptionHelpFormatterType'] = argparse.RawDescriptionHelpFormatter('PROG')\na['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "a['ArgDefaultsHelpFormatterType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "a['ArgDefaultsHelpFormatterType'] = argparse.ArgumentDefaultsHelpFormatter('PROG')\nz = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:\n    d['PyCapsuleType'] = _testcapsule",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z = a if IS_PYPY else x\nz['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:\n    d['PyCapsuleType'] = _testcapsule\ndel _testcapsule",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z['CmpKeyType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z['CmpKeyType'] = _cmpkey = functools.cmp_to_key(_methodwrap) # 2.7, >=3.2\nz['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:\n    d['PyCapsuleType'] = _testcapsule\ndel _testcapsule\nif hasattr(dataclasses, '_HAS_DEFAULT_FACTORY'):",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "z['CmpKeyObjType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "z['CmpKeyObjType'] = _cmpkey('0') #2.7, >=3.2\ndel z\n# oddities: removed, etc\nx['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:\n    d['PyCapsuleType'] = _testcapsule\ndel _testcapsule\nif hasattr(dataclasses, '_HAS_DEFAULT_FACTORY'):\n    a['DataclassesHasDefaultFactoryType'] = dataclasses._HAS_DEFAULT_FACTORY",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "x['BufferType']",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._objects",
        "description": "__pypackages__.3.10.lib.dill._objects",
        "peekOfCode": "x['BufferType'] = x['MemoryType']\nfrom dill._dill import _testcapsule\nif _testcapsule is not None:\n    d['PyCapsuleType'] = _testcapsule\ndel _testcapsule\nif hasattr(dataclasses, '_HAS_DEFAULT_FACTORY'):\n    a['DataclassesHasDefaultFactoryType'] = dataclasses._HAS_DEFAULT_FACTORY\nif hasattr(dataclasses, 'MISSING'):\n    a['DataclassesMissingType'] = dataclasses.MISSING\nif hasattr(dataclasses, 'KW_ONLY'):",
        "detail": "__pypackages__.3.10.lib.dill._objects",
        "documentation": {}
    },
    {
        "label": "Reduce",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "class Reduce(object):\n    \"\"\"\n    Reduce objects are wrappers used for compatibility enforcement during\n    unpickle-time. They should only be used in calls to pickler.save and\n    other Reduce objects. They are only evaluated within unpickler.load.\n    Pickling a Reduce object makes the two implementations equivalent:\n    pickler.save(Reduce(*reduction))\n    pickler.save_reduce(*reduction, obj=reduction)\n    \"\"\"\n    __slots__ = ['reduction']",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_CallableReduce",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "class _CallableReduce(Reduce):\n    # A version of Reduce for functions. Used to trick pickler.save_reduce into\n    # thinking that Reduce objects of functions are themselves meaningful functions.\n    def __call__(self, *args, **kwargs):\n        reduction = self.__reduce__()\n        func = reduction[0]\n        f_args = reduction[1]\n        obj = func(*f_args)\n        return obj(*args, **kwargs)\n__NO_DEFAULT = _dill.Sentinel('Getattr.NO_DEFAULT')",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "Getattr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "def Getattr(object, name, default=__NO_DEFAULT):\n    \"\"\"\n    A Reduce object that represents the getattr operation. When unpickled, the\n    Getattr will access an attribute 'name' of 'object' and return the value\n    stored there. If the attribute doesn't exist, the default value will be\n    returned if present.\n    The following statements are equivalent:\n    Getattr(collections, 'OrderedDict')\n    Getattr(collections, 'spam', None)\n    Getattr(*args)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "move_to",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "def move_to(module, name=None):\n    def decorator(func):\n        if name is None:\n            fname = func.__name__\n        else:\n            fname = name\n        module.__dict__[fname] = func\n        func.__module__ = module.__name__\n        return func\n    return decorator",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "register_shim",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "def register_shim(name, default):\n    \"\"\"\n    A easier to understand and more compact way of \"softly\" defining a function.\n    These two pieces of code are equivalent:\n    if _dill.OLD3X:\n        def _create_class():\n            ...\n    _create_class = register_shim('_create_class', types.new_class)\n    if _dill.OLD3X:\n        @move_to(_dill)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_import_module",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_import_module = Getattr(importlib, 'import_module', Getattr(_dill, '_import_module', None))\nThe code will attempt to find import_module in the importlib module. If not\npresent, it will use the _import_module function in _dill.\nEmulate new Python behavior in older Python versions:\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCellType.cell_contents behaves differently in Python 3.6 and 3.7. It is\nread-only in Python 3.6 and writable and deletable in 3.7.\nif _dill.OLD37 and _dill.HAS_CTYPES and ...:\n    @move_to(_dill)\n    def _setattr(object, name, value):",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_setattr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_setattr = Getattr(_dill, '_setattr', setattr)\n_dill._setattr will be used when present to emulate Python 3.7 functionality in\nolder versions of Python while defaulting to the standard setattr in 3.7+.\nSee this PR for the discussion that lead to this system:\nhttps://github.com/uqfoundation/dill/pull/443\n\"\"\"\nimport inspect\nimport sys\n_dill = sys.modules['dill._dill']\nclass Reduce(object):",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_dill",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_dill = sys.modules['dill._dill']\nclass Reduce(object):\n    \"\"\"\n    Reduce objects are wrappers used for compatibility enforcement during\n    unpickle-time. They should only be used in calls to pickler.save and\n    other Reduce objects. They are only evaluated within unpickler.load.\n    Pickling a Reduce object makes the two implementations equivalent:\n    pickler.save(Reduce(*reduction))\n    pickler.save_reduce(*reduction, obj=reduction)\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "__NO_DEFAULT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "__NO_DEFAULT = _dill.Sentinel('Getattr.NO_DEFAULT')\ndef Getattr(object, name, default=__NO_DEFAULT):\n    \"\"\"\n    A Reduce object that represents the getattr operation. When unpickled, the\n    Getattr will access an attribute 'name' of 'object' and return the value\n    stored there. If the attribute doesn't exist, the default value will be\n    returned if present.\n    The following statements are equivalent:\n    Getattr(collections, 'OrderedDict')\n    Getattr(collections, 'spam', None)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "Getattr.NO_DEFAULT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "Getattr.NO_DEFAULT = __NO_DEFAULT\ndel __NO_DEFAULT\ndef move_to(module, name=None):\n    def decorator(func):\n        if name is None:\n            fname = func.__name__\n        else:\n            fname = name\n        module.__dict__[fname] = func\n        func.__module__ = module.__name__",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_CELL_EMPTY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_CELL_EMPTY = register_shim('_CELL_EMPTY', None)\n_setattr = register_shim('_setattr', setattr)\n_delattr = register_shim('_delattr', delattr)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_setattr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_setattr = register_shim('_setattr', setattr)\n_delattr = register_shim('_delattr', delattr)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "_delattr",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill._shims",
        "description": "__pypackages__.3.10.lib.dill._shims",
        "peekOfCode": "_delattr = register_shim('_delattr', delattr)",
        "detail": "__pypackages__.3.10.lib.dill._shims",
        "documentation": {}
    },
    {
        "label": "getmodule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def getmodule(object, _filename=None, force=False):\n    \"\"\"get the module of the object\"\"\"\n    from inspect import getmodule as getmod\n    module = getmod(object, _filename)\n    if module or not force: return module\n    import builtins\n    from .source import getname\n    name = getname(object, force=True)\n    return builtins if name in vars(builtins).keys() else None\ndef outermost(func): # is analogous to getsource(func,enclosing=True)",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "outermost",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def outermost(func): # is analogous to getsource(func,enclosing=True)\n    \"\"\"get outermost enclosing object (i.e. the outer function in a closure)\n    NOTE: this is the object-equivalent of getsource(func, enclosing=True)\n    \"\"\"\n    if ismethod(func):\n        _globals = func.__func__.__globals__ or {}\n    elif isfunction(func):\n        _globals = func.__globals__ or {}\n    else:\n        return #XXX: or raise? no matches",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "nestedcode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def nestedcode(func, recurse=True): #XXX: or return dict of {co_name: co} ?\n    \"\"\"get the code objects for any nested functions (e.g. in a closure)\"\"\"\n    func = code(func)\n    if not iscode(func): return [] #XXX: or raise? no matches\n    nested = set()\n    for co in func.co_consts:\n        if co is None: continue\n        co = code(co)\n        if co:\n            nested.add(co)",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def code(func):\n    \"\"\"get the code object for the given function or method\n    NOTE: use dill.source.getsource(CODEOBJ) to get the source code\n    \"\"\"\n    if ismethod(func): func = func.__func__\n    if isfunction(func): func = func.__code__\n    if istraceback(func): func = func.tb_frame\n    if isframe(func): func = func.f_code\n    if iscode(func): return func\n    return",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "referrednested",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def referrednested(func, recurse=True): #XXX: return dict of {__name__: obj} ?\n    \"\"\"get functions defined inside of func (e.g. inner functions in a closure)\n    NOTE: results may differ if the function has been executed or not.\n    If len(nestedcode(func)) > len(referrednested(func)), try calling func().\n    If possible, python builds code objects, but delays building functions\n    until func() is called.\n    \"\"\"\n    import gc\n    funcs = set()\n    # get the code objects, and try to track down by referrence",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "freevars",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def freevars(func):\n    \"\"\"get objects defined in enclosing code that are referred to by func\n    returns a dict of {name:object}\"\"\"\n    if ismethod(func): func = func.__func__\n    if isfunction(func):\n        closures = func.__closure__ or ()\n        func = func.__code__.co_freevars # get freevars\n    else:\n        return {}\n    def get_cell_contents():",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "nestedglobals",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def nestedglobals(func, recurse=True):\n    \"\"\"get the names of any globals found within func\"\"\"\n    func = code(func)\n    if func is None: return list()\n    import sys\n    from .temp import capture\n    CAN_NULL = sys.hexversion >= 0x30b00a7 # NULL may be prepended >= 3.11a7\n    names = set()\n    with capture('stdout') as out:\n        dis.dis(func) #XXX: dis.dis(None) disassembles last traceback",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "referredglobals",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def referredglobals(func, recurse=True, builtin=False):\n    \"\"\"get the names of objects in the global scope referred to by func\"\"\"\n    return globalvars(func, recurse, builtin).keys()\ndef globalvars(func, recurse=True, builtin=False):\n    \"\"\"get objects defined in global scope that are referred to by func\n    return a dict of {name:object}\"\"\"\n    if ismethod(func): func = func.__func__\n    if isfunction(func):\n        globs = vars(getmodule(sum)).copy() if builtin else {}\n        # get references from within closure",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "globalvars",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def globalvars(func, recurse=True, builtin=False):\n    \"\"\"get objects defined in global scope that are referred to by func\n    return a dict of {name:object}\"\"\"\n    if ismethod(func): func = func.__func__\n    if isfunction(func):\n        globs = vars(getmodule(sum)).copy() if builtin else {}\n        # get references from within closure\n        orig_func, func = func, set()\n        for obj in orig_func.__closure__ or {}:\n            try:",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "varnames",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def varnames(func):\n    \"\"\"get names of variables defined by func\n    returns a tuple (local vars, local vars referrenced by nested functions)\"\"\"\n    func = code(func)\n    if not iscode(func):\n        return () #XXX: better ((),())? or None?\n    return func.co_varnames, func.co_cellvars\ndef baditems(obj, exact=False, safe=False): #XXX: obj=globals() ?\n    \"\"\"get items in object that fail to pickle\"\"\"\n    if not hasattr(obj,'__iter__'): # is not iterable",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "baditems",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def baditems(obj, exact=False, safe=False): #XXX: obj=globals() ?\n    \"\"\"get items in object that fail to pickle\"\"\"\n    if not hasattr(obj,'__iter__'): # is not iterable\n        return [j for j in (badobjects(obj,0,exact,safe),) if j is not None]\n    obj = obj.values() if getattr(obj,'values',None) else obj\n    _obj = [] # can't use a set, as items may be unhashable\n    [_obj.append(badobjects(i,0,exact,safe)) for i in obj if i not in _obj]\n    return [j for j in _obj if j is not None]\ndef badobjects(obj, depth=0, exact=False, safe=False):\n    \"\"\"get objects that fail to pickle\"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "badobjects",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def badobjects(obj, depth=0, exact=False, safe=False):\n    \"\"\"get objects that fail to pickle\"\"\"\n    from dill import pickles\n    if not depth:\n        if pickles(obj,exact,safe): return None\n        return obj\n    return dict(((attr, badobjects(getattr(obj,attr),depth-1,exact,safe)) \\\n           for attr in dir(obj) if not pickles(getattr(obj,attr),exact,safe)))\ndef badtypes(obj, depth=0, exact=False, safe=False):\n    \"\"\"get types for objects that fail to pickle\"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "badtypes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def badtypes(obj, depth=0, exact=False, safe=False):\n    \"\"\"get types for objects that fail to pickle\"\"\"\n    from dill import pickles\n    if not depth:\n        if pickles(obj,exact,safe): return None\n        return type(obj)\n    return dict(((attr, badtypes(getattr(obj,attr),depth-1,exact,safe)) \\\n           for attr in dir(obj) if not pickles(getattr(obj,attr),exact,safe)))\ndef errors(obj, depth=0, exact=False, safe=False):\n    \"\"\"get errors for objects that fail to pickle\"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "errors",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "def errors(obj, depth=0, exact=False, safe=False):\n    \"\"\"get errors for objects that fail to pickle\"\"\"\n    from dill import pickles, copy\n    if not depth:\n        try:\n            pik = copy(obj)\n            if exact:\n                assert pik == obj, \\\n                    \"Unpickling produces %s instead of %s\" % (pik,obj)\n            assert type(pik) == type(obj), \\",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.detect",
        "description": "__pypackages__.3.10.lib.dill.detect",
        "peekOfCode": "__all__ = ['baditems','badobjects','badtypes','code','errors','freevars',\n           'getmodule','globalvars','nestedcode','nestedglobals','outermost',\n           'referredglobals','referrednested','trace','varnames']\ndef getmodule(object, _filename=None, force=False):\n    \"\"\"get the module of the object\"\"\"\n    from inspect import getmodule as getmod\n    module = getmod(object, _filename)\n    if module or not force: return module\n    import builtins\n    from .source import getname",
        "detail": "__pypackages__.3.10.lib.dill.detect",
        "documentation": {}
    },
    {
        "label": "TraceAdapter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "class TraceAdapter(logging.LoggerAdapter):\n    \"\"\"\n    Tracks object tree depth and calculates pickled object size.\n    A single instance of this wraps the module's logger, as the logging API\n    doesn't allow setting it directly with a custom Logger subclass.  The added\n    'trace()' method receives a pickle instance as the first argument and\n    creates extra values to be added in the LogRecord from it, then calls\n    'info()'.\n    Usage of logger with 'trace()' method:\n    >>> from dill.logger import adapter as logger  #NOTE: not dill.logger.logger",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "TraceFormatter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "class TraceFormatter(logging.Formatter):\n    \"\"\"\n    Generates message prefix and suffix from record.\n    This Formatter adds prefix and suffix strings to the log message in trace\n    mode (an also provides empty string defaults for normal logs).\n    \"\"\"\n    def __init__(self, *args, handler=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        try:\n            encoding = handler.stream.encoding",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "TraceManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "class TraceManager(contextlib.AbstractContextManager):\n    \"\"\"context manager version of trace(); can redirect the trace to a file\"\"\"\n    def __init__(self, file, mode):\n        self.file = file\n        self.mode = mode\n        self.redirect = file is not None\n        self.file_is_stream = hasattr(file, 'write')\n    def __enter__(self):\n        if self.redirect:\n            stderr_handler.flush()",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "trace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "def trace(arg: Union[bool, TextIO, str, os.PathLike] = None, *, mode: str = 'a') -> None:\n    \"\"\"print a trace through the stack when pickling; useful for debugging\n    With a single boolean argument, enable or disable the tracing.\n    Example usage:\n        >>> import dill\n        >>> dill.detect.trace(True)\n        >>> dill.dump_session()\n    Alternatively, ``trace()`` can be used as a context manager. With no\n    arguments, it just takes care of restoring the tracing state on exit.\n    Either a file handle, or a file name and (optionally) a file mode may be",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "__all__ = ['adapter', 'logger', 'trace']\nimport codecs\nimport contextlib\nimport locale\nimport logging\nimport math\nimport os\nfrom functools import partial\nfrom typing import TextIO, Union\nimport dill",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "ASCII_MAP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "ASCII_MAP = str.maketrans({\"│\": \"|\", \"├\": \"|\", \"┬\": \"+\", \"└\": \"`\"})\n## Notes about the design choices ##\n# Here is some domumentation of the Standard Library's logging internals that\n# can't be found completely in the official documentation.  dill's logger is\n# obtained by calling logging.getLogger('dill') and therefore is an instance of\n# logging.getLoggerClass() at the call time.  As this is controlled by the user,\n# in order to add some functionality to it it's necessary to use a LoggerAdapter\n# to wrap it, overriding some of the adapter's methods and creating new ones.\n#\n# Basic calling sequence",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "logger = logging.getLogger('dill')\nlogger.propagate = False\nadapter = TraceAdapter(logger)\nstderr_handler = logging._StderrHandler()\nadapter.addHandler(stderr_handler)\ndef trace(arg: Union[bool, TextIO, str, os.PathLike] = None, *, mode: str = 'a') -> None:\n    \"\"\"print a trace through the stack when pickling; useful for debugging\n    With a single boolean argument, enable or disable the tracing.\n    Example usage:\n        >>> import dill",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "logger.propagate",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "logger.propagate = False\nadapter = TraceAdapter(logger)\nstderr_handler = logging._StderrHandler()\nadapter.addHandler(stderr_handler)\ndef trace(arg: Union[bool, TextIO, str, os.PathLike] = None, *, mode: str = 'a') -> None:\n    \"\"\"print a trace through the stack when pickling; useful for debugging\n    With a single boolean argument, enable or disable the tracing.\n    Example usage:\n        >>> import dill\n        >>> dill.detect.trace(True)",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "adapter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "adapter = TraceAdapter(logger)\nstderr_handler = logging._StderrHandler()\nadapter.addHandler(stderr_handler)\ndef trace(arg: Union[bool, TextIO, str, os.PathLike] = None, *, mode: str = 'a') -> None:\n    \"\"\"print a trace through the stack when pickling; useful for debugging\n    With a single boolean argument, enable or disable the tracing.\n    Example usage:\n        >>> import dill\n        >>> dill.detect.trace(True)\n        >>> dill.dump_session()",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "stderr_handler",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.logger",
        "description": "__pypackages__.3.10.lib.dill.logger",
        "peekOfCode": "stderr_handler = logging._StderrHandler()\nadapter.addHandler(stderr_handler)\ndef trace(arg: Union[bool, TextIO, str, os.PathLike] = None, *, mode: str = 'a') -> None:\n    \"\"\"print a trace through the stack when pickling; useful for debugging\n    With a single boolean argument, enable or disable the tracing.\n    Example usage:\n        >>> import dill\n        >>> dill.detect.trace(True)\n        >>> dill.dump_session()\n    Alternatively, ``trace()`` can be used as a context manager. With no",
        "detail": "__pypackages__.3.10.lib.dill.logger",
        "documentation": {}
    },
    {
        "label": "parent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "def parent(obj, objtype, ignore=()):\n    \"\"\"\n>>> listiter = iter([4,5,6,7])\n>>> obj = parent(listiter, list)\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\nTrue\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\nParent finds *one* parent (e.g. the last member of the sequence).\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "parents",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "def parents(obj, objtype, depth=1, ignore=()): #XXX: objtype=object ?\n    \"\"\"Find the chain of referents for obj. Chain will end with obj.\n    objtype: an object type or tuple of types to search for\n    depth: search depth (e.g. depth=2 is 'grandparents')\n    ignore: an object or tuple of objects to ignore in the search\n    \"\"\"\n    edge_func = gc.get_referents # looking for refs, not back_refs\n    predicate = lambda x: isinstance(x, objtype) # looking for parent type\n   #if objtype is None: predicate = lambda x: True #XXX: in obj.mro() ?\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "children",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "def children(obj, objtype, depth=1, ignore=()): #XXX: objtype=object ?\n    \"\"\"Find the chain of referrers for obj. Chain will start with obj.\n    objtype: an object type or tuple of types to search for\n    depth: search depth (e.g. depth=2 is 'grandchildren')\n    ignore: an object or tuple of objects to ignore in the search\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\n    NOTE: repeated calls may yield different results, as python stores\n    the last value in the special variable '_'; thus, it is often good\n    to execute something to replace '_' (e.g. >>> 1+1).\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "find_chain",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "__all__ = ['parent', 'reference', 'at', 'parents', 'children']\nimport gc\nimport sys\nfrom ._dill import _proxy_helper as reference\nfrom ._dill import _locate_object as at\ndef parent(obj, objtype, ignore=()):\n    \"\"\"\n>>> listiter = iter([4,5,6,7])\n>>> obj = parent(listiter, list)\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "refobject",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.pointers",
        "description": "__pypackages__.3.10.lib.dill.pointers",
        "peekOfCode": "refobject = at\n# EOF",
        "detail": "__pypackages__.3.10.lib.dill.pointers",
        "documentation": {}
    },
    {
        "label": "_PeekableReader",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "class _PeekableReader:\n    \"\"\"lightweight stream wrapper that implements peek()\"\"\"\n    def __init__(self, stream):\n        self.stream = stream\n    def read(self, n):\n        return self.stream.read(n)\n    def readline(self):\n        return self.stream.readline()\n    def tell(self):\n        return self.stream.tell()",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "dump_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "def dump_module(\n    filename = str(TEMPDIR/'session.pkl'),\n    module: Optional[Union[ModuleType, str]] = None,\n    refimported: bool = False,\n    **kwds\n) -> None:\n    \"\"\"Pickle the current state of :py:mod:`__main__` or another module to a file.\n    Save the contents of :py:mod:`__main__` (e.g. from an interactive\n    interpreter session), an imported module, or a module-type object (e.g.\n    built with :py:class:`~types.ModuleType`), to a file. The pickled",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "dump_session",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "def dump_session(filename=str(TEMPDIR/'session.pkl'), main=None, byref=False, **kwds):\n    warnings.warn(\"dump_session() has been renamed dump_module()\", PendingDeprecationWarning)\n    dump_module(filename, module=main, refimported=byref, **kwds)\ndump_session.__doc__ = dump_module.__doc__\nclass _PeekableReader:\n    \"\"\"lightweight stream wrapper that implements peek()\"\"\"\n    def __init__(self, stream):\n        self.stream = stream\n    def read(self, n):\n        return self.stream.read(n)",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "load_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "def load_module(\n    filename = str(TEMPDIR/'session.pkl'),\n    module: Optional[Union[ModuleType, str]] = None,\n    **kwds\n) -> Optional[ModuleType]:\n    \"\"\"Update the selected module (default is :py:mod:`__main__`) with\n    the state saved at ``filename``.\n    Restore a module to the state saved with :py:func:`dump_module`. The\n    saved module can be :py:mod:`__main__` (e.g. an interpreter session),\n    an imported module, or a module-type object (e.g. created with",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "load_session",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "def load_session(filename=str(TEMPDIR/'session.pkl'), main=None, **kwds):\n    warnings.warn(\"load_session() has been renamed load_module().\", PendingDeprecationWarning)\n    load_module(filename, module=main, **kwds)\nload_session.__doc__ = load_module.__doc__\ndef load_module_asdict(\n    filename = str(TEMPDIR/'session.pkl'),\n    update: bool = False,\n    **kwds\n) -> dict:\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "load_module_asdict",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "def load_module_asdict(\n    filename = str(TEMPDIR/'session.pkl'),\n    update: bool = False,\n    **kwds\n) -> dict:\n    \"\"\"\n    Load the contents of a saved module into a dictionary.\n    ``load_module_asdict()`` is the near-equivalent of::\n        lambda filename: vars(dill.load_module(filename)).copy()\n    however, does not alter the original module. Also, the path of",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "__all__ = [\n    'dump_module', 'load_module', 'load_module_asdict',\n    'dump_session', 'load_session' # backward compatibility\n]\nimport re\nimport sys\nimport warnings\nfrom dill import _dill, Pickler, Unpickler\nfrom ._dill import (\n    BuiltinMethodType, FunctionType, MethodType, ModuleType, TypeType,",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "TEMPDIR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "TEMPDIR = pathlib.PurePath(tempfile.gettempdir())\ndef _module_map():\n    \"\"\"get map of imported modules\"\"\"\n    from collections import defaultdict\n    from types import SimpleNamespace\n    modmap = SimpleNamespace(\n        by_name=defaultdict(list),\n        by_id=defaultdict(list),\n        top_level={},\n    )",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "IMPORTED_AS_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "IMPORTED_AS_TYPES = (ModuleType, TypeType, FunctionType, MethodType, BuiltinMethodType)\nif 'PyCapsuleType' in _reverse_typemap:\n    IMPORTED_AS_TYPES += (_reverse_typemap['PyCapsuleType'],)\nIMPORTED_AS_MODULES = ('ctypes', 'typing', 'subprocess', 'threading',\n                               r'concurrent\\.futures(\\.\\w+)?', r'multiprocessing(\\.\\w+)?')\nIMPORTED_AS_MODULES = tuple(re.compile(x) for x in IMPORTED_AS_MODULES)\ndef _lookup_module(modmap, name, obj, main_module):\n    \"\"\"lookup name or id of obj if module is imported\"\"\"\n    for modobj, modname in modmap.by_name[name]:\n        if modobj is obj and sys.modules[modname] is not main_module:",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "IMPORTED_AS_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "IMPORTED_AS_MODULES = ('ctypes', 'typing', 'subprocess', 'threading',\n                               r'concurrent\\.futures(\\.\\w+)?', r'multiprocessing(\\.\\w+)?')\nIMPORTED_AS_MODULES = tuple(re.compile(x) for x in IMPORTED_AS_MODULES)\ndef _lookup_module(modmap, name, obj, main_module):\n    \"\"\"lookup name or id of obj if module is imported\"\"\"\n    for modobj, modname in modmap.by_name[name]:\n        if modobj is obj and sys.modules[modname] is not main_module:\n            return modname, name\n    __module__ = getattr(obj, '__module__', None)\n    if isinstance(obj, IMPORTED_AS_TYPES) or (__module__ is not None",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "IMPORTED_AS_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "IMPORTED_AS_MODULES = tuple(re.compile(x) for x in IMPORTED_AS_MODULES)\ndef _lookup_module(modmap, name, obj, main_module):\n    \"\"\"lookup name or id of obj if module is imported\"\"\"\n    for modobj, modname in modmap.by_name[name]:\n        if modobj is obj and sys.modules[modname] is not main_module:\n            return modname, name\n    __module__ = getattr(obj, '__module__', None)\n    if isinstance(obj, IMPORTED_AS_TYPES) or (__module__ is not None\n            and any(regex.fullmatch(__module__) for regex in IMPORTED_AS_MODULES)):\n        for modobj, objname, modname in modmap.by_id[id(obj)]:",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "dump_session.__doc__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "dump_session.__doc__ = dump_module.__doc__\nclass _PeekableReader:\n    \"\"\"lightweight stream wrapper that implements peek()\"\"\"\n    def __init__(self, stream):\n        self.stream = stream\n    def read(self, n):\n        return self.stream.read(n)\n    def readline(self):\n        return self.stream.readline()\n    def tell(self):",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "load_session.__doc__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.session",
        "description": "__pypackages__.3.10.lib.dill.session",
        "peekOfCode": "load_session.__doc__ = load_module.__doc__\ndef load_module_asdict(\n    filename = str(TEMPDIR/'session.pkl'),\n    update: bool = False,\n    **kwds\n) -> dict:\n    \"\"\"\n    Load the contents of a saved module into a dictionary.\n    ``load_module_asdict()`` is the near-equivalent of::\n        lambda filename: vars(dill.load_module(filename)).copy()",
        "detail": "__pypackages__.3.10.lib.dill.session",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.settings",
        "description": "__pypackages__.3.10.lib.dill.settings",
        "peekOfCode": "settings = {\n   #'main' : None,\n    'protocol' : DEFAULT_PROTOCOL,\n    'byref' : False,\n   #'strictio' : False,\n    'fmode' : 0, #HANDLE_FMODE\n    'recurse' : False,\n    'ignore' : False,\n}\ndel DEFAULT_PROTOCOL",
        "detail": "__pypackages__.3.10.lib.dill.settings",
        "documentation": {}
    },
    {
        "label": "isfrommain",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def isfrommain(obj):\n    \"check if object was built in __main__\"\n    module = getmodule(obj)\n    if module and module.__name__ == '__main__':\n        return True\n    return False\ndef isdynamic(obj):\n    \"check if object was built in the interpreter\"\n    try: file = getfile(obj)\n    except TypeError: file = None",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "isdynamic",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def isdynamic(obj):\n    \"check if object was built in the interpreter\"\n    try: file = getfile(obj)\n    except TypeError: file = None\n    if file == '<stdin>' and isfrommain(obj):\n        return True\n    return False\ndef _matchlambda(func, line):\n    \"\"\"check if lambda object 'func' matches raw line of code 'line'\"\"\"\n    from .detect import code as getcode",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "findsource",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def findsource(object):\n    \"\"\"Return the entire source file and starting line number for an object.\n    For interactively-defined objects, the 'file' is the interpreter's history.\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An IOError\n    is raised if the source code cannot be retrieved, while a TypeError is\n    raised for objects where the source code is unavailable (e.g. builtins).\"\"\"\n    module = getmodule(object)\n    try: file = getfile(module)",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getblocks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getblocks(object, lstrip=False, enclosing=False, locate=False):\n    \"\"\"Return a list of source lines and starting line number for an object.\n    Interactively-defined objects refer to lines in the interpreter's history.\n    If enclosing=True, then also return any enclosing code.\n    If lstrip=True, ensure there is no indentation in the first line of code.\n    If locate=True, then also return the line number for the block of code.\n    DEPRECATED: use 'getsourcelines' instead\n    \"\"\"\n    lines, lnum = findsource(object)\n    if ismodule(object):",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getsourcelines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getsourcelines(object, lstrip=False, enclosing=False):\n    \"\"\"Return a list of source lines and starting line number for an object.\n    Interactively-defined objects refer to lines in the interpreter's history.\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of the lines\n    corresponding to the object and the line number indicates where in the\n    original source file the first line of code was found.  An IOError is\n    raised if the source code cannot be retrieved, while a TypeError is\n    raised for objects where the source code is unavailable (e.g. builtins).\n    If lstrip=True, ensure there is no indentation in the first line of code.",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getsource",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getsource(object, alias='', lstrip=False, enclosing=False, \\\n                                              force=False, builtin=False):\n    \"\"\"Return the text of the source code for an object. The source code for\n    interactively-defined objects are extracted from the interpreter's history.\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a single string.  An\n    IOError is raised if the source code cannot be retrieved, while a\n    TypeError is raised for objects where the source code is unavailable\n    (e.g. builtins).\n    If alias is provided, then add a line of code that renames the object.",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "indent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def indent(code, spaces=4):\n    '''indent a block of code with whitespace (default is 4 spaces)'''\n    indent = indentsize(code)\n    if type(spaces) is int: spaces = ' '*spaces\n    # if '\\t' is provided, will indent with a tab\n    nspaces = indentsize(spaces)\n    # blank lines (etc) need to be ignored\n    lines = code.split('\\n')\n##  stq = \"'''\"; dtq = '\"\"\"'\n##  in_stq = in_dtq = False",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "outdent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def outdent(code, spaces=None, all=True):\n    '''outdent a block of code (default is to strip all leading whitespace)'''\n    indent = indentsize(code)\n    if spaces is None or spaces > indent or spaces < 0: spaces = indent\n    #XXX: will this delete '\\n' in some cases?\n    if not all: return code[spaces:]\n    return '\\n'.join(_outdent(code.split('\\n'), spaces=spaces, all=all))\n#XXX: not sure what the point of _wrap is...\n__globals__ = globals()\n__locals__ = locals()",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "dumpsource",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def dumpsource(object, alias='', new=False, enclose=True):\n    \"\"\"'dump to source', where the code includes a pickled object.\n    If new=True and object is a class instance, then create a new\n    instance using the unpacked class source code. If enclose, then\n    create the object inside a function enclosure (thus minimizing\n    any global namespace pollution).\n    \"\"\"\n    from dill import dumps\n    pik = repr(dumps(object))\n    code = 'import dill\\n'",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getname",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getname(obj, force=False, fqn=False): #XXX: throw(?) to raise error on fail?\n    \"\"\"get the name of the object. for lambdas, get the name of the pointer \"\"\"\n    if fqn: return '.'.join(_namespace(obj))\n    module = getmodule(obj)\n    if not module: # things like \"None\" and \"1\"\n        if not force: return None\n        return repr(obj)\n    try:\n        #XXX: 'wrong' for decorators and curried functions ?\n        #       if obj.func_closure: ...use logic from getimportable, etc ?",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getimport",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getimport(obj, alias='', verify=True, builtin=False, enclosing=False):\n    \"\"\"get the likely import string for the given object\n    obj is the object to inspect\n    If verify=True, then test the import string before returning it.\n    If builtin=True, then force an import for builtins where possible.\n    If enclosing=True, get the import for the outermost enclosing callable.\n    If alias is provided, then rename the object on import.\n    \"\"\"\n    if enclosing:\n        from .detect import outermost",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "importable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def importable(obj, alias='', source=None, builtin=True):\n    \"\"\"get an importable string (i.e. source code or the import string)\n    for the given object, including any required objects from the enclosing\n    and global scope\n    This function will attempt to discover the name of the object, or the repr\n    of the object, or the source code for the object. To attempt to force\n    discovery of the source code, use source=True, to attempt to force the\n    use of an import, use source=False; otherwise an import will be sought\n    for objects not defined in __main__. The intent is to build a string\n    that can be imported from a python file.",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getimportable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def getimportable(obj, alias='', byname=True, explicit=False):\n    return importable(obj,alias,source=(not byname),builtin=explicit)\n   #return outdent(_importable(obj,alias,source=(not byname),builtin=explicit))\ndef likely_import(obj, passive=False, explicit=False):\n    return getimport(obj, verify=(not passive), builtin=explicit)\ndef _likely_import(first, last, passive=False, explicit=True):\n    return _getimport(first, last, verify=(not passive), builtin=explicit)\n_get_name = getname\ngetblocks_from_history = getblocks\n# EOF",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "likely_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "def likely_import(obj, passive=False, explicit=False):\n    return getimport(obj, verify=(not passive), builtin=explicit)\ndef _likely_import(first, last, passive=False, explicit=True):\n    return _getimport(first, last, verify=(not passive), builtin=explicit)\n_get_name = getname\ngetblocks_from_history = getblocks\n# EOF",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "__all__ = ['findsource', 'getsourcelines', 'getsource', 'indent', 'outdent', \\\n           '_wrap', 'dumpsource', 'getname', '_namespace', 'getimport', \\\n           '_importable', 'importable','isdynamic', 'isfrommain']\nimport linecache\nimport re\nfrom inspect import (getblock, getfile, getmodule, getsourcefile, indentsize,\n                     isbuiltin, isclass, iscode, isframe, isfunction, ismethod,\n                     ismodule, istraceback)\nfrom tokenize import TokenError\nfrom ._dill import IS_IPYTHON",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "__globals__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "__globals__ = globals()\n__locals__ = locals()\ndef _wrap(f):\n    \"\"\" encapsulate a function and it's __import__ \"\"\"\n    def func(*args, **kwds):\n        try:\n            # _ = eval(getsource(f, force=True)) #XXX: safer but less robust\n            exec(getimportable(f, alias='_'), __globals__, __locals__)\n        except Exception:\n            raise ImportError('cannot import name ' + f.__name__)",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "__locals__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "__locals__ = locals()\ndef _wrap(f):\n    \"\"\" encapsulate a function and it's __import__ \"\"\"\n    def func(*args, **kwds):\n        try:\n            # _ = eval(getsource(f, force=True)) #XXX: safer but less robust\n            exec(getimportable(f, alias='_'), __globals__, __locals__)\n        except Exception:\n            raise ImportError('cannot import name ' + f.__name__)\n        return _(*args, **kwds)",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "_get_name",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "_get_name = getname\ngetblocks_from_history = getblocks\n# EOF",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "getblocks_from_history",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.source",
        "description": "__pypackages__.3.10.lib.dill.source",
        "peekOfCode": "getblocks_from_history = getblocks\n# EOF",
        "detail": "__pypackages__.3.10.lib.dill.source",
        "documentation": {}
    },
    {
        "label": "capture",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def capture(stream='stdout'):\n    \"\"\"builds a context that temporarily replaces the given stream name\n    >>> with capture('stdout') as out:\n    ...   print (\"foo!\")\n    ... \n    >>> print (out.getvalue())\n    foo!\n    \"\"\"\n    import sys\n    from io import StringIO",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def b(x): # deal with b'foo' versus 'foo'\n    import codecs\n    return codecs.latin_1_encode(x)[0]\ndef load_source(file, **kwds):\n    \"\"\"load an object that was stored with dill.temp.dump_source\n    file: filehandle\n    alias: string name of stored object\n    mode: mode to open the file, one of: {'r', 'rb'}\n    >>> f = lambda x: x**2\n    >>> pyfile = dill.temp.dump_source(f, alias='_f')",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "load_source",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def load_source(file, **kwds):\n    \"\"\"load an object that was stored with dill.temp.dump_source\n    file: filehandle\n    alias: string name of stored object\n    mode: mode to open the file, one of: {'r', 'rb'}\n    >>> f = lambda x: x**2\n    >>> pyfile = dill.temp.dump_source(f, alias='_f')\n    >>> _f = dill.temp.load_source(pyfile)\n    >>> _f(4)\n    16",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "dump_source",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def dump_source(object, **kwds):\n    \"\"\"write object source to a NamedTemporaryFile (instead of dill.dump)\nLoads with \"import\" or \"dill.temp.load_source\".  Returns the filehandle.\n    >>> f = lambda x: x**2\n    >>> pyfile = dill.temp.dump_source(f, alias='_f')\n    >>> _f = dill.temp.load_source(pyfile)\n    >>> _f(4)\n    16\n    >>> f = lambda x: x**2\n    >>> pyfile = dill.temp.dump_source(f, dir='.')",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def load(file, **kwds):\n    \"\"\"load an object that was stored with dill.temp.dump\n    file: filehandle\n    mode: mode to open the file, one of: {'r', 'rb'}\n    >>> dumpfile = dill.temp.dump([1, 2, 3, 4, 5])\n    >>> dill.temp.load(dumpfile)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    import dill as pickle\n    mode = kwds.pop('mode', 'rb')",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def dump(object, **kwds):\n    \"\"\"dill.dump of object to a NamedTemporaryFile.\nLoads with \"dill.temp.load\".  Returns the filehandle.\n    >>> dumpfile = dill.temp.dump([1, 2, 3, 4, 5])\n    >>> dill.temp.load(dumpfile)\n    [1, 2, 3, 4, 5]\nOptional kwds:\n    If 'suffix' is specified, the file name will end with that suffix,\n    otherwise there will be no suffix.\n    If 'prefix' is specified, the file name will begin with that prefix,",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "loadIO",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def loadIO(buffer, **kwds):\n    \"\"\"load an object that was stored with dill.temp.dumpIO\n    buffer: buffer object\n    >>> dumpfile = dill.temp.dumpIO([1, 2, 3, 4, 5])\n    >>> dill.temp.loadIO(dumpfile)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    import dill as pickle\n    from io import BytesIO as StringIO\n    value = getattr(buffer, 'getvalue', buffer) # value or buffer.getvalue",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "dumpIO",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def dumpIO(object, **kwds):\n    \"\"\"dill.dump of object to a buffer.\nLoads with \"dill.temp.loadIO\".  Returns the buffer object.\n    >>> dumpfile = dill.temp.dumpIO([1, 2, 3, 4, 5])\n    >>> dill.temp.loadIO(dumpfile)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    import dill as pickle\n    from io import BytesIO as StringIO\n    file = StringIO()",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "loadIO_source",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def loadIO_source(buffer, **kwds):\n    \"\"\"load an object that was stored with dill.temp.dumpIO_source\n    buffer: buffer object\n    alias: string name of stored object\n    >>> f = lambda x:x**2\n    >>> pyfile = dill.temp.dumpIO_source(f, alias='_f')\n    >>> _f = dill.temp.loadIO_source(pyfile)\n    >>> _f(4)\n    16\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "dumpIO_source",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "def dumpIO_source(object, **kwds):\n    \"\"\"write object source to a buffer (instead of dill.dump)\nLoads by with dill.temp.loadIO_source.  Returns the buffer object.\n    >>> f = lambda x:x**2\n    >>> pyfile = dill.temp.dumpIO_source(f, alias='_f')\n    >>> _f = dill.temp.loadIO_source(pyfile)\n    >>> _f(4)\n    16\nOptional kwds:\n    If 'alias' is specified, the object will be renamed to the given string.",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.dill.temp",
        "description": "__pypackages__.3.10.lib.dill.temp",
        "peekOfCode": "__all__ = ['dump_source', 'dump', 'dumpIO_source', 'dumpIO',\\\n           'load_source', 'load', 'loadIO_source', 'loadIO',\\\n           'capture']\nimport contextlib\n@contextlib.contextmanager\ndef capture(stream='stdout'):\n    \"\"\"builds a context that temporarily replaces the given stream name\n    >>> with capture('stdout') as out:\n    ...   print (\"foo!\")\n    ... ",
        "detail": "__pypackages__.3.10.lib.dill.temp",
        "documentation": {}
    },
    {
        "label": "_Catcher",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "description": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "peekOfCode": "class _Catcher:\n    def __init__(self, handler_map: Mapping[tuple[type[BaseException], ...], _Handler]):\n        self._handler_map = handler_map\n    def __enter__(self) -> None:\n        pass\n    def __exit__(\n        self,\n        etype: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "documentation": {}
    },
    {
        "label": "catch",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "description": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "peekOfCode": "def catch(\n    __handlers: Mapping[type[BaseException] | Iterable[type[BaseException]], _Handler]\n) -> AbstractContextManager[None]:\n    if not isinstance(__handlers, Mapping):\n        raise TypeError(\"the argument must be a mapping\")\n    handler_map: dict[\n        tuple[type[BaseException], ...], Callable[[BaseExceptionGroup]]\n    ] = {}\n    for type_or_iterable, handler in __handlers.items():\n        iterable: tuple[type[BaseException]]",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._catch",
        "documentation": {}
    },
    {
        "label": "BaseExceptionGroup",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n    \"\"\"A combination of multiple unrelated exceptions.\"\"\"\n    def __new__(\n        cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]\n    ) -> Self:\n        if not isinstance(__message, str):\n            raise TypeError(f\"argument 1 must be str, not {type(__message)}\")\n        if not isinstance(__exceptions, Sequence):\n            raise TypeError(\"second argument (exceptions) must be a sequence\")\n        if not __exceptions:",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionGroup",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n    def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self:\n        return super().__new__(cls, __message, __exceptions)\n    if TYPE_CHECKING:\n        @property\n        def exceptions(\n            self,\n        ) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]:\n            ...\n        @overload  # type: ignore[override]",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "check_direct_subclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "def check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "get_condition_filter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "def get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]\n    | Callable[[_BaseExceptionT_co], bool]\n) -> Callable[[_BaseExceptionT_co], bool]:\n    if isclass(condition) and issubclass(\n        cast(Type[BaseException], condition), BaseException\n    ):\n        return partial(check_direct_subclass, parents=(condition,))\n    elif isinstance(condition, tuple):",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_BaseExceptionT_co",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "_BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True)\n_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_BaseExceptionT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionT_co",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "description": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "peekOfCode": "_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionPrintContext",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "class _ExceptionPrintContext:\n    def __init__(self):\n        self.seen = set()\n        self.exception_group_depth = 0\n        self.need_close = False\n    def indent(self):\n        return \" \" * (2 * self.exception_group_depth)\n    def emit(self, text_gen, margin_char=None):\n        if margin_char is None:\n            margin_char = \"|\"",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "PatchedTracebackException",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "class PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,\n        *,\n        limit: int | None = None,\n        lookup_lines: bool = True,\n        capture_locals: bool = False,",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "exceptiongroup_excepthook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "def exceptiongroup_excepthook(\n    etype: type[BaseException], value: BaseException, tb: TracebackType | None\n) -> None:\n    sys.stderr.write(\"\".join(traceback.format_exception(etype, value, tb)))\nclass PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "format_exception_only",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "def format_exception_only(__exc: BaseException) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, None, compact=True\n        ).format_exception_only()\n    )\n@format_exception_only.register\ndef _(__exc: type, value: BaseException) -> List[str]:\n    return format_exception_only(value)\n@singledispatch",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "format_exception",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "def format_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, __exc.__traceback__, limit=limit, compact=True\n        ).format(chain=chain)\n    )",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "def print_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    if file is None:\n        file = sys.stderr\n    for line in PatchedTracebackException(\n        type(__exc), __exc, __exc.__traceback__, limit=limit",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "print_exc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "def print_exc(\n    limit: Optional[int] = None,\n    file: Any | None = None,\n    chain: bool = True,\n) -> None:\n    value = sys.exc_info()[1]\n    print_exception(value, limit, file, chain)\n# Python levenshtein edit distance code for NameError/AttributeError\n# suggestions, backported from 3.12\n_MAX_CANDIDATE_ITEMS = 750",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "max_group_width",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "max_group_width = 15\nmax_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "max_group_depth",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "max_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_cause_message",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_context_message",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"\n    else:\n        line = f\"{etype}: {valuestr}\\n\"\n    return line",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_original_format",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_original_format = traceback.TracebackException.format\ntraceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_original_format_exception_only",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_format_syntax_error",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MAX_CANDIDATE_ITEMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_MAX_CANDIDATE_ITEMS = 750\n_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MAX_STRING_SIZE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MOVE_COST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_CASE_COST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_SENTINEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "description": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "peekOfCode": "_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)\n    if wrong_name is None or not isinstance(wrong_name, str):",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._version",
        "description": "__pypackages__.3.10.lib.exceptiongroup._version",
        "peekOfCode": "__version__ = version = '1.1.0'\n__version_tuple__ = version_tuple = (1, 1, 0)",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.exceptiongroup._version",
        "description": "__pypackages__.3.10.lib.exceptiongroup._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (1, 1, 0)",
        "detail": "__pypackages__.3.10.lib.exceptiongroup._version",
        "documentation": {}
    },
    {
        "label": "_ParsedLine",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.iniconfig._parse",
        "description": "__pypackages__.3.10.lib.iniconfig._parse",
        "peekOfCode": "class _ParsedLine(NamedTuple):\n    lineno: int\n    section: str | None\n    name: str | None\n    value: str | None\ndef parse_lines(path: str, line_iter: list[str]) -> list[_ParsedLine]:\n    result: list[_ParsedLine] = []\n    section = None\n    for lineno, line in enumerate(line_iter):\n        name, data = _parseline(path, line, lineno)",
        "detail": "__pypackages__.3.10.lib.iniconfig._parse",
        "documentation": {}
    },
    {
        "label": "parse_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.iniconfig._parse",
        "description": "__pypackages__.3.10.lib.iniconfig._parse",
        "peekOfCode": "def parse_lines(path: str, line_iter: list[str]) -> list[_ParsedLine]:\n    result: list[_ParsedLine] = []\n    section = None\n    for lineno, line in enumerate(line_iter):\n        name, data = _parseline(path, line, lineno)\n        # new value\n        if name is not None and data is not None:\n            result.append(_ParsedLine(lineno, section, name, data))\n        # new section\n        elif name is not None and data is None:",
        "detail": "__pypackages__.3.10.lib.iniconfig._parse",
        "documentation": {}
    },
    {
        "label": "iscommentline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.iniconfig._parse",
        "description": "__pypackages__.3.10.lib.iniconfig._parse",
        "peekOfCode": "def iscommentline(line: str) -> bool:\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS",
        "detail": "__pypackages__.3.10.lib.iniconfig._parse",
        "documentation": {}
    },
    {
        "label": "COMMENTCHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.iniconfig._parse",
        "description": "__pypackages__.3.10.lib.iniconfig._parse",
        "peekOfCode": "COMMENTCHARS = \"#;\"\nclass _ParsedLine(NamedTuple):\n    lineno: int\n    section: str | None\n    name: str | None\n    value: str | None\ndef parse_lines(path: str, line_iter: list[str]) -> list[_ParsedLine]:\n    result: list[_ParsedLine] = []\n    section = None\n    for lineno, line in enumerate(line_iter):",
        "detail": "__pypackages__.3.10.lib.iniconfig._parse",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.iniconfig._version",
        "description": "__pypackages__.3.10.lib.iniconfig._version",
        "peekOfCode": "__version__ = version = '2.0.0'\n__version_tuple__ = version_tuple = (2, 0, 0)",
        "detail": "__pypackages__.3.10.lib.iniconfig._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.iniconfig._version",
        "description": "__pypackages__.3.10.lib.iniconfig._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (2, 0, 0)",
        "detail": "__pypackages__.3.10.lib.iniconfig._version",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.iniconfig.exceptions",
        "description": "__pypackages__.3.10.lib.iniconfig.exceptions",
        "peekOfCode": "class ParseError(Exception):\n    path: Final[str]\n    lineno: Final[int]\n    msg: Final[str]\n    def __init__(self, path: str, lineno: int, msg: str) -> None:\n        super().__init__(path, lineno, msg)\n        self.path = path\n        self.lineno = lineno\n        self.msg = msg\n    def __str__(self) -> str:",
        "detail": "__pypackages__.3.10.lib.iniconfig.exceptions",
        "documentation": {}
    },
    {
        "label": "TOMLDecodeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\ndef load(fp: IO, *, parse_float: ParseFloat = float) -> Dict[str, Any]:\n    \"\"\"Parse TOML from a file object.\"\"\"\n    s = fp.read()\n    if isinstance(s, bytes):\n        s = s.decode()\n    else:\n        warnings.warn(\n            \"Text file object support is deprecated in favor of binary file objects.\"",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Flags",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n    def __init__(self) -> None:\n        self._flags: Dict[str, dict] = {}\n    def unset_all(self, key: Key) -> None:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "NestedDict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: Dict[str, Any] = {}\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Output",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags\ndef skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def load(fp: IO, *, parse_float: ParseFloat = float) -> Dict[str, Any]:\n    \"\"\"Parse TOML from a file object.\"\"\"\n    s = fp.read()\n    if isinstance(s, bytes):\n        s = s.decode()\n    else:\n        warnings.warn(\n            \"Text file object support is deprecated in favor of binary file objects.\"\n            ' Use `open(\"foo.toml\", \"rb\")` to open the file in binary mode.',\n            DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "loads",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def loads(s: str, *, parse_float: ParseFloat = float) -> Dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    # Parse one statement at a time\n    # (typically means one line in TOML source)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_chars",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos\ndef skip_until(\n    src: str,\n    pos: Pos,",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_until",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: FrozenSet[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: Optional[str] = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False)\n    return pos\ndef skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_comments_and_array_ws",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos\ndef create_dict_rule(src: str, pos: Pos, out: Output) -> Tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "create_dict_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def create_dict_rule(src: str, pos: Pos, out: Output) -> Tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Can not declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "create_list_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def create_list_rule(src: str, pos: Pos, out: Output) -> Tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Can not mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "key_value_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def key_value_rule(src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n    if out.flags.is_(abs_key_parent, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Can not mutate immutable namespace {abs_key_parent}\")\n    # Containers in the relative path can't be opened with the table syntax after this\n    out.flags.set_for_relative_key(header, key, Flags.EXPLICIT_NEST)\n    try:\n        nest = out.data.get_or_create_nest(abs_key_parent)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key_value_pair",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_key_value_pair(src: str, pos: Pos, parse_float: ParseFloat) -> Tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: Optional[str] = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, 'Expected \"=\" after a key in a key/value pair')\n    pos += 1\n    pos = skip_chars(src, pos, TOML_WS)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_key(src: str, pos: Pos) -> Tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: Optional[str] = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key_part",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_key_part(src: str, pos: Pos) -> Tuple[Pos, str]:\n    try:\n        char: Optional[str] = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_one_line_basic_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_one_line_basic_str(src: str, pos: Pos) -> Tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)\ndef parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> Tuple[Pos, list]:\n    pos += 1\n    array: list = []\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_array",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> Tuple[Pos, list]:\n    pos += 1\n    array: list = []\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_inline_table",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> Tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str_escape",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_basic_str_escape(  # noqa: C901\n    src: str, pos: Pos, *, multiline: bool = False\n) -> Tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str_escape_multiline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_basic_str_escape_multiline(src: str, pos: Pos) -> Tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)\ndef parse_hex_char(src: str, pos: Pos, hex_len: int) -> Tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_hex_char",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_hex_char(src: str, pos: Pos, hex_len: int) -> Tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)\ndef parse_literal_str(src: str, pos: Pos) -> Tuple[Pos, str]:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_literal_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_literal_str(src: str, pos: Pos) -> Tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True)\n    return pos + 1, src[start_pos:pos]  # Skip ending apostrophe\ndef parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> Tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n    if literal:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_multiline_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> Tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> Tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def parse_value(src: str, pos: Pos, parse_float: ParseFloat) -> Tuple[Pos, Any]:  # noqa: C901\n    try:\n        char: Optional[str] = src[pos]\n    except IndexError:\n        char = None\n    # Basic strings\n    if char == '\"':\n        if src.startswith('\"\"\"', pos):\n            return parse_multiline_str(src, pos, literal=False)\n        return parse_one_line_basic_str(src, pos)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "suffixed_err",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "is_unicode_scalar_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "def is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ASCII_CTRL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))\n# Neither of these sets include quotation mark or backslash. They are\n# currently handled as separate cases in the parser functions.\nILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\\r\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_BASIC_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\\r\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_MULTILINE_BASIC_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\\r\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_LITERAL_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_MULTILINE_LITERAL_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_COMMENT_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "TOML_WS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "TOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "TOML_WS_AND_NEWLINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "TOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "BARE_KEY_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "BARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "KEY_INITIAL_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "KEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "HEXDIGIT_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "HEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "BASIC_STR_ESCAPE_REPLACEMENTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "BASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ParseFloat",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "ParseFloat = Callable[[str], Any]\nKey = Tuple[str, ...]\nPos = int\nclass TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\ndef load(fp: IO, *, parse_float: ParseFloat = float) -> Dict[str, Any]:\n    \"\"\"Parse TOML from a file object.\"\"\"\n    s = fp.read()\n    if isinstance(s, bytes):\n        s = s.decode()",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "Key = Tuple[str, ...]\nPos = int\nclass TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\ndef load(fp: IO, *, parse_float: ParseFloat = float) -> Dict[str, Any]:\n    \"\"\"Parse TOML from a file object.\"\"\"\n    s = fp.read()\n    if isinstance(s, bytes):\n        s = s.decode()\n    else:",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Pos",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "peekOfCode": "Pos = int\nclass TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\ndef load(fp: IO, *, parse_float: ParseFloat = float) -> Dict[str, Any]:\n    \"\"\"Parse TOML from a file object.\"\"\"\n    s = fp.read()\n    if isinstance(s, bytes):\n        s = s.decode()\n    else:\n        warnings.warn(",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._parser",
        "documentation": {}
    },
    {
        "label": "match_to_datetime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "def match_to_datetime(match: \"re.Match\") -> Union[datetime, date]:\n    \"\"\"Convert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.\n    Raises ValueError if the match does not correspond to a valid date\n    or datetime.\n    \"\"\"\n    (\n        year_str,\n        month_str,\n        day_str,\n        hour_str,",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "cached_tz",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "def cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:\n    sign = 1 if sign_str == \"+\" else -1\n    return timezone(\n        timedelta(\n            hours=sign * int(hour_str),\n            minutes=sign * int(minute_str),\n        )\n    )\ndef match_to_localtime(match: \"re.Match\") -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "match_to_localtime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "def match_to_localtime(match: \"re.Match\") -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    return time(int(hour_str), int(minute_str), int(sec_str), micros)\ndef match_to_number(match: \"re.Match\", parse_float: \"ParseFloat\") -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "match_to_number",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "def match_to_number(match: \"re.Match\", parse_float: \"ParseFloat\") -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "_TIME_RE_STR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "_TIME_RE_STR = r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\\.([0-9]{1,6})[0-9]*)?\"\nRE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_NUMBER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "RE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct\n)",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_LOCALTIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "RE_LOCALTIME = re.compile(_TIME_RE_STR)\nRE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [T ]\n    {_TIME_RE_STR}\n    (?:(Z)|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?     # optional time offset\n)?\n\"\"\",",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_DATETIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "description": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "peekOfCode": "RE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [T ]\n    {_TIME_RE_STR}\n    (?:(Z)|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?     # optional time offset\n)?\n\"\"\",\n    flags=re.VERBOSE,",
        "detail": "__pypackages__.3.10.lib.isort._vendored.tomli._re",
        "documentation": {}
    },
    {
        "label": "BaseFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class BaseFinder(metaclass=ABCMeta):\n    def __init__(self, config: Config) -> None:\n        self.config = config\n    @abstractmethod\n    def find(self, module_name: str) -> Optional[str]:\n        raise NotImplementedError\nclass ForcedSeparateFinder(BaseFinder):\n    def find(self, module_name: str) -> Optional[str]:\n        for forced_separate in self.config.forced_separate:\n            # Ensure all forced_separate patterns will match to end of string",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "ForcedSeparateFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class ForcedSeparateFinder(BaseFinder):\n    def find(self, module_name: str) -> Optional[str]:\n        for forced_separate in self.config.forced_separate:\n            # Ensure all forced_separate patterns will match to end of string\n            path_glob = forced_separate\n            if not forced_separate.endswith(\"*\"):\n                path_glob = f\"{forced_separate}*\"\n            if fnmatch(module_name, path_glob) or fnmatch(module_name, \".\" + path_glob):\n                return forced_separate\n        return None",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "LocalFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class LocalFinder(BaseFinder):\n    def find(self, module_name: str) -> Optional[str]:\n        if module_name.startswith(\".\"):\n            return \"LOCALFOLDER\"\n        return None\nclass KnownPatternFinder(BaseFinder):\n    def __init__(self, config: Config) -> None:\n        super().__init__(config)\n        self.known_patterns: List[Tuple[Pattern[str], str]] = []\n        for placement in reversed(config.sections):",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "KnownPatternFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class KnownPatternFinder(BaseFinder):\n    def __init__(self, config: Config) -> None:\n        super().__init__(config)\n        self.known_patterns: List[Tuple[Pattern[str], str]] = []\n        for placement in reversed(config.sections):\n            known_placement = KNOWN_SECTION_MAPPING.get(placement, placement).lower()\n            config_key = f\"known_{known_placement}\"\n            known_patterns = list(\n                getattr(self.config, config_key, self.config.known_other.get(known_placement, []))\n            )",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "PathFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class PathFinder(BaseFinder):\n    def __init__(self, config: Config, path: str = \".\") -> None:\n        super().__init__(config)\n        # restore the original import path (i.e. not the path to bin/isort)\n        root_dir = os.path.abspath(path)\n        src_dir = f\"{root_dir}/src\"\n        self.paths = [root_dir, src_dir]\n        # virtual env\n        self.virtual_env = self.config.virtual_env or os.environ.get(\"VIRTUAL_ENV\")\n        if self.virtual_env:",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "ReqsBaseFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class ReqsBaseFinder(BaseFinder):\n    enabled = False\n    def __init__(self, config: Config, path: str = \".\") -> None:\n        super().__init__(config)\n        self.path = path\n        if self.enabled:\n            self.mapping = self._load_mapping()\n            self.names = self._load_names()\n    @abstractmethod\n    def _get_names(self, path: str) -> Iterator[str]:",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "RequirementsFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class RequirementsFinder(ReqsBaseFinder):\n    exts = (\".txt\", \".in\")\n    enabled = bool(parse_requirements)\n    def _get_files_from_dir(self, path: str) -> Iterator[str]:\n        \"\"\"Return paths to requirements files from passed dir.\"\"\"\n        yield from self._get_files_from_dir_cached(path)\n    @classmethod\n    @lru_cache(maxsize=16)\n    def _get_files_from_dir_cached(cls, path: str) -> List[str]:\n        results = []",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "PipfileFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class PipfileFinder(ReqsBaseFinder):\n    enabled = bool(Pipfile)\n    def _get_names(self, path: str) -> Iterator[str]:\n        with chdir(path):\n            project = Pipfile.load(path)\n            for req in project.packages:\n                yield req.name\n    def _get_files_from_dir(self, path: str) -> Iterator[str]:\n        if \"Pipfile\" in os.listdir(path):\n            yield path",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "DefaultFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class DefaultFinder(BaseFinder):\n    def find(self, module_name: str) -> Optional[str]:\n        return self.config.default_section\nclass FindersManager:\n    _default_finders_classes: Sequence[Type[BaseFinder]] = (\n        ForcedSeparateFinder,\n        LocalFinder,\n        KnownPatternFinder,\n        PathFinder,\n        PipfileFinder,",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "FindersManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "class FindersManager:\n    _default_finders_classes: Sequence[Type[BaseFinder]] = (\n        ForcedSeparateFinder,\n        LocalFinder,\n        KnownPatternFinder,\n        PathFinder,\n        PipfileFinder,\n        RequirementsFinder,\n        DefaultFinder,\n    )",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "chdir",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "description": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "peekOfCode": "def chdir(path: str) -> Iterator[None]:\n    \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\"\n    curdir = os.getcwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(curdir)\nclass BaseFinder(metaclass=ABCMeta):\n    def __init__(self, config: Config) -> None:",
        "detail": "__pypackages__.3.10.lib.isort.deprecated.finders",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.all",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.all",
        "peekOfCode": "stdlib = py2.stdlib | py3.stdlib",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.all",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py2",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py2",
        "peekOfCode": "stdlib = py27.stdlib",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py2",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py27",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py27",
        "peekOfCode": "stdlib = {\n    \"AL\",\n    \"BaseHTTPServer\",\n    \"Bastion\",\n    \"CGIHTTPServer\",\n    \"Carbon\",\n    \"ColorPicker\",\n    \"ConfigParser\",\n    \"Cookie\",\n    \"DEVICE\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py27",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py3",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py3",
        "peekOfCode": "stdlib = py36.stdlib | py37.stdlib | py38.stdlib | py39.stdlib | py310.stdlib | py311.stdlib",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py3",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py310",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py310",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",\n    \"asyncio\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py310",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py311",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py311",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",\n    \"asyncio\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py311",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py36",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py36",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_dummy_thread\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py36",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py37",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py37",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_dummy_thread\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py37",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py38",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py38",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_dummy_thread\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py38",
        "documentation": {}
    },
    {
        "label": "stdlib",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.stdlibs.py39",
        "description": "__pypackages__.3.10.lib.isort.stdlibs.py39",
        "peekOfCode": "stdlib = {\n    \"_ast\",\n    \"_thread\",\n    \"abc\",\n    \"aifc\",\n    \"argparse\",\n    \"array\",\n    \"ast\",\n    \"asynchat\",\n    \"asyncio\",",
        "detail": "__pypackages__.3.10.lib.isort.stdlibs.py39",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort._version",
        "description": "__pypackages__.3.10.lib.isort._version",
        "peekOfCode": "__version__ = metadata.version(\"isort\")",
        "detail": "__pypackages__.3.10.lib.isort._version",
        "documentation": {}
    },
    {
        "label": "ImportKey",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "class ImportKey(Enum):\n    \"\"\"Defines how to key an individual import, generally for deduping.\n    Import keys are defined from less to more specific:\n    from x.y import z as a\n    ______| |        |    |\n       |    |        |    |\n    PACKAGE |        |    |\n    ________|        |    |\n          |          |    |\n        MODULE       |    |",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "sort_code_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def sort_code_string(\n    code: str,\n    extension: Optional[str] = None,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = False,\n    show_diff: Union[bool, TextIO] = False,\n    **config_kwargs: Any,\n) -> str:\n    \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "check_code_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def check_code_string(\n    code: str,\n    show_diff: Union[bool, TextIO] = False,\n    extension: Optional[str] = None,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = False,\n    **config_kwargs: Any,\n) -> bool:\n    \"\"\"Checks the order, format, and categorization of imports within the provided code string.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "sort_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def sort_stream(\n    input_stream: TextIO,\n    output_stream: TextIO,\n    extension: Optional[str] = None,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = False,\n    show_diff: Union[bool, TextIO] = False,\n    raise_on_skip: bool = True,\n    **config_kwargs: Any,",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "check_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def check_stream(\n    input_stream: TextIO,\n    show_diff: Union[bool, TextIO] = False,\n    extension: Optional[str] = None,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = False,\n    **config_kwargs: Any,\n) -> bool:\n    \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "check_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def check_file(\n    filename: Union[str, Path],\n    show_diff: Union[bool, TextIO] = False,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = True,\n    extension: Optional[str] = None,\n    **config_kwargs: Any,\n) -> bool:\n    \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "sort_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def sort_file(\n    filename: Union[str, Path],\n    extension: Optional[str] = None,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    disregard_skip: bool = True,\n    ask_to_apply: bool = False,\n    show_diff: Union[bool, TextIO] = False,\n    write_to_stdout: bool = False,\n    output: Optional[TextIO] = None,",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "find_imports_in_code",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def find_imports_in_code(\n    code: str,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    unique: Union[bool, ImportKey] = False,\n    top_only: bool = False,\n    **config_kwargs: Any,\n) -> Iterator[identify.Import]:\n    \"\"\"Finds and returns all imports within the provided code string.\n    - **code**: The string of code with imports that need to be sorted.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "find_imports_in_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def find_imports_in_stream(\n    input_stream: TextIO,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    unique: Union[bool, ImportKey] = False,\n    top_only: bool = False,\n    _seen: Optional[Set[str]] = None,\n    **config_kwargs: Any,\n) -> Iterator[identify.Import]:\n    \"\"\"Finds and returns all imports within the provided code stream.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "find_imports_in_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def find_imports_in_file(\n    filename: Union[str, Path],\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    unique: Union[bool, ImportKey] = False,\n    top_only: bool = False,\n    **config_kwargs: Any,\n) -> Iterator[identify.Import]:\n    \"\"\"Finds and returns all imports within the provided source file.\n    - **filename**: The name or Path of the file to look for imports in.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "find_imports_in_paths",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "def find_imports_in_paths(\n    paths: Iterator[Union[str, Path]],\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    unique: Union[bool, ImportKey] = False,\n    top_only: bool = False,\n    **config_kwargs: Any,\n) -> Iterator[identify.Import]:\n    \"\"\"Finds and returns all imports within the provided source paths.\n    - **paths**: A collection of paths to recursively look for imports within.",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.api",
        "description": "__pypackages__.3.10.lib.isort.api",
        "peekOfCode": "__all__ = (\n    \"ImportKey\",\n    \"check_code_string\",\n    \"check_file\",\n    \"check_stream\",\n    \"find_imports_in_code\",\n    \"find_imports_in_file\",\n    \"find_imports_in_paths\",\n    \"find_imports_in_stream\",\n    \"place_module\",",
        "detail": "__pypackages__.3.10.lib.isort.api",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.comments",
        "description": "__pypackages__.3.10.lib.isort.comments",
        "peekOfCode": "def parse(line: str) -> Tuple[str, str]:\n    \"\"\"Parses import lines for comments and returns back the\n    import statement and the associated comment.\n    \"\"\"\n    comment_start = line.find(\"#\")\n    if comment_start != -1:\n        return (line[:comment_start], line[comment_start + 1 :].strip())\n    return (line, \"\")\ndef add_to_line(\n    comments: Optional[List[str]],",
        "detail": "__pypackages__.3.10.lib.isort.comments",
        "documentation": {}
    },
    {
        "label": "add_to_line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.comments",
        "description": "__pypackages__.3.10.lib.isort.comments",
        "peekOfCode": "def add_to_line(\n    comments: Optional[List[str]],\n    original_string: str = \"\",\n    removed: bool = False,\n    comment_prefix: str = \"\",\n) -> str:\n    \"\"\"Returns a string with comments added if removed is not set.\"\"\"\n    if removed:\n        return parse(original_string)[0]\n    if not comments:",
        "detail": "__pypackages__.3.10.lib.isort.comments",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "def process(\n    input_stream: TextIO,\n    output_stream: TextIO,\n    extension: str = \"py\",\n    raise_on_skip: bool = True,\n    config: Config = DEFAULT_CONFIG,\n) -> bool:\n    \"\"\"Parses stream identifying sections of contiguous imports and sorting them\n    Code with unsorted imports is read from the provided `input_stream`, sorted and then\n    outputted to the specified `output_stream`.",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "CIMPORT_IDENTIFIERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "CIMPORT_IDENTIFIERS = (\"cimport \", \"cimport*\", \"from.cimport\")\nIMPORT_START_IDENTIFIERS = (\"from \", \"from.import\", \"import \", \"import*\") + CIMPORT_IDENTIFIERS\nDOCSTRING_INDICATORS = ('\"\"\"', \"'''\")\nCOMMENT_INDICATORS = DOCSTRING_INDICATORS + (\"'\", '\"', \"#\")\nCODE_SORT_COMMENTS = (\n    \"# isort: list\",\n    \"# isort: dict\",\n    \"# isort: set\",\n    \"# isort: unique-list\",\n    \"# isort: tuple\",",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "IMPORT_START_IDENTIFIERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "IMPORT_START_IDENTIFIERS = (\"from \", \"from.import\", \"import \", \"import*\") + CIMPORT_IDENTIFIERS\nDOCSTRING_INDICATORS = ('\"\"\"', \"'''\")\nCOMMENT_INDICATORS = DOCSTRING_INDICATORS + (\"'\", '\"', \"#\")\nCODE_SORT_COMMENTS = (\n    \"# isort: list\",\n    \"# isort: dict\",\n    \"# isort: set\",\n    \"# isort: unique-list\",\n    \"# isort: tuple\",\n    \"# isort: unique-tuple\",",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "DOCSTRING_INDICATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "DOCSTRING_INDICATORS = ('\"\"\"', \"'''\")\nCOMMENT_INDICATORS = DOCSTRING_INDICATORS + (\"'\", '\"', \"#\")\nCODE_SORT_COMMENTS = (\n    \"# isort: list\",\n    \"# isort: dict\",\n    \"# isort: set\",\n    \"# isort: unique-list\",\n    \"# isort: tuple\",\n    \"# isort: unique-tuple\",\n    \"# isort: assignments\",",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "COMMENT_INDICATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "COMMENT_INDICATORS = DOCSTRING_INDICATORS + (\"'\", '\"', \"#\")\nCODE_SORT_COMMENTS = (\n    \"# isort: list\",\n    \"# isort: dict\",\n    \"# isort: set\",\n    \"# isort: unique-list\",\n    \"# isort: tuple\",\n    \"# isort: unique-tuple\",\n    \"# isort: assignments\",\n)",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "CODE_SORT_COMMENTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "CODE_SORT_COMMENTS = (\n    \"# isort: list\",\n    \"# isort: dict\",\n    \"# isort: set\",\n    \"# isort: unique-list\",\n    \"# isort: tuple\",\n    \"# isort: unique-tuple\",\n    \"# isort: assignments\",\n)\nLITERAL_TYPE_MAPPING = {\"(\": \"tuple\", \"[\": \"list\", \"{\": \"set\"}",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "LITERAL_TYPE_MAPPING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.core",
        "description": "__pypackages__.3.10.lib.isort.core",
        "peekOfCode": "LITERAL_TYPE_MAPPING = {\"(\": \"tuple\", \"[\": \"list\", \"{\": \"set\"}\ndef process(\n    input_stream: TextIO,\n    output_stream: TextIO,\n    extension: str = \"py\",\n    raise_on_skip: bool = True,\n    config: Config = DEFAULT_CONFIG,\n) -> bool:\n    \"\"\"Parses stream identifying sections of contiguous imports and sorting them\n    Code with unsorted imports is read from the provided `input_stream`, sorted and then",
        "detail": "__pypackages__.3.10.lib.isort.core",
        "documentation": {}
    },
    {
        "label": "ISortError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class ISortError(Exception):\n    \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\"\n    def __reduce__(self):  # type: ignore\n        return (partial(type(self), **self.__dict__), ())\nclass InvalidSettingsPath(ISortError):\n    \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\"\n    def __init__(self, settings_path: str):\n        super().__init__(\n            f\"isort was told to use the settings_path: {settings_path} as the base directory or \"\n            \"file that represents the starting point of config file discovery, but it does not \"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidSettingsPath",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class InvalidSettingsPath(ISortError):\n    \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\"\n    def __init__(self, settings_path: str):\n        super().__init__(\n            f\"isort was told to use the settings_path: {settings_path} as the base directory or \"\n            \"file that represents the starting point of config file discovery, but it does not \"\n            \"exist.\"\n        )\n        self.settings_path = settings_path\nclass ExistingSyntaxErrors(ISortError):",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "ExistingSyntaxErrors",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class ExistingSyntaxErrors(ISortError):\n    \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\"\n    def __init__(self, file_path: str):\n        super().__init__(\n            f\"isort was told to sort imports within code that contains syntax errors: \"\n            f\"{file_path}.\"\n        )\n        self.file_path = file_path\nclass IntroducedSyntaxErrors(ISortError):\n    \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "IntroducedSyntaxErrors",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class IntroducedSyntaxErrors(ISortError):\n    \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\"\n    def __init__(self, file_path: str):\n        super().__init__(\n            f\"isort introduced syntax errors when attempting to sort the imports contained within \"\n            f\"{file_path}.\"\n        )\n        self.file_path = file_path\nclass FileSkipped(ISortError):\n    \"\"\"Should be raised when a file is skipped for any reason\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "FileSkipped",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class FileSkipped(ISortError):\n    \"\"\"Should be raised when a file is skipped for any reason\"\"\"\n    def __init__(self, message: str, file_path: str):\n        super().__init__(message)\n        self.message = message\n        self.file_path = file_path\nclass FileSkipComment(FileSkipped):\n    \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\"\n    def __init__(self, file_path: str, **kwargs: str):\n        super().__init__(",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "FileSkipComment",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class FileSkipComment(FileSkipped):\n    \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\"\n    def __init__(self, file_path: str, **kwargs: str):\n        super().__init__(\n            f\"{file_path} contains a file skip comment and was skipped.\", file_path=file_path\n        )\nclass FileSkipSetting(FileSkipped):\n    \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\"\n    def __init__(self, file_path: str, **kwargs: str):\n        super().__init__(",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "FileSkipSetting",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class FileSkipSetting(FileSkipped):\n    \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\"\n    def __init__(self, file_path: str, **kwargs: str):\n        super().__init__(\n            f\"{file_path} was skipped as it's listed in 'skip' setting\"\n            \" or matches a glob in 'skip_glob' setting\",\n            file_path=file_path,\n        )\nclass ProfileDoesNotExist(ISortError):\n    \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "ProfileDoesNotExist",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class ProfileDoesNotExist(ISortError):\n    \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\"\n    def __init__(self, profile: str):\n        super().__init__(\n            f\"Specified profile of {profile} does not exist. \"\n            f\"Available profiles: {','.join(profiles)}.\"\n        )\n        self.profile = profile\nclass SortingFunctionDoesNotExist(ISortError):\n    \"\"\"Raised when the specified sorting function isn't available\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "SortingFunctionDoesNotExist",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class SortingFunctionDoesNotExist(ISortError):\n    \"\"\"Raised when the specified sorting function isn't available\"\"\"\n    def __init__(self, sort_order: str, available_sort_orders: List[str]):\n        super().__init__(\n            f\"Specified sort_order of {sort_order} does not exist. \"\n            f\"Available sort_orders: {','.join(available_sort_orders)}.\"\n        )\n        self.sort_order = sort_order\n        self.available_sort_orders = available_sort_orders\nclass FormattingPluginDoesNotExist(ISortError):",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "FormattingPluginDoesNotExist",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class FormattingPluginDoesNotExist(ISortError):\n    \"\"\"Raised when a formatting plugin is set by the user that doesn't exist\"\"\"\n    def __init__(self, formatter: str):\n        super().__init__(f\"Specified formatting plugin of {formatter} does not exist. \")\n        self.formatter = formatter\nclass LiteralParsingFailure(ISortError):\n    \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the\n    the given data structure.\n    \"\"\"\n    def __init__(self, code: str, original_error: Union[Exception, Type[Exception]]):",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "LiteralParsingFailure",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class LiteralParsingFailure(ISortError):\n    \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the\n    the given data structure.\n    \"\"\"\n    def __init__(self, code: str, original_error: Union[Exception, Type[Exception]]):\n        super().__init__(\n            f\"isort failed to parse the given literal {code}. It's important to note \"\n            \"that isort literal sorting only supports simple literals parsable by \"\n            f\"ast.literal_eval which gave the exception of {original_error}.\"\n        )",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "LiteralSortTypeMismatch",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class LiteralSortTypeMismatch(ISortError):\n    \"\"\"Raised when an isort literal sorting comment is used, with a type that doesn't match the\n    supplied data structure's type.\n    \"\"\"\n    def __init__(self, kind: type, expected_kind: type):\n        super().__init__(\n            f\"isort was told to sort a literal of type {expected_kind} but was given \"\n            f\"a literal of type {kind}.\"\n        )\n        self.kind = kind",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "AssignmentsFormatMismatch",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class AssignmentsFormatMismatch(ISortError):\n    \"\"\"Raised when isort is told to sort assignments but the format of the assignment section\n    doesn't match isort's expectation.\n    \"\"\"\n    def __init__(self, code: str):\n        super().__init__(\n            \"isort was told to sort a section of assignments, however the given code:\\n\\n\"\n            f\"{code}\\n\\n\"\n            \"Does not match isort's strict single line formatting requirement for assignment \"\n            \"sorting:\\n\\n\"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "UnsupportedSettings",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class UnsupportedSettings(ISortError):\n    \"\"\"Raised when settings are passed into isort (either from config, CLI, or runtime)\n    that it doesn't support.\n    \"\"\"\n    @staticmethod\n    def _format_option(name: str, value: Any, source: str) -> str:\n        return f\"\\t- {name} = {value}  (source: '{source}')\"\n    def __init__(self, unsupported_settings: Dict[str, Dict[str, str]]):\n        errors = \"\\n\".join(\n            self._format_option(name, **option) for name, option in unsupported_settings.items()",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "UnsupportedEncoding",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class UnsupportedEncoding(ISortError):\n    \"\"\"Raised when isort encounters an encoding error while trying to read a file\"\"\"\n    def __init__(self, filename: Union[str, Path]):\n        super().__init__(f\"Unknown or unsupported encoding in {filename}\")\n        self.filename = filename\nclass MissingSection(ISortError):\n    \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\"\n    def __init__(self, import_module: str, section: str):\n        super().__init__(\n            f\"Found {import_module} import while parsing, but {section} was not included \"",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingSection",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.exceptions",
        "description": "__pypackages__.3.10.lib.isort.exceptions",
        "peekOfCode": "class MissingSection(ISortError):\n    \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\"\n    def __init__(self, import_module: str, section: str):\n        super().__init__(\n            f\"Found {import_module} import while parsing, but {section} was not included \"\n            \"in the `sections` setting of your config. Please add it before continuing\\n\"\n            \"See https://pycqa.github.io/isort/#custom-sections-and-ordering \"\n            \"for more info.\"\n        )",
        "detail": "__pypackages__.3.10.lib.isort.exceptions",
        "documentation": {}
    },
    {
        "label": "find",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.files",
        "description": "__pypackages__.3.10.lib.isort.files",
        "peekOfCode": "def find(\n    paths: Iterable[str], config: Config, skipped: List[str], broken: List[str]\n) -> Iterator[str]:\n    \"\"\"Fines and provides an iterator for all Python source files defined in paths.\"\"\"\n    visited_dirs: Set[Path] = set()\n    for path in paths:\n        if os.path.isdir(path):\n            for dirpath, dirnames, filenames in os.walk(\n                path, topdown=True, followlinks=config.follow_links\n            ):",
        "detail": "__pypackages__.3.10.lib.isort.files",
        "documentation": {}
    },
    {
        "label": "BasicPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "class BasicPrinter:\n    ERROR = \"ERROR\"\n    SUCCESS = \"SUCCESS\"\n    def __init__(self, error: str, success: str, output: Optional[TextIO] = None):\n        self.output = output or sys.stdout\n        self.success_message = success\n        self.error_message = error\n    def success(self, message: str) -> None:\n        print(self.success_message.format(success=self.SUCCESS, message=message), file=self.output)\n    def error(self, message: str) -> None:",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "ColoramaPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "class ColoramaPrinter(BasicPrinter):\n    def __init__(self, error: str, success: str, output: Optional[TextIO]):\n        super().__init__(error, success, output=output)\n        # Note: this constants are instance variables instead ofs class variables\n        # because they refer to colorama which might not be installed.\n        self.ERROR = self.style_text(\"ERROR\", colorama.Fore.RED)\n        self.SUCCESS = self.style_text(\"SUCCESS\", colorama.Fore.GREEN)\n        self.ADDED_LINE = colorama.Fore.GREEN\n        self.REMOVED_LINE = colorama.Fore.RED\n    @staticmethod",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "format_simplified",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def format_simplified(import_line: str) -> str:\n    import_line = import_line.strip()\n    if import_line.startswith(\"from \"):\n        import_line = import_line.replace(\"from \", \"\")\n        import_line = import_line.replace(\" import \", \".\")\n    elif import_line.startswith(\"import \"):\n        import_line = import_line.replace(\"import \", \"\")\n    return import_line\ndef format_natural(import_line: str) -> str:\n    import_line = import_line.strip()",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "format_natural",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def format_natural(import_line: str) -> str:\n    import_line = import_line.strip()\n    if not import_line.startswith(\"from \") and not import_line.startswith(\"import \"):\n        if \".\" not in import_line:\n            return f\"import {import_line}\"\n        parts = import_line.split(\".\")\n        end = parts.pop(-1)\n        return f\"from {'.'.join(parts)} import {end}\"\n    return import_line\ndef show_unified_diff(",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "show_unified_diff",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def show_unified_diff(\n    *,\n    file_input: str,\n    file_output: str,\n    file_path: Optional[Path],\n    output: Optional[TextIO] = None,\n    color_output: bool = False,\n) -> None:\n    \"\"\"Shows a unified_diff for the provided input and output against the provided file path.\n    - **file_input**: A string that represents the contents of a file before changes.",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "ask_whether_to_apply_changes_to_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def ask_whether_to_apply_changes_to_file(file_path: str) -> bool:\n    answer = None\n    while answer not in (\"yes\", \"y\", \"no\", \"n\", \"quit\", \"q\"):\n        answer = input(f\"Apply suggested changes to '{file_path}' [y/n/q]? \")  # nosec\n        answer = answer.lower()\n        if answer in (\"no\", \"n\"):\n            return False\n        if answer in (\"quit\", \"q\"):\n            sys.exit(1)\n    return True",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "remove_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def remove_whitespace(content: str, line_separator: str = \"\\n\") -> str:\n    content = content.replace(line_separator, \"\").replace(\" \", \"\").replace(\"\\x0c\", \"\")\n    return content\nclass BasicPrinter:\n    ERROR = \"ERROR\"\n    SUCCESS = \"SUCCESS\"\n    def __init__(self, error: str, success: str, output: Optional[TextIO] = None):\n        self.output = output or sys.stdout\n        self.success_message = success\n        self.error_message = error",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "create_terminal_printer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "def create_terminal_printer(\n    color: bool, output: Optional[TextIO] = None, error: str = \"\", success: str = \"\"\n) -> BasicPrinter:\n    if color and colorama_unavailable:\n        no_colorama_message = (\n            \"\\n\"\n            \"Sorry, but to use --color (color_output) the colorama python package is required.\\n\\n\"\n            \"Reference: https://pypi.org/project/colorama/\\n\\n\"\n            \"You can either install it separately on your system or as the colors extra \"\n            \"for isort. Ex: \\n\\n\"",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "ADDED_LINE_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "ADDED_LINE_PATTERN = re.compile(r\"\\+[^+]\")\nREMOVED_LINE_PATTERN = re.compile(r\"-[^-]\")\ndef format_simplified(import_line: str) -> str:\n    import_line = import_line.strip()\n    if import_line.startswith(\"from \"):\n        import_line = import_line.replace(\"from \", \"\")\n        import_line = import_line.replace(\" import \", \".\")\n    elif import_line.startswith(\"import \"):\n        import_line = import_line.replace(\"import \", \"\")\n    return import_line",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "REMOVED_LINE_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.format",
        "description": "__pypackages__.3.10.lib.isort.format",
        "peekOfCode": "REMOVED_LINE_PATTERN = re.compile(r\"-[^-]\")\ndef format_simplified(import_line: str) -> str:\n    import_line = import_line.strip()\n    if import_line.startswith(\"from \"):\n        import_line = import_line.replace(\"from \", \"\")\n        import_line = import_line.replace(\" import \", \".\")\n    elif import_line.startswith(\"import \"):\n        import_line = import_line.replace(\"import \", \"\")\n    return import_line\ndef format_natural(import_line: str) -> str:",
        "detail": "__pypackages__.3.10.lib.isort.format",
        "documentation": {}
    },
    {
        "label": "get_output",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.hooks",
        "description": "__pypackages__.3.10.lib.isort.hooks",
        "peekOfCode": "def get_output(command: List[str]) -> str:\n    \"\"\"Run a command and return raw output\n    :param str command: the command to run\n    :returns: the stdout output of the command\n    \"\"\"\n    result = subprocess.run(command, stdout=subprocess.PIPE, check=True)  # nosec - trusted input\n    return result.stdout.decode()\ndef get_lines(command: List[str]) -> List[str]:\n    \"\"\"Run a command and return lines of output\n    :param str command: the command to run",
        "detail": "__pypackages__.3.10.lib.isort.hooks",
        "documentation": {}
    },
    {
        "label": "get_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.hooks",
        "description": "__pypackages__.3.10.lib.isort.hooks",
        "peekOfCode": "def get_lines(command: List[str]) -> List[str]:\n    \"\"\"Run a command and return lines of output\n    :param str command: the command to run\n    :returns: list of whitespace-stripped lines output by command\n    \"\"\"\n    stdout = get_output(command)\n    return [line.strip() for line in stdout.splitlines()]\ndef git_hook(\n    strict: bool = False,\n    modify: bool = False,",
        "detail": "__pypackages__.3.10.lib.isort.hooks",
        "documentation": {}
    },
    {
        "label": "git_hook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.hooks",
        "description": "__pypackages__.3.10.lib.isort.hooks",
        "peekOfCode": "def git_hook(\n    strict: bool = False,\n    modify: bool = False,\n    lazy: bool = False,\n    settings_file: str = \"\",\n    directories: Optional[List[str]] = None,\n) -> int:\n    \"\"\"Git pre-commit hook to check staged files for isort errors\n    :param bool strict - if True, return number of errors on exit,\n        causing the hook to fail. If False, return zero so it will",
        "detail": "__pypackages__.3.10.lib.isort.hooks",
        "documentation": {}
    },
    {
        "label": "Import",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.identify",
        "description": "__pypackages__.3.10.lib.isort.identify",
        "peekOfCode": "class Import(NamedTuple):\n    line_number: int\n    indented: bool\n    module: str\n    attribute: Optional[str] = None\n    alias: Optional[str] = None\n    cimport: bool = False\n    file_path: Optional[Path] = None\n    def statement(self) -> str:\n        import_cmd = \"cimport\" if self.cimport else \"import\"",
        "detail": "__pypackages__.3.10.lib.isort.identify",
        "documentation": {}
    },
    {
        "label": "imports",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.identify",
        "description": "__pypackages__.3.10.lib.isort.identify",
        "peekOfCode": "def imports(\n    input_stream: TextIO,\n    config: Config = DEFAULT_CONFIG,\n    file_path: Optional[Path] = None,\n    top_only: bool = False,\n) -> Iterator[Import]:\n    \"\"\"Parses a python file taking out and categorizing imports.\"\"\"\n    in_quote = \"\"\n    indexed_input = enumerate(input_stream)\n    for index, raw_line in indexed_input:",
        "detail": "__pypackages__.3.10.lib.isort.identify",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.io",
        "description": "__pypackages__.3.10.lib.isort.io",
        "peekOfCode": "class File:\n    stream: TextIO\n    path: Path\n    encoding: str\n    @staticmethod\n    def detect_encoding(filename: Union[str, Path], readline: Callable[[], bytes]) -> str:\n        try:\n            return tokenize.detect_encoding(readline)[0]\n        except Exception:\n            raise UnsupportedEncoding(filename)",
        "detail": "__pypackages__.3.10.lib.isort.io",
        "documentation": {}
    },
    {
        "label": "_EmptyIO",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.io",
        "description": "__pypackages__.3.10.lib.isort.io",
        "peekOfCode": "class _EmptyIO(StringIO):\n    def write(self, *args: Any, **kwargs: Any) -> None:  # type: ignore # skipcq: PTC-W0049\n        pass\nEmpty = _EmptyIO()",
        "detail": "__pypackages__.3.10.lib.isort.io",
        "documentation": {}
    },
    {
        "label": "_ENCODING_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.io",
        "description": "__pypackages__.3.10.lib.isort.io",
        "peekOfCode": "_ENCODING_PATTERN = re.compile(rb\"^[ \\t\\f]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\")\n@dataclasses.dataclass(frozen=True)\nclass File:\n    stream: TextIO\n    path: Path\n    encoding: str\n    @staticmethod\n    def detect_encoding(filename: Union[str, Path], readline: Callable[[], bytes]) -> str:\n        try:\n            return tokenize.detect_encoding(readline)[0]",
        "detail": "__pypackages__.3.10.lib.isort.io",
        "documentation": {}
    },
    {
        "label": "Empty",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.io",
        "description": "__pypackages__.3.10.lib.isort.io",
        "peekOfCode": "Empty = _EmptyIO()",
        "detail": "__pypackages__.3.10.lib.isort.io",
        "documentation": {}
    },
    {
        "label": "ISortPrettyPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.literal",
        "description": "__pypackages__.3.10.lib.isort.literal",
        "peekOfCode": "class ISortPrettyPrinter(PrettyPrinter):\n    \"\"\"an isort customized pretty printer for sorted literals\"\"\"\n    def __init__(self, config: Config):\n        super().__init__(width=config.line_length, compact=True)\ntype_mapping: Dict[str, Tuple[type, Callable[[Any, ISortPrettyPrinter], str]]] = {}\ndef assignments(code: str) -> str:\n    values = {}\n    for line in code.splitlines(keepends=True):\n        if not line.strip():\n            continue",
        "detail": "__pypackages__.3.10.lib.isort.literal",
        "documentation": {}
    },
    {
        "label": "assignments",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.literal",
        "description": "__pypackages__.3.10.lib.isort.literal",
        "peekOfCode": "def assignments(code: str) -> str:\n    values = {}\n    for line in code.splitlines(keepends=True):\n        if not line.strip():\n            continue\n        if \" = \" not in line:\n            raise AssignmentsFormatMismatch(code)\n        variable_name, value = line.split(\" = \", 1)\n        values[variable_name] = value\n    return \"\".join(",
        "detail": "__pypackages__.3.10.lib.isort.literal",
        "documentation": {}
    },
    {
        "label": "assignment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.literal",
        "description": "__pypackages__.3.10.lib.isort.literal",
        "peekOfCode": "def assignment(code: str, sort_type: str, extension: str, config: Config = DEFAULT_CONFIG) -> str:\n    \"\"\"Sorts the literal present within the provided code against the provided sort type,\n    returning the sorted representation of the source code.\n    \"\"\"\n    if sort_type == \"assignments\":\n        return assignments(code)\n    if sort_type not in type_mapping:\n        raise ValueError(\n            \"Trying to sort using an undefined sort_type. \"\n            f\"Defined sort types are {', '.join(type_mapping.keys())}.\"",
        "detail": "__pypackages__.3.10.lib.isort.literal",
        "documentation": {}
    },
    {
        "label": "register_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.literal",
        "description": "__pypackages__.3.10.lib.isort.literal",
        "peekOfCode": "def register_type(\n    name: str, kind: type\n) -> Callable[[Callable[[Any, ISortPrettyPrinter], str]], Callable[[Any, ISortPrettyPrinter], str]]:\n    \"\"\"Registers a new literal sort type.\"\"\"\n    def wrap(\n        function: Callable[[Any, ISortPrettyPrinter], str]\n    ) -> Callable[[Any, ISortPrettyPrinter], str]:\n        type_mapping[name] = (kind, function)\n        return function\n    return wrap",
        "detail": "__pypackages__.3.10.lib.isort.literal",
        "documentation": {}
    },
    {
        "label": "ASCII_ART",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.logo",
        "description": "__pypackages__.3.10.lib.isort.logo",
        "peekOfCode": "ASCII_ART = rf\"\"\"\n                 _                 _\n                (_) ___  ___  _ __| |_\n                | |/ _/ / _ \\/ '__  _/\n                | |\\__ \\/\\_\\/| |  | |_\n                |_|\\___/\\___/\\_/   \\_/\n      isort your imports, so you don't have to.\n                    VERSION {__version__}\n\"\"\"\n__doc__ = f\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.logo",
        "documentation": {}
    },
    {
        "label": "__doc__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.logo",
        "description": "__pypackages__.3.10.lib.isort.logo",
        "peekOfCode": "__doc__ = f\"\"\"\n```python\n{ASCII_ART}\n```\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.logo",
        "documentation": {}
    },
    {
        "label": "SortAttempt",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "class SortAttempt:\n    def __init__(self, incorrectly_sorted: bool, skipped: bool, supported_encoding: bool) -> None:\n        self.incorrectly_sorted = incorrectly_sorted\n        self.skipped = skipped\n        self.supported_encoding = supported_encoding\ndef sort_imports(\n    file_name: str,\n    config: Config,\n    check: bool = False,\n    ask_to_apply: bool = False,",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "sort_imports",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "def sort_imports(\n    file_name: str,\n    config: Config,\n    check: bool = False,\n    ask_to_apply: bool = False,\n    write_to_stdout: bool = False,\n    **kwargs: Any,\n) -> Optional[SortAttempt]:\n    incorrectly_sorted: bool = False\n    skipped: bool = False",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "def parse_args(argv: Optional[Sequence[str]] = None) -> Dict[str, Any]:\n    argv = sys.argv[1:] if argv is None else list(argv)\n    remapped_deprecated_args = []\n    for index, arg in enumerate(argv):\n        if arg in DEPRECATED_SINGLE_DASH_ARGS:\n            remapped_deprecated_args.append(arg)\n            argv[index] = f\"-{arg}\"\n    parser = _build_arg_parser()\n    arguments = {key: value for key, value in vars(parser.parse_args(argv)).items() if value}\n    if remapped_deprecated_args:",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "identify_imports_main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "def identify_imports_main(\n    argv: Optional[Sequence[str]] = None, stdin: Optional[TextIOWrapper] = None\n) -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Get all import definitions from a given file.\"\n        \"Use `-` as the first argument to represent stdin.\"\n    )\n    parser.add_argument(\n        \"files\", nargs=\"+\", help=\"One or more Python source files that need their imports sorted.\"\n    )",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "def main(argv: Optional[Sequence[str]] = None, stdin: Optional[TextIOWrapper] = None) -> None:\n    arguments = parse_args(argv)\n    if arguments.get(\"show_version\"):\n        print(ASCII_ART)\n        return\n    show_config: bool = arguments.pop(\"show_config\", False)\n    show_files: bool = arguments.pop(\"show_files\", False)\n    if show_config and show_files:\n        sys.exit(\"Error: either specify show-config or show-files not both.\")\n    if \"settings_path\" in arguments:",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "DEPRECATED_SINGLE_DASH_ARGS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "DEPRECATED_SINGLE_DASH_ARGS = {\n    \"-ac\",\n    \"-af\",\n    \"-ca\",\n    \"-cs\",\n    \"-df\",\n    \"-ds\",\n    \"-dt\",\n    \"-fas\",\n    \"-fass\",",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "QUICK_GUIDE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.main",
        "description": "__pypackages__.3.10.lib.isort.main",
        "peekOfCode": "QUICK_GUIDE = f\"\"\"\n{ASCII_ART}\nNothing to do: no files or paths have have been passed in!\nTry one of the following:\n    `isort .` - sort all Python files, starting from the current directory, recursively.\n    `isort . --interactive` - Do the same, but ask before making any changes.\n    `isort . --check --diff` - Check to see if imports are correctly sorted within this project.\n    `isort --help` - In-depth information about isort's available command-line options.\nVisit https://pycqa.github.io/isort/ for complete information about how to use isort.\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.main",
        "documentation": {}
    },
    {
        "label": "_LineWithComments",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.output",
        "description": "__pypackages__.3.10.lib.isort.output",
        "peekOfCode": "class _LineWithComments(str):\n    comments: List[str]\n    def __new__(\n        cls: Type[\"_LineWithComments\"], value: Any, comments: List[str]\n    ) -> \"_LineWithComments\":\n        instance = super().__new__(cls, value)\n        instance.comments = comments\n        return instance\ndef _ensure_newline_before_comment(output: List[str]) -> List[str]:\n    new_output: List[str] = []",
        "detail": "__pypackages__.3.10.lib.isort.output",
        "documentation": {}
    },
    {
        "label": "sorted_imports",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.output",
        "description": "__pypackages__.3.10.lib.isort.output",
        "peekOfCode": "def sorted_imports(\n    parsed: parse.ParsedContent,\n    config: Config = DEFAULT_CONFIG,\n    extension: str = \"py\",\n    import_type: str = \"import\",\n) -> str:\n    \"\"\"Adds the imports back to the file.\n    (at the index of the first import) sorted alphabetically and split between groups\n    \"\"\"\n    if parsed.import_index == -1:",
        "detail": "__pypackages__.3.10.lib.isort.output",
        "documentation": {}
    },
    {
        "label": "ParsedContent",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.parse",
        "description": "__pypackages__.3.10.lib.isort.parse",
        "peekOfCode": "class ParsedContent(NamedTuple):\n    in_lines: List[str]\n    lines_without_imports: List[str]\n    import_index: int\n    place_imports: Dict[str, List[str]]\n    import_placements: Dict[str, str]\n    as_map: Dict[str, Dict[str, List[str]]]\n    imports: Dict[str, Dict[str, Any]]\n    categorized_comments: \"CommentsDict\"\n    change_count: int",
        "detail": "__pypackages__.3.10.lib.isort.parse",
        "documentation": {}
    },
    {
        "label": "import_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.parse",
        "description": "__pypackages__.3.10.lib.isort.parse",
        "peekOfCode": "def import_type(line: str, config: Config = DEFAULT_CONFIG) -> Optional[str]:\n    \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\"\n    if config.honor_noqa and line.lower().rstrip().endswith(\"noqa\"):\n        return None\n    if \"isort:skip\" in line or \"isort: skip\" in line or \"isort: split\" in line:\n        return None\n    if line.startswith((\"import \", \"cimport \")):\n        return \"straight\"\n    if line.startswith(\"from \"):\n        return \"from\"",
        "detail": "__pypackages__.3.10.lib.isort.parse",
        "documentation": {}
    },
    {
        "label": "skip_line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.parse",
        "description": "__pypackages__.3.10.lib.isort.parse",
        "peekOfCode": "def skip_line(\n    line: str,\n    in_quote: str,\n    index: int,\n    section_comments: Tuple[str, ...],\n    needs_import: bool = True,\n) -> Tuple[bool, str]:\n    \"\"\"Determine if a given line should be skipped.\n    Returns back a tuple containing:\n    (skip_line: bool,",
        "detail": "__pypackages__.3.10.lib.isort.parse",
        "documentation": {}
    },
    {
        "label": "file_contents",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.parse",
        "description": "__pypackages__.3.10.lib.isort.parse",
        "peekOfCode": "def file_contents(contents: str, config: Config = DEFAULT_CONFIG) -> ParsedContent:\n    \"\"\"Parses a python file taking out and categorizing imports.\"\"\"\n    line_separator: str = config.line_ending or _infer_line_separator(contents)\n    in_lines = contents.splitlines()\n    if contents and contents[-1] in (\"\\n\", \"\\r\"):\n        in_lines.append(\"\")\n    out_lines = []\n    original_line_count = len(in_lines)\n    if config.old_finders:\n        from .deprecated.finders import FindersManager",
        "detail": "__pypackages__.3.10.lib.isort.parse",
        "documentation": {}
    },
    {
        "label": "module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.place",
        "description": "__pypackages__.3.10.lib.isort.place",
        "peekOfCode": "def module(name: str, config: Config = DEFAULT_CONFIG) -> str:\n    \"\"\"Returns the section placement for the given module name.\"\"\"\n    return module_with_reason(name, config)[0]\n@lru_cache(maxsize=1000)\ndef module_with_reason(name: str, config: Config = DEFAULT_CONFIG) -> Tuple[str, str]:\n    \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\"\n    return (\n        _forced_separate(name, config)\n        or _local(name, config)\n        or _known_pattern(name, config)",
        "detail": "__pypackages__.3.10.lib.isort.place",
        "documentation": {}
    },
    {
        "label": "module_with_reason",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.place",
        "description": "__pypackages__.3.10.lib.isort.place",
        "peekOfCode": "def module_with_reason(name: str, config: Config = DEFAULT_CONFIG) -> Tuple[str, str]:\n    \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\"\n    return (\n        _forced_separate(name, config)\n        or _local(name, config)\n        or _known_pattern(name, config)\n        or _src_path(name, config)\n        or (config.default_section, \"Default option in Config or universal default.\")\n    )\ndef _forced_separate(name: str, config: Config) -> Optional[Tuple[str, str]]:",
        "detail": "__pypackages__.3.10.lib.isort.place",
        "documentation": {}
    },
    {
        "label": "LOCAL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.place",
        "description": "__pypackages__.3.10.lib.isort.place",
        "peekOfCode": "LOCAL = \"LOCALFOLDER\"\ndef module(name: str, config: Config = DEFAULT_CONFIG) -> str:\n    \"\"\"Returns the section placement for the given module name.\"\"\"\n    return module_with_reason(name, config)[0]\n@lru_cache(maxsize=1000)\ndef module_with_reason(name: str, config: Config = DEFAULT_CONFIG) -> Tuple[str, str]:\n    \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\"\n    return (\n        _forced_separate(name, config)\n        or _local(name, config)",
        "detail": "__pypackages__.3.10.lib.isort.place",
        "documentation": {}
    },
    {
        "label": "black",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "black = {\n    \"multi_line_output\": 3,\n    \"include_trailing_comma\": True,\n    \"force_grid_wrap\": 0,\n    \"use_parentheses\": True,\n    \"ensure_newline_before_comments\": True,\n    \"line_length\": 88,\n}\ndjango = {\n    \"combine_as_imports\": True,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "django",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "django = {\n    \"combine_as_imports\": True,\n    \"include_trailing_comma\": True,\n    \"multi_line_output\": 5,\n    \"line_length\": 79,\n}\npycharm = {\n    \"multi_line_output\": 3,\n    \"force_grid_wrap\": 2,\n    \"lines_after_imports\": 2,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "pycharm",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "pycharm = {\n    \"multi_line_output\": 3,\n    \"force_grid_wrap\": 2,\n    \"lines_after_imports\": 2,\n}\ngoogle = {\n    \"force_single_line\": True,\n    \"force_sort_within_sections\": True,\n    \"lexicographical\": True,\n    \"single_line_exclusions\": (\"typing\",),",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "google",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "google = {\n    \"force_single_line\": True,\n    \"force_sort_within_sections\": True,\n    \"lexicographical\": True,\n    \"single_line_exclusions\": (\"typing\",),\n    \"order_by_type\": False,\n    \"group_by_package\": True,\n}\nopen_stack = {\n    \"force_single_line\": True,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "open_stack",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "open_stack = {\n    \"force_single_line\": True,\n    \"force_sort_within_sections\": True,\n    \"lexicographical\": True,\n}\nplone = black.copy()\nplone.update(\n    {\n        \"force_alphabetical_sort\": True,\n        \"force_single_line\": True,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "plone",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "plone = black.copy()\nplone.update(\n    {\n        \"force_alphabetical_sort\": True,\n        \"force_single_line\": True,\n        \"lines_after_imports\": 2,\n    }\n)\nattrs = {\n    \"atomic\": True,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "attrs",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "attrs = {\n    \"atomic\": True,\n    \"force_grid_wrap\": 0,\n    \"include_trailing_comma\": True,\n    \"lines_after_imports\": 2,\n    \"lines_between_types\": 1,\n    \"multi_line_output\": 3,\n    \"use_parentheses\": True,\n}\nhug = {",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "hug",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "hug = {\n    \"multi_line_output\": 3,\n    \"include_trailing_comma\": True,\n    \"force_grid_wrap\": 0,\n    \"use_parentheses\": True,\n    \"line_length\": 100,\n}\nwemake = {\n    \"multi_line_output\": 3,\n    \"include_trailing_comma\": True,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "wemake",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "wemake = {\n    \"multi_line_output\": 3,\n    \"include_trailing_comma\": True,\n    \"use_parentheses\": True,\n    \"line_length\": 80,\n}\nappnexus = {\n    **black,\n    \"force_sort_within_sections\": True,\n    \"order_by_type\": False,",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "appnexus",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.profiles",
        "description": "__pypackages__.3.10.lib.isort.profiles",
        "peekOfCode": "appnexus = {\n    **black,\n    \"force_sort_within_sections\": True,\n    \"order_by_type\": False,\n    \"case_sensitive\": False,\n    \"reverse_relative\": True,\n    \"sort_relative_in_force_sorted_sections\": True,\n    \"sections\": [\"FUTURE\", \"STDLIB\", \"THIRDPARTY\", \"FIRSTPARTY\", \"APPLICATION\", \"LOCALFOLDER\"],\n    \"no_lines_before\": \"LOCALFOLDER\",\n}",
        "detail": "__pypackages__.3.10.lib.isort.profiles",
        "documentation": {}
    },
    {
        "label": "Linter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.pylama_isort",
        "description": "__pypackages__.3.10.lib.isort.pylama_isort",
        "peekOfCode": "class Linter(BaseLinter):  # type: ignore\n    def allow(self, path: str) -> bool:\n        \"\"\"Determine if this path should be linted.\"\"\"\n        return path.endswith(\".py\")\n    def run(\n        self, path: str, params: Optional[Dict[str, Any]] = None, **meta: Any\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\"\n        with suppress_stdout():\n            try:",
        "detail": "__pypackages__.3.10.lib.isort.pylama_isort",
        "documentation": {}
    },
    {
        "label": "suppress_stdout",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.pylama_isort",
        "description": "__pypackages__.3.10.lib.isort.pylama_isort",
        "peekOfCode": "def suppress_stdout() -> Iterator[None]:\n    stdout = sys.stdout\n    with open(os.devnull, \"w\") as devnull:\n        sys.stdout = devnull\n        yield\n        sys.stdout = stdout\nclass Linter(BaseLinter):  # type: ignore\n    def allow(self, path: str) -> bool:\n        \"\"\"Determine if this path should be linted.\"\"\"\n        return path.endswith(\".py\")",
        "detail": "__pypackages__.3.10.lib.isort.pylama_isort",
        "documentation": {}
    },
    {
        "label": "_Config",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "class _Config:\n    \"\"\"Defines the data schema and defaults used for isort configuration.\n    NOTE: known lists, such as known_standard_library, are intentionally not complete as they are\n    dynamically determined later on.\n    \"\"\"\n    py_version: str = \"3\"\n    force_to_top: FrozenSet[str] = frozenset()\n    skip: FrozenSet[str] = DEFAULT_SKIP\n    extend_skip: FrozenSet[str] = frozenset()\n    skip_glob: FrozenSet[str] = frozenset()",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "class Config(_Config):\n    def __init__(\n        self,\n        settings_file: str = \"\",\n        settings_path: str = \"\",\n        config: Optional[_Config] = None,\n        **config_overrides: Any,\n    ):\n        self._known_patterns: Optional[List[Tuple[Pattern[str], str]]] = None\n        self._section_comments: Optional[Tuple[str, ...]] = None",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "find_all_configs",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "def find_all_configs(path: str) -> Trie:\n    \"\"\"\n    Looks for config files in the path provided and in all of its sub-directories.\n    Parses and stores any config file encountered in a trie and returns the root of\n    the trie\n    \"\"\"\n    trie_root = Trie(\"default\", {})\n    for (dirpath, _, _) in os.walk(path):\n        for config_file_name in CONFIG_SOURCES:\n            potential_config_file = os.path.join(dirpath, config_file_name)",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "_SHEBANG_RE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "_SHEBANG_RE = re.compile(rb\"^#!.*\\bpython[23w]?\\b\")\nCYTHON_EXTENSIONS = frozenset({\"pyx\", \"pxd\"})\nSUPPORTED_EXTENSIONS = frozenset({\"py\", \"pyi\", *CYTHON_EXTENSIONS})\nBLOCKED_EXTENSIONS = frozenset({\"pex\"})\nFILE_SKIP_COMMENTS: Tuple[str, ...] = (\n    \"isort:\" + \"skip_file\",\n    \"isort: \" + \"skip_file\",\n)  # Concatenated to avoid this file being skipped\nMAX_CONFIG_SEARCH_DEPTH: int = 25  # The number of parent directories to for a config file within\nSTOP_CONFIG_SEARCH_ON_DIRS: Tuple[str, ...] = (\".git\", \".hg\")",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "CYTHON_EXTENSIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "CYTHON_EXTENSIONS = frozenset({\"pyx\", \"pxd\"})\nSUPPORTED_EXTENSIONS = frozenset({\"py\", \"pyi\", *CYTHON_EXTENSIONS})\nBLOCKED_EXTENSIONS = frozenset({\"pex\"})\nFILE_SKIP_COMMENTS: Tuple[str, ...] = (\n    \"isort:\" + \"skip_file\",\n    \"isort: \" + \"skip_file\",\n)  # Concatenated to avoid this file being skipped\nMAX_CONFIG_SEARCH_DEPTH: int = 25  # The number of parent directories to for a config file within\nSTOP_CONFIG_SEARCH_ON_DIRS: Tuple[str, ...] = (\".git\", \".hg\")\nVALID_PY_TARGETS: Tuple[str, ...] = tuple(",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "SUPPORTED_EXTENSIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "SUPPORTED_EXTENSIONS = frozenset({\"py\", \"pyi\", *CYTHON_EXTENSIONS})\nBLOCKED_EXTENSIONS = frozenset({\"pex\"})\nFILE_SKIP_COMMENTS: Tuple[str, ...] = (\n    \"isort:\" + \"skip_file\",\n    \"isort: \" + \"skip_file\",\n)  # Concatenated to avoid this file being skipped\nMAX_CONFIG_SEARCH_DEPTH: int = 25  # The number of parent directories to for a config file within\nSTOP_CONFIG_SEARCH_ON_DIRS: Tuple[str, ...] = (\".git\", \".hg\")\nVALID_PY_TARGETS: Tuple[str, ...] = tuple(\n    target.replace(\"py\", \"\") for target in dir(stdlibs) if not target.startswith(\"_\")",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "BLOCKED_EXTENSIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "BLOCKED_EXTENSIONS = frozenset({\"pex\"})\nFILE_SKIP_COMMENTS: Tuple[str, ...] = (\n    \"isort:\" + \"skip_file\",\n    \"isort: \" + \"skip_file\",\n)  # Concatenated to avoid this file being skipped\nMAX_CONFIG_SEARCH_DEPTH: int = 25  # The number of parent directories to for a config file within\nSTOP_CONFIG_SEARCH_ON_DIRS: Tuple[str, ...] = (\".git\", \".hg\")\nVALID_PY_TARGETS: Tuple[str, ...] = tuple(\n    target.replace(\"py\", \"\") for target in dir(stdlibs) if not target.startswith(\"_\")\n)",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "IMPORT_HEADING_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "IMPORT_HEADING_PREFIX = \"import_heading_\"\nIMPORT_FOOTER_PREFIX = \"import_footer_\"\nKNOWN_PREFIX = \"known_\"\nKNOWN_SECTION_MAPPING: Dict[str, str] = {\n    STDLIB: \"STANDARD_LIBRARY\",\n    FUTURE: \"FUTURE_LIBRARY\",\n    FIRSTPARTY: \"FIRST_PARTY\",\n    THIRDPARTY: \"THIRD_PARTY\",\n    LOCALFOLDER: \"LOCAL_FOLDER\",\n}",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "IMPORT_FOOTER_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "IMPORT_FOOTER_PREFIX = \"import_footer_\"\nKNOWN_PREFIX = \"known_\"\nKNOWN_SECTION_MAPPING: Dict[str, str] = {\n    STDLIB: \"STANDARD_LIBRARY\",\n    FUTURE: \"FUTURE_LIBRARY\",\n    FIRSTPARTY: \"FIRST_PARTY\",\n    THIRDPARTY: \"THIRD_PARTY\",\n    LOCALFOLDER: \"LOCAL_FOLDER\",\n}\nRUNTIME_SOURCE = \"runtime\"",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "KNOWN_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "KNOWN_PREFIX = \"known_\"\nKNOWN_SECTION_MAPPING: Dict[str, str] = {\n    STDLIB: \"STANDARD_LIBRARY\",\n    FUTURE: \"FUTURE_LIBRARY\",\n    FIRSTPARTY: \"FIRST_PARTY\",\n    THIRDPARTY: \"THIRD_PARTY\",\n    LOCALFOLDER: \"LOCAL_FOLDER\",\n}\nRUNTIME_SOURCE = \"runtime\"\nDEPRECATED_SETTINGS = (\"not_skip\", \"keep_direct_and_as_imports\")",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "RUNTIME_SOURCE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "RUNTIME_SOURCE = \"runtime\"\nDEPRECATED_SETTINGS = (\"not_skip\", \"keep_direct_and_as_imports\")\n_STR_BOOLEAN_MAPPING = {\n    \"y\": True,\n    \"yes\": True,\n    \"t\": True,\n    \"on\": True,\n    \"1\": True,\n    \"true\": True,\n    \"n\": False,",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "DEPRECATED_SETTINGS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "DEPRECATED_SETTINGS = (\"not_skip\", \"keep_direct_and_as_imports\")\n_STR_BOOLEAN_MAPPING = {\n    \"y\": True,\n    \"yes\": True,\n    \"t\": True,\n    \"on\": True,\n    \"1\": True,\n    \"true\": True,\n    \"n\": False,\n    \"no\": False,",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "_STR_BOOLEAN_MAPPING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "_STR_BOOLEAN_MAPPING = {\n    \"y\": True,\n    \"yes\": True,\n    \"t\": True,\n    \"on\": True,\n    \"1\": True,\n    \"true\": True,\n    \"n\": False,\n    \"no\": False,\n    \"f\": False,",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_SETTINGS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "_DEFAULT_SETTINGS = {**vars(_Config()), \"source\": \"defaults\"}\nclass Config(_Config):\n    def __init__(\n        self,\n        settings_file: str = \"\",\n        settings_path: str = \"\",\n        config: Optional[_Config] = None,\n        **config_overrides: Any,\n    ):\n        self._known_patterns: Optional[List[Tuple[Pattern[str], str]]] = None",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.settings",
        "description": "__pypackages__.3.10.lib.isort.settings",
        "peekOfCode": "DEFAULT_CONFIG = Config()",
        "detail": "__pypackages__.3.10.lib.isort.settings",
        "documentation": {}
    },
    {
        "label": "ISortCommand",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.setuptools_commands",
        "description": "__pypackages__.3.10.lib.isort.setuptools_commands",
        "peekOfCode": "class ISortCommand(setuptools.Command):  # type: ignore\n    \"\"\"The :class:`ISortCommand` class is used by setuptools to perform\n    imports checks on registered modules.\n    \"\"\"\n    description = \"Run isort on modules registered in setuptools\"\n    user_options: List[Any] = []\n    def initialize_options(self) -> None:\n        default_settings = vars(DEFAULT_CONFIG).copy()\n        for key, value in default_settings.items():\n            setattr(self, key, value)",
        "detail": "__pypackages__.3.10.lib.isort.setuptools_commands",
        "documentation": {}
    },
    {
        "label": "module_key",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "def module_key(\n    module_name: str,\n    config: Config,\n    sub_imports: bool = False,\n    ignore_case: bool = False,\n    section_name: Optional[Any] = None,\n    straight_import: Optional[bool] = False,\n) -> str:\n    match = re.match(r\"^(\\.+)\\s*(.*)\", module_name)\n    if match:",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "section_key",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "def section_key(line: str, config: Config) -> str:\n    section = \"B\"\n    if (\n        not config.sort_relative_in_force_sorted_sections\n        and config.reverse_relative\n        and line.startswith(\"from .\")\n    ):\n        match = re.match(r\"^from (\\.+)\\s*(.*)\", line)\n        if match:  # pragma: no cover - regex always matches if line starts with \"from .\"\n            line = f\"from {' '.join(match.groups())}\"",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "sort",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "def sort(\n    config: Config,\n    to_sort: Iterable[str],\n    key: Optional[Callable[[str], Any]] = None,\n    reverse: bool = False,\n) -> List[str]:\n    return config.sorting_function(to_sort, key=key, reverse=reverse)\ndef naturally(\n    to_sort: Iterable[str], key: Optional[Callable[[str], Any]] = None, reverse: bool = False\n) -> List[str]:",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "naturally",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "def naturally(\n    to_sort: Iterable[str], key: Optional[Callable[[str], Any]] = None, reverse: bool = False\n) -> List[str]:\n    \"\"\"Returns a naturally sorted list\"\"\"\n    if key is None:\n        key_callback = _natural_keys\n    else:\n        def key_callback(text: str) -> List[Any]:\n            return _natural_keys(key(text))  # type: ignore\n    return sorted(to_sort, key=key_callback, reverse=reverse)",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "_import_line_intro_re",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "_import_line_intro_re = re.compile(\"^(?:from|import) \")\n_import_line_midline_import_re = re.compile(\" import \")\ndef module_key(\n    module_name: str,\n    config: Config,\n    sub_imports: bool = False,\n    ignore_case: bool = False,\n    section_name: Optional[Any] = None,\n    straight_import: Optional[bool] = False,\n) -> str:",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "_import_line_midline_import_re",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.sorting",
        "description": "__pypackages__.3.10.lib.isort.sorting",
        "peekOfCode": "_import_line_midline_import_re = re.compile(\" import \")\ndef module_key(\n    module_name: str,\n    config: Config,\n    sub_imports: bool = False,\n    ignore_case: bool = False,\n    section_name: Optional[Any] = None,\n    straight_import: Optional[bool] = False,\n) -> str:\n    match = re.match(r\"^(\\.+)\\s*(.*)\", module_name)",
        "detail": "__pypackages__.3.10.lib.isort.sorting",
        "documentation": {}
    },
    {
        "label": "TrieNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.utils",
        "description": "__pypackages__.3.10.lib.isort.utils",
        "peekOfCode": "class TrieNode:\n    def __init__(self, config_file: str = \"\", config_data: Optional[Dict[str, Any]] = None) -> None:\n        if not config_data:\n            config_data = {}\n        self.nodes: Dict[str, TrieNode] = {}\n        self.config_info: Tuple[str, Dict[str, Any]] = (config_file, config_data)\nclass Trie:\n    \"\"\"\n    A prefix tree to store the paths of all config files and to search the nearest config\n    associated with each file",
        "detail": "__pypackages__.3.10.lib.isort.utils",
        "documentation": {}
    },
    {
        "label": "Trie",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.isort.utils",
        "description": "__pypackages__.3.10.lib.isort.utils",
        "peekOfCode": "class Trie:\n    \"\"\"\n    A prefix tree to store the paths of all config files and to search the nearest config\n    associated with each file\n    \"\"\"\n    def __init__(self, config_file: str = \"\", config_data: Optional[Dict[str, Any]] = None) -> None:\n        self.root: TrieNode = TrieNode(config_file, config_data)\n    def insert(self, config_file: str, config_data: Dict[str, Any]) -> None:\n        resolved_config_path_as_tuple = Path(config_file).parent.resolve().parts\n        temp = self.root",
        "detail": "__pypackages__.3.10.lib.isort.utils",
        "documentation": {}
    },
    {
        "label": "exists_case_sensitive",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.utils",
        "description": "__pypackages__.3.10.lib.isort.utils",
        "peekOfCode": "def exists_case_sensitive(path: str) -> bool:\n    \"\"\"Returns if the given path exists and also matches the case on Windows.\n    When finding files that can be imported, it is important for the cases to match because while\n    file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows,\n    Python can only import using the case of the real file.\n    \"\"\"\n    result = os.path.exists(path)\n    if (sys.platform.startswith(\"win\") or sys.platform == \"darwin\") and result:  # pragma: no cover\n        directory, basename = os.path.split(path)\n        result = basename in os.listdir(directory)",
        "detail": "__pypackages__.3.10.lib.isort.utils",
        "documentation": {}
    },
    {
        "label": "import_statement",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap",
        "description": "__pypackages__.3.10.lib.isort.wrap",
        "peekOfCode": "def import_statement(\n    import_start: str,\n    from_imports: List[str],\n    comments: Sequence[str] = (),\n    line_separator: str = \"\\n\",\n    config: Config = DEFAULT_CONFIG,\n    multi_line_output: Optional[Modes] = None,\n    explode: bool = False,\n) -> str:\n    \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\"",
        "detail": "__pypackages__.3.10.lib.isort.wrap",
        "documentation": {}
    },
    {
        "label": "line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap",
        "description": "__pypackages__.3.10.lib.isort.wrap",
        "peekOfCode": "def line(content: str, line_separator: str, config: Config = DEFAULT_CONFIG) -> str:\n    \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\"\n    wrap_mode = config.multi_line_output\n    if len(content) > config.line_length and wrap_mode != Modes.NOQA:  # type: ignore\n        line_without_comment = content\n        comment = None\n        if \"#\" in content:\n            line_without_comment, comment = content.split(\"#\", 1)\n        for splitter in (\"import \", \"cimport \", \".\", \"as \"):\n            exp = r\"\\b\" + re.escape(splitter) + r\"\\b\"",
        "detail": "__pypackages__.3.10.lib.isort.wrap",
        "documentation": {}
    },
    {
        "label": "_wrap_line",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.wrap",
        "description": "__pypackages__.3.10.lib.isort.wrap",
        "peekOfCode": "_wrap_line = line",
        "detail": "__pypackages__.3.10.lib.isort.wrap",
        "documentation": {}
    },
    {
        "label": "from_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def from_string(value: str) -> \"WrapModes\":\n    return getattr(WrapModes, str(value), None) or WrapModes(int(value))\ndef formatter_from_string(name: str) -> Callable[..., str]:\n    return _wrap_modes.get(name.upper(), grid)\ndef _wrap_mode_interface(\n    statement: str,\n    imports: List[str],\n    white_space: str,\n    indent: str,\n    line_length: int,",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "formatter_from_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def formatter_from_string(name: str) -> Callable[..., str]:\n    return _wrap_modes.get(name.upper(), grid)\ndef _wrap_mode_interface(\n    statement: str,\n    imports: List[str],\n    white_space: str,\n    indent: str,\n    line_length: int,\n    comments: List[str],\n    line_separator: str,",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def grid(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    interface[\"statement\"] += \"(\" + interface[\"imports\"].pop(0)\n    while interface[\"imports\"]:\n        next_import = interface[\"imports\"].pop(0)\n        next_statement = isort.comments.add_to_line(\n            interface[\"comments\"],\n            interface[\"statement\"] + \", \" + next_import,\n            removed=interface[\"remove_comments\"],",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    first_import = (\n        isort.comments.add_to_line(\n            interface[\"comments\"],\n            interface[\"imports\"].pop(0) + \",\",\n            removed=interface[\"remove_comments\"],\n            comment_prefix=interface[\"comment_prefix\"],\n        )",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "hanging_indent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def hanging_indent(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    line_length_limit = interface[\"line_length\"] - 3\n    next_import = interface[\"imports\"].pop(0)\n    next_statement = interface[\"statement\"] + next_import\n    # Check for first import\n    if len(next_statement) > line_length_limit:\n        next_statement = (\n            _hanging_indent_end_line(interface[\"statement\"])",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_hanging_indent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_hanging_indent(**interface: Any) -> str:\n    _line_with_comments = isort.comments.add_to_line(\n        interface[\"comments\"],\n        \"\",\n        removed=interface[\"remove_comments\"],\n        comment_prefix=interface[\"comment_prefix\"],\n    )\n    _imports = (\",\" + interface[\"line_separator\"] + interface[\"indent\"]).join(interface[\"imports\"])\n    _comma_maybe = \",\" if interface[\"include_trailing_comma\"] else \"\"\n    return (",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_grid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_grid(**interface: Any) -> str:\n    return _vertical_grid_common(need_trailing_char=True, **interface) + \")\"\n@_wrap_mode\ndef vertical_grid_grouped(**interface: Any) -> str:\n    return (\n        _vertical_grid_common(need_trailing_char=False, **interface)\n        + str(interface[\"line_separator\"])\n        + \")\"\n    )\n@_wrap_mode",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_grid_grouped",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_grid_grouped(**interface: Any) -> str:\n    return (\n        _vertical_grid_common(need_trailing_char=False, **interface)\n        + str(interface[\"line_separator\"])\n        + \")\"\n    )\n@_wrap_mode\ndef vertical_grid_grouped_no_comma(**interface: Any) -> str:\n    # This is a deprecated alias for vertical_grid_grouped above. This function\n    # needs to exist for backwards compatibility but should never get called.",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_grid_grouped_no_comma",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_grid_grouped_no_comma(**interface: Any) -> str:\n    # This is a deprecated alias for vertical_grid_grouped above. This function\n    # needs to exist for backwards compatibility but should never get called.\n    raise NotImplementedError\n@_wrap_mode\ndef noqa(**interface: Any) -> str:\n    _imports = \", \".join(interface[\"imports\"])\n    retval = f\"{interface['statement']}{_imports}\"\n    comment_str = \" \".join(interface[\"comments\"])\n    if interface[\"comments\"]:",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "noqa",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def noqa(**interface: Any) -> str:\n    _imports = \", \".join(interface[\"imports\"])\n    retval = f\"{interface['statement']}{_imports}\"\n    comment_str = \" \".join(interface[\"comments\"])\n    if interface[\"comments\"]:\n        if (\n            len(retval) + len(interface[\"comment_prefix\"]) + 1 + len(comment_str)\n            <= interface[\"line_length\"]\n        ):\n            return f\"{retval}{interface['comment_prefix']} {comment_str}\"",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_hanging_indent_bracket",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_hanging_indent_bracket(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    statement = vertical_hanging_indent(**interface)\n    return f'{statement[:-1]}{interface[\"indent\"]})'\n@_wrap_mode\ndef vertical_prefix_from_module_import(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    prefix_statement = interface[\"statement\"]",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "vertical_prefix_from_module_import",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def vertical_prefix_from_module_import(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    prefix_statement = interface[\"statement\"]\n    output_statement = prefix_statement + interface[\"imports\"].pop(0)\n    comments = interface[\"comments\"]\n    statement = output_statement\n    statement_with_comments = \"\"\n    for next_import in interface[\"imports\"]:\n        statement = statement + \", \" + next_import",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "hanging_indent_with_parentheses",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def hanging_indent_with_parentheses(**interface: Any) -> str:\n    if not interface[\"imports\"]:\n        return \"\"\n    line_length_limit = interface[\"line_length\"] - 1\n    interface[\"statement\"] += \"(\"\n    next_import = interface[\"imports\"].pop(0)\n    next_statement = interface[\"statement\"] + next_import\n    # Check for first import\n    if len(next_statement) > line_length_limit:\n        next_statement = (",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "backslash_grid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "def backslash_grid(**interface: Any) -> str:\n    interface[\"indent\"] = interface[\"white_space\"][:-1]\n    return hanging_indent(**interface)\nWrapModes = enum.Enum(  # type: ignore\n    \"WrapModes\", {wrap_mode: index for index, wrap_mode in enumerate(_wrap_modes.keys())}\n)",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "WrapModes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.isort.wrap_modes",
        "description": "__pypackages__.3.10.lib.isort.wrap_modes",
        "peekOfCode": "WrapModes = enum.Enum(  # type: ignore\n    \"WrapModes\", {wrap_mode: index for index, wrap_mode in enumerate(_wrap_modes.keys())}\n)",
        "detail": "__pypackages__.3.10.lib.isort.wrap_modes",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "peekOfCode": "__version__ = version = '1.9.0'\n__version_tuple__ = version_tuple = (1, 9, 0)",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (1, 9, 0)",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy._version",
        "documentation": {}
    },
    {
        "label": "with_metaclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "peekOfCode": "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "documentation": {}
    },
    {
        "label": "string_types",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "peekOfCode": "string_types = str, bytes\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.compat",
        "documentation": {}
    },
    {
        "label": "_ProxyMethods",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "peekOfCode": "class _ProxyMethods(object):\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself\n    # via a meta class. In that way the properties will always take\n    # precedence.\n    @property",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "documentation": {}
    },
    {
        "label": "_ProxyMetaType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "peekOfCode": "class _ProxyMetaType(type):\n    def __new__(cls, name, bases, dictionary):\n        # Copy our special properties into the class so that they\n        # always take precedence over attributes of the same name added\n        # during construction of a derived class. This is to save\n        # duplicating the implementation for them in all derived classes.\n        dictionary.update(vars(_ProxyMethods))\n        dictionary.pop('__dict__')\n        return type.__new__(cls, name, bases, dictionary)\nclass Proxy(with_metaclass(_ProxyMetaType)):",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "documentation": {}
    },
    {
        "label": "Proxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "peekOfCode": "class Proxy(with_metaclass(_ProxyMetaType)):\n    __factory__ = None\n    def __init__(self, factory):\n        self.__dict__['__factory__'] = factory\n    @property\n    def __resolved__(self):\n        return '__wrapped__' in self.__dict__\n    @cached_property\n    def __wrapped__(self):\n        self = self.__dict__",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "documentation": {}
    },
    {
        "label": "make_proxy_method",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "peekOfCode": "def make_proxy_method(code):\n    def proxy_wrapper(self, *args):\n        return code(self.__wrapped__, *args)\n    return proxy_wrapper\nclass _ProxyMethods(object):\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.simple",
        "documentation": {}
    },
    {
        "label": "_ProxyMethods",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "peekOfCode": "class _ProxyMethods(object):\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself\n    # via a meta class. In that way the properties will always take\n    # precedence.\n    @property",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "documentation": {}
    },
    {
        "label": "_ProxyMetaType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "peekOfCode": "class _ProxyMetaType(type):\n    def __new__(cls, name, bases, dictionary):\n        # Copy our special properties into the class so that they\n        # always take precedence over attributes of the same name added\n        # during construction of a derived class. This is to save\n        # duplicating the implementation for them in all derived classes.\n        dictionary.update(vars(_ProxyMethods))\n        return type.__new__(cls, name, bases, dictionary)\nclass Proxy(with_metaclass(_ProxyMetaType)):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "documentation": {}
    },
    {
        "label": "Proxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "peekOfCode": "class Proxy(with_metaclass(_ProxyMetaType)):\n    \"\"\"\n    A proxy implementation in pure Python, using slots. You can subclass this to add\n    local methods or attributes, or enable __dict__.\n    The most important internals:\n    * ``__factory__`` is the callback that \"materializes\" the object we proxy to.\n    * ``__target__`` will contain the object we proxy to, once it's \"materialized\".\n    * ``__resolved__`` is a boolean, `True` if factory was called.\n    * ``__wrapped__`` is a property that does either:\n      * return ``__target__`` if it's set.",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.slots",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "peekOfCode": "class cached_property(object):\n    def __init__(self, func):\n        self.func = func\n    def __get__(self, obj, cls):\n        if obj is None:\n            return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "documentation": {}
    },
    {
        "label": "do_yield_from",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "peekOfCode": "def do_yield_from(gen):\n    return (yield from gen)\ndef await_(obj):\n    obj_type = type(obj)\n    if (\n        obj_type is CoroutineType\n        or obj_type is GeneratorType\n        and bool(obj.gi_code.co_flags & CO_ITERABLE_COROUTINE)\n        or isinstance(obj, Awaitable)\n    ):",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "documentation": {}
    },
    {
        "label": "await_",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "peekOfCode": "def await_(obj):\n    obj_type = type(obj)\n    if (\n        obj_type is CoroutineType\n        or obj_type is GeneratorType\n        and bool(obj.gi_code.co_flags & CO_ITERABLE_COROUTINE)\n        or isinstance(obj, Awaitable)\n    ):\n        return do_await(obj).__await__()\n    else:",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "description": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "peekOfCode": "def identity(obj):\n    return obj\nclass cached_property(object):\n    def __init__(self, func):\n        self.func = func\n    def __get__(self, obj, cls):\n        if obj is None:\n            return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value",
        "detail": "__pypackages__.3.10.lib.lazy_object_proxy.utils",
        "documentation": {}
    },
    {
        "label": "ELFInvalid",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._elffile",
        "description": "__pypackages__.3.10.lib.packaging._elffile",
        "peekOfCode": "class ELFInvalid(ValueError):\n    pass\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3",
        "detail": "__pypackages__.3.10.lib.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EIClass",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._elffile",
        "description": "__pypackages__.3.10.lib.packaging._elffile",
        "peekOfCode": "class EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40",
        "detail": "__pypackages__.3.10.lib.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EIData",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._elffile",
        "description": "__pypackages__.3.10.lib.packaging._elffile",
        "peekOfCode": "class EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\nclass ELFFile:",
        "detail": "__pypackages__.3.10.lib.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EMachine",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._elffile",
        "description": "__pypackages__.3.10.lib.packaging._elffile",
        "peekOfCode": "class EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "ELFFile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._elffile",
        "description": "__pypackages__.3.10.lib.packaging._elffile",
        "peekOfCode": "class ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")",
        "detail": "__pypackages__.3.10.lib.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "_GLibCVersion",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "class _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "def platform_tags(linux: str, arch: str) -> Iterator[str]:\n    if not _have_compatible_abi(sys.executable, arch):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if arch in {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABIMASK",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABI_VER5",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\ndef _is_linux_armhf(executable: str) -> bool:",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABI_FLOAT_HARD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "_LEGACY_MANYLINUX_MAP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._manylinux",
        "description": "__pypackages__.3.10.lib.packaging._manylinux",
        "peekOfCode": "_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\ndef platform_tags(linux: str, arch: str) -> Iterator[str]:\n    if not _have_compatible_abi(sys.executable, arch):",
        "detail": "__pypackages__.3.10.lib.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "_MuslVersion",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._musllinux",
        "description": "__pypackages__.3.10.lib.packaging._musllinux",
        "peekOfCode": "class _MuslVersion(NamedTuple):\n    major: int\n    minor: int\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None",
        "detail": "__pypackages__.3.10.lib.packaging._musllinux",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._musllinux",
        "description": "__pypackages__.3.10.lib.packaging._musllinux",
        "peekOfCode": "def platform_tags(arch: str) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n    :param arch: Should be the part of platform tag after the ``linux_``\n        prefix, e.g. ``x86_64``. The ``linux_`` prefix is assumed as a\n        prerequisite for the current platform to be musllinux-compatible.\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return",
        "detail": "__pypackages__.3.10.lib.packaging._musllinux",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "class Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n    def __str__(self) -> str:\n        return self.value\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n    def serialize(self) -> str:\n        raise NotImplementedError\nclass Variable(Node):",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Variable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "class Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "class Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Op",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "class Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "ParsedRequirement",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "class ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "parse_requirement",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "def parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "parse_marker",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "def parse_marker(source: str) -> MarkerList:\n    return _parse_marker(Tokenizer(source, rules=DEFAULT_RULES))\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "process_env_var",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "def process_env_var(env_var: str) -> Variable:\n    if (\n        env_var == \"platform_python_implementation\"\n        or env_var == \"python_implementation\"\n    ):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "process_python_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "def process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerVar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "MarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerItem",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "MarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerAtom",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "MarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerList",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._parser",
        "description": "__pypackages__.3.10.lib.packaging._parser",
        "peekOfCode": "MarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------",
        "detail": "__pypackages__.3.10.lib.packaging._parser",
        "documentation": {}
    },
    {
        "label": "InfinityType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._structures",
        "description": "__pypackages__.3.10.lib.packaging._structures",
        "peekOfCode": "class InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return False\n    def __le__(self, other: object) -> bool:\n        return False\n    def __eq__(self, other: object) -> bool:",
        "detail": "__pypackages__.3.10.lib.packaging._structures",
        "documentation": {}
    },
    {
        "label": "NegativeInfinityType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._structures",
        "description": "__pypackages__.3.10.lib.packaging._structures",
        "peekOfCode": "class NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return True\n    def __le__(self, other: object) -> bool:\n        return True\n    def __eq__(self, other: object) -> bool:",
        "detail": "__pypackages__.3.10.lib.packaging._structures",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._structures",
        "description": "__pypackages__.3.10.lib.packaging._structures",
        "peekOfCode": "Infinity = InfinityType()\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return True\n    def __le__(self, other: object) -> bool:\n        return True",
        "detail": "__pypackages__.3.10.lib.packaging._structures",
        "documentation": {}
    },
    {
        "label": "NegativeInfinity",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging._structures",
        "description": "__pypackages__.3.10.lib.packaging._structures",
        "peekOfCode": "NegativeInfinity = NegativeInfinityType()",
        "detail": "__pypackages__.3.10.lib.packaging._structures",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._tokenizer",
        "description": "__pypackages__.3.10.lib.packaging._tokenizer",
        "peekOfCode": "class Token:\n    name: str\n    text: str\n    position: int\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n    def __init__(\n        self,\n        message: str,\n        *,",
        "detail": "__pypackages__.3.10.lib.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "ParserSyntaxError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._tokenizer",
        "description": "__pypackages__.3.10.lib.packaging._tokenizer",
        "peekOfCode": "class ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span",
        "detail": "__pypackages__.3.10.lib.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging._tokenizer",
        "description": "__pypackages__.3.10.lib.packaging._tokenizer",
        "peekOfCode": "class Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",",
        "detail": "__pypackages__.3.10.lib.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "InvalidMarker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "class InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "UndefinedComparison",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "class UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\ndef _normalize_extra_values(results: Any) -> Any:",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "UndefinedEnvironmentName",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "class UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "Marker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "class Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "format_full_version",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "def format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "default_environment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "def default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\nOperator = Callable[[str, str], bool]\nclass InvalidMarker(ValueError):\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "Operator",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.markers",
        "description": "__pypackages__.3.10.lib.packaging.markers",
        "peekOfCode": "Operator = Callable[[str, str], bool]\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):",
        "detail": "__pypackages__.3.10.lib.packaging.markers",
        "documentation": {}
    },
    {
        "label": "InvalidRequirement",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.requirements",
        "description": "__pypackages__.3.10.lib.packaging.requirements",
        "peekOfCode": "class InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\nclass Requirement:\n    \"\"\"Parse a requirement.\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.requirements",
        "documentation": {}
    },
    {
        "label": "Requirement",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.requirements",
        "description": "__pypackages__.3.10.lib.packaging.requirements",
        "peekOfCode": "class Requirement:\n    \"\"\"Parse a requirement.\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?",
        "detail": "__pypackages__.3.10.lib.packaging.requirements",
        "documentation": {}
    },
    {
        "label": "InvalidSpecifier",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "class InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\nclass BaseSpecifier(metaclass=abc.ABCMeta):",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "BaseSpecifier",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "class BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "Specifier",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "class Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n    .. tip::\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "SpecifierSet",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "class SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n        :param specifiers:",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "UnparsedVersion",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "UnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "UnparsedVersionVar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "UnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "CallableOperator",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "CallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n    >>> Specifier(\"lolwat\")",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "_prefix_regex",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.specifiers",
        "description": "__pypackages__.3.10.lib.packaging.specifiers",
        "peekOfCode": "_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\ndef _version_split(version: str) -> List[str]:\n    result: List[str] = []\n    for item in version.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result",
        "detail": "__pypackages__.3.10.lib.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "Tag",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "class Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "parse_tag",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "cpython_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n    The tags consist of:",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "generic_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n    The tags consist of:",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "compatible_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "mac_platforms",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "interpreter_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "interpreter_version",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "sys_tags",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "def sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "logger = logging.getLogger(__name__)\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "PythonVersion",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "PythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n_32_BIT_INTERPRETER = sys.maxsize <= 2**32",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "MacVersion",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "MacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n_32_BIT_INTERPRETER = sys.maxsize <= 2**32\nclass Tag:",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "_32_BIT_INTERPRETER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.tags",
        "description": "__pypackages__.3.10.lib.packaging.tags",
        "peekOfCode": "_32_BIT_INTERPRETER = sys.maxsize <= 2**32\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()",
        "detail": "__pypackages__.3.10.lib.packaging.tags",
        "documentation": {}
    },
    {
        "label": "InvalidWheelFilename",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "class InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "InvalidSdistFilename",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "class InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "canonicalize_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "def canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "canonicalize_version",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "def canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "parse_wheel_filename",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "def parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "parse_sdist_filename",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "def parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "BuildTag",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "BuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "NormalizedName",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "NormalizedName = NewType(\"NormalizedName\", str)\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "_canonicalize_regex",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "_build_tag_regex",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.utils",
        "description": "__pypackages__.3.10.lib.packaging.utils",
        "peekOfCode": "_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference",
        "detail": "__pypackages__.3.10.lib.packaging.utils",
        "documentation": {}
    },
    {
        "label": "InvalidVersion",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "class InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\nclass _BaseVersion:\n    _key: CmpKey\n    def __hash__(self) -> int:",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "_BaseVersion",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "class _BaseVersion:\n    _key: CmpKey\n    def __hash__(self) -> int:\n        return hash(self._key)\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "Version",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "class Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "def parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\nInfiniteTypes = Union[InfinityType, NegativeInfinityType]\nPrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "InfiniteTypes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "InfiniteTypes = Union[InfinityType, NegativeInfinityType]\nPrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "PrePostDevType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "SubLocalType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "SubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],\n        ...,",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "LocalType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "LocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],\n        ...,\n    ],",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "CmpKey",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "CmpKey = Tuple[\n    int, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "VersionComparisonMethod",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "_Version",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "_VERSION_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "VERSION_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "VERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n:meta hide-value:\n\"\"\"\nclass Version(_BaseVersion):",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "_local_version_separators",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.packaging.version",
        "description": "__pypackages__.3.10.lib.packaging.version",
        "peekOfCode": "_local_version_separators = re.compile(r\"[\\._-]\")\ndef _parse_local_version(local: str) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )",
        "detail": "__pypackages__.3.10.lib.packaging.version",
        "documentation": {}
    },
    {
        "label": "Android",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.platformdirs.android",
        "description": "__pypackages__.3.10.lib.platformdirs.android",
        "peekOfCode": "class Android(PlatformDirsABC):\n    \"\"\"\n    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_. Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>` and\n    `version <platformdirs.api.PlatformDirsABC.version>`.\n    \"\"\"\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"files\")",
        "detail": "__pypackages__.3.10.lib.platformdirs.android",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.android",
        "description": "__pypackages__.3.10.lib.platformdirs.android",
        "peekOfCode": "__all__ = [\n    \"Android\",\n]",
        "detail": "__pypackages__.3.10.lib.platformdirs.android",
        "documentation": {}
    },
    {
        "label": "PlatformDirsABC",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.platformdirs.api",
        "description": "__pypackages__.3.10.lib.platformdirs.api",
        "peekOfCode": "class PlatformDirsABC(ABC):\n    \"\"\"\n    Abstract base class for platform directories.\n    \"\"\"\n    def __init__(\n        self,\n        appname: str | None = None,\n        appauthor: str | None | Literal[False] = None,\n        version: str | None = None,\n        roaming: bool = False,",
        "detail": "__pypackages__.3.10.lib.platformdirs.api",
        "documentation": {}
    },
    {
        "label": "MacOS",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.platformdirs.macos",
        "description": "__pypackages__.3.10.lib.platformdirs.macos",
        "peekOfCode": "class MacOS(PlatformDirsABC):\n    \"\"\"\n    Platform directories for the macOS operating system. Follows the guidance from `Apple documentation\n    <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>` and\n    `version <platformdirs.api.PlatformDirsABC.version>`.\n    \"\"\"\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``\"\"\"",
        "detail": "__pypackages__.3.10.lib.platformdirs.macos",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.macos",
        "description": "__pypackages__.3.10.lib.platformdirs.macos",
        "peekOfCode": "__all__ = [\n    \"MacOS\",\n]",
        "detail": "__pypackages__.3.10.lib.platformdirs.macos",
        "documentation": {}
    },
    {
        "label": "Unix",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.platformdirs.unix",
        "description": "__pypackages__.3.10.lib.platformdirs.unix",
        "peekOfCode": "class Unix(PlatformDirsABC):\n    \"\"\"\n    On Unix/Linux, we follow the\n    `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_. The spec allows\n    overriding directories with environment variables. The examples show are the default values, alongside the name of\n    the environment variable that overrides them. Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `multipath <platformdirs.api.PlatformDirsABC.multipath>`,\n    `opinion <platformdirs.api.PlatformDirsABC.opinion>`.",
        "detail": "__pypackages__.3.10.lib.platformdirs.unix",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.unix",
        "description": "__pypackages__.3.10.lib.platformdirs.unix",
        "peekOfCode": "__all__ = [\n    \"Unix\",\n]",
        "detail": "__pypackages__.3.10.lib.platformdirs.unix",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.version",
        "description": "__pypackages__.3.10.lib.platformdirs.version",
        "peekOfCode": "__version__ = version = '3.0.0'\n__version_tuple__ = version_tuple = (3, 0, 0)",
        "detail": "__pypackages__.3.10.lib.platformdirs.version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.version",
        "description": "__pypackages__.3.10.lib.platformdirs.version",
        "peekOfCode": "__version_tuple__ = version_tuple = (3, 0, 0)",
        "detail": "__pypackages__.3.10.lib.platformdirs.version",
        "documentation": {}
    },
    {
        "label": "Windows",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "class Windows(PlatformDirsABC):\n    \"\"\"`MSDN on where to store app data files\n    <http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120>`_.\n    Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `roaming <platformdirs.api.PlatformDirsABC.roaming>`,\n    `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\"\"\"\n    @property",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "get_win_folder_from_env_vars",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "def get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":  # does not have an environment name\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "get_win_folder_from_registry",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "def get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"Get folder from the registry.\n    This is a fallback technique at best. I'm not sure if using the\n    registry for this guarantees us the correct answer for all CSIDL_*\n    names.\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "get_win_folder_via_ctypes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "def get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n    }.get(csidl_name)\n    if csidl_const is None:\n        raise ValueError(f\"Unknown CSIDL name: {csidl_name}\")",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "get_win_folder",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "get_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n__all__ = [\n    \"Windows\",\n]",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.platformdirs.windows",
        "description": "__pypackages__.3.10.lib.platformdirs.windows",
        "peekOfCode": "__all__ = [\n    \"Windows\",\n]",
        "detail": "__pypackages__.3.10.lib.platformdirs.windows",
        "documentation": {}
    },
    {
        "label": "HookspecMarker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class HookspecMarker:\n    \"\"\"Decorator helper class for marking functions as hook specifications.\n    You can instantiate it with a project_name to get a decorator.\n    Calling :py:meth:`.PluginManager.add_hookspecs` later will discover all marked functions\n    if the :py:class:`.PluginManager` uses the same project_name.\n    \"\"\"\n    def __init__(self, project_name):\n        self.project_name = project_name\n    def __call__(\n        self, function=None, firstresult=False, historic=False, warn_on_impl=None",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "HookimplMarker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class HookimplMarker:\n    \"\"\"Decorator helper class for marking functions as hook implementations.\n    You can instantiate with a ``project_name`` to get a decorator.\n    Calling :py:meth:`.PluginManager.register` later will discover all marked functions\n    if the :py:class:`.PluginManager` uses the same project_name.\n    \"\"\"\n    def __init__(self, project_name):\n        self.project_name = project_name\n    def __call__(\n        self,",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "_HookRelay",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class _HookRelay:\n    \"\"\"hook holder object for performing 1:N hook calls where N is the number\n    of registered plugins.\n    \"\"\"\nclass _HookCaller:\n    def __init__(self, name, hook_execute, specmodule_or_class=None, spec_opts=None):\n        self.name = name\n        self._wrappers = []\n        self._nonwrappers = []\n        self._hookexec = hook_execute",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "_HookCaller",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class _HookCaller:\n    def __init__(self, name, hook_execute, specmodule_or_class=None, spec_opts=None):\n        self.name = name\n        self._wrappers = []\n        self._nonwrappers = []\n        self._hookexec = hook_execute\n        self._call_history = None\n        self.spec = None\n        if specmodule_or_class is not None:\n            assert spec_opts is not None",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "HookImpl",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class HookImpl:\n    def __init__(self, plugin, plugin_name, function, hook_impl_opts):\n        self.function = function\n        self.argnames, self.kwargnames = varnames(self.function)\n        self.plugin = plugin\n        self.opts = hook_impl_opts\n        self.plugin_name = plugin_name\n        self.__dict__.update(hook_impl_opts)\n    def __repr__(self):\n        return f\"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>\"",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "HookSpec",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "class HookSpec:\n    def __init__(self, namespace, name, opts):\n        self.namespace = namespace\n        self.function = function = getattr(namespace, name)\n        self.name = name\n        self.argnames, self.kwargnames = varnames(function)\n        self.opts = opts\n        self.warn_on_impl = opts.get(\"warn_on_impl\")",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "normalize_hookimpl_opts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "def normalize_hookimpl_opts(opts):\n    opts.setdefault(\"tryfirst\", False)\n    opts.setdefault(\"trylast\", False)\n    opts.setdefault(\"hookwrapper\", False)\n    opts.setdefault(\"optionalhook\", False)\n    opts.setdefault(\"specname\", None)\n_PYPY = hasattr(sys, \"pypy_version_info\")\ndef varnames(func):\n    \"\"\"Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "varnames",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "def varnames(func):\n    \"\"\"Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.\n    In case of a class, its ``__init__`` method is considered.\n    For methods the ``self`` parameter is not included.\n    \"\"\"\n    if inspect.isclass(func):\n        try:\n            func = func.__init__\n        except AttributeError:",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "_PYPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pluggy._hooks",
        "description": "__pypackages__.3.10.lib.pluggy._hooks",
        "peekOfCode": "_PYPY = hasattr(sys, \"pypy_version_info\")\ndef varnames(func):\n    \"\"\"Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.\n    In case of a class, its ``__init__`` method is considered.\n    For methods the ``self`` parameter is not included.\n    \"\"\"\n    if inspect.isclass(func):\n        try:\n            func = func.__init__",
        "detail": "__pypackages__.3.10.lib.pluggy._hooks",
        "documentation": {}
    },
    {
        "label": "PluginValidationError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._manager",
        "description": "__pypackages__.3.10.lib.pluggy._manager",
        "peekOfCode": "class PluginValidationError(Exception):\n    \"\"\"plugin failed validation.\n    :param object plugin: the plugin which failed validation,\n        may be a module or an arbitrary object.\n    \"\"\"\n    def __init__(self, plugin, message):\n        self.plugin = plugin\n        super(Exception, self).__init__(message)\nclass DistFacade:\n    \"\"\"Emulate a pkg_resources Distribution\"\"\"",
        "detail": "__pypackages__.3.10.lib.pluggy._manager",
        "documentation": {}
    },
    {
        "label": "DistFacade",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._manager",
        "description": "__pypackages__.3.10.lib.pluggy._manager",
        "peekOfCode": "class DistFacade:\n    \"\"\"Emulate a pkg_resources Distribution\"\"\"\n    def __init__(self, dist):\n        self._dist = dist\n    @property\n    def project_name(self):\n        return self.metadata[\"name\"]\n    def __getattr__(self, attr, default=None):\n        return getattr(self._dist, attr, default)\n    def __dir__(self):",
        "detail": "__pypackages__.3.10.lib.pluggy._manager",
        "documentation": {}
    },
    {
        "label": "PluginManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._manager",
        "description": "__pypackages__.3.10.lib.pluggy._manager",
        "peekOfCode": "class PluginManager:\n    \"\"\"Core :py:class:`.PluginManager` class which manages registration\n    of plugin objects and 1:N hook calling.\n    You can register new hooks by calling :py:meth:`add_hookspecs(module_or_class)\n    <.PluginManager.add_hookspecs>`.\n    You can register plugin objects (which contain hooks) by calling\n    :py:meth:`register(plugin) <.PluginManager.register>`.  The :py:class:`.PluginManager`\n    is initialized with a prefix that is searched for in the names of the dict\n    of registered plugin objects.\n    For debugging purposes you can call :py:meth:`.PluginManager.enable_tracing`",
        "detail": "__pypackages__.3.10.lib.pluggy._manager",
        "documentation": {}
    },
    {
        "label": "HookCallError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._result",
        "description": "__pypackages__.3.10.lib.pluggy._result",
        "peekOfCode": "class HookCallError(Exception):\n    \"\"\"Hook was called wrongly.\"\"\"\nclass _Result:\n    def __init__(self, result, excinfo):\n        self._result = result\n        self._excinfo = excinfo\n    @property\n    def excinfo(self):\n        return self._excinfo\n    @classmethod",
        "detail": "__pypackages__.3.10.lib.pluggy._result",
        "documentation": {}
    },
    {
        "label": "_Result",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._result",
        "description": "__pypackages__.3.10.lib.pluggy._result",
        "peekOfCode": "class _Result:\n    def __init__(self, result, excinfo):\n        self._result = result\n        self._excinfo = excinfo\n    @property\n    def excinfo(self):\n        return self._excinfo\n    @classmethod\n    def from_call(cls, func):\n        __tracebackhide__ = True",
        "detail": "__pypackages__.3.10.lib.pluggy._result",
        "documentation": {}
    },
    {
        "label": "TagTracer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._tracing",
        "description": "__pypackages__.3.10.lib.pluggy._tracing",
        "peekOfCode": "class TagTracer:\n    def __init__(self):\n        self._tags2proc = {}\n        self._writer = None\n        self.indent = 0\n    def get(self, name):\n        return TagTracerSub(self, (name,))\n    def _format_message(self, tags, args):\n        if isinstance(args[-1], dict):\n            extra = args[-1]",
        "detail": "__pypackages__.3.10.lib.pluggy._tracing",
        "documentation": {}
    },
    {
        "label": "TagTracerSub",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pluggy._tracing",
        "description": "__pypackages__.3.10.lib.pluggy._tracing",
        "peekOfCode": "class TagTracerSub:\n    def __init__(self, root, tags):\n        self.root = root\n        self.tags = tags\n    def __call__(self, *args):\n        self.root._processmessage(self.tags, args)\n    def get(self, name):\n        return self.__class__(self.root, self.tags + (name,))",
        "detail": "__pypackages__.3.10.lib.pluggy._tracing",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pluggy._version",
        "description": "__pypackages__.3.10.lib.pluggy._version",
        "peekOfCode": "version = '1.0.0'\nversion_tuple = (1, 0, 0)",
        "detail": "__pypackages__.3.10.lib.pluggy._version",
        "documentation": {}
    },
    {
        "label": "version_tuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pluggy._version",
        "description": "__pypackages__.3.10.lib.pluggy._version",
        "peekOfCode": "version_tuple = (1, 0, 0)",
        "detail": "__pypackages__.3.10.lib.pluggy._version",
        "documentation": {}
    },
    {
        "label": "TypeVarVariance",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "class TypeVarVariance(Enum):\n    invariant = auto()\n    covariant = auto()\n    contravariant = auto()\n    double_variant = auto()\ndef _get_properties(config: argparse.Namespace) -> tuple[set[str], set[str]]:\n    \"\"\"Returns a tuple of property classes and names.\n    Property classes are fully qualified, such as 'abc.abstractproperty' and\n    property names are the actual names, such as 'abstract_property'.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "NameChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "class NameChecker(_BasicChecker):\n    msgs = {\n        \"C0103\": (\n            '%s name \"%s\" doesn\\'t conform to %s',\n            \"invalid-name\",\n            \"Used when the name doesn't conform to naming rules \"\n            \"associated to its type (constant, variable, class...).\",\n        ),\n        \"C0104\": (\n            'Disallowed name \"%s\"',",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "_BadNamesTuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "_BadNamesTuple = Tuple[nodes.NodeNG, str, str, interfaces.Confidence]\n# Default patterns for name types that do not have styles\nDEFAULT_PATTERNS = {\n    \"typevar\": re.compile(\n        r\"^_{0,2}(?!T[A-Z])(?:[A-Z]+|(?:[A-Z]+[a-z]+)+T?(?<!Type))(?:_co(?:ntra)?)?$\"\n    )\n}\nBUILTIN_PROPERTY = \"builtins.property\"\nTYPE_VAR_QNAME = frozenset(\n    (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PATTERNS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "DEFAULT_PATTERNS = {\n    \"typevar\": re.compile(\n        r\"^_{0,2}(?!T[A-Z])(?:[A-Z]+|(?:[A-Z]+[a-z]+)+T?(?<!Type))(?:_co(?:ntra)?)?$\"\n    )\n}\nBUILTIN_PROPERTY = \"builtins.property\"\nTYPE_VAR_QNAME = frozenset(\n    (\n        \"typing.TypeVar\",\n        \"typing_extensions.TypeVar\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "BUILTIN_PROPERTY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "BUILTIN_PROPERTY = \"builtins.property\"\nTYPE_VAR_QNAME = frozenset(\n    (\n        \"typing.TypeVar\",\n        \"typing_extensions.TypeVar\",\n    )\n)\nclass TypeVarVariance(Enum):\n    invariant = auto()\n    covariant = auto()",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "TYPE_VAR_QNAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "TYPE_VAR_QNAME = frozenset(\n    (\n        \"typing.TypeVar\",\n        \"typing_extensions.TypeVar\",\n    )\n)\nclass TypeVarVariance(Enum):\n    invariant = auto()\n    covariant = auto()\n    contravariant = auto()",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "EXEMPT_NAME_CATEGORIES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "peekOfCode": "EXEMPT_NAME_CATEGORIES = {\"exempt\", \"ignore\"}\ndef _is_multi_naming_match(\n    match: re.Match[str] | None, node_type: str, confidence: interfaces.Confidence\n) -> bool:\n    return (\n        match is not None\n        and match.lastgroup is not None\n        and match.lastgroup not in EXEMPT_NAME_CATEGORIES\n        and (node_type != \"method\" or confidence != interfaces.INFERENCE_FAILURE)\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.checker",
        "documentation": {}
    },
    {
        "label": "NamingStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class NamingStyle:\n    \"\"\"Class to register all accepted forms of a single naming style.\n    It may seem counter-intuitive that single naming style has multiple \"accepted\"\n    forms of regular expressions, but we need to special-case stuff like dunder\n    names in method names.\n    \"\"\"\n    ANY: Pattern[str] = re.compile(\".*\")\n    CLASS_NAME_RGX: Pattern[str] = ANY\n    MOD_NAME_RGX: Pattern[str] = ANY\n    CONST_NAME_RGX: Pattern[str] = ANY",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "SnakeCaseStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class SnakeCaseStyle(NamingStyle):\n    \"\"\"Regex rules for snake_case naming style.\"\"\"\n    CLASS_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\WA-Z]+$\")\n    MOD_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\WA-Z]*$\")\n    CONST_NAME_RGX = re.compile(r\"([^\\W\\dA-Z][^\\WA-Z]*|__.*__)$\")\n    COMP_VAR_RGX = CLASS_NAME_RGX\n    DEFAULT_NAME_RGX = re.compile(\n        r\"([^\\W\\dA-Z][^\\WA-Z]{2,}|_[^\\WA-Z]*|__[^\\WA-Z\\d_][^\\WA-Z]+__)$\"\n    )\n    CLASS_ATTRIBUTE_RGX = re.compile(r\"([^\\W\\dA-Z][^\\WA-Z]{2,}|__.*__)$\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "CamelCaseStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class CamelCaseStyle(NamingStyle):\n    \"\"\"Regex rules for camelCase naming style.\"\"\"\n    CLASS_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\W_]+$\")\n    MOD_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\W_]*$\")\n    CONST_NAME_RGX = re.compile(r\"([^\\W\\dA-Z][^\\W_]*|__.*__)$\")\n    COMP_VAR_RGX = MOD_NAME_RGX\n    DEFAULT_NAME_RGX = re.compile(r\"([^\\W\\dA-Z][^\\W_]{2,}|__[^\\W\\dA-Z_]\\w+__)$\")\n    CLASS_ATTRIBUTE_RGX = re.compile(r\"([^\\W\\dA-Z][^\\W_]{2,}|__.*__)$\")\nclass PascalCaseStyle(NamingStyle):\n    \"\"\"Regex rules for PascalCase naming style.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "PascalCaseStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class PascalCaseStyle(NamingStyle):\n    \"\"\"Regex rules for PascalCase naming style.\"\"\"\n    CLASS_NAME_RGX = re.compile(r\"[^\\W\\da-z][^\\W_]+$\")\n    MOD_NAME_RGX = CLASS_NAME_RGX\n    CONST_NAME_RGX = re.compile(r\"([^\\W\\da-z][^\\W_]*|__.*__)$\")\n    COMP_VAR_RGX = CLASS_NAME_RGX\n    DEFAULT_NAME_RGX = re.compile(r\"([^\\W\\da-z][^\\W_]{2,}|__[^\\W\\dA-Z_]\\w+__)$\")\n    CLASS_ATTRIBUTE_RGX = re.compile(r\"[^\\W\\da-z][^\\W_]{2,}$\")\nclass UpperCaseStyle(NamingStyle):\n    \"\"\"Regex rules for UPPER_CASE naming style.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "UpperCaseStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class UpperCaseStyle(NamingStyle):\n    \"\"\"Regex rules for UPPER_CASE naming style.\"\"\"\n    CLASS_NAME_RGX = re.compile(r\"[^\\W\\da-z][^\\Wa-z]+$\")\n    MOD_NAME_RGX = CLASS_NAME_RGX\n    CONST_NAME_RGX = re.compile(r\"([^\\W\\da-z][^\\Wa-z]*|__.*__)$\")\n    COMP_VAR_RGX = CLASS_NAME_RGX\n    DEFAULT_NAME_RGX = re.compile(r\"([^\\W\\da-z][^\\Wa-z]{2,}|__[^\\W\\dA-Z_]\\w+__)$\")\n    CLASS_ATTRIBUTE_RGX = re.compile(r\"[^\\W\\da-z][^\\Wa-z]{2,}$\")\nclass AnyStyle(NamingStyle):\n    pass",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "AnyStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "class AnyStyle(NamingStyle):\n    pass\nNAMING_STYLES = {\n    \"snake_case\": SnakeCaseStyle,\n    \"camelCase\": CamelCaseStyle,\n    \"PascalCase\": PascalCaseStyle,\n    \"UPPER_CASE\": UpperCaseStyle,\n    \"any\": AnyStyle,\n}\n# Name types that have a style option",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "NAMING_STYLES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "NAMING_STYLES = {\n    \"snake_case\": SnakeCaseStyle,\n    \"camelCase\": CamelCaseStyle,\n    \"PascalCase\": PascalCaseStyle,\n    \"UPPER_CASE\": UpperCaseStyle,\n    \"any\": AnyStyle,\n}\n# Name types that have a style option\nKNOWN_NAME_TYPES_WITH_STYLE = {\n    \"module\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "KNOWN_NAME_TYPES_WITH_STYLE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "KNOWN_NAME_TYPES_WITH_STYLE = {\n    \"module\",\n    \"const\",\n    \"class\",\n    \"function\",\n    \"method\",\n    \"attr\",\n    \"argument\",\n    \"variable\",\n    \"class_attribute\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NAMING_STYLES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "DEFAULT_NAMING_STYLES = {\n    \"module\": \"snake_case\",\n    \"const\": \"UPPER_CASE\",\n    \"class\": \"PascalCase\",\n    \"function\": \"snake_case\",\n    \"method\": \"snake_case\",\n    \"attr\": \"snake_case\",\n    \"argument\": \"snake_case\",\n    \"variable\": \"snake_case\",\n    \"class_attribute\": \"any\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "KNOWN_NAME_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "peekOfCode": "KNOWN_NAME_TYPES = {\n    *KNOWN_NAME_TYPES_WITH_STYLE,\n    \"typevar\",\n}\ndef _create_naming_options() -> Options:\n    name_options: list[tuple[str, OptionDict]] = []\n    for name_type in sorted(KNOWN_NAME_TYPES):\n        human_readable_name = constants.HUMAN_READABLE_TYPES[name_type]\n        name_type_hyphened = name_type.replace(\"_\", \"-\")\n        help_msg = f\"Regular expression matching correct {human_readable_name} names. \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.name_checker.naming_style",
        "documentation": {}
    },
    {
        "label": "_BasicChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "class _BasicChecker(BaseChecker):\n    \"\"\"Permits separating multiple checks with the same checker name into\n    classes/file.\n    \"\"\"\n    name = \"basic\"\nREVERSED_PROTOCOL_METHOD = \"__reversed__\"\nSEQUENCE_PROTOCOL_METHODS = (\"__getitem__\", \"__len__\")\nREVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "BasicChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "class BasicChecker(_BasicChecker):\n    \"\"\"Basic checker.\n    Checks for :\n    * doc strings\n    * number of arguments, local variables, branches, returns and statements in\n    functions, methods\n    * required module attributes\n    * dangerous default values as arguments\n    * redefinition of function / method / class\n    * uses of the global statement",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "report_by_type_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "def report_by_type_stats(\n    sect: reporter_nodes.Section,\n    stats: LinterStats,\n    old_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make a report of.\n    * percentage of different types documented\n    * percentage of different types with a bad name\n    \"\"\"\n    # percentage of different types documented and/or with a bad name",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "REVERSED_PROTOCOL_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "REVERSED_PROTOCOL_METHOD = \"__reversed__\"\nSEQUENCE_PROTOCOL_METHODS = (\"__getitem__\", \"__len__\")\nREVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments\nDEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "SEQUENCE_PROTOCOL_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "SEQUENCE_PROTOCOL_METHODS = (\"__getitem__\", \"__len__\")\nREVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments\nDEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),\n    **{",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "REVERSED_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "REVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments\nDEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),\n    **{\n        x: f\"{x}()\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ARGUMENT_SYMBOLS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "peekOfCode": "DEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),\n    **{\n        x: f\"{x}()\"\n        for x in (\n            \"collections.deque\",\n            \"collections.ChainMap\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_checker",
        "documentation": {}
    },
    {
        "label": "BasicErrorChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "peekOfCode": "class BasicErrorChecker(_BasicChecker):\n    msgs = {\n        \"E0100\": (\n            \"__init__ method is a generator\",\n            \"init-is-generator\",\n            \"Used when the special class method __init__ is turned into a \"\n            \"generator by a yield in its body.\",\n        ),\n        \"E0101\": (\n            \"Explicit return in __init__\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "documentation": {}
    },
    {
        "label": "redefined_by_decorator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "peekOfCode": "def redefined_by_decorator(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return True if the object is a method redefined via decorator.\n    For example:\n        @property\n        def x(self): return self._x\n        @x.setter\n        def x(self, value): self._x = value\n    \"\"\"\n    if node.decorators:\n        for decorator in node.decorators.nodes:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "documentation": {}
    },
    {
        "label": "ABC_METACLASSES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "peekOfCode": "ABC_METACLASSES = {\"_py_abc.ABCMeta\", \"abc.ABCMeta\"}  # Python 3.7+,\n# List of methods which can be redefined\nREDEFINABLE_METHODS = frozenset((\"__module__\",))\nTYPING_FORWARD_REF_QNAME = \"typing.ForwardRef\"\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n    Args:\n        break_node (astroid.Break): the break node of interest.\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "documentation": {}
    },
    {
        "label": "REDEFINABLE_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "peekOfCode": "REDEFINABLE_METHODS = frozenset((\"__module__\",))\nTYPING_FORWARD_REF_QNAME = \"typing.ForwardRef\"\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n    Args:\n        break_node (astroid.Break): the break node of interest.\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "documentation": {}
    },
    {
        "label": "TYPING_FORWARD_REF_QNAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "peekOfCode": "TYPING_FORWARD_REF_QNAME = \"typing.ForwardRef\"\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n    Args:\n        break_node (astroid.Break): the break node of interest.\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    parent = break_node.parent",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.basic_error_checker",
        "documentation": {}
    },
    {
        "label": "ComparisonChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "peekOfCode": "class ComparisonChecker(_BasicChecker):\n    \"\"\"Checks for comparisons.\n    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'\n    - yoda condition: 'const \"comp\" right' where comp can be '==', '!=', '<',\n      '<=', '>' or '>=', and right can be a variable, an attribute, a method or\n      a function\n    \"\"\"\n    msgs = {\n        \"C0121\": (\n            \"Comparison %s should be %s\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "documentation": {}
    },
    {
        "label": "LITERAL_NODE_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "peekOfCode": "LITERAL_NODE_TYPES = (nodes.Const, nodes.Dict, nodes.List, nodes.Set)\nCOMPARISON_OPERATORS = frozenset((\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"))\nTYPECHECK_COMPARISON_OPERATORS = frozenset((\"is\", \"is not\", \"==\", \"!=\"))\nTYPE_QNAME = \"builtins.type\"\ndef _is_one_arg_pos_call(call: nodes.NodeNG) -> bool:\n    \"\"\"Is this a call with exactly 1 positional argument ?\"\"\"\n    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords\nclass ComparisonChecker(_BasicChecker):\n    \"\"\"Checks for comparisons.\n    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "documentation": {}
    },
    {
        "label": "COMPARISON_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "peekOfCode": "COMPARISON_OPERATORS = frozenset((\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"))\nTYPECHECK_COMPARISON_OPERATORS = frozenset((\"is\", \"is not\", \"==\", \"!=\"))\nTYPE_QNAME = \"builtins.type\"\ndef _is_one_arg_pos_call(call: nodes.NodeNG) -> bool:\n    \"\"\"Is this a call with exactly 1 positional argument ?\"\"\"\n    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords\nclass ComparisonChecker(_BasicChecker):\n    \"\"\"Checks for comparisons.\n    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'\n    - yoda condition: 'const \"comp\" right' where comp can be '==', '!=', '<',",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "documentation": {}
    },
    {
        "label": "TYPECHECK_COMPARISON_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "peekOfCode": "TYPECHECK_COMPARISON_OPERATORS = frozenset((\"is\", \"is not\", \"==\", \"!=\"))\nTYPE_QNAME = \"builtins.type\"\ndef _is_one_arg_pos_call(call: nodes.NodeNG) -> bool:\n    \"\"\"Is this a call with exactly 1 positional argument ?\"\"\"\n    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords\nclass ComparisonChecker(_BasicChecker):\n    \"\"\"Checks for comparisons.\n    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'\n    - yoda condition: 'const \"comp\" right' where comp can be '==', '!=', '<',\n      '<=', '>' or '>=', and right can be a variable, an attribute, a method or",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "documentation": {}
    },
    {
        "label": "TYPE_QNAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "peekOfCode": "TYPE_QNAME = \"builtins.type\"\ndef _is_one_arg_pos_call(call: nodes.NodeNG) -> bool:\n    \"\"\"Is this a call with exactly 1 positional argument ?\"\"\"\n    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords\nclass ComparisonChecker(_BasicChecker):\n    \"\"\"Checks for comparisons.\n    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'\n    - yoda condition: 'const \"comp\" right' where comp can be '==', '!=', '<',\n      '<=', '>' or '>=', and right can be a variable, an attribute, a method or\n      a function",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.comparison_checker",
        "documentation": {}
    },
    {
        "label": "DocStringChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "peekOfCode": "class DocStringChecker(_BasicChecker):\n    msgs = {\n        \"C0112\": (\n            \"Empty %s docstring\",\n            \"empty-docstring\",\n            \"Used when a module, function, class or method has an empty \"\n            \"docstring (it would be too easy ;).\",\n            {\"old_names\": [(\"W0132\", \"old-empty-docstring\")]},\n        ),\n        \"C0114\": (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "documentation": {}
    },
    {
        "label": "NO_REQUIRED_DOC_RGX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "peekOfCode": "NO_REQUIRED_DOC_RGX = re.compile(\"^_\")\ndef _infer_dunder_doc_attribute(\n    node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n) -> str | None:\n    # Try to see if we have a `__doc__` attribute.\n    try:\n        docstring = node[\"__doc__\"]\n    except KeyError:\n        return None\n    docstring = utils.safe_infer(docstring)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.docstring_checker",
        "documentation": {}
    },
    {
        "label": "PassChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base.pass_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base.pass_checker",
        "peekOfCode": "class PassChecker(_BasicChecker):\n    \"\"\"Check if the pass statement is really necessary.\"\"\"\n    msgs = {\n        \"W0107\": (\n            \"Unnecessary pass statement\",\n            \"unnecessary-pass\",\n            'Used when a \"pass\" statement that can be avoided is encountered.',\n        )\n    }\n    @utils.only_required_for_messages(\"unnecessary-pass\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base.pass_checker",
        "documentation": {}
    },
    {
        "label": "_DefaultMissing",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "class _DefaultMissing:\n    \"\"\"Sentinel value for missing arg default, use _DEFAULT_MISSING.\"\"\"\n_DEFAULT_MISSING = _DefaultMissing()\ndef _has_different_parameters_default_value(\n    original: nodes.Arguments, overridden: nodes.Arguments\n) -> bool:\n    \"\"\"Check if original and overridden methods arguments have different default values.\n    Return True if one of the overridden arguments has a default\n    value different from the default value of the original argument\n    If one of the method doesn't have argument (.args is None)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "ScopeAccessMap",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "class ScopeAccessMap:\n    \"\"\"Store the accessed variables per scope.\"\"\"\n    def __init__(self) -> None:\n        self._scopes: defaultdict[\n            nodes.ClassDef, defaultdict[str, list[_AccessNodes]]\n        ] = defaultdict(_scope_default)\n    def set_accessed(self, node: _AccessNodes) -> None:\n        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "ClassChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "class ClassChecker(BaseChecker):\n    \"\"\"Checker for class nodes.\n    Checks for :\n    * methods without self as first argument\n    * overridden methods signature\n    * access only to existent members via self\n    * attributes not defined in the __init__ method\n    * unreachable code\n    \"\"\"\n    # configuration section name",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "_AccessNodes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "_AccessNodes = Union[nodes.Attribute, nodes.AssignAttr]\nINVALID_BASE_CLASSES = {\"bool\", \"range\", \"slice\", \"memoryview\"}\nBUILTIN_DECORATORS = {\"builtins.property\", \"builtins.classmethod\"}\nASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "INVALID_BASE_CLASSES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "INVALID_BASE_CLASSES = {\"bool\", \"range\", \"slice\", \"memoryview\"}\nBUILTIN_DECORATORS = {\"builtins.property\", \"builtins.classmethod\"}\nASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),\n}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "BUILTIN_DECORATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "BUILTIN_DECORATORS = {\"builtins.property\", \"builtins.classmethod\"}\nASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),\n}\n# Dealing with useless override detection, with regard",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "ASTROID_TYPE_COMPARATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "ASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),\n}\n# Dealing with useless override detection, with regard\n# to parameters vs arguments",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "_CallSignature",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "_CallSignature = collections.namedtuple(\n    \"_CallSignature\", \"args kws starred_args starred_kws\"\n)\n_ParameterSignature = collections.namedtuple(\n    \"_ParameterSignature\", \"args kwonlyargs varargs kwargs\"\n)\ndef _signature_from_call(call: nodes.Call) -> _CallSignature:\n    kws = {}\n    args = []\n    starred_kws = []",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "_ParameterSignature",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "_ParameterSignature = collections.namedtuple(\n    \"_ParameterSignature\", \"args kwonlyargs varargs kwargs\"\n)\ndef _signature_from_call(call: nodes.Call) -> _CallSignature:\n    kws = {}\n    args = []\n    starred_kws = []\n    starred_args = []\n    for keyword in call.keywords or []:\n        arg, value = keyword.arg, keyword.value",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_MISSING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "peekOfCode": "_DEFAULT_MISSING = _DefaultMissing()\ndef _has_different_parameters_default_value(\n    original: nodes.Arguments, overridden: nodes.Arguments\n) -> bool:\n    \"\"\"Check if original and overridden methods arguments have different default values.\n    Return True if one of the overridden arguments has a default\n    value different from the default value of the original argument\n    If one of the method doesn't have argument (.args is None)\n    return False\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.class_checker",
        "documentation": {}
    },
    {
        "label": "SpecialMethodsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "peekOfCode": "class SpecialMethodsChecker(BaseChecker):\n    \"\"\"Checker which verifies that special methods\n    are implemented correctly.\n    \"\"\"\n    name = \"classes\"\n    msgs = {\n        \"E0301\": (\n            \"__iter__ returns non-iterator\",\n            \"non-iterator-returned\",\n            \"Used when an __iter__ method returns something which is not an \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "documentation": {}
    },
    {
        "label": "NEXT_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "peekOfCode": "NEXT_METHOD = \"__next__\"\ndef _safe_infer_call_result(\n    node: nodes.FunctionDef,\n    caller: nodes.FunctionDef,\n    context: InferenceContext | None = None,\n) -> InferenceResult | None:\n    \"\"\"Safely infer the return value of a function.\n    Returns None if inference failed or if there is some ambiguity (more than\n    one node has been inferred). Otherwise, returns inferred value.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.classes.special_methods_checker",
        "documentation": {}
    },
    {
        "label": "ImplicitBooleanessChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.implicit_booleaness_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.implicit_booleaness_checker",
        "peekOfCode": "class ImplicitBooleanessChecker(checkers.BaseChecker):\n    \"\"\"Checks for incorrect usage of comparisons or len() inside conditions.\n    Incorrect usage of len()\n    Pep8 states:\n    For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n        Yes: if not seq:\n             if seq:\n        No: if len(seq):\n            if not len(seq):\n    Problems detected:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.implicit_booleaness_checker",
        "documentation": {}
    },
    {
        "label": "NotChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.not_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.not_checker",
        "peekOfCode": "class NotChecker(checkers.BaseChecker):\n    \"\"\"Checks for too many not in comparison expressions.\n    - \"not not\" should trigger a warning\n    - \"not\" followed by a comparison should trigger a warning\n    \"\"\"\n    msgs = {\n        \"C0113\": (\n            'Consider changing \"%s\" to \"%s\"',\n            \"unneeded-not\",\n            \"Used when a boolean expression contains an unneeded negation.\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.not_checker",
        "documentation": {}
    },
    {
        "label": "RecommendationChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.recommendation_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.recommendation_checker",
        "peekOfCode": "class RecommendationChecker(checkers.BaseChecker):\n    name = \"refactoring\"\n    msgs = {\n        \"C0200\": (\n            \"Consider using enumerate instead of iterating with range and len\",\n            \"consider-using-enumerate\",\n            \"Emitted when code that iterates with range and len is \"\n            \"encountered. Such code can be simplified by using the \"\n            \"enumerate builtin.\",\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.recommendation_checker",
        "documentation": {}
    },
    {
        "label": "ConsiderUsingWithStack",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "class ConsiderUsingWithStack(NamedTuple):\n    \"\"\"Stack for objects that may potentially trigger a R1732 message\n    if they are not used in a ``with`` block later on.\n    \"\"\"\n    module_scope: dict[str, nodes.NodeNG] = {}\n    class_scope: dict[str, nodes.NodeNG] = {}\n    function_scope: dict[str, nodes.NodeNG] = {}\n    def __iter__(self) -> Iterator[dict[str, nodes.NodeNG]]:\n        yield from (self.function_scope, self.class_scope, self.module_scope)\n    def get_stack_for_frame(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "RefactoringChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "class RefactoringChecker(checkers.BaseTokenChecker):\n    \"\"\"Looks for code which can be refactored.\n    This checker also mixes the astroid and the token approaches\n    in order to create knowledge about whether an \"else if\" node\n    is a true \"else if\" node, or an \"elif\" node.\n    \"\"\"\n    name = \"refactoring\"\n    msgs = {\n        \"R1701\": (\n            \"Consider merging these isinstance calls to isinstance(%s, (%s))\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "NodesWithNestedBlocks",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "NodesWithNestedBlocks = Union[\n    nodes.TryExcept, nodes.TryFinally, nodes.While, nodes.For, nodes.If\n]\nKNOWN_INFINITE_ITERATORS = {\"itertools.count\", \"itertools.cycle\"}\nBUILTIN_EXIT_FUNCS = frozenset((\"quit\", \"exit\"))\nCALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(\n    (\n        \"threading.lock.acquire\",\n        \"threading._RLock.acquire\",\n        \"threading.Semaphore.acquire\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "KNOWN_INFINITE_ITERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "KNOWN_INFINITE_ITERATORS = {\"itertools.count\", \"itertools.cycle\"}\nBUILTIN_EXIT_FUNCS = frozenset((\"quit\", \"exit\"))\nCALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(\n    (\n        \"threading.lock.acquire\",\n        \"threading._RLock.acquire\",\n        \"threading.Semaphore.acquire\",\n        \"multiprocessing.managers.BaseManager.start\",\n        \"multiprocessing.managers.SyncManager.start\",\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "BUILTIN_EXIT_FUNCS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "BUILTIN_EXIT_FUNCS = frozenset((\"quit\", \"exit\"))\nCALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(\n    (\n        \"threading.lock.acquire\",\n        \"threading._RLock.acquire\",\n        \"threading.Semaphore.acquire\",\n        \"multiprocessing.managers.BaseManager.start\",\n        \"multiprocessing.managers.SyncManager.start\",\n    )\n)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "CALLS_THAT_COULD_BE_REPLACED_BY_WITH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "CALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(\n    (\n        \"threading.lock.acquire\",\n        \"threading._RLock.acquire\",\n        \"threading.Semaphore.acquire\",\n        \"multiprocessing.managers.BaseManager.start\",\n        \"multiprocessing.managers.SyncManager.start\",\n    )\n)\nCALLS_RETURNING_CONTEXT_MANAGERS = frozenset(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "CALLS_RETURNING_CONTEXT_MANAGERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "peekOfCode": "CALLS_RETURNING_CONTEXT_MANAGERS = frozenset(\n    (\n        \"_io.open\",  # regular 'open()' call\n        \"pathlib.Path.open\",\n        \"codecs.open\",\n        \"urllib.request.urlopen\",\n        \"tempfile.NamedTemporaryFile\",\n        \"tempfile.SpooledTemporaryFile\",\n        \"tempfile.TemporaryDirectory\",\n        \"tempfile.TemporaryFile\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.refactoring.refactoring_checker",
        "documentation": {}
    },
    {
        "label": "AsyncChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.async",
        "description": "__pypackages__.3.10.lib.pylint.checkers.async",
        "peekOfCode": "class AsyncChecker(checkers.BaseChecker):\n    name = \"async\"\n    msgs = {\n        \"E1700\": (\n            \"Yield inside async function\",\n            \"yield-inside-async-function\",\n            \"Used when an `yield` or `yield from` statement is \"\n            \"found inside an async function.\",\n            {\"minversion\": (3, 5)},\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.async",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.async",
        "description": "__pypackages__.3.10.lib.pylint.checkers.async",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(AsyncChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.async",
        "documentation": {}
    },
    {
        "label": "BaseChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "peekOfCode": "class BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "documentation": {}
    },
    {
        "label": "BaseTokenChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "peekOfCode": "class BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n    @abc.abstractmethod\n    def process_module(self, node: nodes.Module) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "documentation": {}
    },
    {
        "label": "BaseRawFileChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "peekOfCode": "class BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n    @abc.abstractmethod\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n        The module's content is accessible via ``astroid.stream``\n        \"\"\"\n        raise NotImplementedError()",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.base_checker",
        "documentation": {}
    },
    {
        "label": "DeprecatedMixin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "description": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "peekOfCode": "class DeprecatedMixin(BaseChecker):\n    \"\"\"A mixin implementing logic for checking deprecated symbols.\n    A class implementing mixin must define \"deprecated-method\" Message.\n    \"\"\"\n    DEPRECATED_MODULE_MESSAGE: dict[str, MessageDefinitionTuple] = {\n        \"W4901\": (\n            \"Deprecated module %r\",\n            \"deprecated-module\",\n            \"A module marked as deprecated is imported.\",\n            {\"old_names\": [(\"W0402\", \"old-deprecated-module\")], \"shared\": True},",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "documentation": {}
    },
    {
        "label": "ACCEPTABLE_NODES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "description": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "peekOfCode": "ACCEPTABLE_NODES = (\n    astroid.BoundMethod,\n    astroid.UnboundMethod,\n    nodes.FunctionDef,\n    nodes.ClassDef,\n)\nclass DeprecatedMixin(BaseChecker):\n    \"\"\"A mixin implementing logic for checking deprecated symbols.\n    A class implementing mixin must define \"deprecated-method\" Message.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.deprecated",
        "documentation": {}
    },
    {
        "label": "MisdesignChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "class MisdesignChecker(BaseChecker):\n    \"\"\"Checker of potential misdesigns.\n    Checks for sign of poor/misdesign:\n    * number of methods, attributes, local variables...\n    * size, complexity of functions, methods\n    \"\"\"\n    # configuration section name\n    name = \"design\"\n    # messages\n    msgs = MSGS",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(MisdesignChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"R0901\": (\n        \"Too many ancestors (%s/%s)\",\n        \"too-many-ancestors\",\n        \"Used when class has too many parent classes, try to reduce \"\n        \"this to get a simpler (and so easier to use) class.\",\n    ),\n    \"R0902\": (\n        \"Too many instance attributes (%s/%s)\",\n        \"too-many-instance-attributes\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "SPECIAL_OBJ",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "SPECIAL_OBJ = re.compile(\"^_{2}[a-z]+_{2}$\")\nDATACLASSES_DECORATORS = frozenset({\"dataclass\", \"attrs\"})\nDATACLASS_IMPORT = \"dataclasses\"\nTYPING_NAMEDTUPLE = \"typing.NamedTuple\"\nTYPING_TYPEDDICT = \"typing.TypedDict\"\n# Set of stdlib classes to ignore when calculating number of ancestors\nSTDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "DATACLASSES_DECORATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "DATACLASSES_DECORATORS = frozenset({\"dataclass\", \"attrs\"})\nDATACLASS_IMPORT = \"dataclasses\"\nTYPING_NAMEDTUPLE = \"typing.NamedTuple\"\nTYPING_TYPEDDICT = \"typing.TypedDict\"\n# Set of stdlib classes to ignore when calculating number of ancestors\nSTDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",\n        \"builtins.dict\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "DATACLASS_IMPORT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "DATACLASS_IMPORT = \"dataclasses\"\nTYPING_NAMEDTUPLE = \"typing.NamedTuple\"\nTYPING_TYPEDDICT = \"typing.TypedDict\"\n# Set of stdlib classes to ignore when calculating number of ancestors\nSTDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",\n        \"builtins.dict\",\n        \"builtins.list\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "TYPING_NAMEDTUPLE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "TYPING_NAMEDTUPLE = \"typing.NamedTuple\"\nTYPING_TYPEDDICT = \"typing.TypedDict\"\n# Set of stdlib classes to ignore when calculating number of ancestors\nSTDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",\n        \"builtins.dict\",\n        \"builtins.list\",\n        \"builtins.set\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "TYPING_TYPEDDICT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "TYPING_TYPEDDICT = \"typing.TypedDict\"\n# Set of stdlib classes to ignore when calculating number of ancestors\nSTDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",\n        \"builtins.dict\",\n        \"builtins.list\",\n        \"builtins.set\",\n        \"bulitins.frozenset\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "STDLIB_CLASSES_IGNORE_ANCESTOR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "description": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "peekOfCode": "STDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(\n    (\n        \"builtins.object\",\n        \"builtins.tuple\",\n        \"builtins.dict\",\n        \"builtins.list\",\n        \"builtins.set\",\n        \"bulitins.frozenset\",\n        \"collections.ChainMap\",\n        \"collections.Counter\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.design_analysis",
        "documentation": {}
    },
    {
        "label": "DunderCallChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "description": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "peekOfCode": "class DunderCallChecker(BaseChecker):\n    \"\"\"Check for unnecessary dunder method calls.\n    Docs: https://docs.python.org/3/reference/datamodel.html#basic-customization\n    We exclude names in list pylint.constants.EXTRA_DUNDER_METHODS such as\n    __index__ (see https://github.com/PyCQA/pylint/issues/6795)\n    since these either have no alternative method of being called or\n    have a genuine use case for being called manually.\n    Additionally, we exclude classes that are not instantiated since these\n    might be used to access the dunder methods of a base class of an instance.\n    We also exclude dunder method calls on super() since",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "description": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DunderCallChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.dunder_methods",
        "documentation": {}
    },
    {
        "label": "EllipsisChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "peekOfCode": "class EllipsisChecker(BaseChecker):\n    name = \"unnecessary_ellipsis\"\n    msgs = {\n        \"W2301\": (\n            \"Unnecessary ellipsis constant\",\n            \"unnecessary-ellipsis\",\n            \"Used when the ellipsis constant is encountered and can be avoided. \"\n            \"A line of code consisting of an ellipsis is unnecessary if \"\n            \"there is a docstring on the preceding line or if there is a \"\n            \"statement in the same scope.\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(EllipsisChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.ellipsis_checker",
        "documentation": {}
    },
    {
        "label": "BaseVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "peekOfCode": "class BaseVisitor:\n    \"\"\"Base class for visitors defined in this module.\"\"\"\n    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -> None:\n        self._checker = checker\n        self._node = node\n    def visit(self, node: SuccessfulInferenceResult) -> None:\n        name = node.__class__.__name__.lower()\n        dispatch_meth = getattr(self, \"visit_\" + name, None)\n        if dispatch_meth:\n            dispatch_meth(node)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionRaiseRefVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "peekOfCode": "class ExceptionRaiseRefVisitor(BaseVisitor):\n    \"\"\"Visit references (anything that is not an AST leaf).\"\"\"\n    def visit_name(self, node: nodes.Name) -> None:\n        if node.name == \"NotImplemented\":\n            self._checker.add_message(\n                \"notimplemented-raised\", node=self._node, confidence=HIGH\n            )\n            return\n        try:\n            exceptions = list(_annotated_unpack_infer(node))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionRaiseLeafVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "peekOfCode": "class ExceptionRaiseLeafVisitor(BaseVisitor):\n    \"\"\"Visitor for handling leaf kinds of a raise value.\"\"\"\n    def visit_const(self, node: nodes.Const) -> None:\n        self._checker.add_message(\n            \"raising-bad-type\",\n            node=self._node,\n            args=node.value.__class__.__name__,\n            confidence=INFERENCE,\n        )\n    def visit_instance(self, instance: objects.ExceptionInstance) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "peekOfCode": "class ExceptionsChecker(checkers.BaseChecker):\n    \"\"\"Exception related checks.\"\"\"\n    name = \"exceptions\"\n    msgs = MSGS\n    options = (\n        (\n            \"overgeneral-exceptions\",\n            {\n                \"default\": (\"builtins.BaseException\", \"builtins.Exception\"),\n                \"type\": \"csv\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ExceptionsChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.exceptions",
        "documentation": {}
    },
    {
        "label": "TokenWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.format",
        "description": "__pypackages__.3.10.lib.pylint.checkers.format",
        "peekOfCode": "class TokenWrapper:\n    \"\"\"A wrapper for readable access to token information.\"\"\"\n    def __init__(self, tokens: list[tokenize.TokenInfo]) -> None:\n        self._tokens = tokens\n    def token(self, idx: int) -> str:\n        return self._tokens[idx][1]\n    def type(self, idx: int) -> int:\n        return self._tokens[idx][0]\n    def start_line(self, idx: int) -> int:\n        return self._tokens[idx][2][0]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.format",
        "documentation": {}
    },
    {
        "label": "FormatChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.format",
        "description": "__pypackages__.3.10.lib.pylint.checkers.format",
        "peekOfCode": "class FormatChecker(BaseTokenChecker, BaseRawFileChecker):\n    \"\"\"Formatting checker.\n    Checks for :\n    * unauthorized constructions\n    * strict indentation\n    * line length\n    \"\"\"\n    # configuration section name\n    name = \"format\"\n    # messages",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.format",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.format",
        "description": "__pypackages__.3.10.lib.pylint.checkers.format",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(FormatChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.format",
        "documentation": {}
    },
    {
        "label": "_KEYWORD_TOKENS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.format",
        "description": "__pypackages__.3.10.lib.pylint.checkers.format",
        "peekOfCode": "_KEYWORD_TOKENS = {\n    \"assert\",\n    \"del\",\n    \"elif\",\n    \"except\",\n    \"for\",\n    \"if\",\n    \"in\",\n    \"not\",\n    \"raise\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.format",
        "documentation": {}
    },
    {
        "label": "_JUNK_TOKENS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.format",
        "description": "__pypackages__.3.10.lib.pylint.checkers.format",
        "peekOfCode": "_JUNK_TOKENS = {tokenize.COMMENT, tokenize.NL}\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"C0301\": (\n        \"Line too long (%s/%s)\",\n        \"line-too-long\",\n        \"Used when a line is longer than a given number of characters.\",\n    ),\n    \"C0302\": (\n        \"Too many lines in module (%s/%s)\",  # was W0302\n        \"too-many-lines\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.format",
        "documentation": {}
    },
    {
        "label": "ImportsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "class ImportsChecker(DeprecatedMixin, BaseChecker):\n    \"\"\"BaseChecker for import statements.\n    Checks for\n    * external modules dependencies\n    * relative / wildcard imports\n    * cyclic imports\n    * uses of deprecated modules\n    * uses of modules instead of preferred modules\n    \"\"\"\n    name = \"imports\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ImportsChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "_ImportTree",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "_ImportTree = Dict[str, Union[List[Dict[str, Any]], List[str]]]\nDEPRECATED_MODULES = {\n    (0, 0, 0): {\"tkinter.tix\", \"fpectl\"},\n    (3, 2, 0): {\"optparse\"},\n    (3, 3, 0): {\"xml.etree.cElementTree\"},\n    (3, 4, 0): {\"imp\"},\n    (3, 5, 0): {\"formatter\"},\n    (3, 6, 0): {\"asynchat\", \"asyncore\", \"smtpd\"},\n    (3, 7, 0): {\"macpath\"},\n    (3, 9, 0): {\"lib2to3\", \"parser\", \"symbol\", \"binhex\"},",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "DEPRECATED_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "DEPRECATED_MODULES = {\n    (0, 0, 0): {\"tkinter.tix\", \"fpectl\"},\n    (3, 2, 0): {\"optparse\"},\n    (3, 3, 0): {\"xml.etree.cElementTree\"},\n    (3, 4, 0): {\"imp\"},\n    (3, 5, 0): {\"formatter\"},\n    (3, 6, 0): {\"asynchat\", \"asyncore\", \"smtpd\"},\n    (3, 7, 0): {\"macpath\"},\n    (3, 9, 0): {\"lib2to3\", \"parser\", \"symbol\", \"binhex\"},\n    (3, 10, 0): {\"distutils\", \"typing.io\", \"typing.re\"},",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "DEFAULT_STANDARD_LIBRARY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "DEFAULT_STANDARD_LIBRARY = ()\nDEFAULT_KNOWN_THIRD_PARTY = (\"enchant\",)\nDEFAULT_PREFERRED_MODULES = ()\nclass ImportsChecker(DeprecatedMixin, BaseChecker):\n    \"\"\"BaseChecker for import statements.\n    Checks for\n    * external modules dependencies\n    * relative / wildcard imports\n    * cyclic imports\n    * uses of deprecated modules",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "DEFAULT_KNOWN_THIRD_PARTY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "DEFAULT_KNOWN_THIRD_PARTY = (\"enchant\",)\nDEFAULT_PREFERRED_MODULES = ()\nclass ImportsChecker(DeprecatedMixin, BaseChecker):\n    \"\"\"BaseChecker for import statements.\n    Checks for\n    * external modules dependencies\n    * relative / wildcard imports\n    * cyclic imports\n    * uses of deprecated modules\n    * uses of modules instead of preferred modules",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PREFERRED_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "description": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "peekOfCode": "DEFAULT_PREFERRED_MODULES = ()\nclass ImportsChecker(DeprecatedMixin, BaseChecker):\n    \"\"\"BaseChecker for import statements.\n    Checks for\n    * external modules dependencies\n    * relative / wildcard imports\n    * cyclic imports\n    * uses of deprecated modules\n    * uses of modules instead of preferred modules\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.imports",
        "documentation": {}
    },
    {
        "label": "LambdaExpressionChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "peekOfCode": "class LambdaExpressionChecker(BaseChecker):\n    \"\"\"Check for unnecessary usage of lambda expressions.\"\"\"\n    name = \"lambda-expressions\"\n    msgs = {\n        \"C3001\": (\n            \"Lambda expression assigned to a variable. \"\n            'Define a function using the \"def\" keyword instead.',\n            \"unnecessary-lambda-assignment\",\n            \"Used when a lambda expression is assigned to variable \"\n            'rather than defining a standard function with the \"def\" keyword.',",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "description": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(LambdaExpressionChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.lambda_expressions",
        "documentation": {}
    },
    {
        "label": "LoggingChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "class LoggingChecker(checkers.BaseChecker):\n    \"\"\"Checks use of the logging module.\"\"\"\n    name = \"logging\"\n    msgs = MSGS\n    options = (\n        (\n            \"logging-modules\",\n            {\n                \"default\": (\"logging\",),\n                \"type\": \"csv\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "is_method_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "def is_method_call(\n    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()\n) -> bool:\n    \"\"\"Determines if a BoundMethod node represents a method call.\n    Args:\n      func: The BoundMethod AST node to check.\n      types: Optional sequence of caller type names to restrict check.\n      methods: Optional sequence of method names to restrict check.\n    Returns:\n      true if the node represents a method call for the given type and",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "is_complex_format_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "def is_complex_format_str(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the node represents a string with complex formatting specs.\"\"\"\n    inferred = utils.safe_infer(node)\n    if inferred is None or not (\n        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)\n    ):\n        return True\n    try:\n        parsed = list(string.Formatter().parse(inferred.value))\n    except ValueError:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "str_formatting_in_f_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "def str_formatting_in_f_string(node: nodes.JoinedStr) -> bool:\n    \"\"\"Determine whether the node represents an f-string with string formatting.\n    For example: `f'Hello %s'`\n    \"\"\"\n    # Check \"%\" presence first for performance.\n    return any(\n        \"%\" in val.value and any(x in val.value for x in MOST_COMMON_FORMATTING)\n        for val in node.values\n        if isinstance(val, nodes.Const)\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(LoggingChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"W1201\": (\n        \"Use %s formatting in logging functions\",\n        \"logging-not-lazy\",\n        \"Used when a logging statement has a call form of \"\n        '\"logging.<logging method>(format_string % (format_args...))\". '\n        \"Use another type of string formatting instead. \"\n        \"You can use % formatting but leave interpolation to \"\n        \"the logging function by passing the parameters as arguments. \"\n        \"If logging-fstring-interpolation is disabled then \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "CHECKED_CONVENIENCE_FUNCTIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "CHECKED_CONVENIENCE_FUNCTIONS = {\n    \"critical\",\n    \"debug\",\n    \"error\",\n    \"exception\",\n    \"fatal\",\n    \"info\",\n    \"warn\",\n    \"warning\",\n}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "MOST_COMMON_FORMATTING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "description": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "peekOfCode": "MOST_COMMON_FORMATTING = frozenset([\"%s\", \"%d\", \"%f\", \"%r\"])\ndef is_method_call(\n    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()\n) -> bool:\n    \"\"\"Determines if a BoundMethod node represents a method call.\n    Args:\n      func: The BoundMethod AST node to check.\n      types: Optional sequence of caller type names to restrict check.\n      methods: Optional sequence of method names to restrict check.\n    Returns:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.logging",
        "documentation": {}
    },
    {
        "label": "MapReduceMixin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.mapreduce_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.mapreduce_checker",
        "peekOfCode": "class MapReduceMixin(metaclass=abc.ABCMeta):\n    \"\"\"A mixin design to allow multi-process/threaded runs of a Checker.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(\n            \"MapReduceMixin has been deprecated and will be removed in pylint 3.0. \"\n            \"To make a checker reduce map data simply implement get_map_data and reduce_map_data.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    @abc.abstractmethod",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.mapreduce_checker",
        "documentation": {}
    },
    {
        "label": "MethodArgsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "description": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "peekOfCode": "class MethodArgsChecker(BaseChecker):\n    \"\"\"BaseChecker for method_args.\n    Checks for\n    * missing-timeout\n    * positional-only-arguments-expected\n    \"\"\"\n    name = \"method_args\"\n    msgs = {\n        \"W3101\": (\n            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "description": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(MethodArgsChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.method_args",
        "documentation": {}
    },
    {
        "label": "ByIdManagedMessagesChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "description": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "peekOfCode": "class ByIdManagedMessagesChecker(BaseRawFileChecker):\n    \"\"\"Checks for messages that are enabled or disabled by id instead of symbol.\"\"\"\n    name = \"miscellaneous\"\n    msgs = {\n        \"I0023\": (\n            \"%s\",\n            \"use-symbolic-message-instead\",\n            \"Used when a message is enabled or disabled by id.\",\n        )\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "documentation": {}
    },
    {
        "label": "EncodingChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "description": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "peekOfCode": "class EncodingChecker(BaseTokenChecker, BaseRawFileChecker):\n    \"\"\"BaseChecker for encoding issues.\n    Checks for:\n    * warning notes in the code like FIXME, XXX\n    * encoding issues.\n    \"\"\"\n    # configuration section name\n    name = \"miscellaneous\"\n    msgs = {\n        \"W0511\": (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "description": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(EncodingChecker(linter))\n    linter.register_checker(ByIdManagedMessagesChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.misc",
        "documentation": {}
    },
    {
        "label": "ModifiedIterationChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "peekOfCode": "class ModifiedIterationChecker(checkers.BaseChecker):\n    \"\"\"Checks for modified iterators in for loops iterations.\n    Currently supports `for` loops for Sets, Dictionaries and Lists.\n    \"\"\"\n    name = \"modified_iteration\"\n    msgs = {\n        \"W4701\": (\n            \"Iterated list '%s' is being modified inside for loop body, consider iterating through a copy of it \"\n            \"instead.\",\n            \"modified-iterating-list\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ModifiedIterationChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "documentation": {}
    },
    {
        "label": "_LIST_MODIFIER_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "peekOfCode": "_LIST_MODIFIER_METHODS = {\"append\", \"remove\"}\n_SET_MODIFIER_METHODS = {\"add\", \"remove\"}\nclass ModifiedIterationChecker(checkers.BaseChecker):\n    \"\"\"Checks for modified iterators in for loops iterations.\n    Currently supports `for` loops for Sets, Dictionaries and Lists.\n    \"\"\"\n    name = \"modified_iteration\"\n    msgs = {\n        \"W4701\": (\n            \"Iterated list '%s' is being modified inside for loop body, consider iterating through a copy of it \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "documentation": {}
    },
    {
        "label": "_SET_MODIFIER_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "peekOfCode": "_SET_MODIFIER_METHODS = {\"add\", \"remove\"}\nclass ModifiedIterationChecker(checkers.BaseChecker):\n    \"\"\"Checks for modified iterators in for loops iterations.\n    Currently supports `for` loops for Sets, Dictionaries and Lists.\n    \"\"\"\n    name = \"modified_iteration\"\n    msgs = {\n        \"W4701\": (\n            \"Iterated list '%s' is being modified inside for loop body, consider iterating through a copy of it \"\n            \"instead.\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.modified_iterating_checker",
        "documentation": {}
    },
    {
        "label": "NestedMinMaxChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "description": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "peekOfCode": "class NestedMinMaxChecker(BaseChecker):\n    \"\"\"Multiple nested min/max calls on the same line will raise multiple messages.\n    This behaviour is intended as it would slow down the checker to check\n    for nested call with minimal benefits.\n    \"\"\"\n    FUNC_NAMES = (\"builtins.min\", \"builtins.max\")\n    name = \"nested_min_max\"\n    msgs = {\n        \"W3301\": (\n            \"Do not use nested call of '%s'; it's possible to do '%s' instead\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "description": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(NestedMinMaxChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "documentation": {}
    },
    {
        "label": "DICT_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "description": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "peekOfCode": "DICT_TYPES = (\n    objects.DictValues,\n    objects.DictKeys,\n    objects.DictItems,\n    nodes.node_classes.Dict,\n)\nclass NestedMinMaxChecker(BaseChecker):\n    \"\"\"Multiple nested min/max calls on the same line will raise multiple messages.\n    This behaviour is intended as it would slow down the checker to check\n    for nested call with minimal benefits.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.nested_min_max",
        "documentation": {}
    },
    {
        "label": "NewStyleConflictChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "description": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "peekOfCode": "class NewStyleConflictChecker(BaseChecker):\n    \"\"\"Checks for usage of new style capabilities on old style classes and\n    other new/old styles conflicts problems.\n    * use of property, __slots__, super\n    * \"super\" usage\n    \"\"\"\n    # configuration section name\n    name = \"newstyle\"\n    # messages\n    msgs = MSGS",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "description": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(NewStyleConflictChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.newstyle",
        "documentation": {}
    },
    {
        "label": "NonAsciiNameChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "description": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "peekOfCode": "class NonAsciiNameChecker(base_checker.BaseChecker):\n    \"\"\"A strict name checker only allowing ASCII.\n    Note: This check only checks Names, so it ignores the content of\n          docstrings and comments!\n    \"\"\"\n    msgs = {\n        \"C2401\": (\n            '%s name \"%s\" contains a non-ASCII character, consider renaming it.',\n            \"non-ascii-name\",\n            NON_ASCII_HELP,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "description": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "peekOfCode": "def register(linter: lint.PyLinter) -> None:\n    linter.register_checker(NonAsciiNameChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "documentation": {}
    },
    {
        "label": "NON_ASCII_HELP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "description": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "peekOfCode": "NON_ASCII_HELP = (\n    \"Used when the name contains at least one non-ASCII unicode character. \"\n    \"See https://peps.python.org/pep-0672/#confusing-features\"\n    \" for a background why this could be bad. \\n\"\n    \"If your programming guideline defines that you are programming in \"\n    \"English, then there should be no need for non ASCII characters in \"\n    \"Python Names. If not you can simply disable this check.\"\n)\nclass NonAsciiNameChecker(base_checker.BaseChecker):\n    \"\"\"A strict name checker only allowing ASCII.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.non_ascii_names",
        "documentation": {}
    },
    {
        "label": "RawMetricsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "description": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "peekOfCode": "class RawMetricsChecker(BaseTokenChecker):\n    \"\"\"Checker that provides raw metrics instead of checking anything.\n    Provides:\n    * total number of lines\n    * total number of code lines\n    * total number of docstring lines\n    * total number of comments lines\n    * total number of empty lines\n    \"\"\"\n    # configuration section name",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "documentation": {}
    },
    {
        "label": "report_raw_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "description": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "peekOfCode": "def report_raw_stats(\n    sect: Section,\n    stats: LinterStats,\n    old_stats: LinterStats | None,\n) -> None:\n    \"\"\"Calculate percentage of code / doc / comment / empty.\"\"\"\n    total_lines = stats.code_type_count[\"total\"]\n    sect.insert(0, Paragraph([Text(f\"{total_lines} lines have been analyzed\\n\")]))\n    lines = [\"type\", \"number\", \"%\", \"previous\", \"difference\"]\n    for node_type in (\"code\", \"docstring\", \"comment\", \"empty\"):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "documentation": {}
    },
    {
        "label": "get_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "description": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "peekOfCode": "def get_type(\n    tokens: list[tokenize.TokenInfo], start_index: int\n) -> tuple[int, int, Literal[\"code\", \"docstring\", \"comment\", \"empty\"]]:\n    \"\"\"Return the line type : docstring, comment, code, empty.\"\"\"\n    i = start_index\n    start = tokens[i][2]\n    pos = start\n    line_type = None\n    while i < len(tokens) and tokens[i][2][0] == start[0]:\n        tok_type = tokens[i][0]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "description": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(RawMetricsChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "documentation": {}
    },
    {
        "label": "JUNK",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "description": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "peekOfCode": "JUNK = (tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER)\ndef get_type(\n    tokens: list[tokenize.TokenInfo], start_index: int\n) -> tuple[int, int, Literal[\"code\", \"docstring\", \"comment\", \"empty\"]]:\n    \"\"\"Return the line type : docstring, comment, code, empty.\"\"\"\n    i = start_index\n    start = tokens[i][2]\n    pos = start\n    line_type = None\n    while i < len(tokens) and tokens[i][2][0] == start[0]:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.raw_metrics",
        "documentation": {}
    },
    {
        "label": "LineSpecifs",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class LineSpecifs(NamedTuple):\n    line_number: LineNumber\n    text: str\n# Links LinesChunk object to the starting indices (in lineset's stripped lines)\n# of the different chunk of lines that are used to compute the hash\nHashToIndex_T = Dict[\"LinesChunk\", List[Index]]\n# Links index in the lineset's stripped lines to the real lines in the file\nIndexToLines_T = Dict[Index, \"SuccessiveLinesLimits\"]\n# The types the streams read by pylint can take. Originating from astroid.nodes.Module.stream() and open()\nSTREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "CplSuccessiveLinesLimits",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class CplSuccessiveLinesLimits:\n    \"\"\"Holds a SuccessiveLinesLimits object for each checked file and counts the number\n    of common lines between both stripped lines collections extracted from both files.\n    \"\"\"\n    __slots__ = (\"first_file\", \"second_file\", \"effective_cmn_lines_nb\")\n    def __init__(\n        self,\n        first_file: SuccessiveLinesLimits,\n        second_file: SuccessiveLinesLimits,\n        effective_cmn_lines_nb: int,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "LinesChunk",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class LinesChunk:\n    \"\"\"The LinesChunk object computes and stores the hash of some consecutive stripped\n    lines of a lineset.\n    \"\"\"\n    __slots__ = (\"_fileid\", \"_index\", \"_hash\")\n    def __init__(self, fileid: str, num_line: int, *lines: Iterable[str]) -> None:\n        self._fileid: str = fileid\n        \"\"\"The name of the file from which the LinesChunk object is generated.\"\"\"\n        self._index: Index = Index(num_line)\n        \"\"\"The index in the stripped lines that is the starting of consecutive",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "SuccessiveLinesLimits",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class SuccessiveLinesLimits:\n    \"\"\"A class to handle the numbering of begin and end of successive lines.\n    :note: Only the end line number can be updated.\n    \"\"\"\n    __slots__ = (\"_start\", \"_end\")\n    def __init__(self, start: LineNumber, end: LineNumber) -> None:\n        self._start: LineNumber = start\n        self._end: LineNumber = end\n    @property\n    def start(self) -> LineNumber:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "LineSetStartCouple",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class LineSetStartCouple(NamedTuple):\n    \"\"\"Indices in both linesets that mark the beginning of successive lines.\"\"\"\n    fst_lineset_index: Index\n    snd_lineset_index: Index\n    def __repr__(self) -> str:\n        return (\n            f\"<LineSetStartCouple <{self.fst_lineset_index};{self.snd_lineset_index}>>\"\n        )\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, LineSetStartCouple):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "Commonality",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class Commonality(NamedTuple):\n    cmn_lines_nb: int\n    fst_lset: LineSet\n    fst_file_start: LineNumber\n    fst_file_end: LineNumber\n    snd_lset: LineSet\n    snd_file_start: LineNumber\n    snd_file_end: LineNumber\nclass Similar:\n    \"\"\"Finds copy-pasted lines of code in a project.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "Similar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class Similar:\n    \"\"\"Finds copy-pasted lines of code in a project.\"\"\"\n    def __init__(\n        self,\n        min_lines: int = DEFAULT_MIN_SIMILARITY_LINE,\n        ignore_comments: bool = False,\n        ignore_docstrings: bool = False,\n        ignore_imports: bool = False,\n        ignore_signatures: bool = False,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "LineSet",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class LineSet:\n    \"\"\"Holds and indexes all the lines of a single source file.\n    Allows for correspondence between real lines of the source file and stripped ones, which\n    are the real ones from which undesired patterns have been removed.\n    \"\"\"\n    def __init__(\n        self,\n        name: str,\n        lines: list[str],\n        ignore_comments: bool = False,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "SimilarChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "class SimilarChecker(BaseRawFileChecker, Similar):\n    \"\"\"Checks for similarities and duplicated code.\n    This computation may be memory / CPU intensive, so you\n    should disable it if you experience some problems.\n    \"\"\"\n    # configuration section name\n    name = \"similarities\"\n    # messages\n    msgs = MSGS\n    # configuration options",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "hash_lineset",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def hash_lineset(\n    lineset: LineSet, min_common_lines: int = DEFAULT_MIN_SIMILARITY_LINE\n) -> tuple[HashToIndex_T, IndexToLines_T]:\n    \"\"\"Return two dicts.\n    The first associates the hash of successive stripped lines of a lineset\n    to the indices of the starting lines.\n    The second dict, associates the index of the starting line in the lineset's stripped lines to the\n    couple [start, end] lines number in the corresponding file.\n    :param lineset: lineset object (i.e the lines in a file)\n    :param min_common_lines: number of successive lines that are used to compute the hash",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "remove_successive",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def remove_successive(all_couples: CplIndexToCplLines_T) -> None:\n    \"\"\"Removes all successive entries in the dictionary in argument.\n    :param all_couples: collection that has to be cleaned up from successive entries.\n                        The keys are couples of indices that mark the beginning of common entries\n                        in both linesets. The values have two parts. The first one is the couple\n                        of starting and ending line numbers of common successive lines in the first file.\n                        The second part is the same for the second file.\n    For example consider the following dict:\n    >>> all_couples\n    {(11, 34): ([5, 9], [27, 31]),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "filter_noncode_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def filter_noncode_lines(\n    ls_1: LineSet,\n    stindex_1: Index,\n    ls_2: LineSet,\n    stindex_2: Index,\n    common_lines_nb: int,\n) -> int:\n    \"\"\"Return the effective number of common lines between lineset1\n    and lineset2 filtered from non code lines.\n    That is to say the number of common successive stripped",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "stripped_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def stripped_lines(\n    lines: Iterable[str],\n    ignore_comments: bool,\n    ignore_docstrings: bool,\n    ignore_imports: bool,\n    ignore_signatures: bool,\n    line_enabled_callback: Callable[[str, int], bool] | None = None,\n) -> list[LineSpecifs]:\n    \"\"\"Return tuples of line/line number/line type with leading/trailing white-space and\n    any ignored code features removed.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "report_similarities",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def report_similarities(\n    sect: Section,\n    stats: LinterStats,\n    old_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make a layout with some stats about duplication.\"\"\"\n    lines = [\"\", \"now\", \"previous\", \"difference\"]\n    lines += table_lines_from_stats(stats, old_stats, \"duplicated_lines\")\n    sect.append(Table(children=lines, cols=4, rheaders=1, cheaders=1))\n# wrapper to get a pylint checker from the similar class",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(SimilarChecker(linter))\ndef usage(status: int = 0) -> NoReturn:\n    \"\"\"Display command line usage information.\"\"\"\n    print(\"finds copy pasted blocks in a set of files\")\n    print()\n    print(\n        \"Usage: symilar [-d|--duplicates min_duplicated_lines] \\\n[-i|--ignore-comments] [--ignore-docstrings] [--ignore-imports] [--ignore-signatures] file1...\"\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def usage(status: int = 0) -> NoReturn:\n    \"\"\"Display command line usage information.\"\"\"\n    print(\"finds copy pasted blocks in a set of files\")\n    print()\n    print(\n        \"Usage: symilar [-d|--duplicates min_duplicated_lines] \\\n[-i|--ignore-comments] [--ignore-docstrings] [--ignore-imports] [--ignore-signatures] file1...\"\n    )\n    sys.exit(status)\ndef Run(argv: Sequence[str] | None = None) -> NoReturn:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "def Run(argv: Sequence[str] | None = None) -> NoReturn:\n    \"\"\"Standalone command line access point.\"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    s_opts = \"hdi\"\n    l_opts = [\n        \"help\",\n        \"duplicates=\",\n        \"ignore-comments\",\n        \"ignore-imports\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MIN_SIMILARITY_LINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "DEFAULT_MIN_SIMILARITY_LINE = 4\nREGEX_FOR_LINES_WITH_CONTENT = re.compile(r\".*\\w+\")\n# Index defines a location in a LineSet stripped lines collection\nIndex = NewType(\"Index\", int)\n# LineNumber defines a location in a LinesSet real lines collection (the whole file lines)\nLineNumber = NewType(\"LineNumber\", int)\n# LineSpecifs holds characteristics of a line in a file\nclass LineSpecifs(NamedTuple):\n    line_number: LineNumber\n    text: str",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "REGEX_FOR_LINES_WITH_CONTENT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "REGEX_FOR_LINES_WITH_CONTENT = re.compile(r\".*\\w+\")\n# Index defines a location in a LineSet stripped lines collection\nIndex = NewType(\"Index\", int)\n# LineNumber defines a location in a LinesSet real lines collection (the whole file lines)\nLineNumber = NewType(\"LineNumber\", int)\n# LineSpecifs holds characteristics of a line in a file\nclass LineSpecifs(NamedTuple):\n    line_number: LineNumber\n    text: str\n# Links LinesChunk object to the starting indices (in lineset's stripped lines)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "Index",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "Index = NewType(\"Index\", int)\n# LineNumber defines a location in a LinesSet real lines collection (the whole file lines)\nLineNumber = NewType(\"LineNumber\", int)\n# LineSpecifs holds characteristics of a line in a file\nclass LineSpecifs(NamedTuple):\n    line_number: LineNumber\n    text: str\n# Links LinesChunk object to the starting indices (in lineset's stripped lines)\n# of the different chunk of lines that are used to compute the hash\nHashToIndex_T = Dict[\"LinesChunk\", List[Index]]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "LineNumber",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "LineNumber = NewType(\"LineNumber\", int)\n# LineSpecifs holds characteristics of a line in a file\nclass LineSpecifs(NamedTuple):\n    line_number: LineNumber\n    text: str\n# Links LinesChunk object to the starting indices (in lineset's stripped lines)\n# of the different chunk of lines that are used to compute the hash\nHashToIndex_T = Dict[\"LinesChunk\", List[Index]]\n# Links index in the lineset's stripped lines to the real lines in the file\nIndexToLines_T = Dict[Index, \"SuccessiveLinesLimits\"]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "HashToIndex_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "HashToIndex_T = Dict[\"LinesChunk\", List[Index]]\n# Links index in the lineset's stripped lines to the real lines in the file\nIndexToLines_T = Dict[Index, \"SuccessiveLinesLimits\"]\n# The types the streams read by pylint can take. Originating from astroid.nodes.Module.stream() and open()\nSTREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]\nclass CplSuccessiveLinesLimits:\n    \"\"\"Holds a SuccessiveLinesLimits object for each checked file and counts the number\n    of common lines between both stripped lines collections extracted from both files.\n    \"\"\"\n    __slots__ = (\"first_file\", \"second_file\", \"effective_cmn_lines_nb\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "IndexToLines_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "IndexToLines_T = Dict[Index, \"SuccessiveLinesLimits\"]\n# The types the streams read by pylint can take. Originating from astroid.nodes.Module.stream() and open()\nSTREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]\nclass CplSuccessiveLinesLimits:\n    \"\"\"Holds a SuccessiveLinesLimits object for each checked file and counts the number\n    of common lines between both stripped lines collections extracted from both files.\n    \"\"\"\n    __slots__ = (\"first_file\", \"second_file\", \"effective_cmn_lines_nb\")\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "STREAM_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "STREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]\nclass CplSuccessiveLinesLimits:\n    \"\"\"Holds a SuccessiveLinesLimits object for each checked file and counts the number\n    of common lines between both stripped lines collections extracted from both files.\n    \"\"\"\n    __slots__ = (\"first_file\", \"second_file\", \"effective_cmn_lines_nb\")\n    def __init__(\n        self,\n        first_file: SuccessiveLinesLimits,\n        second_file: SuccessiveLinesLimits,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "CplIndexToCplLines_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "CplIndexToCplLines_T = Dict[\"LineSetStartCouple\", CplSuccessiveLinesLimits]\nclass LinesChunk:\n    \"\"\"The LinesChunk object computes and stores the hash of some consecutive stripped\n    lines of a lineset.\n    \"\"\"\n    __slots__ = (\"_fileid\", \"_index\", \"_hash\")\n    def __init__(self, fileid: str, num_line: int, *lines: Iterable[str]) -> None:\n        self._fileid: str = fileid\n        \"\"\"The name of the file from which the LinesChunk object is generated.\"\"\"\n        self._index: Index = Index(num_line)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "LinesChunkLimits_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "description": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "peekOfCode": "LinesChunkLimits_T = Tuple[\"LineSet\", LineNumber, LineNumber]\ndef hash_lineset(\n    lineset: LineSet, min_common_lines: int = DEFAULT_MIN_SIMILARITY_LINE\n) -> tuple[HashToIndex_T, IndexToLines_T]:\n    \"\"\"Return two dicts.\n    The first associates the hash of successive stripped lines of a lineset\n    to the indices of the starting lines.\n    The second dict, associates the index of the starting line in the lineset's stripped lines to the\n    couple [start, end] lines number in the corresponding file.\n    :param lineset: lineset object (i.e the lines in a file)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.similar",
        "documentation": {}
    },
    {
        "label": "WordsWithDigitsFilter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class WordsWithDigitsFilter(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with digits.\"\"\"\n    def _skip(self, word: str) -> bool:\n        return any(char.isdigit() for char in word)\nclass WordsWithUnderscores(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with underscores.\n    They are probably function parameter names.\n    \"\"\"\n    def _skip(self, word: str) -> bool:\n        return \"_\" in word",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "WordsWithUnderscores",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class WordsWithUnderscores(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with underscores.\n    They are probably function parameter names.\n    \"\"\"\n    def _skip(self, word: str) -> bool:\n        return \"_\" in word\nclass RegExFilter(Filter):  # type: ignore[misc]\n    \"\"\"Parent class for filters using regular expressions.\n    This filter skips any words the match the expression\n    assigned to the class attribute ``_pattern``.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "RegExFilter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class RegExFilter(Filter):  # type: ignore[misc]\n    \"\"\"Parent class for filters using regular expressions.\n    This filter skips any words the match the expression\n    assigned to the class attribute ``_pattern``.\n    \"\"\"\n    _pattern: Pattern[str]\n    def _skip(self, word: str) -> bool:\n        return bool(self._pattern.match(word))\nclass CamelCasedWord(RegExFilter):\n    r\"\"\"Filter skipping over camelCasedWords.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "CamelCasedWord",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class CamelCasedWord(RegExFilter):\n    r\"\"\"Filter skipping over camelCasedWords.\n    This filter skips any words matching the following regular expression:\n           ^([a-z]\\w+[A-Z]+\\w+)\n    That is, any words that are camelCasedWords.\n    \"\"\"\n    _pattern = re.compile(r\"^([a-z]+(\\d|[A-Z])(?:\\w+)?)\")\nclass SphinxDirectives(RegExFilter):\n    r\"\"\"Filter skipping over Sphinx Directives.\n    This filter skips any words matching the following regular expression:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "SphinxDirectives",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class SphinxDirectives(RegExFilter):\n    r\"\"\"Filter skipping over Sphinx Directives.\n    This filter skips any words matching the following regular expression:\n           ^(:([a-z]+)){1,2}:`([^`]+)(`)?\n    That is, for example, :class:`BaseQuery`\n    \"\"\"\n    # The final ` in the pattern is optional because enchant strips it out\n    _pattern = re.compile(r\"^(:([a-z]+)){1,2}:`([^`]+)(`)?\")\nclass ForwardSlashChunker(Chunker):  # type: ignore[misc]\n    \"\"\"This chunker allows splitting words like 'before/after' into 'before' and",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "ForwardSlashChunker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class ForwardSlashChunker(Chunker):  # type: ignore[misc]\n    \"\"\"This chunker allows splitting words like 'before/after' into 'before' and\n    'after'.\n    \"\"\"\n    _text: str\n    def next(self) -> tuple[str, int]:\n        while True:\n            if not self._text:\n                raise StopIteration()\n            if \"/\" not in self._text:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "SpellingChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "class SpellingChecker(BaseTokenChecker):\n    \"\"\"Check spelling in comments and docstrings.\"\"\"\n    name = \"spelling\"\n    msgs = {\n        \"C0401\": (\n            \"Wrong spelling of a word '%s' in a comment:\\n%s\\n\"\n            \"%s\\nDid you mean: '%s'?\",\n            \"wrong-spelling-in-comment\",\n            \"Used when a word in comment is not spelled correctly.\",\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(SpellingChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "CODE_FLANKED_IN_BACKTICK_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r\"(\\s|^)(`{1,2})([^`]+)(\\2)([^`]|$)\")\nMYPY_IGNORE_DIRECTIVE_RULE_REGEX = re.compile(r\"(\\s|^)(type\\: ignore\\[[^\\]]+\\])(.*)\")\ndef _strip_code_flanked_in_backticks(line: str) -> str:\n    \"\"\"Alter line so code flanked in back-ticks is ignored.\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n        return match_obj.group(1) + match_obj.group(5)\n    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "MYPY_IGNORE_DIRECTIVE_RULE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "description": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "peekOfCode": "MYPY_IGNORE_DIRECTIVE_RULE_REGEX = re.compile(r\"(\\s|^)(type\\: ignore\\[[^\\]]+\\])(.*)\")\ndef _strip_code_flanked_in_backticks(line: str) -> str:\n    \"\"\"Alter line so code flanked in back-ticks is ignored.\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n        return match_obj.group(1) + match_obj.group(5)\n    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(\n        replace_code_but_leave_surrounding_characters, line",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.spelling",
        "documentation": {}
    },
    {
        "label": "StdlibChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "class StdlibChecker(DeprecatedMixin, BaseChecker):\n    name = \"stdlib\"\n    msgs: dict[str, MessageDefinitionTuple] = {\n        **DeprecatedMixin.DEPRECATED_METHOD_MESSAGE,\n        **DeprecatedMixin.DEPRECATED_ARGUMENT_MESSAGE,\n        **DeprecatedMixin.DEPRECATED_CLASS_MESSAGE,\n        **DeprecatedMixin.DEPRECATED_DECORATOR_MESSAGE,\n        \"W1501\": (\n            '\"%s\" is not a valid mode for open.',\n            \"bad-open-mode\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(StdlibChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "DeprecationDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "DeprecationDict = Dict[Tuple[int, int, int], Set[str]]\nOPEN_FILES_MODE = (\"open\", \"file\")\nOPEN_FILES_FUNCS = OPEN_FILES_MODE + (\"read_text\", \"write_text\")\nUNITTEST_CASE = \"unittest.case\"\nTHREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "OPEN_FILES_MODE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "OPEN_FILES_MODE = (\"open\", \"file\")\nOPEN_FILES_FUNCS = OPEN_FILES_MODE + (\"read_text\", \"write_text\")\nUNITTEST_CASE = \"unittest.case\"\nTHREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "OPEN_FILES_FUNCS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "OPEN_FILES_FUNCS = OPEN_FILES_MODE + (\"read_text\", \"write_text\")\nUNITTEST_CASE = \"unittest.case\"\nTHREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "UNITTEST_CASE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "UNITTEST_CASE = \"unittest.case\"\nTHREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "THREADING_THREAD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "THREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "COPY_COPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "COPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "OS_ENVIRON",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "OS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "ENV_GETTERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "ENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "SUBPROCESS_POPEN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "SUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}\nNON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "SUBPROCESS_RUN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "SUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}\nNON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}\n# For modules, see ImportsChecker",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "OPEN_MODULE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "OPEN_MODULE = {\"_io\", \"pathlib\"}\nDEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}\nNON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}\n# For modules, see ImportsChecker\nDEPRECATED_ARGUMENTS: dict[",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "DEBUG_BREAKPOINTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "DEBUG_BREAKPOINTS = (\"builtins.breakpoint\", \"sys.breakpointhook\", \"pdb.set_trace\")\nLRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}\nNON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}\n# For modules, see ImportsChecker\nDEPRECATED_ARGUMENTS: dict[\n    tuple[int, int, int], dict[str, tuple[tuple[int | None, str], ...]]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "LRU_CACHE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "LRU_CACHE = {\n    \"functools.lru_cache\",  # Inferred for @lru_cache\n    \"functools._lru_cache_wrapper.wrapper\",  # Inferred for @lru_cache() on >= Python 3.8\n    \"functools.lru_cache.decorating_function\",  # Inferred for @lru_cache() on <= Python 3.7\n}\nNON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}\n# For modules, see ImportsChecker\nDEPRECATED_ARGUMENTS: dict[\n    tuple[int, int, int], dict[str, tuple[tuple[int | None, str], ...]]\n] = {",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "NON_INSTANCE_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "NON_INSTANCE_METHODS = {\"builtins.staticmethod\", \"builtins.classmethod\"}\n# For modules, see ImportsChecker\nDEPRECATED_ARGUMENTS: dict[\n    tuple[int, int, int], dict[str, tuple[tuple[int | None, str], ...]]\n] = {\n    (0, 0, 0): {\n        \"int\": ((None, \"x\"),),\n        \"bool\": ((None, \"x\"),),\n        \"float\": ((None, \"x\"),),\n    },",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "description": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "peekOfCode": "] = {\n    (0, 0, 0): {\n        \"int\": ((None, \"x\"),),\n        \"bool\": ((None, \"x\"),),\n        \"float\": ((None, \"x\"),),\n    },\n    (3, 8, 0): {\n        \"asyncio.tasks.sleep\": ((None, \"loop\"),),\n        \"asyncio.tasks.gather\": ((None, \"loop\"),),\n        \"asyncio.tasks.shield\": ((None, \"loop\"),),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.stdlib",
        "documentation": {}
    },
    {
        "label": "StringFormatChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "class StringFormatChecker(BaseChecker):\n    \"\"\"Checks string formatting operations to ensure that the format string\n    is valid and the arguments match the format string.\n    \"\"\"\n    name = \"string\"\n    msgs = MSGS\n    # pylint: disable = too-many-branches, too-many-locals, too-many-statements\n    @only_required_for_messages(\n        \"bad-format-character\",\n        \"truncated-format-string\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "StringConstantChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):\n    \"\"\"Check string literals.\"\"\"\n    name = \"string\"\n    msgs = {\n        \"W1401\": (\n            \"Anomalous backslash in string: '%s'. \"\n            \"String constant might be missing an r prefix.\",\n            \"anomalous-backslash-in-string\",\n            \"Used when a backslash is in a literal string but not as an escape.\",\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "get_access_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "def get_access_path(key: str | Literal[0], parts: list[tuple[bool, str]]) -> str:\n    \"\"\"Given a list of format specifiers, returns\n    the final access path (e.g. a.b.c[0][1]).\n    \"\"\"\n    path = []\n    for is_attribute, specifier in parts:\n        if is_attribute:\n            path.append(f\".{specifier}\")\n        else:\n            path.append(f\"[{specifier!r}]\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "arg_matches_format_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "def arg_matches_format_type(\n    arg_type: SuccessfulInferenceResult, format_type: str\n) -> bool:\n    if format_type in \"sr\":\n        # All types can be printed with %s and %r\n        return True\n    if isinstance(arg_type, astroid.Instance):\n        arg_type = arg_type.pytype()\n        if arg_type == \"builtins.str\":\n            return format_type == \"c\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(StringFormatChecker(linter))\n    linter.register_checker(StringConstantChecker(linter))\ndef str_eval(token: str) -> str:\n    \"\"\"Mostly replicate `ast.literal_eval(token)` manually to avoid any performance hit.\n    This supports f-strings, contrary to `ast.literal_eval`.\n    We have to support all string literal notations:\n    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n    \"\"\"\n    if token[0:2].lower() in {\"fr\", \"rf\"}:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "str_eval",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "def str_eval(token: str) -> str:\n    \"\"\"Mostly replicate `ast.literal_eval(token)` manually to avoid any performance hit.\n    This supports f-strings, contrary to `ast.literal_eval`.\n    We have to support all string literal notations:\n    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n    \"\"\"\n    if token[0:2].lower() in {\"fr\", \"rf\"}:\n        token = token[2:]\n    elif token[0].lower() in {\"r\", \"u\", \"f\"}:\n        token = token[1:]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "_AST_NODE_STR_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "_AST_NODE_STR_TYPES = (\"__builtin__.unicode\", \"__builtin__.str\", \"builtins.str\")\n# Prefixes for both strings and bytes literals per\n# https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n_PREFIXES = {\n    \"r\",\n    \"u\",\n    \"R\",\n    \"U\",\n    \"f\",\n    \"F\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "_PREFIXES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "_PREFIXES = {\n    \"r\",\n    \"u\",\n    \"R\",\n    \"U\",\n    \"f\",\n    \"F\",\n    \"fr\",\n    \"Fr\",\n    \"fR\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "SINGLE_QUOTED_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "SINGLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?'''\")\nDOUBLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?\\\"\\\"\\\"\")\nQUOTE_DELIMITER_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?(\\\"|')\", re.DOTALL)\nMSGS: dict[\n    str, MessageDefinitionTuple\n] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"E1300\": (\n        \"Unsupported format character %r (%#02x) at index %d\",\n        \"bad-format-character\",\n        \"Used when an unsupported format character is used in a format string.\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "DOUBLE_QUOTED_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "DOUBLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?\\\"\\\"\\\"\")\nQUOTE_DELIMITER_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?(\\\"|')\", re.DOTALL)\nMSGS: dict[\n    str, MessageDefinitionTuple\n] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"E1300\": (\n        \"Unsupported format character %r (%#02x) at index %d\",\n        \"bad-format-character\",\n        \"Used when an unsupported format character is used in a format string.\",\n    ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "QUOTE_DELIMITER_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "QUOTE_DELIMITER_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?(\\\"|')\", re.DOTALL)\nMSGS: dict[\n    str, MessageDefinitionTuple\n] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"E1300\": (\n        \"Unsupported format character %r (%#02x) at index %d\",\n        \"bad-format-character\",\n        \"Used when an unsupported format character is used in a format string.\",\n    ),\n    \"E1301\": (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"E1300\": (\n        \"Unsupported format character %r (%#02x) at index %d\",\n        \"bad-format-character\",\n        \"Used when an unsupported format character is used in a format string.\",\n    ),\n    \"E1301\": (\n        \"Format string ends in middle of conversion specifier\",\n        \"truncated-format-string\",\n        \"Used when a format string terminates before the end of a \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "OTHER_NODES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "description": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "peekOfCode": "OTHER_NODES = (\n    nodes.Const,\n    nodes.List,\n    nodes.Lambda,\n    nodes.FunctionDef,\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.GeneratorExp,\n)\ndef get_access_path(key: str | Literal[0], parts: list[tuple[bool, str]]) -> str:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.strings",
        "documentation": {}
    },
    {
        "label": "ThreadingChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "peekOfCode": "class ThreadingChecker(BaseChecker):\n    \"\"\"Checks for threading module.\n    - useless with lock - locking used in wrong way that has no effect (with threading.Lock():)\n    \"\"\"\n    name = \"threading\"\n    LOCKS = frozenset(\n        (\n            \"threading.Lock\",\n            \"threading.RLock\",\n            \"threading.Condition\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "description": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ThreadingChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.threading_checker",
        "documentation": {}
    },
    {
        "label": "VERSION_COMPATIBLE_OVERLOAD",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "class VERSION_COMPATIBLE_OVERLOAD:\n    pass\nVERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()\ndef _unflatten(iterable: Iterable[_T]) -> Iterator[_T]:\n    for index, elem in enumerate(iterable):\n        if isinstance(elem, Sequence) and not isinstance(elem, str):\n            yield from _unflatten(elem)\n        elif elem and not index:\n            # We're interested only in the first element.\n            yield elem  # type: ignore[misc]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "TypeChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "class TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n    # configuration section name\n    name = \"typecheck\"\n    # messages\n    msgs = MSGS\n    # configuration options\n    options = (\n        (\n            \"ignore-on-opaque-inference\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "IterableChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "class IterableChecker(BaseChecker):\n    \"\"\"Checks for non-iterables used in an iterable context.\n    Contexts include:\n    - for-statement\n    - starargs in function call\n    - `yield from`-statement\n    - list, dict and set comprehensions\n    - generator expressions\n    Also checks for non-mappings in function call kwargs.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(TypeChecker(linter))\n    linter.register_checker(IterableChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "CallableObjects",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "CallableObjects = Union[\n    bases.BoundMethod,\n    bases.UnboundMethod,\n    nodes.FunctionDef,\n    nodes.Lambda,\n    nodes.ClassDef,\n]\n_T = TypeVar(\"_T\")\nSTR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "_T = TypeVar(\"_T\")\nSTR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nclass VERSION_COMPATIBLE_OVERLOAD:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "STR_FORMAT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "STR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nclass VERSION_COMPATIBLE_OVERLOAD:\n    pass",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "ASYNCIO_COROUTINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "ASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nclass VERSION_COMPATIBLE_OVERLOAD:\n    pass\nVERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "BUILTIN_TUPLE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "BUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nclass VERSION_COMPATIBLE_OVERLOAD:\n    pass\nVERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()\ndef _unflatten(iterable: Iterable[_T]) -> Iterator[_T]:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "TYPE_ANNOTATION_NODES_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "TYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nclass VERSION_COMPATIBLE_OVERLOAD:\n    pass\nVERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()\ndef _unflatten(iterable: Iterable[_T]) -> Iterator[_T]:\n    for index, elem in enumerate(iterable):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "VERSION_COMPATIBLE_OVERLOAD_SENTINEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "VERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()\ndef _unflatten(iterable: Iterable[_T]) -> Iterator[_T]:\n    for index, elem in enumerate(iterable):\n        if isinstance(elem, Sequence) and not isinstance(elem, str):\n            yield from _unflatten(elem)\n        elif elem and not index:\n            # We're interested only in the first element.\n            yield elem  # type: ignore[misc]\ndef _flatten_container(iterable: Iterable[_T]) -> Iterator[_T]:\n    # Flatten nested containers into a single iterable",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "SEQUENCE_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "description": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "peekOfCode": "SEQUENCE_TYPES = {\n    \"str\",\n    \"unicode\",\n    \"list\",\n    \"tuple\",\n    \"bytearray\",\n    \"xrange\",\n    \"range\",\n    \"bytes\",\n    \"memoryview\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.typecheck",
        "documentation": {}
    },
    {
        "label": "_BadChar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "class _BadChar(NamedTuple):\n    \"\"\"Representation of an ASCII char considered bad.\"\"\"\n    name: str\n    unescaped: str\n    escaped: str\n    code: str\n    help_text: str\n    def description(self) -> str:\n        \"\"\"Used for the detailed error message description.\"\"\"\n        return (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "UnicodeChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "class UnicodeChecker(checkers.BaseRawFileChecker):\n    \"\"\"Check characters that could be used to hide bad code to humans.\n    This includes:\n    - Bidirectional Unicode (see https://trojansource.codes/)\n    - Bad ASCII characters (see PEP672)\n        If a programmer requires to use such a character they should use the escaped\n        version, that is also much easier to read and does not depend on the editor used.\n    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n    At the time of writing Python supported only UTF-8. See",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "extract_codec_from_bom",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "def extract_codec_from_bom(first_line: bytes) -> str:\n    \"\"\"Try to extract the codec (unicode only) by checking for the BOM.\n    For details about BOM see https://unicode.org/faq/utf_bom.html#BOM\n    Args:\n        first_line: the first line of a file\n    Returns:\n        a codec name\n    Raises:\n        ValueError: if no codec was found\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "def register(linter: pylint.lint.PyLinter) -> None:\n    linter.register_checker(UnicodeChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "_StrLike",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "_StrLike = TypeVar(\"_StrLike\", str, bytes)\n# Based on:\n# https://golangexample.com/go-linter-which-checks-for-dangerous-unicode-character-sequences/\n# We use '\\u' because it doesn't require a map lookup and is therefore faster\nBIDI_UNICODE = [\n    \"\\u202A\",  # \\N{LEFT-TO-RIGHT EMBEDDING}\n    \"\\u202B\",  # \\N{RIGHT-TO-LEFT EMBEDDING}\n    \"\\u202C\",  # \\N{POP DIRECTIONAL FORMATTING}\n    \"\\u202D\",  # \\N{LEFT-TO-RIGHT OVERRIDE}\n    \"\\u202E\",  # \\N{RIGHT-TO-LEFT OVERRIDE}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "BIDI_UNICODE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "BIDI_UNICODE = [\n    \"\\u202A\",  # \\N{LEFT-TO-RIGHT EMBEDDING}\n    \"\\u202B\",  # \\N{RIGHT-TO-LEFT EMBEDDING}\n    \"\\u202C\",  # \\N{POP DIRECTIONAL FORMATTING}\n    \"\\u202D\",  # \\N{LEFT-TO-RIGHT OVERRIDE}\n    \"\\u202E\",  # \\N{RIGHT-TO-LEFT OVERRIDE}\n    \"\\u2066\",  # \\N{LEFT-TO-RIGHT ISOLATE}\n    \"\\u2067\",  # \\N{RIGHT-TO-LEFT ISOLATE}\n    \"\\u2068\",  # \\N{FIRST STRONG ISOLATE}\n    \"\\u2069\",  # \\N{POP DIRECTIONAL ISOLATE}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "BAD_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "BAD_CHARS = [\n    _BadChar(\n        \"backspace\",\n        \"\\b\",\n        \"\\\\b\",\n        \"E2510\",\n        (\n            \"Moves the cursor back, so the character after it will overwrite the \"\n            \"character before.\"\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "BAD_ASCII_SEARCH_DICT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "BAD_ASCII_SEARCH_DICT = {char.unescaped: char for char in BAD_CHARS}\ndef _line_length(line: _StrLike, codec: str) -> int:\n    \"\"\"Get the length of a string like line as displayed in an editor.\"\"\"\n    if isinstance(line, bytes):\n        decoded = _remove_bom(line, codec).decode(codec, \"replace\")\n    else:\n        decoded = line\n    stripped = decoded.rstrip(\"\\n\")\n    if stripped != decoded:\n        stripped = stripped.rstrip(\"\\r\")",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "UNICODE_BOMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "UNICODE_BOMS = {\n    \"utf-8\": codecs.BOM_UTF8,\n    \"utf-16\": codecs.BOM_UTF16,\n    \"utf-32\": codecs.BOM_UTF32,\n    \"utf-16le\": codecs.BOM_UTF16_LE,\n    \"utf-16be\": codecs.BOM_UTF16_BE,\n    \"utf-32le\": codecs.BOM_UTF32_LE,\n    \"utf-32be\": codecs.BOM_UTF32_BE,\n}\nBOM_SORTED_TO_CODEC = OrderedDict(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "BOM_SORTED_TO_CODEC",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "BOM_SORTED_TO_CODEC = OrderedDict(\n    # Sorted by length of BOM of each codec\n    (UNICODE_BOMS[codec], codec)\n    for codec in (\"utf-32le\", \"utf-32be\", \"utf-8\", \"utf-16le\", \"utf-16be\")\n)\nUTF_NAME_REGEX_COMPILED = re.compile(\n    \"utf[ -]?(8|16|32)[ -]?(le|be|)?(sig)?\", flags=re.IGNORECASE\n)\ndef _normalize_codec_name(codec: str) -> str:\n    \"\"\"Make sure the codec name is always given as defined in the BOM dict.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "UTF_NAME_REGEX_COMPILED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "peekOfCode": "UTF_NAME_REGEX_COMPILED = re.compile(\n    \"utf[ -]?(8|16|32)[ -]?(le|be|)?(sig)?\", flags=re.IGNORECASE\n)\ndef _normalize_codec_name(codec: str) -> str:\n    \"\"\"Make sure the codec name is always given as defined in the BOM dict.\"\"\"\n    return UTF_NAME_REGEX_COMPILED.sub(r\"utf-\\1\\2\", codec).lower()\ndef _remove_bom(encoded: bytes, encoding: str) -> bytes:\n    \"\"\"Remove the bom if given from a line.\"\"\"\n    if encoding not in UNICODE_BOMS:\n        return encoded",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unicode",
        "documentation": {}
    },
    {
        "label": "UnsupportedVersionChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "peekOfCode": "class UnsupportedVersionChecker(BaseChecker):\n    \"\"\"Checker for features that are not supported by all python versions\n    indicated by the py-version setting.\n    \"\"\"\n    name = \"unsupported_version\"\n    msgs = {\n        \"W2601\": (\n            \"F-strings are not supported by all versions included in the py-version setting\",\n            \"using-f-string-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.6 and pylint encounters \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "description": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(UnsupportedVersionChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.unsupported_version",
        "documentation": {}
    },
    {
        "label": "NoSuchArgumentError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "class NoSuchArgumentError(Exception):\n    pass\nclass InferredTypeError(Exception):\n    pass\ndef is_inside_lambda(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the given node is inside a lambda.\"\"\"\n    warnings.warn(\n        \"utils.is_inside_lambda will be removed in favour of calling \"\n        \"utils.get_node_first_ancestor_of_type(x, nodes.Lambda) in pylint 3.0\",\n        DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "InferredTypeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "class InferredTypeError(Exception):\n    pass\ndef is_inside_lambda(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the given node is inside a lambda.\"\"\"\n    warnings.warn(\n        \"utils.is_inside_lambda will be removed in favour of calling \"\n        \"utils.get_node_first_ancestor_of_type(x, nodes.Lambda) in pylint 3.0\",\n        DeprecationWarning,\n        stacklevel=2,\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "IncompleteFormatString",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "class IncompleteFormatString(Exception):\n    \"\"\"A format string ended in the middle of a format specifier.\"\"\"\nclass UnsupportedFormatCharacter(Exception):\n    \"\"\"A format character in a format string is not one of the supported\n    format characters.\n    \"\"\"\n    def __init__(self, index: int) -> None:\n        super().__init__(index)\n        self.index = index\ndef parse_format_string(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "UnsupportedFormatCharacter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "class UnsupportedFormatCharacter(Exception):\n    \"\"\"A format character in a format string is not one of the supported\n    format characters.\n    \"\"\"\n    def __init__(self, index: int) -> None:\n        super().__init__(index)\n        self.index = index\ndef parse_format_string(\n    format_string: str,\n) -> tuple[set[str], int, dict[str, str], list[str]]:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_inside_lambda",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_inside_lambda(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the given node is inside a lambda.\"\"\"\n    warnings.warn(\n        \"utils.is_inside_lambda will be removed in favour of calling \"\n        \"utils.get_node_first_ancestor_of_type(x, nodes.Lambda) in pylint 3.0\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return any(isinstance(parent, nodes.Lambda) for parent in node.node_ancestors())\ndef get_all_elements(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_all_elements",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_all_elements(\n    node: nodes.NodeNG,\n) -> Iterable[nodes.NodeNG]:\n    \"\"\"Recursively returns all atoms in nested lists and tuples.\"\"\"\n    if isinstance(node, (nodes.Tuple, nodes.List)):\n        for child in node.elts:\n            yield from get_all_elements(child)\n    else:\n        yield node\ndef is_super(node: nodes.NodeNG) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_super",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n    if getattr(node, \"name\", None) == \"super\" and node.root().name == \"builtins\":\n        return True\n    return False\ndef is_error(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return true if the given function node only raises an exception.\"\"\"\n    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)\nbuiltins = builtins.__dict__.copy()  # type: ignore[assignment]\nSPECIAL_BUILTINS = (\"__builtins__\",)  # '__path__', '__file__')",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_error",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_error(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return true if the given function node only raises an exception.\"\"\"\n    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)\nbuiltins = builtins.__dict__.copy()  # type: ignore[assignment]\nSPECIAL_BUILTINS = (\"__builtins__\",)  # '__path__', '__file__')\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\ndef is_builtin(name: str) -> bool:\n    \"\"\"Return true if <name> could be considered as a builtin defined by python.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_builtin_object",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\ndef is_builtin(name: str) -> bool:\n    \"\"\"Return true if <name> could be considered as a builtin defined by python.\"\"\"\n    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore[operator]\ndef is_defined_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,\n    scope: nodes.NodeNG,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_builtin",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_builtin(name: str) -> bool:\n    \"\"\"Return true if <name> could be considered as a builtin defined by python.\"\"\"\n    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore[operator]\ndef is_defined_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,\n    scope: nodes.NodeNG,\n) -> bool:\n    return defnode_in_scope(var_node, varname, scope) is not None\n# pylint: disable = too-many-branches",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_defined_in_scope",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_defined_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,\n    scope: nodes.NodeNG,\n) -> bool:\n    return defnode_in_scope(var_node, varname, scope) is not None\n# pylint: disable = too-many-branches\ndef defnode_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "defnode_in_scope",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def defnode_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,\n    scope: nodes.NodeNG,\n) -> nodes.NodeNG | None:\n    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_defined_before",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n    \"\"\"\n    varname = var_node.name\n    for parent in var_node.node_ancestors():",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_default_argument",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = None) -> bool:\n    \"\"\"Return true if the given Name node is used in function or lambda\n    default argument's value.\n    \"\"\"\n    if not scope:\n        scope = node.scope()\n    if isinstance(scope, (nodes.FunctionDef, nodes.Lambda)):\n        all_defaults = itertools.chain(\n            scope.args.defaults, (d for d in scope.args.kw_defaults if d is not None)\n        )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_func_decorator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_func_decorator(node: nodes.NodeNG) -> bool:\n    \"\"\"Return true if the name is used in function decorator.\"\"\"\n    for parent in node.node_ancestors():\n        if isinstance(parent, nodes.Decorators):\n            return True\n        if parent.is_statement or isinstance(\n            parent,\n            (\n                nodes.Lambda,\n                nodes.ComprehensionScope,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_ancestor_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether `frame` is an astroid.Class node with `node` in the\n    subtree of its bases attribute.\n    \"\"\"\n    if not isinstance(frame, nodes.ClassDef):\n        return False\n    return any(node in base.nodes_of_class(nodes.Name) for base in frame.bases)\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_being_called",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "assign_parent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n    which is not the base object class.\n    \"\"\"\n    for ancestor in class_node.ancestors():",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "overrides_a_method",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n    which is not the base object class.\n    \"\"\"\n    for ancestor in class_node.ancestors():\n        if ancestor.name == \"object\":\n            continue\n        if name in ancestor and isinstance(ancestor[name], nodes.FunctionDef):\n            return True\n    return False",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "only_required_for_messages",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "check_messages",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def check_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Kept for backwards compatibility, deprecated.\n    Use only_required_for_messages instead, which conveys the intent of the decorator much clearer.\n    \"\"\"\n    warnings.warn(\n        \"utils.check_messages will be removed in favour of calling \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "parse_format_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def parse_format_string(\n    format_string: str,\n) -> tuple[set[str], int, dict[str, str], list[str]]:\n    \"\"\"Parses a format string, returning a tuple (keys, num_args).\n    Where 'keys' is the set of mapping keys in the format string, and 'num_args' is the number\n    of arguments required by the format string. Raises IncompleteFormatString or\n    UnsupportedFormatCharacter if a parse error occurs.\n    \"\"\"\n    keys = set()\n    key_types = {}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "split_format_field_names",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def split_format_field_names(\n    format_string: str,\n) -> tuple[str, Iterable[tuple[bool, str]]]:\n    try:\n        return _string.formatter_field_name_split(format_string)  # type: ignore[no-any-return]\n    except ValueError as e:\n        raise IncompleteFormatString() from e\ndef collect_string_fields(format_string: str) -> Iterable[str | None]:\n    \"\"\"Given a format string, return an iterator\n    of all the valid format fields.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "collect_string_fields",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def collect_string_fields(format_string: str) -> Iterable[str | None]:\n    \"\"\"Given a format string, return an iterator\n    of all the valid format fields.\n    It handles nested fields as well.\n    \"\"\"\n    formatter = string.Formatter()\n    # pylint: disable = too-many-try-statements\n    try:\n        parseiterator = formatter.parse(format_string)\n        for result in parseiterator:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "parse_format_method_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def parse_format_method_string(\n    format_string: str,\n) -> tuple[list[tuple[str, list[tuple[bool, str]]]], int, int]:\n    \"\"\"Parses a PEP 3101 format string, returning a tuple of\n    (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args).\n    keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt\n    is the number of arguments required by the format string and\n    explicit_pos_args is the number of arguments passed with the position.\n    \"\"\"\n    keyword_arguments = []",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_attr_protected",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_attr_protected(attrname: str) -> bool:\n    \"\"\"Return True if attribute name is protected (start with _ and some other\n    details), False otherwise.\n    \"\"\"\n    return (\n        attrname[0] == \"_\"\n        and attrname != \"_\"\n        and not (attrname.startswith(\"__\") and attrname.endswith(\"__\"))\n    )\ndef node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_frame_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:\n    \"\"\"Return the class that is wrapping the given node.\n    The function returns a class for a method node (or a staticmethod or a\n    classmethod), otherwise it returns `None`.\n    \"\"\"\n    klass = node.frame(future=True)\n    nodes_to_check = (\n        nodes.NodeNG,\n        astroid.UnboundMethod,\n        astroid.BaseInstance,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_outer_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_outer_class(class_node: astroid.ClassDef) -> astroid.ClassDef | None:\n    \"\"\"Return the class that is the outer class of given (nested) class_node.\"\"\"\n    parent_klass = class_node.parent.frame(future=True)\n    return parent_klass if isinstance(parent_klass, astroid.ClassDef) else None\ndef is_attr_private(attrname: str) -> Match[str] | None:\n    \"\"\"Check that attribute name is private (at least two leading underscores,\n    at most one trailing underscore).\n    \"\"\"\n    regex = re.compile(\"^_{2,10}.*[^_]+_?$\")\n    return regex.match(attrname)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_attr_private",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_attr_private(attrname: str) -> Match[str] | None:\n    \"\"\"Check that attribute name is private (at least two leading underscores,\n    at most one trailing underscore).\n    \"\"\"\n    regex = re.compile(\"^_{2,10}.*[^_]+_?$\")\n    return regex.match(attrname)\ndef get_argument_from_call(\n    call_node: nodes.Call, position: int | None = None, keyword: str | None = None\n) -> nodes.Name:\n    \"\"\"Returns the specified argument from a function call.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_argument_from_call",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_argument_from_call(\n    call_node: nodes.Call, position: int | None = None, keyword: str | None = None\n) -> nodes.Name:\n    \"\"\"Returns the specified argument from a function call.\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "inherit_from_std_ex",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -> bool:\n    \"\"\"Return whether the given class node is subclass of\n    exceptions.Exception.\n    \"\"\"\n    ancestors = node.ancestors() if hasattr(node, \"ancestors\") else []\n    return any(\n        ancestor.name in {\"Exception\", \"BaseException\"}\n        and ancestor.root().name == EXCEPTIONS_MODULE\n        for ancestor in itertools.chain([node], ancestors)\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "error_of_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def error_of_type(\n    handler: nodes.ExceptHandler,\n    error_type: str | type[Exception] | tuple[str | type[Exception], ...],\n) -> bool:\n    \"\"\"Check if the given exception handler catches\n    the given error_type.\n    The *handler* parameter is a node, representing an ExceptHandler node.\n    The *error_type* can be an exception, such as AttributeError,\n    the name of an exception, or it can be a tuple of errors.\n    The function will return True if the handler catches any of the",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def decorated_with_property(node: nodes.FunctionDef) -> bool:\n    \"\"\"Detect if the given function node is decorated with a property.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator in node.decorators.nodes:\n        try:\n            if _is_property_decorator(decorator):\n                return True\n        except astroid.InferenceError:\n            pass",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_property_setter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property setter.\"\"\"\n    return _is_property_kind(node, \"setter\")\ndef is_property_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property deleter.\"\"\"\n    return _is_property_kind(node, \"deleter\")\ndef is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\ndef _is_property_decorator(decorator: nodes.Name) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_deleter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_property_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property deleter.\"\"\"\n    return _is_property_kind(node, \"deleter\")\ndef is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\ndef _is_property_decorator(decorator: nodes.Name) -> bool:\n    for inferred in decorator.infer():\n        if isinstance(inferred, nodes.ClassDef):\n            if inferred.qname() in {\"builtins.property\", \"functools.cached_property\"}:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_property_setter_or_deleter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\ndef _is_property_decorator(decorator: nodes.Name) -> bool:\n    for inferred in decorator.infer():\n        if isinstance(inferred, nodes.ClassDef):\n            if inferred.qname() in {\"builtins.property\", \"functools.cached_property\"}:\n                return True\n            for ancestor in inferred.ancestors():\n                if ancestor.name == \"property\" and ancestor.root().name == \"builtins\":",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "decorated_with",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def decorated_with(\n    func: (\n        nodes.ClassDef | nodes.FunctionDef | astroid.BoundMethod | astroid.UnboundMethod\n    ),\n    qnames: Iterable[str],\n) -> bool:\n    \"\"\"Determine if the `func` node has a decorator with the qualified name `qname`.\"\"\"\n    decorators = func.decorators.nodes if func.decorators else []\n    for decorator_node in decorators:\n        if isinstance(decorator_node, nodes.Call):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "uninferable_final_decorators",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def uninferable_final_decorators(\n    node: nodes.Decorators,\n) -> list[nodes.Attribute | nodes.Name | None]:\n    \"\"\"Return a list of uninferable `typing.final` decorators in `node`.\n    This function is used to determine if the `typing.final` decorator is used\n    with an unsupported Python version; the decorator cannot be inferred when\n    using a Python version lower than 3.8.\n    \"\"\"\n    decorators = []\n    for decorator in getattr(node, \"nodes\", []):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "unimplemented_abstract_methods",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def unimplemented_abstract_methods(\n    node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef = None\n) -> dict[str, nodes.FunctionDef]:\n    \"\"\"Get the unimplemented abstract methods for the given *node*.\n    A method can be considered abstract if the callback *is_abstract_cb*\n    returns a ``True`` value. The check defaults to verifying that\n    a method is decorated with abstract methods.\n    It will return a dictionary of abstract method\n    names and their inferred objects.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "find_try_except_wrapper_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.TryExcept | None:\n    \"\"\"Return the ExceptHandler or the TryExcept node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.TryExcept)\n    while current and not isinstance(current.parent, ignores):\n        current = current.parent\n    if current and isinstance(current.parent, ignores):\n        return current.parent",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "find_except_wrapper_node_in_scope",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def find_except_wrapper_node_in_scope(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.TryExcept | None:\n    \"\"\"Return the ExceptHandler in which the node is, without going out of scope.\"\"\"\n    for current in node.node_ancestors():\n        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):\n            # If we're inside a function/class definition, we don't want to keep checking\n            # higher ancestors for `except` clauses, because if these exist, it means our\n            # function/class was defined in an `except` clause, rather than the current code\n            # actually running in an `except` clause.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_from_fallback_block",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_from_fallback_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is from a fallback import block.\"\"\"\n    context = find_try_except_wrapper_node(node)\n    if not context:\n        return False\n    if isinstance(context, nodes.ExceptHandler):\n        other_body = context.parent.body\n        handlers = context.parent.handlers\n    else:\n        other_body = itertools.chain.from_iterable(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_exception_handlers",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_exception_handlers(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> list[nodes.ExceptHandler] | None:\n    \"\"\"Return the collections of handlers handling the exception in arguments.\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n    Returns:\n        list: the collection of handlers that are handling the exception or None.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_contextlib_with_statements",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_contextlib_with_statements(node: nodes.NodeNG) -> Iterator[nodes.With]:\n    \"\"\"Get all contextlib.with statements in the ancestors of the given node.\"\"\"\n    for with_node in node.node_ancestors():\n        if isinstance(with_node, nodes.With):\n            yield with_node\ndef _suppresses_exception(\n    call: nodes.Call, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the given node suppresses the given exception.\"\"\"\n    if not isinstance(exception, str):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_contextlib_suppressors",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_contextlib_suppressors(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> Iterator[nodes.With]:\n    \"\"\"Return the contextlib suppressors handling the exception.\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n    Yields:\n        nodes.With: A with node that is suppressing the exception.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_inside_try_except",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_node_inside_try_except(node: nodes.Raise) -> bool:\n    \"\"\"Check if the node is directly under a Try/Except statement\n    (but not under an ExceptHandler!).\n    Args:\n        node (nodes.Raise): the node raising the exception.\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n    \"\"\"\n    context = find_try_except_wrapper_node(node)\n    return isinstance(context, nodes.TryExcept)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_ignores_exception",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def node_ignores_exception(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the node is in a TryExcept which handles the given exception.\n    If the exception is not given, the function is going to look for bare\n    excepts.\n    \"\"\"\n    managing_handlers = get_exception_handlers(node, exception)\n    if managing_handlers:\n        return True",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "class_is_abstract",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def class_is_abstract(node: nodes.ClassDef) -> bool:\n    \"\"\"Return true if the given class node should be considered as an abstract\n    class.\n    \"\"\"\n    # Protocol classes are considered \"abstract\"\n    if is_protocol_class(node):\n        return True\n    # Only check for explicit metaclass=ABCMeta on this specific class\n    meta = node.declared_metaclass()\n    if meta is not None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_comprehension",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_comprehension(node: nodes.NodeNG) -> bool:\n    comprehensions = (\n        nodes.ListComp,\n        nodes.SetComp,\n        nodes.DictComp,\n        nodes.GeneratorExp,\n    )\n    return isinstance(node, comprehensions)\ndef _supports_mapping_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_inside_abstract_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_iterable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_iterable(value: nodes.NodeNG, check_async: bool = False) -> bool:\n    if check_async:\n        protocol_check = _supports_async_iteration_protocol\n    else:\n        protocol_check = _supports_iteration_protocol\n    return _supports_protocol(value, protocol_check)\ndef is_mapping(value: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_mapping_protocol)\ndef supports_membership_test(value: nodes.NodeNG) -> bool:\n    supported = _supports_protocol(value, _supports_membership_test_protocol)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_mapping",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_mapping(value: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_mapping_protocol)\ndef supports_membership_test(value: nodes.NodeNG) -> bool:\n    supported = _supports_protocol(value, _supports_membership_test_protocol)\n    return supported or is_iterable(value)\ndef supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_membership_test",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def supports_membership_test(value: nodes.NodeNG) -> bool:\n    supported = _supports_protocol(value, _supports_membership_test_protocol)\n    return supported or is_iterable(value)\ndef supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_getitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getitem_protocol)\ndef supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_setitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_setitem_protocol)\ndef supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_delitem_protocol)\ndef _get_python_type_of_node(node: nodes.NodeNG) -> str | None:\n    pytype: Callable[[], str] | None = getattr(node, \"pytype\", None)\n    if callable(pytype):\n        return pytype()\n    return None\n@lru_cache(maxsize=1024)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "supports_delitem",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_delitem_protocol)\ndef _get_python_type_of_node(node: nodes.NodeNG) -> str | None:\n    pytype: Callable[[], str] | None = getattr(node, \"pytype\", None)\n    if callable(pytype):\n        return pytype()\n    return None\n@lru_cache(maxsize=1024)\ndef safe_infer(\n    node: nodes.NodeNG,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "safe_infer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def safe_infer(\n    node: nodes.NodeNG,\n    context: InferenceContext | None = None,\n    *,\n    compare_constants: bool = False,\n) -> InferenceResult | None:\n    \"\"\"Return the inferred value for the given node.\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n    If compare_constants is True and if multiple constants are inferred,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "infer_all",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def infer_all(\n    node: nodes.NodeNG, context: InferenceContext | None = None\n) -> list[InferenceResult]:\n    try:\n        return list(node.infer(context=context))\n    except astroid.InferenceError:\n        return []\n    except Exception as e:  # pragma: no cover\n        raise AstroidError from e\ndef has_known_bases(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "has_known_bases",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def has_known_bases(\n    klass: nodes.ClassDef, context: InferenceContext | None = None\n) -> bool:\n    \"\"\"Return true if all base classes of a class could be inferred.\"\"\"\n    try:\n        return klass._all_bases_known  # type: ignore[no-any-return]\n    except AttributeError:\n        pass\n    for base in klass.bases:\n        result = safe_infer(base, context=context)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_none",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_none(node: nodes.NodeNG) -> bool:\n    return (\n        node is None\n        or (isinstance(node, nodes.Const) and node.value is None)\n        or (isinstance(node, nodes.Name) and node.name == \"None\")\n    )\ndef node_type(node: nodes.NodeNG) -> SuccessfulInferenceResult | None:\n    \"\"\"Return the inferred type for `node`.\n    If there is more than one possible type, or if inferred type is Uninferable or None,\n    return None",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "node_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def node_type(node: nodes.NodeNG) -> SuccessfulInferenceResult | None:\n    \"\"\"Return the inferred type for `node`.\n    If there is more than one possible type, or if inferred type is Uninferable or None,\n    return None\n    \"\"\"\n    # check there is only one possible type for the assign node. Else we\n    # don't handle it for now\n    types: set[SuccessfulInferenceResult] = set()\n    try:\n        for var_type in node.infer():",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_registered_in_singledispatch_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n    singledispatch_qnames = (\n        \"functools.singledispatch\",\n        \"singledispatch.singledispatch\",\n    )\n    if not isinstance(node, nodes.FunctionDef):\n        return False\n    decorators = node.decorators.nodes if node.decorators else []\n    for decorator in decorators:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "find_inferred_fn_from_register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def find_inferred_fn_from_register(node: nodes.NodeNG) -> nodes.FunctionDef | None:\n    # func.register are function calls or register attributes\n    # when the function is annotated with types\n    if isinstance(node, nodes.Call):\n        func = node.func\n    elif isinstance(node, nodes.Attribute):\n        func = node\n    else:\n        return None\n    if not isinstance(func, nodes.Attribute) or func.attrname != \"register\":",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_registered_in_singledispatchmethod_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatchmethod function.\"\"\"\n    singledispatchmethod_qnames = (\n        \"functools.singledispatchmethod\",\n        \"singledispatch.singledispatchmethod\",\n    )\n    decorators = node.decorators.nodes if node.decorators else []\n    for decorator in decorators:\n        func_def = find_inferred_fn_from_register(decorator)\n        if func_def:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_node_last_lineno",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_node_last_lineno(node: nodes.NodeNG) -> int:\n    \"\"\"Get the last lineno of the given node.\n    For a simple statement this will just be node.lineno,\n    but for a node that has child statements (e.g. a method) this will be the lineno of the last\n    child statement recursively.\n    \"\"\"\n    # 'finalbody' is always the last clause in a try statement, if present\n    if getattr(node, \"finalbody\", False):\n        return get_node_last_lineno(node.finalbody[-1])\n    # For if, while, and for statements 'orelse' is always the last clause.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_postponed_evaluation_enabled",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_postponed_evaluation_enabled(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the postponed evaluation of annotations is enabled.\"\"\"\n    module = node.root()\n    return \"annotations\" in module.future_imports\ndef is_class_subscriptable_pep585_with_postponed_evaluation_enabled(\n    value: nodes.ClassDef, node: nodes.NodeNG\n) -> bool:\n    \"\"\"Check if class is subscriptable with PEP 585 and\n    postponed evaluation enabled.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_class_subscriptable_pep585_with_postponed_evaluation_enabled",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_class_subscriptable_pep585_with_postponed_evaluation_enabled(\n    value: nodes.ClassDef, node: nodes.NodeNG\n) -> bool:\n    \"\"\"Check if class is subscriptable with PEP 585 and\n    postponed evaluation enabled.\n    \"\"\"\n    warnings.warn(\n        \"'is_class_subscriptable_pep585_with_postponed_evaluation_enabled' has been \"\n        \"deprecated and will be removed in pylint 3.0. \"\n        \"Use 'is_postponed_evaluation_enabled(node) and \"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_type_annotation_context",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_node_in_type_annotation_context(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if node is in type annotation context.\n    Check for 'AnnAssign', function 'Arguments',\n    or part of function return type annotation.\n    \"\"\"\n    # pylint: disable=too-many-boolean-expressions\n    current_node, parent_node = node, node.parent\n    while True:\n        if (\n            isinstance(parent_node, nodes.AnnAssign)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_subclass_of",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n        return False\n    for ancestor in child.ancestors():\n        try:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_overload_stub",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n    return bool(decorators and decorated_with(node, [\"typing.overload\", \"overload\"]))\ndef is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n    :param cls: The node to check",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_protocol_class",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n        return False\n    # Return if klass is protocol\n    if cls.qname() in TYPING_PROTOCOLS:\n        return True",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_call_of_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_call_of_name(node: nodes.NodeNG, name: str) -> bool:\n    \"\"\"Checks if node is a function call with the given name.\"\"\"\n    return (\n        isinstance(node, nodes.Call)\n        and isinstance(node.func, nodes.Name)\n        and node.func.name == name\n    )\ndef is_test_condition(\n    node: nodes.NodeNG,\n    parent: nodes.NodeNG | None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_test_condition",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_test_condition(\n    node: nodes.NodeNG,\n    parent: nodes.NodeNG | None = None,\n) -> bool:\n    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_classdef_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_classdef_type(node: nodes.ClassDef) -> bool:\n    \"\"\"Test if ClassDef node is Type.\"\"\"\n    if node.name == \"type\":\n        return True\n    return any(isinstance(b, nodes.Name) and b.name == \"type\" for b in node.bases)\ndef is_attribute_typed_annotation(\n    node: nodes.ClassDef | astroid.Instance, attr_name: str\n) -> bool:\n    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_attribute_typed_annotation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_attribute_typed_annotation(\n    node: nodes.ClassDef | astroid.Instance, attr_name: str\n) -> bool:\n    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n        attribute\n        and isinstance(attribute, nodes.AssignName)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_enum",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_enum(node: nodes.ClassDef) -> bool:\n    return node.name == \"Enum\" and node.root().name == \"enum\"  # type: ignore[no-any-return]\ndef is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:\n    \"\"\"Test if AssignName node has `typing_name` annotation.\n    Especially useful to check for `typing._SpecialForm` instances\n    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n    \"\"\"\n    if not isinstance(node.parent, nodes.AnnAssign):\n        return False\n    annotation = node.parent.annotation",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_assign_name_annotated_with",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:\n    \"\"\"Test if AssignName node has `typing_name` annotation.\n    Especially useful to check for `typing._SpecialForm` instances\n    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n    \"\"\"\n    if not isinstance(node.parent, nodes.AnnAssign):\n        return False\n    annotation = node.parent.annotation\n    if isinstance(annotation, nodes.Subscript):\n        annotation = annotation.value",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_iterating_dictionary_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_iterating_dictionary_name(node: nodes.For | nodes.Comprehension) -> str | None:\n    \"\"\"Get the name of the dictionary which keys are being iterated over on\n    a ``nodes.For`` or ``nodes.Comprehension`` node.\n    If the iterating object is not either the keys method of a dictionary\n    or a dictionary itself, this returns None.\n    \"\"\"\n    # Is it a proper keys call?\n    if (\n        isinstance(node.iter, nodes.Call)\n        and isinstance(node.iter.func, nodes.Attribute)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_subscript_const_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:\n    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n    if not isinstance(inferred, nodes.Const):\n        raise InferredTypeError(\"Subscript.slice cannot be inferred as a nodes.Const\")\n    return inferred",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_import_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_import_name(importnode: ImportNode, modname: str | None) -> str | None:\n    \"\"\"Get a prepared module name from the given import node.\n    In the case of relative imports, this will return the\n    absolute qualified module name, which might be useful\n    for debugging. Otherwise, the initial module name\n    is returned unchanged.\n    :param importnode: node representing import statement.\n    :param modname: module name from import statement.\n    :returns: absolute qualified module name of the module\n        used in import.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_sys_guard",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_sys_guard(node: nodes.If) -> bool:\n    \"\"\"Return True if IF stmt is a sys.version_info guard.\n    >>> import sys\n    >>> if sys.version_info > (3, 8):\n    >>>     from typing import Literal\n    >>> else:\n    >>>     from typing_extensions import Literal\n    \"\"\"\n    if isinstance(node.test, nodes.Compare):\n        value = node.test.left",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_typing_guard",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_typing_guard(node: nodes.If) -> bool:\n    \"\"\"Return True if IF stmt is a typing guard.\n    >>> from typing import TYPE_CHECKING\n    >>> if TYPE_CHECKING:\n    >>>     from xyz import a\n    \"\"\"\n    return isinstance(\n        node.test, (nodes.Name, nodes.Attribute)\n    ) and node.test.as_string().endswith(\"TYPE_CHECKING\")\ndef is_node_in_typing_guarded_import_block(node: nodes.NodeNG) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_typing_guarded_import_block",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_node_in_typing_guarded_import_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is part for guarded `typing.TYPE_CHECKING` if block.\"\"\"\n    return isinstance(node.parent, nodes.If) and is_typing_guard(node.parent)\ndef is_node_in_guarded_import_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is part for guarded if block.\n    I.e. `sys.version_info` or `typing.TYPE_CHECKING`\n    \"\"\"\n    return isinstance(node.parent, nodes.If) and (\n        is_sys_guard(node.parent) or is_typing_guard(node.parent)\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_node_in_guarded_import_block",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_node_in_guarded_import_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is part for guarded if block.\n    I.e. `sys.version_info` or `typing.TYPE_CHECKING`\n    \"\"\"\n    return isinstance(node.parent, nodes.If) and (\n        is_sys_guard(node.parent) or is_typing_guard(node.parent)\n    )\ndef is_reassigned_after_current(node: nodes.NodeNG, varname: str) -> bool:\n    \"\"\"Check if the given variable name is reassigned in the same scope after the\n    current node.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_reassigned_after_current",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_reassigned_after_current(node: nodes.NodeNG, varname: str) -> bool:\n    \"\"\"Check if the given variable name is reassigned in the same scope after the\n    current node.\n    \"\"\"\n    return any(\n        a.name == varname and a.lineno > node.lineno\n        for a in node.scope().nodes_of_class(\n            (nodes.AssignName, nodes.ClassDef, nodes.FunctionDef)\n        )\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_deleted_after_current",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_deleted_after_current(node: nodes.NodeNG, varname: str) -> bool:\n    \"\"\"Check if the given variable name is deleted in the same scope after the current\n    node.\n    \"\"\"\n    return any(\n        getattr(target, \"name\", None) == varname and target.lineno > node.lineno\n        for del_node in node.scope().nodes_of_class(nodes.Delete)\n        for target in del_node.targets\n    )\ndef is_function_body_ellipsis(node: nodes.FunctionDef) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_function_body_ellipsis",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_function_body_ellipsis(node: nodes.FunctionDef) -> bool:\n    \"\"\"Checks whether a function body only consists of a single Ellipsis.\"\"\"\n    return (\n        len(node.body) == 1\n        and isinstance(node.body[0], nodes.Expr)\n        and isinstance(node.body[0].value, nodes.Const)\n        and node.body[0].value.value == Ellipsis\n    )\ndef is_base_container(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.BaseContainer) and not node.elts",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_base_container",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_base_container(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.BaseContainer) and not node.elts\ndef is_empty_dict_literal(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.Dict) and not node.items\ndef is_empty_str_literal(node: nodes.NodeNG | None) -> bool:\n    return (\n        isinstance(node, nodes.Const) and isinstance(node.value, str) and not node.value\n    )\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_empty_dict_literal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_empty_dict_literal(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.Dict) and not node.items\ndef is_empty_str_literal(node: nodes.NodeNG | None) -> bool:\n    return (\n        isinstance(node, nodes.Const) and isinstance(node.value, str) and not node.value\n    )\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_empty_str_literal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_empty_str_literal(node: nodes.NodeNG | None) -> bool:\n    return (\n        isinstance(node, nodes.Const) and isinstance(node.value, str) and not node.value\n    )\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n        and isinstance(node.value.value, bool)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "returns_bool",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n        and isinstance(node.value.value, bool)\n    )\ndef assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "assigned_bool",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Assign)\n        and isinstance(node.value, nodes.Const)\n        and isinstance(node.value.value, bool)\n    )\ndef get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_node_first_ancestor_of_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:\n    \"\"\"Return the first parent node that is any of the provided types (or None).\"\"\"\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return ancestor  # type: ignore[no-any-return]\n    return None\ndef get_node_first_ancestor_of_type_and_its_child(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_node_first_ancestor_of_type_and_its_child",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_node_first_ancestor_of_type_and_its_child(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> tuple[None, None] | tuple[_NodeT, nodes.NodeNG]:\n    \"\"\"Modified version of get_node_first_ancestor_of_type to also return the\n    descendant visited directly before reaching the sought ancestor.\n    Useful for extracting whether a statement is guarded by a try, except, or finally\n    when searching for a TryFinally ancestor.\n    \"\"\"\n    child = node\n    for ancestor in node.node_ancestors():",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "in_type_checking_block",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def in_type_checking_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is guarded by a TYPE_CHECKING guard.\"\"\"\n    for ancestor in node.node_ancestors():\n        if not isinstance(ancestor, nodes.If):\n            continue\n        if isinstance(ancestor.test, nodes.Name):\n            if ancestor.test.name != \"TYPE_CHECKING\":\n                continue\n            maybe_import_from = ancestor.test.lookup(ancestor.test.name)[1][0]\n            if (",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_typing_member",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_typing_member(node: nodes.NodeNG, names_to_check: tuple[str, ...]) -> bool:\n    \"\"\"Check if `node` is a member of the `typing` module and has one of the names from\n    `names_to_check`.\n    \"\"\"\n    if isinstance(node, nodes.Name):\n        try:\n            import_from = node.lookup(node.name)[1][0]\n        except IndexError:\n            return False\n        if isinstance(import_from, nodes.ImportFrom):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "in_for_else_branch",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def in_for_else_branch(parent: nodes.NodeNG, stmt: nodes.Statement) -> bool:\n    \"\"\"Returns True if stmt is inside the else branch for a parent For stmt.\"\"\"\n    return isinstance(parent, nodes.For) and any(\n        else_stmt.parent_of(stmt) or else_stmt == stmt for else_stmt in parent.orelse\n    )\ndef find_assigned_names_recursive(\n    target: nodes.AssignName | nodes.BaseContainer,\n) -> Iterator[str]:\n    \"\"\"Yield the names of assignment targets, accounting for nested ones.\"\"\"\n    if isinstance(target, nodes.AssignName):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "find_assigned_names_recursive",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def find_assigned_names_recursive(\n    target: nodes.AssignName | nodes.BaseContainer,\n) -> Iterator[str]:\n    \"\"\"Yield the names of assignment targets, accounting for nested ones.\"\"\"\n    if isinstance(target, nodes.AssignName):\n        if target.name is not None:\n            yield target.name\n    elif isinstance(target, nodes.BaseContainer):\n        for elt in target.elts:\n            yield from find_assigned_names_recursive(elt)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "has_starred_node_recursive",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def has_starred_node_recursive(\n    node: nodes.For | nodes.Comprehension | nodes.Set,\n) -> Iterator[bool]:\n    \"\"\"Yield ``True`` if a Starred node is found recursively.\"\"\"\n    if isinstance(node, nodes.Starred):\n        yield True\n    elif isinstance(node, nodes.Set):\n        for elt in node.elts:\n            yield from has_starred_node_recursive(elt)\n    elif isinstance(node, (nodes.For, nodes.Comprehension)):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_hashable",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_hashable(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether any inferred value of `node` is hashable.\n    When finding ambiguity, return True.\n    \"\"\"\n    # pylint: disable = too-many-try-statements\n    try:\n        for inferred in node.infer():\n            if inferred is astroid.Uninferable or isinstance(inferred, nodes.ClassDef):\n                return True\n            if not hasattr(inferred, \"igetattr\"):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_augmented_assign",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_augmented_assign(node: nodes.Assign) -> tuple[bool, str]:\n    \"\"\"Determine if the node is assigning itself (with modifications) to itself.\n    For example: x = 1 + x\n    \"\"\"\n    if not isinstance(node.value, nodes.BinOp):\n        return False, \"\"\n    binop = node.value\n    target = node.targets[0]\n    if not isinstance(target, (nodes.AssignName, nodes.AssignAttr)):\n        return False, \"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_module_ignored",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_module_ignored(\n    module: nodes.Module,\n    ignored_modules: Iterable[str],\n) -> bool:\n    ignored_modules = set(ignored_modules)\n    module_name = module.name\n    module_qname = module.qname()\n    for ignore in ignored_modules:\n        # Try to match the module name / fully qualified name directly\n        if module_qname in ignored_modules or module_name in ignored_modules:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_singleton_const",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_singleton_const(node: nodes.NodeNG) -> bool:\n    return isinstance(node, nodes.Const) and any(\n        node.value is value for value in SINGLETON_VALUES\n    )\ndef is_terminating_func(node: nodes.Call) -> bool:\n    \"\"\"Detect call to exit(), quit(), os._exit(), or sys.exit().\"\"\"\n    if (\n        not isinstance(node.func, nodes.Attribute)\n        and not (isinstance(node.func, nodes.Name))\n        or isinstance(node.parent, nodes.Lambda)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_terminating_func",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_terminating_func(node: nodes.Call) -> bool:\n    \"\"\"Detect call to exit(), quit(), os._exit(), or sys.exit().\"\"\"\n    if (\n        not isinstance(node.func, nodes.Attribute)\n        and not (isinstance(node.func, nodes.Name))\n        or isinstance(node.parent, nodes.Lambda)\n    ):\n        return False\n    try:\n        for inferred in node.func.infer():",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_class_attr",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_class_attr(name: str, klass: nodes.ClassDef) -> bool:\n    try:\n        klass.getattr(name)\n        return True\n    except astroid.NotFoundError:\n        return False\ndef is_defined(name: str, node: nodes.NodeNG) -> bool:\n    \"\"\"Searches for a tree node that defines the given variable name.\"\"\"\n    is_defined_so_far = False\n    if isinstance(node, nodes.NamedExpr):",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "is_defined",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def is_defined(name: str, node: nodes.NodeNG) -> bool:\n    \"\"\"Searches for a tree node that defines the given variable name.\"\"\"\n    is_defined_so_far = False\n    if isinstance(node, nodes.NamedExpr):\n        is_defined_so_far = node.target.name == name\n    if isinstance(node, (nodes.Import, nodes.ImportFrom)):\n        is_defined_so_far = any(node_name[0] == name for node_name in node.names)\n    if isinstance(node, nodes.With):\n        is_defined_so_far = any(\n            isinstance(item[1], nodes.AssignName) and item[1].name == name",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "get_inverse_comparator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def get_inverse_comparator(op: str) -> str:\n    \"\"\"Returns the inverse comparator given a comparator.\n    E.g. when given \"==\", returns \"!=\"\n    :param str op: the comparator to look up.\n    :returns: The inverse of the comparator in string format\n    :raises KeyError: if input is not recognized as a comparator\n    \"\"\"\n    return {\n        \"==\": \"!=\",\n        \"!=\": \"==\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "not_condition_as_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "def not_condition_as_string(\n    test_node: nodes.Compare | nodes.Name | nodes.UnaryOp | nodes.BoolOp | nodes.BinOp,\n) -> str:\n    msg = f\"not {test_node.as_string()}\"\n    if isinstance(test_node, nodes.UnaryOp):\n        msg = test_node.operand.as_string()\n    elif isinstance(test_node, nodes.BoolOp):\n        msg = f\"not ({test_node.as_string()})\"\n    elif isinstance(test_node, nodes.Compare):\n        lhs = test_node.left",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "_NodeT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "_NodeT = TypeVar(\"_NodeT\", bound=nodes.NodeNG)\n_CheckerT = TypeVar(\"_CheckerT\", bound=\"BaseChecker\")\nAstCallbackMethod = Callable[[_CheckerT, _NodeT], None]\nCOMP_NODE_TYPES = (\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.DictComp,\n    nodes.GeneratorExp,\n)\nEXCEPTIONS_MODULE = \"builtins\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "_CheckerT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "_CheckerT = TypeVar(\"_CheckerT\", bound=\"BaseChecker\")\nAstCallbackMethod = Callable[[_CheckerT, _NodeT], None]\nCOMP_NODE_TYPES = (\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.DictComp,\n    nodes.GeneratorExp,\n)\nEXCEPTIONS_MODULE = \"builtins\"\nABC_MODULES = {\"abc\", \"_py_abc\"}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "AstCallbackMethod",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "AstCallbackMethod = Callable[[_CheckerT, _NodeT], None]\nCOMP_NODE_TYPES = (\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.DictComp,\n    nodes.GeneratorExp,\n)\nEXCEPTIONS_MODULE = \"builtins\"\nABC_MODULES = {\"abc\", \"_py_abc\"}\nABC_METHODS = {",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "COMP_NODE_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "COMP_NODE_TYPES = (\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.DictComp,\n    nodes.GeneratorExp,\n)\nEXCEPTIONS_MODULE = \"builtins\"\nABC_MODULES = {\"abc\", \"_py_abc\"}\nABC_METHODS = {\n    \"abc.abstractproperty\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "EXCEPTIONS_MODULE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "EXCEPTIONS_MODULE = \"builtins\"\nABC_MODULES = {\"abc\", \"_py_abc\"}\nABC_METHODS = {\n    \"abc.abstractproperty\",\n    \"abc.abstractmethod\",\n    \"abc.abstractclassmethod\",\n    \"abc.abstractstaticmethod\",\n}\nTYPING_PROTOCOLS = frozenset(\n    {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "ABC_MODULES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "ABC_MODULES = {\"abc\", \"_py_abc\"}\nABC_METHODS = {\n    \"abc.abstractproperty\",\n    \"abc.abstractmethod\",\n    \"abc.abstractclassmethod\",\n    \"abc.abstractstaticmethod\",\n}\nTYPING_PROTOCOLS = frozenset(\n    {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}\n)",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "ABC_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "ABC_METHODS = {\n    \"abc.abstractproperty\",\n    \"abc.abstractmethod\",\n    \"abc.abstractclassmethod\",\n    \"abc.abstractstaticmethod\",\n}\nTYPING_PROTOCOLS = frozenset(\n    {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}\n)\nCOMMUTATIVE_OPERATORS = frozenset({\"*\", \"+\", \"^\", \"&\", \"|\"})",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "TYPING_PROTOCOLS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "TYPING_PROTOCOLS = frozenset(\n    {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}\n)\nCOMMUTATIVE_OPERATORS = frozenset({\"*\", \"+\", \"^\", \"&\", \"|\"})\nITER_METHOD = \"__iter__\"\nAITER_METHOD = \"__aiter__\"\nNEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "COMMUTATIVE_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "COMMUTATIVE_OPERATORS = frozenset({\"*\", \"+\", \"^\", \"&\", \"|\"})\nITER_METHOD = \"__iter__\"\nAITER_METHOD = \"__aiter__\"\nNEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "ITER_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "ITER_METHOD = \"__iter__\"\nAITER_METHOD = \"__aiter__\"\nNEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "AITER_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "AITER_METHOD = \"__aiter__\"\nNEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "NEXT_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "NEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "GETITEM_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "GETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "CLASS_GETITEM_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "CLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#\n# * None: variable number of parameters",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SETITEM_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "SETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#\n# * None: variable number of parameters\n# * number: exactly that number of parameters",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "DELITEM_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "DELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#\n# * None: variable number of parameters\n# * number: exactly that number of parameters\n# * tuple: these are the odd ones. Basically it means that the function",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "CONTAINS_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "CONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#\n# * None: variable number of parameters\n# * number: exactly that number of parameters\n# * tuple: these are the odd ones. Basically it means that the function\n#          can work with any number of arguments from that tuple,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "KEYS_METHOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "KEYS_METHOD = \"keys\"\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set of special methods.\n# The following keys are used to denote the parameters restrictions:\n#\n# * None: variable number of parameters\n# * number: exactly that number of parameters\n# * tuple: these are the odd ones. Basically it means that the function\n#          can work with any number of arguments from that tuple,\n#          although it's best to implement it in order to accept",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "_SPECIAL_METHODS_PARAMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "_SPECIAL_METHODS_PARAMS = {\n    None: (\"__new__\", \"__init__\", \"__call__\", \"__init_subclass__\"),\n    0: (\n        \"__del__\",\n        \"__repr__\",\n        \"__str__\",\n        \"__bytes__\",\n        \"__hash__\",\n        \"__bool__\",\n        \"__dir__\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SPECIAL_METHODS_PARAMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "SPECIAL_METHODS_PARAMS = {\n    name: params\n    for params, methods in _SPECIAL_METHODS_PARAMS.items()\n    for name in methods\n}\nPYMETHODS = set(SPECIAL_METHODS_PARAMS)\nSUBSCRIPTABLE_CLASSES_PEP585 = frozenset(\n    (\n        \"builtins.tuple\",\n        \"builtins.list\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "PYMETHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "PYMETHODS = set(SPECIAL_METHODS_PARAMS)\nSUBSCRIPTABLE_CLASSES_PEP585 = frozenset(\n    (\n        \"builtins.tuple\",\n        \"builtins.list\",\n        \"builtins.dict\",\n        \"builtins.set\",\n        \"builtins.frozenset\",\n        \"builtins.type\",\n        \"collections.deque\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SUBSCRIPTABLE_CLASSES_PEP585",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(\n    (\n        \"builtins.tuple\",\n        \"builtins.list\",\n        \"builtins.dict\",\n        \"builtins.set\",\n        \"builtins.frozenset\",\n        \"builtins.type\",\n        \"collections.deque\",\n        \"collections.defaultdict\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SINGLETON_VALUES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "SINGLETON_VALUES = {True, False, None}\nTERMINATING_FUNCS_QNAMES = frozenset(\n    {\"_sitebuiltins.Quitter\", \"sys.exit\", \"posix._exit\", \"nt._exit\"}\n)\nclass NoSuchArgumentError(Exception):\n    pass\nclass InferredTypeError(Exception):\n    pass\ndef is_inside_lambda(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the given node is inside a lambda.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "TERMINATING_FUNCS_QNAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "TERMINATING_FUNCS_QNAMES = frozenset(\n    {\"_sitebuiltins.Quitter\", \"sys.exit\", \"posix._exit\", \"nt._exit\"}\n)\nclass NoSuchArgumentError(Exception):\n    pass\nclass InferredTypeError(Exception):\n    pass\ndef is_inside_lambda(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the given node is inside a lambda.\"\"\"\n    warnings.warn(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "builtins = builtins.__dict__.copy()  # type: ignore[assignment]\nSPECIAL_BUILTINS = (\"__builtins__\",)  # '__path__', '__file__')\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\ndef is_builtin(name: str) -> bool:\n    \"\"\"Return true if <name> could be considered as a builtin defined by python.\"\"\"\n    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore[operator]\ndef is_defined_in_scope(\n    var_node: nodes.NodeNG,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "SPECIAL_BUILTINS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "description": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "peekOfCode": "SPECIAL_BUILTINS = (\"__builtins__\",)  # '__path__', '__file__')\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\ndef is_builtin(name: str) -> bool:\n    \"\"\"Return true if <name> could be considered as a builtin defined by python.\"\"\"\n    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore[operator]\ndef is_defined_in_scope(\n    var_node: nodes.NodeNG,\n    varname: str,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.utils",
        "documentation": {}
    },
    {
        "label": "VariableVisitConsumerAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "class VariableVisitConsumerAction(Enum):\n    \"\"\"Reported by _check_consumer() and its sub-methods to determine the\n    subsequent action to take in _undefined_and_used_before_checker().\n    Continue -> continue loop to next consumer\n    Return -> return and thereby break the loop\n    \"\"\"\n    CONTINUE = 0\n    RETURN = 1\ndef _is_from_future_import(stmt: nodes.ImportFrom, name: str) -> bool | None:\n    \"\"\"Check if the name is a future import from another module.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "ScopeConsumer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "class ScopeConsumer(NamedTuple):\n    \"\"\"Store nodes and their consumption states.\"\"\"\n    to_consume: dict[str, list[nodes.NodeNG]]\n    consumed: dict[str, list[nodes.NodeNG]]\n    consumed_uncertain: defaultdict[str, list[nodes.NodeNG]]\n    scope_type: str\nclass NamesConsumer:\n    \"\"\"A simple class to handle consumed, to consume and scope type info of node locals.\"\"\"\n    def __init__(self, node: nodes.NodeNG, scope_type: str) -> None:\n        self._atomic = ScopeConsumer(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "NamesConsumer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "class NamesConsumer:\n    \"\"\"A simple class to handle consumed, to consume and scope type info of node locals.\"\"\"\n    def __init__(self, node: nodes.NodeNG, scope_type: str) -> None:\n        self._atomic = ScopeConsumer(\n            copy.copy(node.locals), {}, collections.defaultdict(list), scope_type\n        )\n        self.node = node\n        self._if_nodes_deemed_uncertain: set[nodes.If] = set()\n    def __repr__(self) -> str:\n        _to_consumes = [f\"{k}->{v}\" for k, v in self._atomic.to_consume.items()]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "VariablesChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "class VariablesChecker(BaseChecker):\n    \"\"\"BaseChecker for variables.\n    Checks for\n    * unused variables / imports\n    * undefined variables\n    * redefinition of variable from builtins or from an outer scope or except handler\n    * use of variable before assignment\n    * __all__ consistency\n    * self/cls assignment\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "overridden_method",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "def overridden_method(\n    klass: nodes.LocalsDictNodeNG, name: str | None\n) -> nodes.FunctionDef | None:\n    \"\"\"Get overridden method if any.\"\"\"\n    try:\n        parent = next(klass.local_attr_ancestors(name))\n    except (StopIteration, KeyError):\n        return None\n    try:\n        meth_node = parent[name]",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(VariablesChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "SPECIAL_OBJ",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "SPECIAL_OBJ = re.compile(\"^_{2}[a-z]+_{2}$\")\nFUTURE = \"__future__\"\n# regexp for ignored argument name\nIGNORED_ARGUMENT_NAMES = re.compile(\"_.*|^ignored_|^unused_\")\n# In Python 3.7 abc has a Python implementation which is preferred\n# by astroid. Unfortunately this also messes up our explicit checks\n# for `abc`\nMETACLASS_NAME_TRANSFORMS = {\"_py_abc\": \"abc\"}\nBUILTIN_RANGE = \"builtins.range\"\nTYPING_MODULE = \"typing\"",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "FUTURE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "FUTURE = \"__future__\"\n# regexp for ignored argument name\nIGNORED_ARGUMENT_NAMES = re.compile(\"_.*|^ignored_|^unused_\")\n# In Python 3.7 abc has a Python implementation which is preferred\n# by astroid. Unfortunately this also messes up our explicit checks\n# for `abc`\nMETACLASS_NAME_TRANSFORMS = {\"_py_abc\": \"abc\"}\nBUILTIN_RANGE = \"builtins.range\"\nTYPING_MODULE = \"typing\"\nTYPING_NAMES = frozenset(",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "IGNORED_ARGUMENT_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "IGNORED_ARGUMENT_NAMES = re.compile(\"_.*|^ignored_|^unused_\")\n# In Python 3.7 abc has a Python implementation which is preferred\n# by astroid. Unfortunately this also messes up our explicit checks\n# for `abc`\nMETACLASS_NAME_TRANSFORMS = {\"_py_abc\": \"abc\"}\nBUILTIN_RANGE = \"builtins.range\"\nTYPING_MODULE = \"typing\"\nTYPING_NAMES = frozenset(\n    {\n        \"Any\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "METACLASS_NAME_TRANSFORMS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "METACLASS_NAME_TRANSFORMS = {\"_py_abc\": \"abc\"}\nBUILTIN_RANGE = \"builtins.range\"\nTYPING_MODULE = \"typing\"\nTYPING_NAMES = frozenset(\n    {\n        \"Any\",\n        \"Callable\",\n        \"ClassVar\",\n        \"Generic\",\n        \"Optional\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "BUILTIN_RANGE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "BUILTIN_RANGE = \"builtins.range\"\nTYPING_MODULE = \"typing\"\nTYPING_NAMES = frozenset(\n    {\n        \"Any\",\n        \"Callable\",\n        \"ClassVar\",\n        \"Generic\",\n        \"Optional\",\n        \"Tuple\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "TYPING_MODULE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "TYPING_MODULE = \"typing\"\nTYPING_NAMES = frozenset(\n    {\n        \"Any\",\n        \"Callable\",\n        \"ClassVar\",\n        \"Generic\",\n        \"Optional\",\n        \"Tuple\",\n        \"Type\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "TYPING_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "TYPING_NAMES = frozenset(\n    {\n        \"Any\",\n        \"Callable\",\n        \"ClassVar\",\n        \"Generic\",\n        \"Optional\",\n        \"Tuple\",\n        \"Type\",\n        \"TypeVar\",",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "DICT_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "DICT_TYPES = (\n    astroid.objects.DictValues,\n    astroid.objects.DictKeys,\n    astroid.objects.DictItems,\n    astroid.nodes.node_classes.Dict,\n)\nNODES_WITH_VALUE_ATTR = (\n    nodes.Assign,\n    nodes.AnnAssign,\n    nodes.AugAssign,",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "NODES_WITH_VALUE_ATTR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "description": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "peekOfCode": "NODES_WITH_VALUE_ATTR = (\n    nodes.Assign,\n    nodes.AnnAssign,\n    nodes.AugAssign,\n    nodes.Expr,\n    nodes.Return,\n    nodes.Match,\n)\nclass VariableVisitConsumerAction(Enum):\n    \"\"\"Reported by _check_consumer() and its sub-methods to determine the",
        "detail": "__pypackages__.3.10.lib.pylint.checkers.variables",
        "documentation": {}
    },
    {
        "label": "generate_interactive_config",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "peekOfCode": "def generate_interactive_config(linter: PyLinter) -> None:\n    print(\"Starting interactive pylint configuration generation\")\n    format_type = utils.get_and_validate_format()\n    minimal = format_type == \"toml\" and utils.get_minimal_setting()\n    to_file, output_file_name = utils.get_and_validate_output_file()\n    if format_type == \"toml\":\n        config_string = linter._generate_config_file(minimal=minimal)\n    else:\n        output_stream = StringIO()\n        with warnings.catch_warnings():",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "documentation": {}
    },
    {
        "label": "handle_generate_command",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "peekOfCode": "def handle_generate_command(linter: PyLinter) -> int:\n    \"\"\"Handle 'pylint-config generate'.\"\"\"\n    # Interactively generate a pylint configuration\n    if linter.config.interactive:\n        generate_interactive_config(linter)\n        return 0\n    print(get_subparser_help(linter, \"generate\"))\n    return 32",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.generate_command",
        "documentation": {}
    },
    {
        "label": "get_subparser_help",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "peekOfCode": "def get_subparser_help(linter: PyLinter, command: str) -> str:\n    \"\"\"Get the help message for one of the subcommands.\"\"\"\n    # Make sure subparsers are initialized properly\n    assert linter._arg_parser._subparsers\n    subparser_action = linter._arg_parser._subparsers._group_actions[0]\n    assert isinstance(subparser_action, argparse._SubParsersAction)\n    for name, subparser in subparser_action.choices.items():\n        assert isinstance(subparser, argparse.ArgumentParser)\n        if name == command:\n            # Remove last character which is an extra new line",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "documentation": {}
    },
    {
        "label": "get_help",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "peekOfCode": "def get_help(parser: argparse.ArgumentParser) -> str:\n    \"\"\"Get the help message for the main 'pylint-config' command.\n    Taken from argparse.ArgumentParser.format_help.\n    \"\"\"\n    formatter = parser._get_formatter()\n    # usage\n    formatter.add_usage(\n        parser.usage, parser._actions, parser._mutually_exclusive_groups\n    )\n    # description",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.help_message",
        "documentation": {}
    },
    {
        "label": "_HelpAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.setup",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.setup",
        "peekOfCode": "class _HelpAction(_AccessParserAction):\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--help\",\n    ) -> None:\n        get_help(self.parser)\ndef _register_generate_config_options(parser: argparse.ArgumentParser) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.setup",
        "documentation": {}
    },
    {
        "label": "InvalidUserInput",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "class InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)\ndef should_retry_after_invalid_input(\n    func: Callable[_P, _ReturnValueT]\n) -> Callable[_P, _ReturnValueT]:\n    \"\"\"Decorator that handles InvalidUserInput exceptions and retries.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "should_retry_after_invalid_input",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "def should_retry_after_invalid_input(\n    func: Callable[_P, _ReturnValueT]\n) -> Callable[_P, _ReturnValueT]:\n    \"\"\"Decorator that handles InvalidUserInput exceptions and retries.\"\"\"\n    def inner_function(*args: _P.args, **kwargs: _P.kwargs) -> _ReturnValueT:\n        called_once = False\n        while True:\n            try:\n                return func(*args, **kwargs)\n            except InvalidUserInput as exc:",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "get_and_validate_format",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "def get_and_validate_format() -> Literal[\"toml\", \"ini\"]:\n    \"\"\"Make sure that the output format is either .toml or .ini.\"\"\"\n    # pylint: disable-next=bad-builtin\n    format_type = input(\n        \"Please choose the format of configuration, (T)oml or (I)ni (.cfg): \"\n    ).lower()\n    if format_type not in SUPPORTED_FORMATS:\n        raise InvalidUserInput(\", \".join(sorted(SUPPORTED_FORMATS)), format_type)\n    if format_type.startswith(\"t\"):\n        return \"toml\"",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "validate_yes_no",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "def validate_yes_no(question: str, default: Literal[\"yes\", \"no\"] | None) -> bool:\n    \"\"\"Validate that a yes or no answer is correct.\"\"\"\n    question = f\"{question} (y)es or (n)o \"\n    if default:\n        question += f\" (default={default}) \"\n    # pylint: disable-next=bad-builtin\n    answer = input(question).lower()\n    if not answer and default:\n        answer = default\n    if answer not in YES_NO_ANSWERS:",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "get_minimal_setting",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "def get_minimal_setting() -> bool:\n    \"\"\"Ask the user if they want to use the minimal setting.\"\"\"\n    return validate_yes_no(\n        \"Do you want a minimal configuration without comments or default values?\", \"no\"\n    )\ndef get_and_validate_output_file() -> tuple[bool, Path]:\n    \"\"\"Make sure that the output file is correct.\"\"\"\n    to_file = validate_yes_no(\"Do you want to write the output to a file?\", \"no\")\n    if not to_file:\n        return False, Path()",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "get_and_validate_output_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "def get_and_validate_output_file() -> tuple[bool, Path]:\n    \"\"\"Make sure that the output file is correct.\"\"\"\n    to_file = validate_yes_no(\"Do you want to write the output to a file?\", \"no\")\n    if not to_file:\n        return False, Path()\n    # pylint: disable-next=bad-builtin\n    file_name = Path(input(\"What should the file be called: \"))\n    if file_name.exists():\n        overwrite = validate_yes_no(\n            f\"{file_name} already exists. Are you sure you want to overwrite?\", \"no\"",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "_P",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "_P = ParamSpec(\"_P\")\n_ReturnValueT = TypeVar(\"_ReturnValueT\", bool, str)\nSUPPORTED_FORMATS = {\"t\", \"toml\", \"i\", \"ini\"}\nYES_NO_ANSWERS = {\"y\", \"yes\", \"n\", \"no\"}\nclass InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "_ReturnValueT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "_ReturnValueT = TypeVar(\"_ReturnValueT\", bool, str)\nSUPPORTED_FORMATS = {\"t\", \"toml\", \"i\", \"ini\"}\nYES_NO_ANSWERS = {\"y\", \"yes\", \"n\", \"no\"}\nclass InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)\ndef should_retry_after_invalid_input(",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "SUPPORTED_FORMATS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "SUPPORTED_FORMATS = {\"t\", \"toml\", \"i\", \"ini\"}\nYES_NO_ANSWERS = {\"y\", \"yes\", \"n\", \"no\"}\nclass InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)\ndef should_retry_after_invalid_input(\n    func: Callable[_P, _ReturnValueT]",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "YES_NO_ANSWERS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "peekOfCode": "YES_NO_ANSWERS = {\"y\", \"yes\", \"n\", \"no\"}\nclass InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)\ndef should_retry_after_invalid_input(\n    func: Callable[_P, _ReturnValueT]\n) -> Callable[_P, _ReturnValueT]:",
        "detail": "__pypackages__.3.10.lib.pylint.config._pylint_config.utils",
        "documentation": {}
    },
    {
        "label": "_Argument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _Argument:\n    \"\"\"Class representing an argument to be parsed by an argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_BaseStoreArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _BaseStoreArgument(_Argument):\n    \"\"\"Base class for store arguments to be parsed by an argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _StoreArgument(_BaseStoreArgument):\n    \"\"\"Class representing a store argument to be parsed by an argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreTrueArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _StoreTrueArgument(_BaseStoreArgument):\n    \"\"\"Class representing a 'store_true' argument to be parsed by an\n    argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    # pylint: disable-next=useless-parent-delegation # We narrow down the type of action\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_DeprecationArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _DeprecationArgument(_Argument):\n    \"\"\"Store arguments while also handling deprecation warnings for old and new names.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_ExtendArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _ExtendArgument(_DeprecationArgument):\n    \"\"\"Class for extend arguments to be parsed by an argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreOldNamesArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _StoreOldNamesArgument(_DeprecationArgument):\n    \"\"\"Store arguments while also handling old names.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_StoreNewNamesArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _StoreNewNamesArgument(_DeprecationArgument):\n    \"\"\"Store arguments while also emitting deprecation warnings.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,\n        flags: list[str],",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_CallableArgument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "class _CallableArgument(_Argument):\n    \"\"\"Class representing an callable argument to be parsed by an\n    argparse.ArgumentsParser.\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n    def __init__(\n        self,\n        *,",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_ArgumentTypes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "_ArgumentTypes = Union[\n    str,\n    int,\n    float,\n    bool,\n    Pattern[str],\n    Sequence[str],\n    Sequence[Pattern[str]],\n    Tuple[int, ...],\n]",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "YES_VALUES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "YES_VALUES = {\"y\", \"yes\", \"true\"}\nNO_VALUES = {\"n\", \"no\", \"false\"}\ndef _yn_transformer(value: str) -> bool:\n    \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n    value = value.lower()\n    if value in YES_VALUES:\n        return True\n    if value in NO_VALUES:\n        return False\n    raise argparse.ArgumentTypeError(",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "NO_VALUES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.argument",
        "description": "__pypackages__.3.10.lib.pylint.config.argument",
        "peekOfCode": "NO_VALUES = {\"n\", \"no\", \"false\"}\ndef _yn_transformer(value: str) -> bool:\n    \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n    value = value.lower()\n    if value in YES_VALUES:\n        return True\n    if value in NO_VALUES:\n        return False\n    raise argparse.ArgumentTypeError(\n        None, f\"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}\"",
        "detail": "__pypackages__.3.10.lib.pylint.config.argument",
        "documentation": {}
    },
    {
        "label": "_ArgumentsManager",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "description": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "peekOfCode": "class _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n        This is necessary for the per-directory configuration support. Whenever we",
        "detail": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "documentation": {}
    },
    {
        "label": "ConfigProvider",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "description": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "peekOfCode": "ConfigProvider = Union[\"_ArgumentsProvider\", OptionsProviderMixIn]\n# pylint: disable-next=too-many-instance-attributes\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n        self._base_config = self._config",
        "detail": "__pypackages__.3.10.lib.pylint.config.arguments_manager",
        "documentation": {}
    },
    {
        "label": "UnsupportedAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "description": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "peekOfCode": "class UnsupportedAction(Exception):\n    \"\"\"Raised by set_option when it doesn't know what to do for an action.\"\"\"\n    def __init__(self, *args: object) -> None:\n        # TODO: 3.0: Remove deprecated exception\n        warnings.warn(\n            \"UnsupportedAction has been deprecated and will be removed in pylint 3.0\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args)",
        "detail": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "documentation": {}
    },
    {
        "label": "_ArgumentsProvider",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "description": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "peekOfCode": "class _ArgumentsProvider:\n    \"\"\"Base class for classes that provide arguments.\"\"\"\n    name: str\n    \"\"\"Name of the provider.\"\"\"\n    options: Options = ()\n    \"\"\"Options provided by this provider.\"\"\"\n    option_groups_descs: dict[str, str] = {}\n    \"\"\"Option groups of this provider and their descriptions.\"\"\"\n    def __init__(self, arguments_manager: _ArgumentsManager) -> None:\n        self._arguments_manager = arguments_manager",
        "detail": "__pypackages__.3.10.lib.pylint.config.arguments_provider",
        "documentation": {}
    },
    {
        "label": "_CallbackAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _CallbackAction(argparse.Action):\n    \"\"\"Custom callback action.\"\"\"\n    @abc.abstractmethod\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = None,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_DoNothingAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _DoNothingAction(_CallbackAction):\n    \"\"\"Action that just passes.\n    This action is used to allow pre-processing of certain options\n    without erroring when they are then processed again by argparse.\n    \"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ExtendAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ExtendAction(argparse._AppendAction):\n    \"\"\"Action that adds the value to a pre-existing list.\n    It is directly copied from the stdlib implementation which is only available\n    on 3.8+.\n    \"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_AccessRunObjectAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _AccessRunObjectAction(_CallbackAction):\n    \"\"\"Action that has access to the Run object.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_MessageHelpAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _MessageHelpAction(_CallbackAction):\n    \"\"\"Display the help message of a message.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListMessagesAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ListMessagesAction(_AccessRunObjectAction):\n    \"\"\"Display all available messages.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--list-enabled\",\n    ) -> None:\n        self.run.linter.msgs_store.list_messages()",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListMessagesEnabledAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ListMessagesEnabledAction(_AccessRunObjectAction):\n    \"\"\"Display all enabled messages.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--list-msgs-enabled\",\n    ) -> None:\n        self.run.linter.list_messages_enabled()",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListCheckGroupsAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ListCheckGroupsAction(_AccessRunObjectAction):\n    \"\"\"Display all the check groups that pylint knows about.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--list-groups\",\n    ) -> None:\n        for check in self.run.linter.get_checker_names():",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListConfidenceLevelsAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ListConfidenceLevelsAction(_AccessRunObjectAction):\n    \"\"\"Display all the confidence levels that pylint knows about.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--list-conf-levels\",\n    ) -> None:\n        for level in interfaces.CONFIDENCE_LEVELS:",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ListExtensionsAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ListExtensionsAction(_AccessRunObjectAction):\n    \"\"\"Display all extensions under pylint.extensions.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--list-extensions\",\n    ) -> None:\n        for filename in Path(extensions.__file__).parent.iterdir():",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_FullDocumentationAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _FullDocumentationAction(_AccessRunObjectAction):\n    \"\"\"Display the full documentation.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--full-documentation\",\n    ) -> None:\n        utils.print_full_documentation(self.run.linter)",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_GenerateRCFileAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _GenerateRCFileAction(_AccessRunObjectAction):\n    \"\"\"Generate a pylintrc file.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--generate-rcfile\",\n    ) -> None:\n        # TODO: 2.x: Deprecate this after the auto-upgrade functionality of",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_GenerateConfigFileAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _GenerateConfigFileAction(_AccessRunObjectAction):\n    \"\"\"Generate a .toml format configuration file.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--generate-toml-config\",\n    ) -> None:\n        print(self.run.linter._generate_config_file())",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ErrorsOnlyModeAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _ErrorsOnlyModeAction(_AccessRunObjectAction):\n    \"\"\"Turn on errors-only mode.\n    Error mode:\n        * disable all but error messages\n        * disable the 'miscellaneous' checker which can be safely deactivated in\n          debug\n        * disable reports\n        * do not save execution information\n    \"\"\"\n    def __call__(",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_LongHelpAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _LongHelpAction(_AccessRunObjectAction):\n    \"\"\"Display the long help message.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--long-help\",\n    ) -> None:\n        formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter()  # type: ignore[assignment]",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_AccessLinterObjectAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _AccessLinterObjectAction(_CallbackAction):\n    \"\"\"Action that has access to the Linter object.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_XableAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _XableAction(_AccessLinterObjectAction):\n    \"\"\"Callback action for enabling or disabling a message.\"\"\"\n    def _call(\n        self,\n        xabling_function: Callable[[str], None],\n        values: str | Sequence[Any] | None,\n        option_string: str | None,\n    ) -> None:\n        assert isinstance(values, (tuple, list))\n        for msgid in utils._check_csv(values[0]):",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_DisableAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _DisableAction(_XableAction):\n    \"\"\"Callback action for disabling a message.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--disable\",\n    ) -> None:\n        self._call(self.linter.disable, values, option_string)",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_EnableAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _EnableAction(_XableAction):\n    \"\"\"Callback action for enabling a message.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--enable\",\n    ) -> None:\n        self._call(self.linter.enable, values, option_string)",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_OutputFormatAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _OutputFormatAction(_AccessLinterObjectAction):\n    \"\"\"Callback action for setting the output format.\"\"\"\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--enable\",\n    ) -> None:\n        assert isinstance(values, (tuple, list))",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_AccessParserAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "peekOfCode": "class _AccessParserAction(_CallbackAction):\n    \"\"\"Action that has access to the ArgumentParser object.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.callback_actions",
        "documentation": {}
    },
    {
        "label": "_ConfigurationFileParser",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.config_file_parser",
        "description": "__pypackages__.3.10.lib.pylint.config.config_file_parser",
        "peekOfCode": "class _ConfigurationFileParser:\n    \"\"\"Class to parse various formats of configuration files.\"\"\"\n    def __init__(self, verbose: bool, linter: PyLinter) -> None:\n        self.verbose_mode = verbose\n        self.linter = linter\n    def _parse_ini_file(self, file_path: Path) -> tuple[dict[str, str], list[str]]:\n        \"\"\"Parse and handle errors of a ini configuration file.\"\"\"\n        parser = configparser.ConfigParser(inline_comment_prefixes=(\"#\", \";\"))\n        # Use this encoding in order to strip the BOM marker, if any.\n        with open(file_path, encoding=\"utf_8_sig\") as fp:",
        "detail": "__pypackages__.3.10.lib.pylint.config.config_file_parser",
        "documentation": {}
    },
    {
        "label": "ConfigurationMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.configuration_mixin",
        "description": "__pypackages__.3.10.lib.pylint.config.configuration_mixin",
        "peekOfCode": "class ConfigurationMixIn(OptionsManagerMixIn, OptionsProviderMixIn):  # type: ignore[misc]\n    \"\"\"Basic mixin for simple configurations which don't need the\n    manager / providers model.\n    \"\"\"\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        # TODO: 3.0: Remove deprecated class\n        warnings.warn(\n            \"ConfigurationMixIn has been deprecated and will be removed in pylint 3.0\",\n            DeprecationWarning,\n            stacklevel=2,",
        "detail": "__pypackages__.3.10.lib.pylint.config.configuration_mixin",
        "documentation": {}
    },
    {
        "label": "_OldNamesAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "peekOfCode": "class _OldNamesAction(argparse._StoreAction):\n    \"\"\"Store action that also sets the value to old names.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "documentation": {}
    },
    {
        "label": "_NewNamesAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "description": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "peekOfCode": "class _NewNamesAction(argparse._StoreAction):\n    \"\"\"Store action that also emits a deprecation warning about a new name.\"\"\"\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.config.deprecation_actions",
        "documentation": {}
    },
    {
        "label": "UnrecognizedArgumentAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "peekOfCode": "class UnrecognizedArgumentAction(Exception):\n    \"\"\"Raised if an ArgumentManager instance tries to add an argument for which the\n    action is not recognized.\n    \"\"\"\nclass _UnrecognizedOptionError(Exception):\n    \"\"\"Raised if an ArgumentManager instance tries to parse an option that is\n    unknown.\n    \"\"\"\n    def __init__(self, options: list[str], *args: object) -> None:\n        self.options = options",
        "detail": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "_UnrecognizedOptionError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "peekOfCode": "class _UnrecognizedOptionError(Exception):\n    \"\"\"Raised if an ArgumentManager instance tries to parse an option that is\n    unknown.\n    \"\"\"\n    def __init__(self, options: list[str], *args: object) -> None:\n        self.options = options\n        super().__init__(*args)\nclass ArgumentPreprocessingError(Exception):\n    \"\"\"Raised if an error occurs during argument pre-processing.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "ArgumentPreprocessingError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "peekOfCode": "class ArgumentPreprocessingError(Exception):\n    \"\"\"Raised if an error occurs during argument pre-processing.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.config.exceptions",
        "documentation": {}
    },
    {
        "label": "find_default_config_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "description": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "peekOfCode": "def find_default_config_files() -> Iterator[Path]:\n    \"\"\"Find all possible config files.\"\"\"\n    yield from _yield_default_files()\n    try:\n        yield from _find_project_config()\n    except OSError:\n        pass\n    try:\n        yield from _find_config_in_home_or_environment()\n    except OSError:",
        "detail": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "documentation": {}
    },
    {
        "label": "find_pylintrc",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "description": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "peekOfCode": "def find_pylintrc() -> str | None:\n    \"\"\"Search the pylint rc file and return its path if it finds it, else return\n    None.\n    \"\"\"\n    # TODO: 3.0: Remove deprecated function\n    warnings.warn(\n        \"find_pylintrc and the PYLINTRC constant have been deprecated. \"\n        \"Use find_default_config_files if you want access to pylint's configuration file \"\n        \"finding logic.\",\n        DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "documentation": {}
    },
    {
        "label": "RC_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "description": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "peekOfCode": "RC_NAMES = (Path(\"pylintrc\"), Path(\".pylintrc\"))\nCONFIG_NAMES = RC_NAMES + (Path(\"pyproject.toml\"), Path(\"setup.cfg\"))\ndef _toml_has_config(path: Path | str) -> bool:\n    with open(path, mode=\"rb\") as toml_handle:\n        try:\n            content = tomllib.load(toml_handle)\n        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])",
        "detail": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "documentation": {}
    },
    {
        "label": "CONFIG_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "description": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "peekOfCode": "CONFIG_NAMES = RC_NAMES + (Path(\"pyproject.toml\"), Path(\"setup.cfg\"))\ndef _toml_has_config(path: Path | str) -> bool:\n    with open(path, mode=\"rb\") as toml_handle:\n        try:\n            content = tomllib.load(toml_handle)\n        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])\ndef _cfg_has_config(path: Path | str) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.config.find_default_config_files",
        "documentation": {}
    },
    {
        "label": "_HelpFormatter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.help_formatter",
        "description": "__pypackages__.3.10.lib.pylint.config.help_formatter",
        "peekOfCode": "class _HelpFormatter(argparse.RawDescriptionHelpFormatter):\n    \"\"\"Formatter for the help message emitted by argparse.\"\"\"\n    def _get_help_string(self, action: argparse.Action) -> str | None:\n        \"\"\"Copied from argparse.ArgumentDefaultsHelpFormatter.\"\"\"\n        assert action.help\n        help_string = action.help\n        # CallbackActions don't have a default\n        if isinstance(action, _CallbackAction):\n            return help_string\n        if \"%(default)\" not in help_string:",
        "detail": "__pypackages__.3.10.lib.pylint.config.help_formatter",
        "documentation": {}
    },
    {
        "label": "Option",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.option",
        "description": "__pypackages__.3.10.lib.pylint.config.option",
        "peekOfCode": "class Option(optparse.Option):\n    TYPES = optparse.Option.TYPES + (\n        \"regexp\",\n        \"regexp_csv\",\n        \"regexp_paths_csv\",\n        \"csv\",\n        \"yn\",\n        \"confidence\",\n        \"multiple_choice\",\n        \"non_empty_string\",",
        "detail": "__pypackages__.3.10.lib.pylint.config.option",
        "documentation": {}
    },
    {
        "label": "OptionsManagerMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.option_manager_mixin",
        "description": "__pypackages__.3.10.lib.pylint.config.option_manager_mixin",
        "peekOfCode": "class OptionsManagerMixIn:\n    \"\"\"Handle configuration from both a configuration file and command line options.\"\"\"\n    def __init__(self, usage: str) -> None:\n        # TODO: 3.0: Remove deprecated class\n        warnings.warn(\n            \"OptionsManagerMixIn has been deprecated and will be removed in pylint 3.0\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.reset_parsers(usage)",
        "detail": "__pypackages__.3.10.lib.pylint.config.option_manager_mixin",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.option_parser",
        "description": "__pypackages__.3.10.lib.pylint.config.option_parser",
        "peekOfCode": "class OptionParser(optparse.OptionParser):\n    def __init__(self, option_class, *args, **kwargs):\n        # TODO: 3.0: Remove deprecated class\n        warnings.warn(\n            \"OptionParser has been deprecated and will be removed in pylint 3.0\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(option_class=Option, *args, **kwargs)\n    def format_option_help(self, formatter=None):",
        "detail": "__pypackages__.3.10.lib.pylint.config.option_parser",
        "documentation": {}
    },
    {
        "label": "UnsupportedAction",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "description": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "peekOfCode": "class UnsupportedAction(Exception):\n    \"\"\"Raised by set_option when it doesn't know what to do for an action.\"\"\"\nclass OptionsProviderMixIn:\n    \"\"\"Mixin to provide options to an OptionsManager.\"\"\"\n    # those attributes should be overridden\n    name = \"default\"\n    options: Options = ()\n    level = 0\n    def __init__(self):\n        # TODO: 3.0: Remove deprecated class",
        "detail": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "documentation": {}
    },
    {
        "label": "OptionsProviderMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "description": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "peekOfCode": "class OptionsProviderMixIn:\n    \"\"\"Mixin to provide options to an OptionsManager.\"\"\"\n    # those attributes should be overridden\n    name = \"default\"\n    options: Options = ()\n    level = 0\n    def __init__(self):\n        # TODO: 3.0: Remove deprecated class\n        warnings.warn(\n            \"OptionsProviderMixIn has been deprecated and will be removed in pylint 3.0\",",
        "detail": "__pypackages__.3.10.lib.pylint.config.options_provider_mixin",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.config.utils",
        "description": "__pypackages__.3.10.lib.pylint.config.utils",
        "peekOfCode": "] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    # pylint: disable=useless-suppression, wrong-spelling-in-comment\n    # Argparse by default allows abbreviations. It behaves differently\n    # if you turn this off, so we also turn it on. We mimic this\n    # by allowing some abbreviations or incorrect spelling here.\n    # The integer at the end of the tuple indicates how many letters\n    # should match, include the '-'. 0 indicates a full match.\n    #\n    # Clashes with --init-(import)\n    \"--init-hook\": (True, _init_hook, 8),",
        "detail": "__pypackages__.3.10.lib.pylint.config.utils",
        "documentation": {}
    },
    {
        "label": "Docstring",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "class Docstring:\n    re_for_parameters_see = re.compile(\n        r\"\"\"\n        For\\s+the\\s+(other)?\\s*parameters\\s*,\\s+see\n        \"\"\",\n        re.X | re.S,\n    )\n    supports_yields: bool = False\n    \"\"\"True if the docstring supports a \"yield\" section.\n    False if the docstring uses the returns section to document generators.",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "SphinxDocstring",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "class SphinxDocstring(Docstring):\n    re_type = r\"\"\"\n        [~!.]?               # Optional link style prefix\n        \\w(?:\\w|\\.[^\\.])*    # Valid python name\n        \"\"\"\n    re_simple_container_type = rf\"\"\"\n        {re_type}                     # a container type\n        [\\(\\[] [^\\n\\s]+ [\\)\\]]        # with the contents of the container\n    \"\"\"\n    re_multiple_simple_type = r\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "EpytextDocstring",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "class EpytextDocstring(SphinxDocstring):\n    \"\"\"Epytext is similar to Sphinx.\n    See the docs:\n        http://epydoc.sourceforge.net/epytext.html\n        http://epydoc.sourceforge.net/fields.html#fields\n    It's used in PyCharm:\n        https://www.jetbrains.com/help/pycharm/2016.1/creating-documentation-comments.html#d848203e314\n        https://www.jetbrains.com/help/pycharm/2016.1/using-docstrings-to-specify-types.html\n    \"\"\"\n    re_param_in_docstring = re.compile(",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "GoogleDocstring",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "class GoogleDocstring(Docstring):\n    re_type = SphinxDocstring.re_type\n    re_xref = SphinxDocstring.re_xref\n    re_container_type = rf\"\"\"\n        (?:{re_type}|{re_xref})       # a container type\n        [\\(\\[] [^\\n]+ [\\)\\]]          # with the contents of the container\n    \"\"\"\n    re_multiple_type = r\"\"\"\n        (?:{container_type}|{type}|{xref})\n        (?:(?:\\s+(?:of|or)\\s+|\\s*,\\s*|\\s+\\|\\s+)(?:{container_type}|{type}|{xref}))*",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "NumpyDocstring",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "class NumpyDocstring(GoogleDocstring):\n    _re_section_template = r\"\"\"\n        ^([ ]*)   {0}   \\s*?$          # Numpy parameters header\n        \\s*     [-=]+   \\s*?$          # underline\n        (  .* )                        # section\n    \"\"\"\n    re_param_section = re.compile(\n        _re_section_template.format(r\"(?:Args|Arguments|Parameters)\"),\n        re.X | re.S | re.M,\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "space_indentation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def space_indentation(s: str) -> int:\n    \"\"\"The number of leading spaces in a string.\n    :param str s: input string\n    :rtype: int\n    :return: number of leading spaces\n    \"\"\"\n    return len(s) - len(s.lstrip(\" \"))\ndef get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n    :param node: The node to get the property name for.",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "get_setters_property_name",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n    :param node: The node to get the property name for.\n    :type node: str\n    :rtype: str or None\n    :returns: The name of the property that the node is a setter for,\n        or None if one could not be found.\n    \"\"\"\n    decorators = node.decorators.nodes if node.decorators else []\n    for decorator in decorators:",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "get_setters_property",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n    :rtype: nodes.FunctionDef or None\n    :returns: The node relating to the property of the given setter node,\n        or None if one could not be found.\n    \"\"\"\n    property_ = None\n    property_name = get_setters_property_name(node)",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "returns_something",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n    :rtype: bool\n    :return: True if the return node returns a value other than None,\n        False otherwise.\n    \"\"\"\n    returns = return_node.value\n    if returns is None:",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "possible_exc_types",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def possible_exc_types(node: nodes.NodeNG) -> set[nodes.ClassDef]:\n    \"\"\"Gets all the possible raised exception types for the given raise node.\n    .. note::\n        Caught exception types are ignored.\n    :param node: The raise node to find exception types for.\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n    exceptions = []\n    if isinstance(node.exc, nodes.Name):\n        inferred = utils.safe_infer(node.exc)",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "docstringify",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "def docstringify(\n    docstring: nodes.Const | None, default_type: str = \"default\"\n) -> Docstring:\n    best_match = (0, DOCSTRING_TYPES.get(default_type, Docstring)(docstring))\n    for docstring_type in (\n        SphinxDocstring,\n        EpytextDocstring,\n        GoogleDocstring,\n        NumpyDocstring,\n    ):",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "DOCSTRING_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "description": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "peekOfCode": "DOCSTRING_TYPES = {\n    \"sphinx\": SphinxDocstring,\n    \"epytext\": EpytextDocstring,\n    \"google\": GoogleDocstring,\n    \"numpy\": NumpyDocstring,\n    \"default\": Docstring,\n}\n\"\"\"A map of the name of the docstring type to its class.\n:type: dict(str, type)\n\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions._check_docs_utils",
        "documentation": {}
    },
    {
        "label": "BadBuiltinChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "description": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "peekOfCode": "class BadBuiltinChecker(BaseChecker):\n    name = \"deprecated_builtins\"\n    msgs = {\n        \"W0141\": (\n            \"Used builtin function %s\",\n            \"bad-builtin\",\n            \"Used when a disallowed builtin function is used (see the \"\n            \"bad-function option). Usual disallowed functions are the ones \"\n            \"like map, or filter , where Python offers now some cleaner \"\n            \"alternative like list comprehension.\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "description": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(BadBuiltinChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "documentation": {}
    },
    {
        "label": "BAD_FUNCTIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "description": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "peekOfCode": "BAD_FUNCTIONS = [\"map\", \"filter\"]\n# Some hints regarding the use of bad builtins.\nLIST_COMP_MSG = \"Using a list comprehension can be clearer.\"\nBUILTIN_HINTS = {\"map\": LIST_COMP_MSG, \"filter\": LIST_COMP_MSG}\nclass BadBuiltinChecker(BaseChecker):\n    name = \"deprecated_builtins\"\n    msgs = {\n        \"W0141\": (\n            \"Used builtin function %s\",\n            \"bad-builtin\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "documentation": {}
    },
    {
        "label": "LIST_COMP_MSG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "description": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "peekOfCode": "LIST_COMP_MSG = \"Using a list comprehension can be clearer.\"\nBUILTIN_HINTS = {\"map\": LIST_COMP_MSG, \"filter\": LIST_COMP_MSG}\nclass BadBuiltinChecker(BaseChecker):\n    name = \"deprecated_builtins\"\n    msgs = {\n        \"W0141\": (\n            \"Used builtin function %s\",\n            \"bad-builtin\",\n            \"Used when a disallowed builtin function is used (see the \"\n            \"bad-function option). Usual disallowed functions are the ones \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "documentation": {}
    },
    {
        "label": "BUILTIN_HINTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "description": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "peekOfCode": "BUILTIN_HINTS = {\"map\": LIST_COMP_MSG, \"filter\": LIST_COMP_MSG}\nclass BadBuiltinChecker(BaseChecker):\n    name = \"deprecated_builtins\"\n    msgs = {\n        \"W0141\": (\n            \"Used builtin function %s\",\n            \"bad-builtin\",\n            \"Used when a disallowed builtin function is used (see the \"\n            \"bad-function option). Usual disallowed functions are the ones \"\n            \"like map, or filter , where Python offers now some cleaner \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.bad_builtin",
        "documentation": {}
    },
    {
        "label": "BroadTryClauseChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "description": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "peekOfCode": "class BroadTryClauseChecker(checkers.BaseChecker):\n    \"\"\"Checks for try clauses with too many lines.\n    According to PEP 8, ``try`` clauses shall contain the absolute minimum\n    amount of code. This checker enforces a maximum number of statements within\n    ``try`` clauses.\n    \"\"\"\n    # configuration section name\n    name = \"broad_try_clause\"\n    msgs = {\n        \"W0717\": (",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "description": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(BroadTryClauseChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.broad_try_clause",
        "documentation": {}
    },
    {
        "label": "ElseifUsedChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "description": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "peekOfCode": "class ElseifUsedChecker(BaseTokenChecker):\n    \"\"\"Checks for use of \"else if\" when an \"elif\" could be used.\"\"\"\n    name = \"else_if_used\"\n    msgs = {\n        \"R5501\": (\n            'Consider using \"elif\" instead of \"else\" then \"if\" to remove one indentation level',\n            \"else-if-used\",\n            \"Used when an else statement is immediately followed by \"\n            \"an if statement and does not contain statements that \"\n            \"would be unrelated to it.\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "description": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ElseifUsedChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.check_elif",
        "documentation": {}
    },
    {
        "label": "CodeStyleChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "description": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "peekOfCode": "class CodeStyleChecker(BaseChecker):\n    \"\"\"Checkers that can improve code consistency.\n    As such they don't necessarily provide a performance benefit and\n    are often times opinionated.\n    Before adding another checker here, consider this:\n    1. Does the checker provide a clear benefit,\n       i.e. detect a common issue or improve performance\n       => it should probably be part of the core checker classes\n    2. Is it something that would improve code consistency,\n       maybe because it's slightly better with regard to performance",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "description": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(CodeStyleChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.code_style",
        "documentation": {}
    },
    {
        "label": "CompareToZeroChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "peekOfCode": "class CompareToZeroChecker(checkers.BaseChecker):\n    \"\"\"Checks for comparisons to zero.\n    Most of the time you should use the fact that integers with a value of 0 are false.\n    An exception to this rule is when 0 is allowed in the program and has a\n    different meaning than None!\n    \"\"\"\n    # configuration section name\n    name = \"compare-to-zero\"\n    msgs = {\n        \"C2001\": (",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(CompareToZeroChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparetozero",
        "documentation": {}
    },
    {
        "label": "MisplacedComparisonConstantChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "peekOfCode": "class MisplacedComparisonConstantChecker(BaseChecker):\n    \"\"\"Checks the placement of constants in comparisons.\"\"\"\n    # configuration section name\n    name = \"comparison-placement\"\n    msgs = {\n        \"C2201\": (\n            \"Comparison should be %s\",\n            \"misplaced-comparison-constant\",\n            \"Used when the constant is placed on the left side \"\n            \"of a comparison. It is usually clearer in intent to \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(MisplacedComparisonConstantChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "documentation": {}
    },
    {
        "label": "REVERSED_COMPS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "peekOfCode": "REVERSED_COMPS = {\"<\": \">\", \"<=\": \">=\", \">\": \"<\", \">=\": \"<=\"}\nCOMPARISON_OPERATORS = frozenset((\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"))\nclass MisplacedComparisonConstantChecker(BaseChecker):\n    \"\"\"Checks the placement of constants in comparisons.\"\"\"\n    # configuration section name\n    name = \"comparison-placement\"\n    msgs = {\n        \"C2201\": (\n            \"Comparison should be %s\",\n            \"misplaced-comparison-constant\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "documentation": {}
    },
    {
        "label": "COMPARISON_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "description": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "peekOfCode": "COMPARISON_OPERATORS = frozenset((\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"))\nclass MisplacedComparisonConstantChecker(BaseChecker):\n    \"\"\"Checks the placement of constants in comparisons.\"\"\"\n    # configuration section name\n    name = \"comparison-placement\"\n    msgs = {\n        \"C2201\": (\n            \"Comparison should be %s\",\n            \"misplaced-comparison-constant\",\n            \"Used when the constant is placed on the left side \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.comparison_placement",
        "documentation": {}
    },
    {
        "label": "ConfusingConsecutiveElifChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "description": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "peekOfCode": "class ConfusingConsecutiveElifChecker(BaseChecker):\n    \"\"\"Checks if \"elif\" is used right after an indented block that finishes with \"if\" or\n    \"elif\" itself.\n    \"\"\"\n    name = \"confusing_elif\"\n    msgs = {\n        \"R5601\": (\n            \"Consecutive elif with differing indentation level, consider creating a function to separate the inner elif\",\n            \"confusing-consecutive-elif\",\n            \"Used when an elif statement follows right after an indented block which itself ends with if or elif. \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "description": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ConfusingConsecutiveElifChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.confusing_elif",
        "documentation": {}
    },
    {
        "label": "ConsiderRefactorIntoWhileConditionChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "description": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "peekOfCode": "class ConsiderRefactorIntoWhileConditionChecker(checkers.BaseChecker):\n    \"\"\"Checks for instances where while loops are implemented with a constant condition\n    which.\n    always evaluates to truthy and the first statement(s) is/are if statements which, when\n    evaluated.\n    to True, breaks out of the loop.\n    The if statement(s) can be refactored into the while loop.\n    \"\"\"\n    name = \"consider_refactoring_into_while\"\n    msgs = {",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "description": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ConsiderRefactorIntoWhileConditionChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.consider_refactoring_into_while_condition",
        "documentation": {}
    },
    {
        "label": "ConsiderTernaryExpressionChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "description": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "peekOfCode": "class ConsiderTernaryExpressionChecker(BaseChecker):\n    name = \"consider_ternary_expression\"\n    msgs = {\n        \"W0160\": (\n            \"Consider rewriting as a ternary expression\",\n            \"consider-ternary-expression\",\n            \"Multiple assign statements spread across if/else blocks can be \"\n            \"rewritten with a single assignment and ternary expression\",\n        )\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "description": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ConsiderTernaryExpressionChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.consider_ternary_expression",
        "documentation": {}
    },
    {
        "label": "DictInitMutateChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "description": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "peekOfCode": "class DictInitMutateChecker(BaseChecker):\n    name = \"dict-init-mutate\"\n    msgs = {\n        \"C3401\": (\n            \"Declare all known key/values when initializing the dictionary.\",\n            \"dict-init-mutate\",\n            \"Dictionaries can be initialized with a single statement \"\n            \"using dictionary literal syntax.\",\n        )\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "description": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DictInitMutateChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.dict_init_mutate",
        "documentation": {}
    },
    {
        "label": "DocstringParameterChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "description": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "peekOfCode": "class DocstringParameterChecker(BaseChecker):\n    \"\"\"Checker for Sphinx, Google, or Numpy style docstrings.\n    * Check that all function, method and constructor parameters are mentioned\n      in the params and types part of the docstring.  Constructor parameters\n      can be documented in either the class docstring or ``__init__`` docstring,\n      but not both.\n    * Check that there are no naming inconsistencies between the signature and\n      the documentation, i.e. also report documented parameters that are missing\n      in the signature. This is important to find cases where parameters are\n      renamed only in the code, not in the documentation.",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "description": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DocstringParameterChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.docparams",
        "documentation": {}
    },
    {
        "label": "DocStringStyleChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "description": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "peekOfCode": "class DocStringStyleChecker(checkers.BaseChecker):\n    \"\"\"Checks format of docstrings based on PEP 0257.\"\"\"\n    name = \"docstyle\"\n    msgs = {\n        \"C0198\": (\n            'Bad docstring quotes in %s, expected \"\"\", given %s',\n            \"bad-docstring-quotes\",\n            \"Used when a docstring does not have triple double quotes.\",\n        ),\n        \"C0199\": (",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "description": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DocStringStyleChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.docstyle",
        "documentation": {}
    },
    {
        "label": "DunderChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "description": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "peekOfCode": "class DunderChecker(BaseChecker):\n    \"\"\"Checks related to dunder methods.\"\"\"\n    name = \"dunder\"\n    priority = -1\n    msgs = {\n        \"W3201\": (\n            \"Bad or misspelled dunder method name %s.\",\n            \"bad-dunder-name\",\n            \"Used when a dunder method is misspelled or defined with a name \"\n            \"not within the predefined list of dunder names.\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "description": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DunderChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.dunder",
        "documentation": {}
    },
    {
        "label": "CommentChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "description": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "peekOfCode": "class CommentChecker(BaseRawFileChecker):\n    name = \"empty-comment\"\n    msgs = {\n        \"R2044\": (\n            \"Line with empty comment\",\n            \"empty-comment\",\n            (\n                \"Used when a # symbol appears on a line not followed by an actual comment\"\n            ),\n        )",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "documentation": {}
    },
    {
        "label": "is_line_commented",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "description": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "peekOfCode": "def is_line_commented(line: bytes) -> bool:\n    \"\"\"Checks if a `# symbol that is not part of a string was found in line.\"\"\"\n    comment_idx = line.find(b\"#\")\n    if comment_idx == -1:\n        return False\n    if comment_part_of_string(line, comment_idx):\n        return is_line_commented(line[:comment_idx] + line[comment_idx + 1 :])\n    return True\ndef comment_part_of_string(line: bytes, comment_idx: int) -> bool:\n    \"\"\"Checks if the symbol at comment_idx is part of a string.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "documentation": {}
    },
    {
        "label": "comment_part_of_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "description": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "peekOfCode": "def comment_part_of_string(line: bytes, comment_idx: int) -> bool:\n    \"\"\"Checks if the symbol at comment_idx is part of a string.\"\"\"\n    if (\n        line[:comment_idx].count(b\"'\") % 2 == 1\n        and line[comment_idx:].count(b\"'\") % 2 == 1\n    ) or (\n        line[:comment_idx].count(b'\"') % 2 == 1\n        and line[comment_idx:].count(b'\"') % 2 == 1\n    ):\n        return True",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "description": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(CommentChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.empty_comment",
        "documentation": {}
    },
    {
        "label": "CompareToEmptyStringChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "description": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "peekOfCode": "class CompareToEmptyStringChecker(checkers.BaseChecker):\n    name = \"compare-to-empty-string\"\n    msgs = {\n        \"C1901\": (\n            '\"%s\" can be simplified to \"%s\" as an empty string is falsey',\n            \"compare-to-empty-string\",\n            \"Used when Pylint detects comparison to an empty string constant.\",\n        )\n    }\n    options = ()",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "description": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(CompareToEmptyStringChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.emptystring",
        "documentation": {}
    },
    {
        "label": "EqWithoutHash",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "description": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "peekOfCode": "class EqWithoutHash(checkers.BaseChecker):\n    name = \"eq-without-hash\"\n    msgs = {\n        \"W1641\": (\n            \"Implementing __eq__ without also implementing __hash__\",\n            \"eq-without-hash\",\n            \"Used when a class implements __eq__ but not __hash__. Objects get \"\n            \"None as their default __hash__ implementation if they also implement __eq__.\",\n        ),\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "description": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(EqWithoutHash(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.eq_without_hash",
        "documentation": {}
    },
    {
        "label": "ConsiderUsingAnyOrAllChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "description": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "peekOfCode": "class ConsiderUsingAnyOrAllChecker(BaseChecker):\n    name = \"consider-using-any-or-all\"\n    msgs = {\n        \"C0501\": (\n            \"`for` loop could be `%s`\",\n            \"consider-using-any-or-all\",\n            \"A for loop that checks for a condition and return a bool can be replaced with any or all.\",\n        )\n    }\n    @only_required_for_messages(\"consider-using-any-or-all\")",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "description": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(ConsiderUsingAnyOrAllChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.for_any_all",
        "documentation": {}
    },
    {
        "label": "MagicValueChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "description": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "peekOfCode": "class MagicValueChecker(BaseChecker):\n    \"\"\"Checks for constants in comparisons.\"\"\"\n    name = \"magic-value\"\n    msgs = {\n        \"R2004\": (\n            \"Consider using a named constant or an enum instead of '%s'.\",\n            \"magic-value-comparison\",\n            \"Using named constants instead of magic values helps improve readability and maintainability of your\"\n            \" code, try to avoid them in comparisons.\",\n        )",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "description": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(MagicValueChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.magic_value",
        "documentation": {}
    },
    {
        "label": "PathGraph",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "class PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()\n        self._bottom_counter = 0\n        self.graph: PathGraph | None = None\n    def default(self, node: nodes.NodeNG, *args: Any) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "PathGraphingAstVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "class PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()\n        self._bottom_counter = 0\n        self.graph: PathGraph | None = None\n    def default(self, node: nodes.NodeNG, *args: Any) -> None:\n        for child in node.get_children():\n            self.dispatch(child, *args)\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "McCabeMethodChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "class McCabeMethodChecker(checkers.BaseChecker):\n    \"\"\"Checks McCabe complexity cyclomatic threshold in methods and functions\n    to validate a too complex code.\n    \"\"\"\n    name = \"design\"\n    msgs = {\n        \"R1260\": (\n            \"%s is too complex. The McCabe rating is %d\",\n            \"too-complex\",\n            \"Used when a method or function is too complex based on \"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(McCabeMethodChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "_StatementNodes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "_StatementNodes = Union[\n    nodes.Assert,\n    nodes.Assign,\n    nodes.AugAssign,\n    nodes.Delete,\n    nodes.Raise,\n    nodes.Yield,\n    nodes.Import,\n    nodes.Call,\n    nodes.Subscript,",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "_SubGraphNodes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "_SubGraphNodes = Union[nodes.If, nodes.TryExcept, nodes.For, nodes.While]\n_AppendableNodeT = TypeVar(\n    \"_AppendableNodeT\", bound=Union[_StatementNodes, nodes.While, nodes.FunctionDef]\n)\nclass PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "_AppendableNodeT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "description": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "peekOfCode": "_AppendableNodeT = TypeVar(\n    \"_AppendableNodeT\", bound=Union[_StatementNodes, nodes.While, nodes.FunctionDef]\n)\nclass PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.mccabe",
        "documentation": {}
    },
    {
        "label": "NoSelfUseChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "description": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "peekOfCode": "class NoSelfUseChecker(BaseChecker):\n    name = \"no_self_use\"\n    msgs = {\n        \"R6301\": (\n            \"Method could be a function\",\n            \"no-self-use\",\n            \"Used when a method doesn't use its bound instance, and so could \"\n            \"be written as a function.\",\n            {\"old_names\": [(\"R0201\", \"old-no-self-use\")]},\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "description": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(NoSelfUseChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.no_self_use",
        "documentation": {}
    },
    {
        "label": "OverlappingExceptionsChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "description": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "peekOfCode": "class OverlappingExceptionsChecker(checkers.BaseChecker):\n    \"\"\"Checks for two or more exceptions in the same exception handler\n    clause that are identical or parts of the same inheritance hierarchy.\n    (i.e. overlapping).\n    \"\"\"\n    name = \"overlap-except\"\n    msgs = {\n        \"W0714\": (\n            \"Overlapping exceptions (%s)\",\n            \"overlapping-except\",",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "description": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(OverlappingExceptionsChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.overlapping_exceptions",
        "documentation": {}
    },
    {
        "label": "PrivateImportChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "description": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "peekOfCode": "class PrivateImportChecker(BaseChecker):\n    name = \"import-private-name\"\n    msgs = {\n        \"C2701\": (\n            \"Imported private %s (%s)\",\n            \"import-private-name\",\n            \"Used when a private module or object prefixed with _ is imported. \"\n            \"PEP8 guidance on Naming Conventions states that public attributes with \"\n            \"leading underscores should be considered private.\",\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "description": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(PrivateImportChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.private_import",
        "documentation": {}
    },
    {
        "label": "RedefinedLoopNameChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "description": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "peekOfCode": "class RedefinedLoopNameChecker(checkers.BaseChecker):\n    name = \"redefined-loop-name\"\n    msgs = {\n        \"W2901\": (\n            \"Redefining %r from loop (line %s)\",\n            \"redefined-loop-name\",\n            \"Used when a loop variable is overwritten in the loop body.\",\n        ),\n    }\n    def __init__(self, linter: PyLinter) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "description": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(RedefinedLoopNameChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.redefined_loop_name",
        "documentation": {}
    },
    {
        "label": "MultipleTypesChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "description": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "peekOfCode": "class MultipleTypesChecker(BaseChecker):\n    \"\"\"Checks for variable type redefinition (NoneType excepted).\n    At a function, method, class or module scope\n    This rule could be improved:\n    - Currently, if an attribute is set to different types in 2 methods of a\n      same class, it won't be detected (see functional test)\n    - One could improve the support for inference on assignment with tuples,\n      ifexpr, etc. Also, it would be great to have support for inference on\n      str.split()\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "description": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(MultipleTypesChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.redefined_variable_type",
        "documentation": {}
    },
    {
        "label": "SetMembershipChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "description": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "peekOfCode": "class SetMembershipChecker(BaseChecker):\n    name = \"set_membership\"\n    msgs = {\n        \"R6201\": (\n            \"Consider using set for membership test\",\n            \"use-set-for-membership\",\n            \"Membership tests are more efficient when performed on \"\n            \"a lookup optimized datatype like ``sets``.\",\n        ),\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "description": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(SetMembershipChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.set_membership",
        "documentation": {}
    },
    {
        "label": "TypingAlias",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "class TypingAlias(NamedTuple):\n    name: str\n    name_collision: bool\nDEPRECATED_TYPING_ALIASES: dict[str, TypingAlias] = {\n    \"typing.Tuple\": TypingAlias(\"tuple\", False),\n    \"typing.List\": TypingAlias(\"list\", False),\n    \"typing.Dict\": TypingAlias(\"dict\", False),\n    \"typing.Set\": TypingAlias(\"set\", False),\n    \"typing.FrozenSet\": TypingAlias(\"frozenset\", False),\n    \"typing.Type\": TypingAlias(\"type\", False),",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "DeprecatedTypingAliasMsg",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "class DeprecatedTypingAliasMsg(NamedTuple):\n    node: nodes.Name | nodes.Attribute\n    qname: str\n    alias: str\n    parent_subscript: bool = False\nclass TypingChecker(BaseChecker):\n    \"\"\"Find issue specifically related to type annotations.\"\"\"\n    name = \"typing\"\n    msgs = {\n        \"W6001\": (",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "TypingChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "class TypingChecker(BaseChecker):\n    \"\"\"Find issue specifically related to type annotations.\"\"\"\n    name = \"typing\"\n    msgs = {\n        \"W6001\": (\n            \"'%s' is deprecated, use '%s' instead\",\n            \"deprecated-typing-alias\",\n            \"Emitted when a deprecated typing alias is used.\",\n        ),\n        \"R6002\": (",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(TypingChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "ALIAS_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "ALIAS_NAMES = frozenset(key.split(\".\")[1] for key in DEPRECATED_TYPING_ALIASES)\nUNION_NAMES = (\"Optional\", \"Union\")\nclass DeprecatedTypingAliasMsg(NamedTuple):\n    node: nodes.Name | nodes.Attribute\n    qname: str\n    alias: str\n    parent_subscript: bool = False\nclass TypingChecker(BaseChecker):\n    \"\"\"Find issue specifically related to type annotations.\"\"\"\n    name = \"typing\"",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "UNION_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "description": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "peekOfCode": "UNION_NAMES = (\"Optional\", \"Union\")\nclass DeprecatedTypingAliasMsg(NamedTuple):\n    node: nodes.Name | nodes.Attribute\n    qname: str\n    alias: str\n    parent_subscript: bool = False\nclass TypingChecker(BaseChecker):\n    \"\"\"Find issue specifically related to type annotations.\"\"\"\n    name = \"typing\"\n    msgs = {",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.typing",
        "documentation": {}
    },
    {
        "label": "WhileChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "description": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "peekOfCode": "class WhileChecker(BaseChecker):\n    name = \"while_used\"\n    msgs = {\n        \"W0149\": (\n            \"Used `while` loop\",\n            \"while-used\",\n            \"Unbounded `while` loops can often be rewritten as bounded `for` loops. \"\n            \"Exceptions can be made for cases such as event loops, listeners, etc.\",\n        )\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "description": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_checker(WhileChecker(linter))",
        "detail": "__pypackages__.3.10.lib.pylint.extensions.while_used",
        "documentation": {}
    },
    {
        "label": "load_results",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.caching",
        "description": "__pypackages__.3.10.lib.pylint.lint.caching",
        "peekOfCode": "def load_results(\n    base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n    if not data_file.exists():\n        return None\n    try:\n        with open(data_file, \"rb\") as stream:",
        "detail": "__pypackages__.3.10.lib.pylint.lint.caching",
        "documentation": {}
    },
    {
        "label": "save_results",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.caching",
        "description": "__pypackages__.3.10.lib.pylint.lint.caching",
        "peekOfCode": "def save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n        pylint_home.mkdir(parents=True, exist_ok=True)\n    except OSError:  # pragma: no cover\n        print(f\"Unable to create directory {pylint_home}\", file=sys.stderr)\n    data_file = _get_pdata_path(base, 1)",
        "detail": "__pypackages__.3.10.lib.pylint.lint.caching",
        "documentation": {}
    },
    {
        "label": "PYLINT_HOME_AS_PATH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.caching",
        "description": "__pypackages__.3.10.lib.pylint.lint.caching",
        "peekOfCode": "PYLINT_HOME_AS_PATH = Path(PYLINT_HOME)\ndef _get_pdata_path(\n    base_name: Path, recurs: int, pylint_home: Path = PYLINT_HOME_AS_PATH\n) -> Path:\n    # We strip all characters that can't be used in a filename. Also strip '/' and\n    # '\\\\' because we want to create a single file, not sub-directories.\n    underscored_name = \"_\".join(\n        str(p.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\"))\n        for p in base_name.parts\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.lint.caching",
        "documentation": {}
    },
    {
        "label": "get_python_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "description": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "peekOfCode": "def get_python_path(filepath: str) -> str:\n    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n    an __init__.py.\n    This is not true since python 3.3 and is causing problem.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):",
        "detail": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "documentation": {}
    },
    {
        "label": "expand_modules",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "description": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "peekOfCode": "def expand_modules(\n    files_or_modules: Sequence[str],\n    ignore_list: list[str],\n    ignore_list_re: list[Pattern[str]],\n    ignore_list_paths_re: list[Pattern[str]],\n) -> tuple[dict[str, ModuleDescriptionDict], list[ErrorDescriptionDict]]:\n    \"\"\"Take a list of files/modules/packages and return the list of tuple\n    (file, module name) which have to be actually checked.\n    \"\"\"\n    result: dict[str, ModuleDescriptionDict] = {}",
        "detail": "__pypackages__.3.10.lib.pylint.lint.expand_modules",
        "documentation": {}
    },
    {
        "label": "_MessageStateHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.message_state_handler",
        "description": "__pypackages__.3.10.lib.pylint.lint.message_state_handler",
        "peekOfCode": "class _MessageStateHandler:\n    \"\"\"Class that handles message disabling & enabling and processing of inline\n    pragma's.\n    \"\"\"\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,",
        "detail": "__pypackages__.3.10.lib.pylint.lint.message_state_handler",
        "documentation": {}
    },
    {
        "label": "check_parallel",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.parallel",
        "description": "__pypackages__.3.10.lib.pylint.lint.parallel",
        "peekOfCode": "def check_parallel(\n    linter: PyLinter,\n    jobs: int,\n    files: Iterable[FileItem],\n    arguments: None | str | Sequence[str] = None,\n) -> None:\n    \"\"\"Use the given linter to lint the files with given amount of workers (jobs).\n    This splits the work filestream-by-filestream. If you need to do work across\n    multiple files, as in the similarity-checker, then implement the map/reduce mixin functionality.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.lint.parallel",
        "documentation": {}
    },
    {
        "label": "GetAstProtocol",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "description": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "peekOfCode": "class GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module:\n        ...\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()",
        "detail": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "PyLinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "description": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "peekOfCode": "class PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:",
        "detail": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "MANAGER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "description": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "peekOfCode": "MANAGER = astroid.MANAGER\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module:\n        ...\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")",
        "detail": "__pypackages__.3.10.lib.pylint.lint.pylinter",
        "documentation": {}
    },
    {
        "label": "report_total_messages_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "description": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "peekOfCode": "def report_total_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    previous_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make total errors / warnings report.\"\"\"\n    lines = [\"type\", \"number\", \"previous\", \"difference\"]\n    lines += checkers.table_lines_from_stats(stats, previous_stats, \"message_types\")\n    sect.append(Table(children=lines, cols=4, rheaders=1))\ndef report_messages_stats(",
        "detail": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "report_messages_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "description": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "peekOfCode": "def report_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make messages type report.\"\"\"\n    by_msg_stats = stats.by_msg\n    in_order = sorted(\n        (value, msg_id)\n        for msg_id, value in by_msg_stats.items()",
        "detail": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "report_messages_by_module_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "description": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "peekOfCode": "def report_messages_by_module_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make errors / warnings by modules report.\"\"\"\n    module_stats = stats.by_module\n    if len(module_stats) == 1:\n        # don't print this report when we are analysing a single module\n        raise exceptions.EmptyReportError()",
        "detail": "__pypackages__.3.10.lib.pylint.lint.report_functions",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.run",
        "description": "__pypackages__.3.10.lib.pylint.lint.run",
        "peekOfCode": "class Run:\n    \"\"\"Helper class to use as main for pylint with 'run(*sys.argv[1:])'.\"\"\"\n    LinterClass = PyLinter\n    option_groups = (\n        (\n            \"Commands\",\n            \"Options which are actually commands. Options in this \\\ngroup are mutually exclusive.\",\n        ),\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.lint.run",
        "documentation": {}
    },
    {
        "label": "_PylintConfigRun",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.run",
        "description": "__pypackages__.3.10.lib.pylint.lint.run",
        "peekOfCode": "class _PylintConfigRun(Run):\n    \"\"\"A private wrapper for the 'pylint-config' command.\"\"\"\n    _is_pylint_config: ClassVar[bool] = True\n    \"\"\"Boolean whether or not this is a 'pylint-config' run.\n    Used by _PylintConfigRun to make the 'pylint-config' command work.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.lint.run",
        "documentation": {}
    },
    {
        "label": "UNUSED_PARAM_SENTINEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.run",
        "description": "__pypackages__.3.10.lib.pylint.lint.run",
        "peekOfCode": "UNUSED_PARAM_SENTINEL = object()\nclass Run:\n    \"\"\"Helper class to use as main for pylint with 'run(*sys.argv[1:])'.\"\"\"\n    LinterClass = PyLinter\n    option_groups = (\n        (\n            \"Commands\",\n            \"Options which are actually commands. Options in this \\\ngroup are mutually exclusive.\",\n        ),",
        "detail": "__pypackages__.3.10.lib.pylint.lint.run",
        "documentation": {}
    },
    {
        "label": "prepare_crash_report",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.utils",
        "description": "__pypackages__.3.10.lib.pylint.lint.utils",
        "peekOfCode": "def prepare_crash_report(ex: Exception, filepath: str, crash_file_path: str) -> Path:\n    issue_template_path = (\n        Path(PYLINT_HOME) / datetime.now().strftime(str(crash_file_path))\n    ).resolve()\n    with open(filepath, encoding=\"utf8\") as f:\n        file_content = f.read()\n    template = \"\"\n    if not issue_template_path.exists():\n        template = \"\"\"\\\nFirst, please verify that the bug is not already filled:",
        "detail": "__pypackages__.3.10.lib.pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "get_fatal_error_message",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.utils",
        "description": "__pypackages__.3.10.lib.pylint.lint.utils",
        "peekOfCode": "def get_fatal_error_message(filepath: str, issue_template_path: Path) -> str:\n    return (\n        f\"Fatal error while checking '{filepath}'. \"\n        f\"Please open an issue in our bug tracker so we address this. \"\n        f\"There is a pre-filled template that you can use in '{issue_template_path}'.\"\n    )\ndef _patch_sys_path(args: Sequence[str]) -> list[str]:\n    original = list(sys.path)\n    changes = []\n    seen = set()",
        "detail": "__pypackages__.3.10.lib.pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "fix_import_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.lint.utils",
        "description": "__pypackages__.3.10.lib.pylint.lint.utils",
        "peekOfCode": "def fix_import_path(args: Sequence[str]) -> Iterator[None]:\n    \"\"\"Prepare 'sys.path' for running the linter checks.\n    Within this context, each of the given arguments is importable.\n    Paths are added to 'sys.path' in corresponding order to the arguments.\n    We avoid adding duplicate directories to sys.path.\n    `sys.path` is reset to its original value upon exiting this context.\n    \"\"\"\n    original = _patch_sys_path(args)\n    try:\n        yield",
        "detail": "__pypackages__.3.10.lib.pylint.lint.utils",
        "documentation": {}
    },
    {
        "label": "DeletedMessage",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "class DeletedMessage(NamedTuple):\n    msgid: str\n    symbol: str\n    old_names: list[tuple[str, str]] = []\nDELETED_MSGID_PREFIXES: list[int] = []\nDELETED_MESSAGES_IDS = {\n    # Everything until the next comment is from the PY3K+ checker\n    \"https://github.com/PyCQA/pylint/pull/4942\": [\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"E1601\", \"print-statement\"),",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_deleted_symbol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "def is_deleted_symbol(symbol: str) -> str | None:\n    \"\"\"Return the explanation for removal if the message was removed.\"\"\"\n    for explanation, deleted_messages in DELETED_MESSAGES_IDS.items():\n        for deleted_message in deleted_messages:\n            if symbol == deleted_message.symbol or any(\n                symbol == m[1] for m in deleted_message.old_names\n            ):\n                return explanation\n    return None\n@lru_cache(maxsize=None)",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_deleted_msgid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "def is_deleted_msgid(msgid: str) -> str | None:\n    \"\"\"Return the explanation for removal if the message was removed.\"\"\"\n    for explanation, deleted_messages in DELETED_MESSAGES_IDS.items():\n        for deleted_message in deleted_messages:\n            if msgid == deleted_message.msgid or any(\n                msgid == m[0] for m in deleted_message.old_names\n            ):\n                return explanation\n    return None\n@lru_cache(maxsize=None)",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_moved_symbol",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "def is_moved_symbol(symbol: str) -> str | None:\n    \"\"\"Return the explanation for moving if the message was moved to extensions.\"\"\"\n    for explanation, moved_messages in MOVED_TO_EXTENSIONS.items():\n        for moved_message in moved_messages:\n            if symbol == moved_message.symbol or any(\n                symbol == m[1] for m in moved_message.old_names\n            ):\n                return explanation\n    return None\n@lru_cache(maxsize=None)",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "is_moved_msgid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "def is_moved_msgid(msgid: str) -> str | None:\n    \"\"\"Return the explanation for moving if the message was moved to extensions.\"\"\"\n    for explanation, moved_messages in MOVED_TO_EXTENSIONS.items():\n        for moved_message in moved_messages:\n            if msgid == moved_message.msgid or any(\n                msgid == m[0] for m in moved_message.old_names\n            ):\n                return explanation\n    return None",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "DELETED_MESSAGES_IDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "DELETED_MESSAGES_IDS = {\n    # Everything until the next comment is from the PY3K+ checker\n    \"https://github.com/PyCQA/pylint/pull/4942\": [\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"E1601\", \"print-statement\"),\n        DeletedMessage(\"E1602\", \"parameter-unpacking\"),\n        DeletedMessage(\n            \"E1603\", \"unpacking-in-except\", [(\"W0712\", \"old-unpacking-in-except\")]\n        ),\n        DeletedMessage(",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "MOVED_TO_EXTENSIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "description": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "peekOfCode": "MOVED_TO_EXTENSIONS = {\n    \"https://pylint.pycqa.org/en/latest/whatsnew/2/2.14/summary.html#removed-checkers\": [\n        DeletedMessage(\"R0201\", \"no-self-use\")\n    ],\n}\n@lru_cache(maxsize=None)\ndef is_deleted_symbol(symbol: str) -> str | None:\n    \"\"\"Return the explanation for removal if the message was removed.\"\"\"\n    for explanation, deleted_messages in DELETED_MESSAGES_IDS.items():\n        for deleted_message in deleted_messages:",
        "detail": "__pypackages__.3.10.lib.pylint.message._deleted_message_ids",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.message.message",
        "description": "__pypackages__.3.10.lib.pylint.message.message",
        "peekOfCode": "class Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str",
        "detail": "__pypackages__.3.10.lib.pylint.message.message",
        "documentation": {}
    },
    {
        "label": "MessageDefinition",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.message.message_definition",
        "description": "__pypackages__.3.10.lib.pylint.message.message_definition",
        "peekOfCode": "class MessageDefinition:\n    # pylint: disable-next=too-many-arguments\n    def __init__(\n        self,\n        checker: BaseChecker,\n        msgid: str,\n        msg: str,\n        description: str,\n        symbol: str,\n        scope: str,",
        "detail": "__pypackages__.3.10.lib.pylint.message.message_definition",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionStore",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.message.message_definition_store",
        "description": "__pypackages__.3.10.lib.pylint.message.message_definition_store",
        "peekOfCode": "class MessageDefinitionStore:\n    \"\"\"The messages store knows information about every possible message definition but\n    has no particular state during analysis.\n    \"\"\"\n    def __init__(\n        self, py_version: tuple[int, ...] | sys._version_info = sys.version_info\n    ) -> None:\n        self.message_id_store: MessageIdStore = MessageIdStore()\n        # Primary registry for all active messages definitions.\n        # It contains the 1:1 mapping from msgid to MessageDefinition.",
        "detail": "__pypackages__.3.10.lib.pylint.message.message_definition_store",
        "documentation": {}
    },
    {
        "label": "MessageIdStore",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.message.message_id_store",
        "description": "__pypackages__.3.10.lib.pylint.message.message_id_store",
        "peekOfCode": "class MessageIdStore:\n    \"\"\"The MessageIdStore store MessageId and make sure that there is a 1-1 relation\n    between msgid and symbol.\n    \"\"\"\n    def __init__(self) -> None:\n        self.__msgid_to_symbol: dict[str, str] = {}\n        self.__symbol_to_msgid: dict[str, str] = {}\n        self.__old_names: dict[str, list[str]] = {}\n        self.__active_msgids: dict[str, list[str]] = {}\n    def __len__(self) -> int:",
        "detail": "__pypackages__.3.10.lib.pylint.message.message_id_store",
        "documentation": {}
    },
    {
        "label": "DiaDefGenerator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "peekOfCode": "class DiaDefGenerator:\n    \"\"\"Handle diagram generation options.\"\"\"\n    def __init__(self, linker: Linker, handler: DiadefsHandler) -> None:\n        \"\"\"Common Diagram Handler initialization.\"\"\"\n        self.config = handler.config\n        self.module_names: bool = False\n        self._set_default_options()\n        self.linker = linker\n        self.classdiagram: ClassDiagram  # defined by subclasses\n    def get_title(self, node: nodes.ClassDef) -> str:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "documentation": {}
    },
    {
        "label": "DefaultDiadefGenerator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "peekOfCode": "class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):\n    \"\"\"Generate minimum diagram definition for the project :\n    * a package diagram including project's modules\n    * a class diagram including project's classes\n    \"\"\"\n    def __init__(self, linker: Linker, handler: DiadefsHandler) -> None:\n        DiaDefGenerator.__init__(self, linker, handler)\n        LocalsVisitor.__init__(self)\n    def visit_project(self, node: Project) -> None:\n        \"\"\"Visit a pyreverse.utils.Project node.",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "documentation": {}
    },
    {
        "label": "ClassDiadefGenerator",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "peekOfCode": "class ClassDiadefGenerator(DiaDefGenerator):\n    \"\"\"Generate a class diagram definition including all classes related to a\n    given class.\n    \"\"\"\n    def class_diagram(self, project: Project, klass: nodes.ClassDef) -> ClassDiagram:\n        \"\"\"Return a class diagram definition for the class and related classes.\"\"\"\n        self.classdiagram = ClassDiagram(klass, self.config.mode)\n        if len(project.modules) > 1:\n            module, klass = klass.rsplit(\".\", 1)\n            module = project.get_module(module)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "documentation": {}
    },
    {
        "label": "DiadefsHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "peekOfCode": "class DiadefsHandler:\n    \"\"\"Get diagram definitions from user (i.e. xml files) or generate them.\"\"\"\n    def __init__(self, config: argparse.Namespace) -> None:\n        self.config = config\n    def get_diadefs(self, project: Project, linker: Linker) -> list[ClassDiagram]:\n        \"\"\"Get the diagram's configuration data.\n        :param project:The pyreverse project\n        :type project: pyreverse.utils.Project\n        :param linker: The linker\n        :type linker: pyreverse.inspector.Linker(IdGeneratorMixIn, LocalsVisitor)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diadefslib",
        "documentation": {}
    },
    {
        "label": "Figure",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class Figure:\n    \"\"\"Base class for counter handling.\"\"\"\n    def __init__(self) -> None:\n        self.fig_id: str = \"\"\nclass Relationship(Figure):\n    \"\"\"A relationship from an object in the diagram to another.\"\"\"\n    def __init__(\n        self,\n        from_object: DiagramEntity,\n        to_object: DiagramEntity,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class Relationship(Figure):\n    \"\"\"A relationship from an object in the diagram to another.\"\"\"\n    def __init__(\n        self,\n        from_object: DiagramEntity,\n        to_object: DiagramEntity,\n        relation_type: str,\n        name: str | None = None,\n    ):\n        super().__init__()",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "DiagramEntity",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class DiagramEntity(Figure):\n    \"\"\"A diagram object, i.e. a label associated to an astroid node.\"\"\"\n    default_shape = \"\"\n    def __init__(\n        self, title: str = \"No name\", node: nodes.NodeNG | None = None\n    ) -> None:\n        super().__init__()\n        self.title = title\n        self.node: nodes.NodeNG = node if node else nodes.NodeNG()\n        self.shape = self.default_shape",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "PackageEntity",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class PackageEntity(DiagramEntity):\n    \"\"\"A diagram object representing a package.\"\"\"\n    default_shape = \"package\"\nclass ClassEntity(DiagramEntity):\n    \"\"\"A diagram object representing a class.\"\"\"\n    default_shape = \"class\"\n    def __init__(self, title: str, node: nodes.ClassDef) -> None:\n        super().__init__(title=title, node=node)\n        self.attrs: list[str] = []\n        self.methods: list[nodes.FunctionDef] = []",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "ClassEntity",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class ClassEntity(DiagramEntity):\n    \"\"\"A diagram object representing a class.\"\"\"\n    default_shape = \"class\"\n    def __init__(self, title: str, node: nodes.ClassDef) -> None:\n        super().__init__(title=title, node=node)\n        self.attrs: list[str] = []\n        self.methods: list[nodes.FunctionDef] = []\nclass ClassDiagram(Figure, FilterMixIn):\n    \"\"\"Main class diagram handling.\"\"\"\n    TYPE = \"class\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "ClassDiagram",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class ClassDiagram(Figure, FilterMixIn):\n    \"\"\"Main class diagram handling.\"\"\"\n    TYPE = \"class\"\n    def __init__(self, title: str, mode: str) -> None:\n        FilterMixIn.__init__(self, mode)\n        Figure.__init__(self)\n        self.title = title\n        # TODO: Specify 'Any' after refactor of `DiagramEntity`\n        self.objects: list[Any] = []\n        self.relationships: dict[str, list[Relationship]] = {}",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "PackageDiagram",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "peekOfCode": "class PackageDiagram(ClassDiagram):\n    \"\"\"Package diagram handling.\"\"\"\n    TYPE = \"package\"\n    def modules(self) -> list[PackageEntity]:\n        \"\"\"Return all module nodes in the diagram.\"\"\"\n        return [o for o in self.objects if isinstance(o, PackageEntity)]\n    def module(self, name: str) -> PackageEntity:\n        \"\"\"Return a module by its name, raise KeyError if not found.\"\"\"\n        for mod in self.modules():\n            if mod.node.name == name:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.diagrams",
        "documentation": {}
    },
    {
        "label": "HTMLLabels",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "peekOfCode": "class HTMLLabels(Enum):\n    LINEBREAK_LEFT = '<br ALIGN=\"LEFT\"/>'\nALLOWED_CHARSETS: frozenset[str] = frozenset((\"utf-8\", \"iso-8859-1\", \"latin1\"))\nSHAPES: dict[NodeType, str] = {\n    NodeType.PACKAGE: \"box\",\n    NodeType.INTERFACE: \"record\",\n    NodeType.CLASS: \"record\",\n}\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nARROWS: dict[EdgeType, dict[str, str]] = {",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "documentation": {}
    },
    {
        "label": "DotPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "peekOfCode": "class DotPrinter(Printer):\n    DEFAULT_COLOR = \"black\"\n    def __init__(\n        self,\n        title: str,\n        layout: Layout | None = None,\n        use_automatic_namespace: bool | None = None,\n    ):\n        layout = layout or Layout.BOTTOM_TO_TOP\n        self.charset = \"utf-8\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.dot_printer",
        "documentation": {}
    },
    {
        "label": "IdGeneratorMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class IdGeneratorMixIn:\n    \"\"\"Mixin adding the ability to generate integer uid.\"\"\"\n    def __init__(self, start_value: int = 0) -> None:\n        self.id_count = start_value\n    def init_counter(self, start_value: int = 0) -> None:\n        \"\"\"Init the id counter.\"\"\"\n        self.id_count = start_value\n    def generate_id(self) -> int:\n        \"\"\"Generate a new identifier.\"\"\"\n        self.id_count += 1",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "Project",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class Project:\n    \"\"\"A project handle a set of modules / packages.\"\"\"\n    def __init__(self, name: str = \"\"):\n        self.name = name\n        self.uid: int | None = None\n        self.path: str = \"\"\n        self.modules: list[nodes.Module] = []\n        self.locals: dict[str, nodes.Module] = {}\n        self.__getitem__ = self.locals.__getitem__\n        self.__iter__ = self.locals.__iter__",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "Linker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n    \"\"\"Walk on the project tree and resolve relationships.\n    According to options the following attributes may be\n    added to visited nodes:\n    * uid,\n      a unique identifier for the node (on astroid.Project, astroid.Module,\n      astroid.Class and astroid.locals_type). Only if the linker\n      has been instantiated with tag=True parameter (False by default).\n    * Function\n      a mapping from locals names to their bounded value, which may be a",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "AssociationHandlerInterface",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class AssociationHandlerInterface(ABC):\n    @abstractmethod\n    def set_next(\n        self, handler: AssociationHandlerInterface\n    ) -> AssociationHandlerInterface:\n        pass\n    @abstractmethod\n    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        pass\nclass AbstractAssociationHandler(AssociationHandlerInterface):",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "AbstractAssociationHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n    The default chaining behavior is implemented inside the base handler\n    class.\n    \"\"\"\n    _next_handler: AssociationHandlerInterface",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "AggregationsHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class AggregationsHandler(AbstractAssociationHandler):\n    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        if isinstance(node.parent, (nodes.AnnAssign, nodes.Assign)) and isinstance(\n            node.parent.value, astroid.node_classes.Name\n        ):\n            current = set(parent.aggregations_type[node.attrname])\n            parent.aggregations_type[node.attrname] = list(\n                current | utils.infer_node(node)\n            )\n        else:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "OtherAssociationsHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "class OtherAssociationsHandler(AbstractAssociationHandler):\n    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        current = set(parent.associations_type[node.attrname])\n        parent.associations_type[node.attrname] = list(current | utils.infer_node(node))\ndef project_from_files(\n    files: list[str],\n    func_wrapper: _WrapperFuncT = _astroid_wrapper,\n    project_name: str = \"no name\",\n    black_list: tuple[str, ...] = constants.DEFAULT_IGNORE_LIST,\n) -> Project:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "interfaces",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "def interfaces(node: nodes.ClassDef) -> Generator[Any, None, None]:\n    \"\"\"Return an iterator on interfaces implemented by the given class node.\"\"\"\n    try:\n        implements = astroid.bases.Instance(node).getattr(\"__implements__\")[0]\n    except astroid.exceptions.NotFoundError:\n        return\n    if implements.frame(future=True) is not node:\n        return\n    found = set()\n    missing = False",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "project_from_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "def project_from_files(\n    files: list[str],\n    func_wrapper: _WrapperFuncT = _astroid_wrapper,\n    project_name: str = \"no name\",\n    black_list: tuple[str, ...] = constants.DEFAULT_IGNORE_LIST,\n) -> Project:\n    \"\"\"Return a Project from a list of files or modules.\"\"\"\n    # build the project representation\n    astroid_manager = astroid.MANAGER\n    project = Project(project_name)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "_WrapperFuncT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "peekOfCode": "_WrapperFuncT = Callable[[Callable[[str], nodes.Module], str], Optional[nodes.Module]]\ndef _astroid_wrapper(\n    func: Callable[[str], nodes.Module], modname: str\n) -> nodes.Module | None:\n    print(f\"parsing {modname}...\")\n    try:\n        return func(modname)\n    except astroid.exceptions.AstroidBuildingException as exc:\n        print(exc)\n    except Exception:  # pylint: disable=broad-except",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.inspector",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "peekOfCode": "class Run(_ArgumentsManager, _ArgumentsProvider):\n    \"\"\"Base class providing common behaviour for pyreverse commands.\"\"\"\n    options = OPTIONS\n    name = \"pyreverse\"\n    def __init__(self, args: Sequence[str]) -> NoReturn:\n        # Immediately exit if user asks for version\n        if \"--version\" in args:\n            print(\"pyreverse is included in pylint:\")\n            print(constants.full_version)\n            sys.exit(0)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "documentation": {}
    },
    {
        "label": "DIRECTLY_SUPPORTED_FORMATS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "peekOfCode": "DIRECTLY_SUPPORTED_FORMATS = (\n    \"dot\",\n    \"vcg\",\n    \"puml\",\n    \"plantuml\",\n    \"mmd\",\n    \"html\",\n)\nOPTIONS: Options = (\n    (",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.main",
        "documentation": {}
    },
    {
        "label": "MermaidJSPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "peekOfCode": "class MermaidJSPrinter(Printer):\n    \"\"\"Printer for MermaidJS diagrams.\"\"\"\n    DEFAULT_COLOR = \"black\"\n    NODES: dict[NodeType, str] = {\n        NodeType.CLASS: \"class\",\n        NodeType.INTERFACE: \"class\",\n        NodeType.PACKAGE: \"class\",\n    }\n    ARROWS: dict[EdgeType, str] = {\n        EdgeType.INHERITS: \"--|>\",",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "documentation": {}
    },
    {
        "label": "HTMLMermaidJSPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "peekOfCode": "class HTMLMermaidJSPrinter(MermaidJSPrinter):\n    \"\"\"Printer for MermaidJS diagrams wrapped in a html boilerplate.\"\"\"\n    HTML_OPEN_BOILERPLATE = \"\"\"<html>\n  <body>\n    <script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"></script>\n      <div class=\"mermaid\">\n    \"\"\"\n    HTML_CLOSE_BOILERPLATE = \"\"\"\n       </div>\n  </body>",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.mermaidjs_printer",
        "documentation": {}
    },
    {
        "label": "PlantUmlPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.plantuml_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.plantuml_printer",
        "peekOfCode": "class PlantUmlPrinter(Printer):\n    \"\"\"Printer for PlantUML diagrams.\"\"\"\n    DEFAULT_COLOR = \"black\"\n    NODES: dict[NodeType, str] = {\n        NodeType.CLASS: \"class\",\n        NodeType.INTERFACE: \"class\",\n        NodeType.PACKAGE: \"package\",\n    }\n    ARROWS: dict[EdgeType, str] = {\n        EdgeType.INHERITS: \"--|>\",",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.plantuml_printer",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "peekOfCode": "class NodeType(Enum):\n    CLASS = \"class\"\n    INTERFACE = \"interface\"\n    PACKAGE = \"package\"\nclass EdgeType(Enum):\n    INHERITS = \"inherits\"\n    IMPLEMENTS = \"implements\"\n    ASSOCIATION = \"association\"\n    AGGREGATION = \"aggregation\"\n    USES = \"uses\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "EdgeType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "peekOfCode": "class EdgeType(Enum):\n    INHERITS = \"inherits\"\n    IMPLEMENTS = \"implements\"\n    ASSOCIATION = \"association\"\n    AGGREGATION = \"aggregation\"\n    USES = \"uses\"\nclass Layout(Enum):\n    LEFT_TO_RIGHT = \"LR\"\n    RIGHT_TO_LEFT = \"RL\"\n    TOP_TO_BOTTOM = \"TB\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Layout",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "peekOfCode": "class Layout(Enum):\n    LEFT_TO_RIGHT = \"LR\"\n    RIGHT_TO_LEFT = \"RL\"\n    TOP_TO_BOTTOM = \"TB\"\n    BOTTOM_TO_TOP = \"BT\"\nclass NodeProperties(NamedTuple):\n    label: str\n    attrs: list[str] | None = None\n    methods: list[nodes.FunctionDef] | None = None\n    color: str | None = None",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "NodeProperties",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "peekOfCode": "class NodeProperties(NamedTuple):\n    label: str\n    attrs: list[str] | None = None\n    methods: list[nodes.FunctionDef] | None = None\n    color: str | None = None\n    fontcolor: str | None = None\nclass Printer(ABC):\n    \"\"\"Base class defining the interface for a printer.\"\"\"\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "Printer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "peekOfCode": "class Printer(ABC):\n    \"\"\"Base class defining the interface for a printer.\"\"\"\n    def __init__(\n        self,\n        title: str,\n        layout: Layout | None = None,\n        use_automatic_namespace: bool | None = None,\n    ) -> None:\n        self.title: str = title\n        self.layout = layout",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer",
        "documentation": {}
    },
    {
        "label": "get_printer_for_filetype",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.printer_factory",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.printer_factory",
        "peekOfCode": "def get_printer_for_filetype(filetype: str) -> type[Printer]:\n    return filetype_to_printer.get(filetype, DotPrinter)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.printer_factory",
        "documentation": {}
    },
    {
        "label": "FilterMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "class FilterMixIn:\n    \"\"\"Filter nodes according to a mode and nodes' visibility.\"\"\"\n    def __init__(self, mode: str) -> None:\n        \"\"\"Init filter modes.\"\"\"\n        __mode = 0\n        for nummod in mode.split(\"+\"):\n            try:\n                __mode += MODES[nummod]\n            except KeyError as ex:\n                print(f\"Unknown filter mode {ex}\", file=sys.stderr)",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "LocalsVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "class LocalsVisitor:\n    \"\"\"Visit a project by traversing the locals dictionary.\n    * visit_<class name> on entering a node, where class name is the class of\n    the node in lower case\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n    \"\"\"\n    def __init__(self) -> None:\n        self._cache: dict[type[nodes.NodeNG], _CallbackTupleT] = {}\n        self._visited: set[nodes.NodeNG] = set()",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_default_options",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n            with open(rcfile, encoding=\"utf-8\") as file_handle:\n                options = file_handle.read().split()\n        except OSError:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "insert_default_options",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def insert_default_options() -> None:\n    \"\"\"Insert default options to sys.argv.\"\"\"\n    options = get_default_options()\n    options.reverse()\n    for arg in options:\n        sys.argv.insert(1, arg)\n# astroid utilities ###########################################################\nSPECIAL = re.compile(r\"^__([^\\W_]_*)+__$\")\nPRIVATE = re.compile(r\"^__(_*[^\\W_])+_?$\")\nPROTECTED = re.compile(r\"^_\\w*$\")",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_visibility",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def get_visibility(name: str) -> str:\n    \"\"\"Return the visibility from a name: public, protected, private or special.\"\"\"\n    if SPECIAL.match(name):\n        visibility = \"special\"\n    elif PRIVATE.match(name):\n        visibility = \"private\"\n    elif PROTECTED.match(name):\n        visibility = \"protected\"\n    else:\n        visibility = \"public\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "is_interface",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def is_interface(node: nodes.ClassDef) -> bool:\n    # bw compatibility\n    return node.type == \"interface\"  # type: ignore[no-any-return]\ndef is_exception(node: nodes.ClassDef) -> bool:\n    # bw compatibility\n    return node.type == \"exception\"  # type: ignore[no-any-return]\n# Helpers #####################################################################\n_SPECIAL = 2\n_PROTECTED = 4\n_PRIVATE = 8",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "is_exception",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def is_exception(node: nodes.ClassDef) -> bool:\n    # bw compatibility\n    return node.type == \"exception\"  # type: ignore[no-any-return]\n# Helpers #####################################################################\n_SPECIAL = 2\n_PROTECTED = 4\n_PRIVATE = 8\nMODES = {\n    \"ALL\": 0,\n    \"PUB_ONLY\": _SPECIAL + _PROTECTED + _PRIVATE,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation_label",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def get_annotation_label(ann: nodes.Name | nodes.NodeNG) -> str:\n    if isinstance(ann, nodes.Name) and ann.name is not None:\n        return ann.name  # type: ignore[no-any-return]\n    if isinstance(ann, nodes.NodeNG):\n        return ann.as_string()  # type: ignore[no-any-return]\n    return \"\"\ndef get_annotation(\n    node: nodes.AssignAttr | nodes.AssignName,\n) -> nodes.Name | nodes.Subscript | None:\n    \"\"\"Return the annotation for `node`.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "get_annotation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def get_annotation(\n    node: nodes.AssignAttr | nodes.AssignName,\n) -> nodes.Name | nodes.Subscript | None:\n    \"\"\"Return the annotation for `node`.\"\"\"\n    ann = None\n    if isinstance(node.parent, nodes.AnnAssign):\n        ann = node.parent.annotation\n    elif isinstance(node, nodes.AssignAttr):\n        init_method = node.parent.parent\n        try:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "infer_node",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def infer_node(node: nodes.AssignAttr | nodes.AssignName) -> set[InferenceResult]:\n    \"\"\"Return a set containing the node annotation if it exists\n    otherwise return a set of the inferred types using the NodeNG.infer method.\n    \"\"\"\n    ann = get_annotation(node)\n    try:\n        if ann:\n            if isinstance(ann, nodes.Subscript) or (\n                isinstance(ann, nodes.BinOp) and ann.op == \"|\"\n            ):",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "check_graphviz_availability",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def check_graphviz_availability() -> None:\n    \"\"\"Check if the ``dot`` command is available on the machine.\n    This is needed if image output is desired and ``dot`` is used to convert\n    from *.dot or *.gv into the final output format.\n    \"\"\"\n    if shutil.which(\"dot\") is None:\n        print(\"'Graphviz' needs to be installed for your chosen output format.\")\n        sys.exit(32)\ndef check_if_graphviz_supports_format(output_format: str) -> None:\n    \"\"\"Check if the ``dot`` command supports the requested output format.",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "check_if_graphviz_supports_format",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "def check_if_graphviz_supports_format(output_format: str) -> None:\n    \"\"\"Check if the ``dot`` command supports the requested output format.\n    This is needed if image output is desired and ``dot`` is used to convert\n    from *.gv into the final output format.\n    \"\"\"\n    dot_output = subprocess.run(\n        [\"dot\", \"-T?\"], capture_output=True, check=False, encoding=\"utf-8\"\n    )\n    match = re.match(\n        pattern=r\".*Use one of: (?P<formats>(\\S*\\s?)+)\",",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "RCFILE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "RCFILE = \".pyreverserc\"\ndef get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n            with open(rcfile, encoding=\"utf-8\") as file_handle:\n                options = file_handle.read().split()",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "SPECIAL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "SPECIAL = re.compile(r\"^__([^\\W_]_*)+__$\")\nPRIVATE = re.compile(r\"^__(_*[^\\W_])+_?$\")\nPROTECTED = re.compile(r\"^_\\w*$\")\ndef get_visibility(name: str) -> str:\n    \"\"\"Return the visibility from a name: public, protected, private or special.\"\"\"\n    if SPECIAL.match(name):\n        visibility = \"special\"\n    elif PRIVATE.match(name):\n        visibility = \"private\"\n    elif PROTECTED.match(name):",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "PRIVATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "PRIVATE = re.compile(r\"^__(_*[^\\W_])+_?$\")\nPROTECTED = re.compile(r\"^_\\w*$\")\ndef get_visibility(name: str) -> str:\n    \"\"\"Return the visibility from a name: public, protected, private or special.\"\"\"\n    if SPECIAL.match(name):\n        visibility = \"special\"\n    elif PRIVATE.match(name):\n        visibility = \"private\"\n    elif PROTECTED.match(name):\n        visibility = \"protected\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "PROTECTED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "PROTECTED = re.compile(r\"^_\\w*$\")\ndef get_visibility(name: str) -> str:\n    \"\"\"Return the visibility from a name: public, protected, private or special.\"\"\"\n    if SPECIAL.match(name):\n        visibility = \"special\"\n    elif PRIVATE.match(name):\n        visibility = \"private\"\n    elif PROTECTED.match(name):\n        visibility = \"protected\"\n    else:",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "_SPECIAL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "_SPECIAL = 2\n_PROTECTED = 4\n_PRIVATE = 8\nMODES = {\n    \"ALL\": 0,\n    \"PUB_ONLY\": _SPECIAL + _PROTECTED + _PRIVATE,\n    \"SPECIAL\": _SPECIAL,\n    \"OTHER\": _PROTECTED + _PRIVATE,\n}\nVIS_MOD = {",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "_PROTECTED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "_PROTECTED = 4\n_PRIVATE = 8\nMODES = {\n    \"ALL\": 0,\n    \"PUB_ONLY\": _SPECIAL + _PROTECTED + _PRIVATE,\n    \"SPECIAL\": _SPECIAL,\n    \"OTHER\": _PROTECTED + _PRIVATE,\n}\nVIS_MOD = {\n    \"special\": _SPECIAL,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "_PRIVATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "_PRIVATE = 8\nMODES = {\n    \"ALL\": 0,\n    \"PUB_ONLY\": _SPECIAL + _PROTECTED + _PRIVATE,\n    \"SPECIAL\": _SPECIAL,\n    \"OTHER\": _PROTECTED + _PRIVATE,\n}\nVIS_MOD = {\n    \"special\": _SPECIAL,\n    \"protected\": _PROTECTED,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "MODES = {\n    \"ALL\": 0,\n    \"PUB_ONLY\": _SPECIAL + _PROTECTED + _PRIVATE,\n    \"SPECIAL\": _SPECIAL,\n    \"OTHER\": _PROTECTED + _PRIVATE,\n}\nVIS_MOD = {\n    \"special\": _SPECIAL,\n    \"protected\": _PROTECTED,\n    \"private\": _PRIVATE,",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "VIS_MOD",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "peekOfCode": "VIS_MOD = {\n    \"special\": _SPECIAL,\n    \"protected\": _PROTECTED,\n    \"private\": _PRIVATE,\n    \"public\": 0,\n}\nclass FilterMixIn:\n    \"\"\"Filter nodes according to a mode and nodes' visibility.\"\"\"\n    def __init__(self, mode: str) -> None:\n        \"\"\"Init filter modes.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.utils",
        "documentation": {}
    },
    {
        "label": "VCGPrinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "peekOfCode": "class VCGPrinter(Printer):\n    def _open_graph(self) -> None:\n        \"\"\"Emit the header lines.\"\"\"\n        self.emit(\"graph:{\\n\")\n        self._inc_indent()\n        self._write_attributes(\n            GRAPH_ATTRS,\n            title=self.title,\n            layoutalgorithm=\"dfs\",\n            late_edge_labels=\"yes\",",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "ATTRS_VAL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "peekOfCode": "ATTRS_VAL = {\n    \"algos\": (\n        \"dfs\",\n        \"tree\",\n        \"minbackward\",\n        \"left_to_right\",\n        \"right_to_left\",\n        \"top_to_bottom\",\n        \"bottom_to_top\",\n        \"maxdepth\",",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "GRAPH_ATTRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "peekOfCode": "GRAPH_ATTRS = {\n    \"title\": 0,\n    \"label\": 0,\n    \"color\": ATTRS_VAL[\"colors\"],\n    \"textcolor\": ATTRS_VAL[\"colors\"],\n    \"bordercolor\": ATTRS_VAL[\"colors\"],\n    \"width\": 1,\n    \"height\": 1,\n    \"borderwidth\": 1,\n    \"textmode\": ATTRS_VAL[\"textmodes\"],",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "NODE_ATTRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "peekOfCode": "NODE_ATTRS = {\n    \"title\": 0,\n    \"label\": 0,\n    \"color\": ATTRS_VAL[\"colors\"],\n    \"textcolor\": ATTRS_VAL[\"colors\"],\n    \"bordercolor\": ATTRS_VAL[\"colors\"],\n    \"width\": 1,\n    \"height\": 1,\n    \"borderwidth\": 1,\n    \"textmode\": ATTRS_VAL[\"textmodes\"],",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "EDGE_ATTRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "peekOfCode": "EDGE_ATTRS = {\n    \"sourcename\": 0,\n    \"targetname\": 0,\n    \"label\": 0,\n    \"linestyle\": ATTRS_VAL[\"linestyles\"],\n    \"class\": 1,\n    \"thickness\": 0,\n    \"color\": ATTRS_VAL[\"colors\"],\n    \"textcolor\": ATTRS_VAL[\"colors\"],\n    \"arrowcolor\": ATTRS_VAL[\"colors\"],",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.vcg_printer",
        "documentation": {}
    },
    {
        "label": "DiagramWriter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.pyreverse.writer",
        "description": "__pypackages__.3.10.lib.pylint.pyreverse.writer",
        "peekOfCode": "class DiagramWriter:\n    \"\"\"Base class for writing project diagrams.\"\"\"\n    def __init__(self, config: argparse.Namespace) -> None:\n        self.config = config\n        self.printer_class = get_printer_for_filetype(self.config.output_format)\n        self.printer: Printer  # defined in set_printer\n        self.file_name = \"\"  # defined in set_printer\n        self.depth = self.config.max_color_depth\n        self.available_colors = itertools.cycle(\n            [",
        "detail": "__pypackages__.3.10.lib.pylint.pyreverse.writer",
        "documentation": {}
    },
    {
        "label": "BaseWriter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.base_writer",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.base_writer",
        "peekOfCode": "class BaseWriter:\n    \"\"\"Base class for ureport writers.\"\"\"\n    def format(\n        self,\n        layout: BaseLayout,\n        stream: TextIO = sys.stdout,\n        encoding: str | None = None,\n    ) -> None:\n        \"\"\"Format and write the given layout into the stream object.\n        unicode policy: unicode strings may be found in the layout;",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.base_writer",
        "documentation": {}
    },
    {
        "label": "VNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class VNode:\n    def __init__(self) -> None:\n        self.parent: BaseLayout | None = None\n        self.children: list[VNode] = []\n        self.visitor_name: str = self.__class__.__name__.lower()\n    def __iter__(self) -> Iterator[VNode]:\n        return iter(self.children)\n    def accept(self: _VNodeT, visitor: BaseWriter, *args: Any, **kwargs: Any) -> None:\n        func: VisitLeaveFunction[_VNodeT] = getattr(\n            visitor, f\"visit_{self.visitor_name}\"",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "BaseLayout",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class BaseLayout(VNode):\n    \"\"\"Base container node.\n    attributes\n    * children : components in this table (i.e. the table's cells)\n    \"\"\"\n    def __init__(self, children: Iterable[Text | str] = ()) -> None:\n        super().__init__()\n        for child in children:\n            if isinstance(child, VNode):\n                self.append(child)",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class Text(VNode):\n    \"\"\"A text portion.\n    attributes :\n    * data : the text value as an encoded or unicode string\n    \"\"\"\n    def __init__(self, data: str, escaped: bool = True) -> None:\n        super().__init__()\n        self.escaped = escaped\n        self.data = data\nclass VerbatimText(Text):",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "VerbatimText",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class VerbatimText(Text):\n    \"\"\"A verbatim text, display the raw data.\n    attributes :\n    * data : the text value as an encoded or unicode string\n    \"\"\"\n# container nodes #############################################################\nclass Section(BaseLayout):\n    \"\"\"A section.\n    attributes :\n    * BaseLayout attributes",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Section",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class Section(BaseLayout):\n    \"\"\"A section.\n    attributes :\n    * BaseLayout attributes\n    a title may also be given to the constructor, it'll be added\n    as a first element\n    a description may also be given to the constructor, it'll be added\n    as a first paragraph\n    \"\"\"\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "EvaluationSection",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class EvaluationSection(Section):\n    def __init__(self, message: str, children: Iterable[Text | str] = ()) -> None:\n        super().__init__(children=children)\n        title = Paragraph()\n        title.append(Text(\"-\" * len(message)))\n        self.append(title)\n        message_body = Paragraph()\n        message_body.append(Text(message))\n        self.append(message_body)\nclass Title(BaseLayout):",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Title",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class Title(BaseLayout):\n    \"\"\"A title.\n    attributes :\n    * BaseLayout attributes\n    A title must not contain a section nor a paragraph!\n    \"\"\"\nclass Paragraph(BaseLayout):\n    \"\"\"A simple text paragraph.\n    attributes :\n    * BaseLayout attributes",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Paragraph",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class Paragraph(BaseLayout):\n    \"\"\"A simple text paragraph.\n    attributes :\n    * BaseLayout attributes\n    A paragraph must not contains a section !\n    \"\"\"\nclass Table(BaseLayout):\n    \"\"\"Some tabular data.\n    attributes :\n    * BaseLayout attributes",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "class Table(BaseLayout):\n    \"\"\"Some tabular data.\n    attributes :\n    * BaseLayout attributes\n    * cols : the number of columns of the table (REQUIRED)\n    * rheaders : the first row's elements are table's header\n    * cheaders : the first col's elements are table's header\n    * title : the table's optional title\n    \"\"\"\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "_T = TypeVar(\"_T\")\n_VNodeT = TypeVar(\"_VNodeT\", bound=\"VNode\")\nVisitLeaveFunction = Callable[[_T, Any, Any], None]\nclass VNode:\n    def __init__(self) -> None:\n        self.parent: BaseLayout | None = None\n        self.children: list[VNode] = []\n        self.visitor_name: str = self.__class__.__name__.lower()\n    def __iter__(self) -> Iterator[VNode]:\n        return iter(self.children)",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "_VNodeT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "_VNodeT = TypeVar(\"_VNodeT\", bound=\"VNode\")\nVisitLeaveFunction = Callable[[_T, Any, Any], None]\nclass VNode:\n    def __init__(self) -> None:\n        self.parent: BaseLayout | None = None\n        self.children: list[VNode] = []\n        self.visitor_name: str = self.__class__.__name__.lower()\n    def __iter__(self) -> Iterator[VNode]:\n        return iter(self.children)\n    def accept(self: _VNodeT, visitor: BaseWriter, *args: Any, **kwargs: Any) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "VisitLeaveFunction",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "peekOfCode": "VisitLeaveFunction = Callable[[_T, Any, Any], None]\nclass VNode:\n    def __init__(self) -> None:\n        self.parent: BaseLayout | None = None\n        self.children: list[VNode] = []\n        self.visitor_name: str = self.__class__.__name__.lower()\n    def __iter__(self) -> Iterator[VNode]:\n        return iter(self.children)\n    def accept(self: _VNodeT, visitor: BaseWriter, *args: Any, **kwargs: Any) -> None:\n        func: VisitLeaveFunction[_VNodeT] = getattr(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.nodes",
        "documentation": {}
    },
    {
        "label": "TextWriter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "peekOfCode": "class TextWriter(BaseWriter):\n    \"\"\"Format layouts as text\n    (ReStructured inspiration but not totally handled yet).\n    \"\"\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.list_level = 0\n    def visit_section(self, layout: Section) -> None:\n        \"\"\"Display a section as text.\"\"\"\n        self.section += 1",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "documentation": {}
    },
    {
        "label": "TITLE_UNDERLINES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "peekOfCode": "TITLE_UNDERLINES = [\"\", \"=\", \"-\", \"`\", \".\", \"~\", \"^\"]\nBULLETS = [\"*\", \"-\"]\nclass TextWriter(BaseWriter):\n    \"\"\"Format layouts as text\n    (ReStructured inspiration but not totally handled yet).\n    \"\"\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.list_level = 0\n    def visit_section(self, layout: Section) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "documentation": {}
    },
    {
        "label": "BULLETS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "description": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "peekOfCode": "BULLETS = [\"*\", \"-\"]\nclass TextWriter(BaseWriter):\n    \"\"\"Format layouts as text\n    (ReStructured inspiration but not totally handled yet).\n    \"\"\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.list_level = 0\n    def visit_section(self, layout: Section) -> None:\n        \"\"\"Display a section as text.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.ureports.text_writer",
        "documentation": {}
    },
    {
        "label": "BaseReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.base_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.base_reporter",
        "peekOfCode": "class BaseReporter:\n    \"\"\"Base class for reporters.\n    symbols: show short symbolic names for messages.\n    \"\"\"\n    extension = \"\"\n    name = \"base\"\n    \"\"\"Name of the reporter.\"\"\"\n    def __init__(self, output: TextIO | None = None) -> None:\n        if getattr(self, \"__implements__\", None):\n            warnings.warn(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.base_reporter",
        "documentation": {}
    },
    {
        "label": "CollectingReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.collecting_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.collecting_reporter",
        "peekOfCode": "class CollectingReporter(BaseReporter):\n    \"\"\"Collects messages.\"\"\"\n    name = \"collector\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.messages = []\n    def reset(self) -> None:\n        self.messages = []\n    def _display(self, layout: Section) -> None:\n        pass",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.collecting_reporter",
        "documentation": {}
    },
    {
        "label": "BaseJSONReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "peekOfCode": "class BaseJSONReporter(BaseReporter):\n    \"\"\"Report messages and layouts in JSON.\"\"\"\n    name = \"json\"\n    extension = \"json\"\n    def display_messages(self, layout: Section | None) -> None:\n        \"\"\"Launch layouts display.\"\"\"\n        json_dumpable = [self.serialize(message) for message in self.messages]\n        print(json.dumps(json_dumpable, indent=4), file=self.out)\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Don't do anything in this reporter.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "JSONReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "peekOfCode": "class JSONReporter(BaseJSONReporter):\n    \"\"\"\n    TODO: 3.0: Remove this JSONReporter in favor of the new one handling abs-path\n    and confidence.\n    TODO: 2.16: Add a new JSONReporter handling abs-path, confidence and scores.\n    (Ultimately all other breaking change related to json for 3.0).\n    \"\"\"\n    @staticmethod\n    def serialize(message: Message) -> OldJsonExport:\n        return {",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_reporter(JSONReporter)",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "OldJsonExport",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "peekOfCode": "OldJsonExport = TypedDict(\n    \"OldJsonExport\",\n    {\n        \"type\": str,\n        \"module\": str,\n        \"obj\": str,\n        \"line\": int,\n        \"column\": int,\n        \"endLine\": Optional[int],\n        \"endColumn\": Optional[int],",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.json_reporter",
        "documentation": {}
    },
    {
        "label": "MultiReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.multi_reporter",
        "description": "__pypackages__.3.10.lib.pylint.reporters.multi_reporter",
        "peekOfCode": "class MultiReporter:\n    \"\"\"Reports messages and layouts in plain text.\"\"\"\n    name = \"_internal_multi_reporter\"\n    # Note: do not register this reporter with linter.register_reporter as it is\n    #       not intended to be used directly like a regular reporter, but is\n    #       instead used to implement the\n    #       `--output-format=json:somefile.json,colorized`\n    #       multiple output formats feature\n    extension = \"\"\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.multi_reporter",
        "documentation": {}
    },
    {
        "label": "ReportsHandlerMixIn",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "description": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "peekOfCode": "class ReportsHandlerMixIn:\n    \"\"\"A mix-in class containing all the reports and stats manipulation\n    related methods for the main lint class.\n    \"\"\"\n    def __init__(self) -> None:\n        self._reports: ReportsDict = collections.defaultdict(list)\n        self._reports_state: dict[str, bool] = {}\n    def report_order(self) -> MutableSequence[BaseChecker]:\n        \"\"\"Return a list of reporters.\"\"\"\n        return list(self._reports)",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "documentation": {}
    },
    {
        "label": "ReportsDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "description": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "peekOfCode": "ReportsDict = DefaultDict[\"BaseChecker\", List[Tuple[str, str, ReportsCallable]]]\nclass ReportsHandlerMixIn:\n    \"\"\"A mix-in class containing all the reports and stats manipulation\n    related methods for the main lint class.\n    \"\"\"\n    def __init__(self) -> None:\n        self._reports: ReportsDict = collections.defaultdict(list)\n        self._reports_state: dict[str, bool] = {}\n    def report_order(self) -> MutableSequence[BaseChecker]:\n        \"\"\"Return a list of reporters.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.reports_handler_mix_in",
        "documentation": {}
    },
    {
        "label": "MessageStyle",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class MessageStyle(NamedTuple):\n    \"\"\"Styling of a message.\"\"\"\n    color: str | None\n    \"\"\"The color name (see `ANSI_COLORS` for available values)\n    or the color number when 256 colors are available.\n    \"\"\"\n    style: tuple[str, ...] = ()\n    \"\"\"Tuple of style strings (see `ANSI_COLORS` for available values).\"\"\"\nColorMappingDict = Dict[str, MessageStyle]\nTITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "TextReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class TextReporter(BaseReporter):\n    \"\"\"Reports messages and layouts in plain text.\"\"\"\n    name = \"text\"\n    extension = \"txt\"\n    line_format = \"{path}:{line}:{column}: {msg_id}: {msg} ({symbol})\"\n    def __init__(self, output: TextIO | None = None) -> None:\n        super().__init__(output)\n        self._modules: set[str] = set()\n        self._template = self.line_format\n        self._fixed_template = self.line_format",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "NoHeaderReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class NoHeaderReporter(TextReporter):\n    \"\"\"Reports messages and layouts in plain text without a module header.\"\"\"\n    name = \"no-header\"\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Write message(s) without module header.\"\"\"\n        if msg.module not in self._modules:\n            self._modules.add(msg.module)\n        self.write_message(msg)\nclass ParseableTextReporter(TextReporter):\n    \"\"\"A reporter very similar to TextReporter, but display messages in a form",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ParseableTextReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class ParseableTextReporter(TextReporter):\n    \"\"\"A reporter very similar to TextReporter, but display messages in a form\n    recognized by most text editors :\n    <filename>:<linenum>:<msg>\n    \"\"\"\n    name = \"parseable\"\n    line_format = \"{path}:{line}: [{msg_id}({symbol}), {obj}] {msg}\"\n    def __init__(self, output: TextIO | None = None) -> None:\n        warnings.warn(\n            f\"{self.name} output format is deprecated. This is equivalent to --msg-template={self.line_format}\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "VSTextReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class VSTextReporter(ParseableTextReporter):\n    \"\"\"Visual studio text reporter.\"\"\"\n    name = \"msvs\"\n    line_format = \"{path}({line}): [{msg_id}({symbol}){obj}] {msg}\"\nclass ColorizedTextReporter(TextReporter):\n    \"\"\"Simple TextReporter that colorizes text output.\"\"\"\n    name = \"colorized\"\n    COLOR_MAPPING: ColorMappingDict = {\n        \"I\": MessageStyle(\"green\"),\n        \"C\": MessageStyle(None, (\"bold\",)),",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ColorizedTextReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "class ColorizedTextReporter(TextReporter):\n    \"\"\"Simple TextReporter that colorizes text output.\"\"\"\n    name = \"colorized\"\n    COLOR_MAPPING: ColorMappingDict = {\n        \"I\": MessageStyle(\"green\"),\n        \"C\": MessageStyle(None, (\"bold\",)),\n        \"R\": MessageStyle(\"magenta\", (\"bold\", \"italic\")),\n        \"W\": MessageStyle(\"magenta\"),\n        \"E\": MessageStyle(\"red\", (\"bold\",)),\n        \"F\": MessageStyle(\"red\", (\"bold\", \"underline\")),",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "colorize_ansi",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "def colorize_ansi(\n    msg: str,\n    msg_style: MessageStyle | None = ...,\n) -> str:\n    ...\n@overload\ndef colorize_ansi(\n    msg: str,\n    msg_style: str | None = ...,\n    style: str = ...,",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "colorize_ansi",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "def colorize_ansi(\n    msg: str,\n    msg_style: str | None = ...,\n    style: str = ...,\n    *,\n    color: str | None = ...,\n) -> str:\n    # Remove for pylint 3.0\n    ...\ndef colorize_ansi(",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "colorize_ansi",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "def colorize_ansi(\n    msg: str,\n    msg_style: MessageStyle | str | None = None,\n    style: str = \"\",\n    **kwargs: str | None,\n) -> str:\n    r\"\"\"colorize message by wrapping it with ANSI escape codes\n    :param msg: the message string to colorize\n    :param msg_style: the message style\n        or color (for backwards compatibility): the color of the message style",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "make_header",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "def make_header(msg: Message) -> str:\n    return f\"************* Module {msg.module}\"\nclass TextReporter(BaseReporter):\n    \"\"\"Reports messages and layouts in plain text.\"\"\"\n    name = \"text\"\n    extension = \"txt\"\n    line_format = \"{path}:{line}:{column}: {msg_id}: {msg} ({symbol})\"\n    def __init__(self, output: TextIO | None = None) -> None:\n        super().__init__(output)\n        self._modules: set[str] = set()",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "def register(linter: PyLinter) -> None:\n    linter.register_reporter(TextReporter)\n    linter.register_reporter(NoHeaderReporter)\n    linter.register_reporter(ParseableTextReporter)\n    linter.register_reporter(VSTextReporter)\n    linter.register_reporter(ColorizedTextReporter)",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ColorMappingDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ColorMappingDict = Dict[str, MessageStyle]\nTITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]\nANSI_PREFIX = \"\\033[\"\nANSI_END = \"m\"\nANSI_RESET = \"\\033[0m\"\nANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "TITLE_UNDERLINES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "TITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]\nANSI_PREFIX = \"\\033[\"\nANSI_END = \"m\"\nANSI_RESET = \"\\033[0m\"\nANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",\n    \"blink\": \"5\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ANSI_PREFIX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ANSI_PREFIX = \"\\033[\"\nANSI_END = \"m\"\nANSI_RESET = \"\\033[0m\"\nANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",\n    \"blink\": \"5\",\n    \"inverse\": \"7\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ANSI_END",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ANSI_END = \"m\"\nANSI_RESET = \"\\033[0m\"\nANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",\n    \"blink\": \"5\",\n    \"inverse\": \"7\",\n    \"strike\": \"9\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ANSI_RESET",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ANSI_RESET = \"\\033[0m\"\nANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",\n    \"blink\": \"5\",\n    \"inverse\": \"7\",\n    \"strike\": \"9\",\n}",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ANSI_STYLES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ANSI_STYLES = {\n    \"reset\": \"0\",\n    \"bold\": \"1\",\n    \"italic\": \"3\",\n    \"underline\": \"4\",\n    \"blink\": \"5\",\n    \"inverse\": \"7\",\n    \"strike\": \"9\",\n}\nANSI_COLORS = {",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "ANSI_COLORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "ANSI_COLORS = {\n    \"reset\": \"0\",\n    \"black\": \"30\",\n    \"red\": \"31\",\n    \"green\": \"32\",\n    \"yellow\": \"33\",\n    \"blue\": \"34\",\n    \"magenta\": \"35\",\n    \"cyan\": \"36\",\n    \"white\": \"37\",",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "MESSAGE_FIELDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.reporters.text",
        "description": "__pypackages__.3.10.lib.pylint.reporters.text",
        "peekOfCode": "MESSAGE_FIELDS = {i.name for i in fields(Message)}\n\"\"\"All fields of the Message class.\"\"\"\ndef _get_ansi_code(msg_style: MessageStyle) -> str:\n    \"\"\"Return ANSI escape code corresponding to color and style.\n    :param msg_style: the message style\n    :raise KeyError: if a nonexistent color or style identifier is given\n    :return: the built escape code\n    \"\"\"\n    ansi_code = [ANSI_STYLES[effect] for effect in msg_style.style]\n    if msg_style.color:",
        "detail": "__pypackages__.3.10.lib.pylint.reporters.text",
        "documentation": {}
    },
    {
        "label": "PackageToLint",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "peekOfCode": "class PackageToLint:\n    \"\"\"Represents data about a package to be tested during primer tests.\"\"\"\n    url: str\n    \"\"\"URL of the repository to clone.\"\"\"\n    branch: str\n    \"\"\"Branch of the repository to clone.\"\"\"\n    directories: list[str]\n    \"\"\"Directories within the repository to run pylint over.\"\"\"\n    commit: str | None\n    \"\"\"Commit hash to pin the repository on.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "documentation": {}
    },
    {
        "label": "PRIMER_DIRECTORY_PATH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "peekOfCode": "PRIMER_DIRECTORY_PATH = Path(\"tests\") / \".pylint_primer_tests\"\nclass PackageToLint:\n    \"\"\"Represents data about a package to be tested during primer tests.\"\"\"\n    url: str\n    \"\"\"URL of the repository to clone.\"\"\"\n    branch: str\n    \"\"\"Branch of the repository to clone.\"\"\"\n    directories: list[str]\n    \"\"\"Directories within the repository to run pylint over.\"\"\"\n    commit: str | None",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.package_to_lint",
        "documentation": {}
    },
    {
        "label": "Primer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer",
        "peekOfCode": "class Primer:\n    \"\"\"Main class to handle priming of packages.\"\"\"\n    def __init__(self, primer_directory: Path, json_path: Path) -> None:\n        # Preparing arguments\n        self.primer_directory = primer_directory\n        self._argument_parser = argparse.ArgumentParser(prog=\"Pylint Primer\")\n        self._subparsers = self._argument_parser.add_subparsers(\n            dest=\"command\", required=True\n        )\n        # All arguments for the prepare parser",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer",
        "documentation": {}
    },
    {
        "label": "PackageData",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "peekOfCode": "class PackageData(TypedDict):\n    commit: str\n    messages: list[OldJsonExport]\nPackageMessages = Dict[str, PackageData]\nclass PrimerCommand:\n    \"\"\"Generic primer action with required arguments.\"\"\"\n    def __init__(\n        self,\n        primer_directory: Path,\n        packages: dict[str, PackageToLint],",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PrimerCommand",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "peekOfCode": "class PrimerCommand:\n    \"\"\"Generic primer action with required arguments.\"\"\"\n    def __init__(\n        self,\n        primer_directory: Path,\n        packages: dict[str, PackageToLint],\n        config: argparse.Namespace,\n    ) -> None:\n        self.primer_directory = primer_directory\n        self.packages = packages",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "PackageMessages",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "peekOfCode": "PackageMessages = Dict[str, PackageData]\nclass PrimerCommand:\n    \"\"\"Generic primer action with required arguments.\"\"\"\n    def __init__(\n        self,\n        primer_directory: Path,\n        packages: dict[str, PackageToLint],\n        config: argparse.Namespace,\n    ) -> None:\n        self.primer_directory = primer_directory",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_command",
        "documentation": {}
    },
    {
        "label": "CompareCommand",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "peekOfCode": "class CompareCommand(PrimerCommand):\n    def run(self) -> None:\n        main_data = self._load_json(self.config.base_file)\n        pr_data = self._load_json(self.config.new_file)\n        missing_messages_data, new_messages_data = self._cross_reference(\n            main_data, pr_data\n        )\n        comment = self._create_comment(missing_messages_data, new_messages_data)\n        with open(self.primer_directory / \"comment.txt\", \"w\", encoding=\"utf-8\") as f:\n            f.write(comment)",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "documentation": {}
    },
    {
        "label": "MAX_GITHUB_COMMENT_LENGTH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "peekOfCode": "MAX_GITHUB_COMMENT_LENGTH = 65536\nclass CompareCommand(PrimerCommand):\n    def run(self) -> None:\n        main_data = self._load_json(self.config.base_file)\n        pr_data = self._load_json(self.config.new_file)\n        missing_messages_data, new_messages_data = self._cross_reference(\n            main_data, pr_data\n        )\n        comment = self._create_comment(missing_messages_data, new_messages_data)\n        with open(self.primer_directory / \"comment.txt\", \"w\", encoding=\"utf-8\") as f:",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_compare_command",
        "documentation": {}
    },
    {
        "label": "PrepareCommand",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_prepare_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_prepare_command",
        "peekOfCode": "class PrepareCommand(PrimerCommand):\n    def run(self) -> None:\n        commit_string = \"\"\n        version_string = \".\".join(str(x) for x in sys.version_info[:2])\n        if self.config.clone:\n            for package, data in self.packages.items():\n                local_commit = data.lazy_clone()\n                print(f\"Cloned '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit + \"_\"\n        elif self.config.check:",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_prepare_command",
        "documentation": {}
    },
    {
        "label": "RunCommand",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "peekOfCode": "class RunCommand(PrimerCommand):\n    def run(self) -> None:\n        packages: PackageMessages = {}\n        fatal_msgs: list[Message] = []\n        for package, data in self.packages.items():\n            messages, p_fatal_msgs = self._lint_package(package, data)\n            fatal_msgs += p_fatal_msgs\n            local_commit = Repo(data.clone_directory).head.object.hexsha\n            packages[package] = PackageData(commit=local_commit, messages=messages)\n        path = (",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "documentation": {}
    },
    {
        "label": "GITHUB_CRASH_TEMPLATE_LOCATION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "peekOfCode": "GITHUB_CRASH_TEMPLATE_LOCATION = \"/home/runner/.cache\"\nCRASH_TEMPLATE_INTRO = \"There is a pre-filled template\"\nclass RunCommand(PrimerCommand):\n    def run(self) -> None:\n        packages: PackageMessages = {}\n        fatal_msgs: list[Message] = []\n        for package, data in self.packages.items():\n            messages, p_fatal_msgs = self._lint_package(package, data)\n            fatal_msgs += p_fatal_msgs\n            local_commit = Repo(data.clone_directory).head.object.hexsha",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "documentation": {}
    },
    {
        "label": "CRASH_TEMPLATE_INTRO",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "description": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "peekOfCode": "CRASH_TEMPLATE_INTRO = \"There is a pre-filled template\"\nclass RunCommand(PrimerCommand):\n    def run(self) -> None:\n        packages: PackageMessages = {}\n        fatal_msgs: list[Message] = []\n        for package, data in self.packages.items():\n            messages, p_fatal_msgs = self._lint_package(package, data)\n            fatal_msgs += p_fatal_msgs\n            local_commit = Repo(data.clone_directory).head.object.hexsha\n            packages[package] = PackageData(commit=local_commit, messages=messages)",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._primer.primer_run_command",
        "documentation": {}
    },
    {
        "label": "get_functional_test_files_from_directory",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "peekOfCode": "def get_functional_test_files_from_directory(\n    input_dir: Path | str,\n) -> list[FunctionalTestFile]:\n    \"\"\"Get all functional tests in the input_dir.\"\"\"\n    suite = []\n    _check_functional_tests_structure(Path(input_dir))\n    for dirpath, dirnames, filenames in os.walk(input_dir):\n        if dirpath.endswith(\"__pycache__\"):\n            continue\n        dirnames.sort()",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "documentation": {}
    },
    {
        "label": "REASONABLY_DISPLAYABLE_VERTICALLY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "peekOfCode": "REASONABLY_DISPLAYABLE_VERTICALLY = 48\n\"\"\"'Wet finger' number of files that are reasonable to display by an IDE.\"\"\"\nSHOULD_BE_IN_THE_SAME_DIRECTORY = 5\n\"\"\"'Wet finger' as in 'in my settings there are precisely this many'.\"\"\"\nIGNORED_PARENT_DIRS = {\n    \"deprecated_relative_import\",\n    \"ext\",\n    \"regression\",\n    \"regression_02\",\n}",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "documentation": {}
    },
    {
        "label": "SHOULD_BE_IN_THE_SAME_DIRECTORY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "peekOfCode": "SHOULD_BE_IN_THE_SAME_DIRECTORY = 5\n\"\"\"'Wet finger' as in 'in my settings there are precisely this many'.\"\"\"\nIGNORED_PARENT_DIRS = {\n    \"deprecated_relative_import\",\n    \"ext\",\n    \"regression\",\n    \"regression_02\",\n}\n\"\"\"Direct parent directories that should be ignored.\"\"\"\nIGNORED_PARENT_PARENT_DIRS = {",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "documentation": {}
    },
    {
        "label": "IGNORED_PARENT_DIRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "peekOfCode": "IGNORED_PARENT_DIRS = {\n    \"deprecated_relative_import\",\n    \"ext\",\n    \"regression\",\n    \"regression_02\",\n}\n\"\"\"Direct parent directories that should be ignored.\"\"\"\nIGNORED_PARENT_PARENT_DIRS = {\n    \"docparams\",\n    \"deprecated_relative_import\",",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "documentation": {}
    },
    {
        "label": "IGNORED_PARENT_PARENT_DIRS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "peekOfCode": "IGNORED_PARENT_PARENT_DIRS = {\n    \"docparams\",\n    \"deprecated_relative_import\",\n    \"ext\",\n}\n\"\"\"Parents of direct parent directories that should be ignored.\"\"\"\ndef get_functional_test_files_from_directory(\n    input_dir: Path | str,\n) -> list[FunctionalTestFile]:\n    \"\"\"Get all functional tests in the input_dir.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.find_functional_tests",
        "documentation": {}
    },
    {
        "label": "LintModuleOutputUpdate",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.lint_module_output_update",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.lint_module_output_update",
        "peekOfCode": "class LintModuleOutputUpdate(LintModuleTest):\n    \"\"\"Class to be used if expected output files should be updated instead of\n    checked.\n    \"\"\"\n    class TestDialect(csv.excel):\n        \"\"\"Dialect used by the csv writer.\"\"\"\n        delimiter = \":\"\n        lineterminator = \"\\n\"\n    csv.register_dialect(\"test\", TestDialect)\n    def __init__(",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.lint_module_output_update",
        "documentation": {}
    },
    {
        "label": "NoFileError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "peekOfCode": "class NoFileError(Exception):\n    pass\nif sys.version_info >= (3, 8):\n    from typing import TypedDict\nelse:\n    from typing_extensions import TypedDict\nclass TestFileOptions(TypedDict):\n    min_pyver: tuple[int, ...]\n    max_pyver: tuple[int, ...]\n    min_pyver_end_position: tuple[int, ...]",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "TestFileOptions",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "peekOfCode": "class TestFileOptions(TypedDict):\n    min_pyver: tuple[int, ...]\n    max_pyver: tuple[int, ...]\n    min_pyver_end_position: tuple[int, ...]\n    requires: list[str]\n    except_implementations: list[str]\n    exclude_platforms: list[str]\n    exclude_from_minimal_messages_config: bool\n# mypy need something literal, we can't create this dynamically from TestFileOptions\nPOSSIBLE_TEST_OPTIONS = {",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "FunctionalTestFile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "peekOfCode": "class FunctionalTestFile:\n    \"\"\"A single functional test case file with options.\"\"\"\n    _CONVERTERS: dict[str, Callable[[str], tuple[int, ...] | list[str]]] = {\n        \"min_pyver\": parse_python_version,\n        \"max_pyver\": parse_python_version,\n        \"min_pyver_end_position\": parse_python_version,\n        \"requires\": lambda s: [i.strip() for i in s.split(\",\")],\n        \"except_implementations\": lambda s: [i.strip() for i in s.split(\",\")],\n        \"exclude_platforms\": lambda s: [i.strip() for i in s.split(\",\")],\n    }",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "parse_python_version",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "peekOfCode": "def parse_python_version(ver_str: str) -> tuple[int, ...]:\n    \"\"\"Convert python version to a tuple of integers for easy comparison.\"\"\"\n    return tuple(int(digit) for digit in ver_str.split(\".\"))\nclass NoFileError(Exception):\n    pass\nif sys.version_info >= (3, 8):\n    from typing import TypedDict\nelse:\n    from typing_extensions import TypedDict\nclass TestFileOptions(TypedDict):",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "POSSIBLE_TEST_OPTIONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "peekOfCode": "POSSIBLE_TEST_OPTIONS = {\n    \"min_pyver\",\n    \"max_pyver\",\n    \"min_pyver_end_position\",\n    \"requires\",\n    \"except_implementations\",\n    \"exclude_platforms\",\n    \"exclude_from_minimal_messages_config\",\n}\nclass FunctionalTestFile:",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional.test_file",
        "documentation": {}
    },
    {
        "label": "_Run",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils._run",
        "description": "__pypackages__.3.10.lib.pylint.testutils._run",
        "peekOfCode": "class _Run(LintRun):\n    \"\"\"Like Run, but we're using an explicitly set empty pylintrc.\n    We don't want to use the project's pylintrc during tests, because\n    it means that a change in our config could break tests.\n    But we want to see if the changes to the default break tests.\n    \"\"\"\n    def __init__(\n        self,\n        args: Sequence[str],\n        reporter: BaseReporter | None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.testutils._run",
        "documentation": {}
    },
    {
        "label": "CheckerTestCase",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.checker_test_case",
        "description": "__pypackages__.3.10.lib.pylint.testutils.checker_test_case",
        "peekOfCode": "class CheckerTestCase:\n    \"\"\"A base testcase class for unit testing individual checker classes.\"\"\"\n    # TODO: Figure out way to type this as type[BaseChecker] while also\n    # setting self.checker correctly.\n    CHECKER_CLASS: Any\n    CONFIG: dict[str, Any] = {}\n    def setup_method(self) -> None:\n        self.linter = UnittestLinter()\n        self.checker = self.CHECKER_CLASS(self.linter)\n        for key, value in self.CONFIG.items():",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.checker_test_case",
        "documentation": {}
    },
    {
        "label": "get_expected_or_default",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "def get_expected_or_default(\n    tested_configuration_file: str | Path,\n    suffix: str,\n    default: str,\n) -> str:\n    \"\"\"Return the expected value from the file if it exists, or the given default.\"\"\"\n    expected = default\n    path = Path(tested_configuration_file)\n    expected_result_path = path.parent / f\"{path.stem}.{suffix}\"\n    if expected_result_path.exists():",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "get_expected_configuration",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "def get_expected_configuration(\n    configuration_path: str, default_configuration: PylintConfiguration\n) -> PylintConfiguration:\n    \"\"\"Get the expected parsed configuration of a configuration functional test.\"\"\"\n    result = copy.deepcopy(default_configuration)\n    config_as_json = get_expected_or_default(\n        configuration_path, suffix=\"result.json\", default=\"{}\"\n    )\n    to_override = json.loads(config_as_json)\n    for key, value in to_override.items():",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "get_related_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "def get_related_files(\n    tested_configuration_file: str | Path, suffix_filter: str\n) -> list[Path]:\n    \"\"\"Return all the file related to a test conf file ending with a suffix.\"\"\"\n    conf_path = Path(tested_configuration_file)\n    return [\n        p\n        for p in conf_path.parent.iterdir()\n        if str(p.stem).startswith(conf_path.stem) and str(p).endswith(suffix_filter)\n    ]",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "get_expected_output",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "def get_expected_output(\n    configuration_path: str | Path, user_specific_path: Path\n) -> tuple[int, str]:\n    \"\"\"Get the expected output of a functional test.\"\"\"\n    exit_code = 0\n    msg = (\n        \"we expect a single file of the form 'filename.32.out' where 'filename' represents \"\n        \"the name of the configuration file, and '32' the expected error code.\"\n    )\n    possible_out_files = get_related_files(configuration_path, suffix_filter=\"out\")",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "run_using_a_configuration_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "def run_using_a_configuration_file(\n    configuration_path: Path | str, file_to_lint: str = __file__\n) -> tuple[Mock, Mock, Run]:\n    \"\"\"Simulate a run with a configuration without really launching the checks.\"\"\"\n    configuration_path = str(configuration_path)\n    args = [\"--rcfile\", configuration_path, file_to_lint]\n    # We do not capture the `SystemExit` as then the `runner` variable\n    # would not be accessible outside the `with` block.\n    with unittest.mock.patch(\"sys.exit\") as mocked_exit:\n        # Do not actually run checks, that could be slow. We don't mock",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "ConfigurationValue",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "ConfigurationValue = Any\nPylintConfiguration = Dict[str, ConfigurationValue]\nif not PY38_PLUS:\n    # We need to deepcopy a compiled regex pattern\n    # In python 3.6 and 3.7 this requires a hack\n    # See https://stackoverflow.com/a/56935186\n    copy._deepcopy_dispatch[type(re.compile(\"\"))] = lambda r, _: r  # type: ignore[attr-defined]\ndef get_expected_or_default(\n    tested_configuration_file: str | Path,\n    suffix: str,",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "PylintConfiguration",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "PylintConfiguration = Dict[str, ConfigurationValue]\nif not PY38_PLUS:\n    # We need to deepcopy a compiled regex pattern\n    # In python 3.6 and 3.7 this requires a hack\n    # See https://stackoverflow.com/a/56935186\n    copy._deepcopy_dispatch[type(re.compile(\"\"))] = lambda r, _: r  # type: ignore[attr-defined]\ndef get_expected_or_default(\n    tested_configuration_file: str | Path,\n    suffix: str,\n    default: str,",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_CONF_APPEND_KEY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "EXPECTED_CONF_APPEND_KEY = \"functional_append\"\nEXPECTED_CONF_REMOVE_KEY = \"functional_remove\"\ndef get_expected_configuration(\n    configuration_path: str, default_configuration: PylintConfiguration\n) -> PylintConfiguration:\n    \"\"\"Get the expected parsed configuration of a configuration functional test.\"\"\"\n    result = copy.deepcopy(default_configuration)\n    config_as_json = get_expected_or_default(\n        configuration_path, suffix=\"result.json\", default=\"{}\"\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_CONF_REMOVE_KEY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "peekOfCode": "EXPECTED_CONF_REMOVE_KEY = \"functional_remove\"\ndef get_expected_configuration(\n    configuration_path: str, default_configuration: PylintConfiguration\n) -> PylintConfiguration:\n    \"\"\"Get the expected parsed configuration of a configuration functional test.\"\"\"\n    result = copy.deepcopy(default_configuration)\n    config_as_json = get_expected_or_default(\n        configuration_path, suffix=\"result.json\", default=\"{}\"\n    )\n    to_override = json.loads(config_as_json)",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.configuration_test",
        "documentation": {}
    },
    {
        "label": "SYS_VERS_STR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "SYS_VERS_STR = (\n    \"%d%d%d\" % sys.version_info[:3]  # pylint: disable=consider-using-f-string\n)\nTITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]\nUPDATE_OPTION = \"--update-functional-output\"\nUPDATE_FILE = Path(\"pylint-functional-test-update\")\n# Common sub-expressions.\n_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "TITLE_UNDERLINES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "TITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]\nUPDATE_OPTION = \"--update-functional-output\"\nUPDATE_FILE = Path(\"pylint-functional-test-update\")\n# Common sub-expressions.\n_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),\n#  - followed by a line number with a +/- (optional),\n#  - followed by a list of bracketed message symbols.\n# Used to extract expected messages from testdata files.",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "UPDATE_OPTION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "UPDATE_OPTION = \"--update-functional-output\"\nUPDATE_FILE = Path(\"pylint-functional-test-update\")\n# Common sub-expressions.\n_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),\n#  - followed by a line number with a +/- (optional),\n#  - followed by a list of bracketed message symbols.\n# Used to extract expected messages from testdata files.\n_EXPECTED_RE = re.compile(",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "UPDATE_FILE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "UPDATE_FILE = Path(\"pylint-functional-test-update\")\n# Common sub-expressions.\n_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),\n#  - followed by a line number with a +/- (optional),\n#  - followed by a list of bracketed message symbols.\n# Used to extract expected messages from testdata files.\n_EXPECTED_RE = re.compile(\n    r\"\\s*#\\s*(?:(?P<line>[+-]?[0-9]+):)?\"  # pylint: disable=consider-using-f-string",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "_MESSAGE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),\n#  - followed by a line number with a +/- (optional),\n#  - followed by a list of bracketed message symbols.\n# Used to extract expected messages from testdata files.\n_EXPECTED_RE = re.compile(\n    r\"\\s*#\\s*(?:(?P<line>[+-]?[0-9]+):)?\"  # pylint: disable=consider-using-f-string\n    r\"(?:(?P<op>[><=]+) *(?P<version>[0-9.]+):)?\"\n    r\"\\s*\\[(?P<msgs>%(msg)s(?:,\\s*%(msg)s)*)]\" % _MESSAGE",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "_EXPECTED_RE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "_EXPECTED_RE = re.compile(\n    r\"\\s*#\\s*(?:(?P<line>[+-]?[0-9]+):)?\"  # pylint: disable=consider-using-f-string\n    r\"(?:(?P<op>[><=]+) *(?P<version>[0-9.]+):)?\"\n    r\"\\s*\\[(?P<msgs>%(msg)s(?:,\\s*%(msg)s)*)]\" % _MESSAGE\n)\n_OPERATORS = {\">\": operator.gt, \"<\": operator.lt, \">=\": operator.ge, \"<=\": operator.le}",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "description": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "peekOfCode": "_OPERATORS = {\">\": operator.gt, \"<\": operator.lt, \">=\": operator.ge, \"<=\": operator.le}",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.constants",
        "documentation": {}
    },
    {
        "label": "set_config",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.decorator",
        "description": "__pypackages__.3.10.lib.pylint.testutils.decorator",
        "peekOfCode": "def set_config(**kwargs: Any) -> Callable[[Callable[..., None]], Callable[..., None]]:\n    \"\"\"Decorator for setting an option on the linter.\n    Passing the args and kwargs back to the test function itself\n    allows this decorator to be used on parameterized test cases.\n    \"\"\"\n    def _wrapper(fun: Callable[..., None]) -> Callable[..., None]:\n        @functools.wraps(fun)\n        def _forward(\n            self: CheckerTestCase, *args: Any, **test_function_kwargs: Any\n        ) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.decorator",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.functional_test_file",
        "description": "__pypackages__.3.10.lib.pylint.testutils.functional_test_file",
        "peekOfCode": "__all__ = [\n    \"FunctionalTestFile\",\n    \"NoFileError\",\n    \"parse_python_version\",\n]\nimport warnings\nfrom pylint.testutils.functional import (\n    FunctionalTestFile,\n    NoFileError,\n    parse_python_version,",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.functional_test_file",
        "documentation": {}
    },
    {
        "label": "create_test_linter",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "description": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "peekOfCode": "def create_test_linter() -> PyLinter:\n    test_reporter = GenericTestReporter()\n    linter_ = PyLinter()\n    linter_.set_reporter(test_reporter)\n    linter_.config.persistent = 0\n    checkers.initialize(linter_)\n    return linter_\n# Can't be renamed to a constant (easily), it breaks countless tests\nlinter = create_test_linter()",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "documentation": {}
    },
    {
        "label": "linter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "description": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "peekOfCode": "linter = create_test_linter()",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.global_test_linter",
        "documentation": {}
    },
    {
        "label": "LintModuleTest",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "peekOfCode": "class LintModuleTest:\n    maxDiff = None\n    def __init__(\n        self, test_file: FunctionalTestFile, config: Config | None = None\n    ) -> None:\n        _test_reporter = FunctionalTestReporter()\n        self._linter = PyLinter()\n        self._linter.config.persistent = 0\n        checkers.initialize(self._linter)\n        # See if test has its own .rc file, if so we use that one",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "MessageCounter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "peekOfCode": "MessageCounter = CounterType[Tuple[int, str]]\nPYLINTRC = Path(__file__).parent / \"testing_pylintrc\"\nclass LintModuleTest:\n    maxDiff = None\n    def __init__(\n        self, test_file: FunctionalTestFile, config: Config | None = None\n    ) -> None:\n        _test_reporter = FunctionalTestReporter()\n        self._linter = PyLinter()\n        self._linter.config.persistent = 0",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "PYLINTRC",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "description": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "peekOfCode": "PYLINTRC = Path(__file__).parent / \"testing_pylintrc\"\nclass LintModuleTest:\n    maxDiff = None\n    def __init__(\n        self, test_file: FunctionalTestFile, config: Config | None = None\n    ) -> None:\n        _test_reporter = FunctionalTestReporter()\n        self._linter = PyLinter()\n        self._linter.config.persistent = 0\n        checkers.initialize(self._linter)",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.lint_module_test",
        "documentation": {}
    },
    {
        "label": "MessageTest",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "description": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "peekOfCode": "class MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "OutputLine",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "description": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "peekOfCode": "class OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n    @classmethod",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "description": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "peekOfCode": "_T = TypeVar(\"_T\")\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.output_line",
        "documentation": {}
    },
    {
        "label": "PyreverseConfig",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "description": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "peekOfCode": "class PyreverseConfig(\n    argparse.Namespace\n):  # pylint: disable=too-many-instance-attributes, too-many-arguments\n    \"\"\"Holds the configuration options for Pyreverse.\n    The default values correspond to the defaults of the options' parser.\n    \"\"\"\n    def __init__(\n        self,\n        mode: str = \"PUB_ONLY\",\n        classes: list[str] | None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "documentation": {}
    },
    {
        "label": "TestFileOptions",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "description": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "peekOfCode": "class TestFileOptions(TypedDict):\n    output_formats: list[str]\n    command_line_args: list[str]\nclass FunctionalPyreverseTestfile(NamedTuple):\n    \"\"\"Named tuple containing the test file and the expected output.\"\"\"\n    source: Path\n    options: TestFileOptions\ndef get_functional_test_files(\n    root_directory: Path,\n) -> list[FunctionalPyreverseTestfile]:",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "documentation": {}
    },
    {
        "label": "FunctionalPyreverseTestfile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "description": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "peekOfCode": "class FunctionalPyreverseTestfile(NamedTuple):\n    \"\"\"Named tuple containing the test file and the expected output.\"\"\"\n    source: Path\n    options: TestFileOptions\ndef get_functional_test_files(\n    root_directory: Path,\n) -> list[FunctionalPyreverseTestfile]:\n    \"\"\"Get all functional test files from the given directory.\"\"\"\n    test_files = []\n    for path in root_directory.rglob(\"*.py\"):",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "documentation": {}
    },
    {
        "label": "get_functional_test_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "description": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "peekOfCode": "def get_functional_test_files(\n    root_directory: Path,\n) -> list[FunctionalPyreverseTestfile]:\n    \"\"\"Get all functional test files from the given directory.\"\"\"\n    test_files = []\n    for path in root_directory.rglob(\"*.py\"):\n        if path.stem.startswith(\"_\"):\n            continue\n        config_file = path.with_suffix(\".rc\")\n        if config_file.exists():",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.pyreverse",
        "documentation": {}
    },
    {
        "label": "GenericTestReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "peekOfCode": "class GenericTestReporter(BaseReporter):\n    \"\"\"Reporter storing plain text messages.\"\"\"\n    out: StringIO\n    def __init__(  # pylint: disable=super-init-not-called # See https://github.com/PyCQA/pylint/issues/4941\n        self,\n    ) -> None:\n        self.path_strip_prefix: str = getcwd() + sep\n        self.reset()\n    def reset(self) -> None:\n        self.out = StringIO()",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "documentation": {}
    },
    {
        "label": "MinimalTestReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "peekOfCode": "class MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n    def _display(self, layout: Section) -> None:\n        pass\nclass FunctionalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts and don't call self._display().\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "documentation": {}
    },
    {
        "label": "FunctionalTestReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "description": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "peekOfCode": "class FunctionalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts and don't call self._display().\"\"\"\n    def _display(self, layout: Section) -> None:\n        pass",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.reporter_for_tests",
        "documentation": {}
    },
    {
        "label": "UnittestLinter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.unittest_linter",
        "description": "__pypackages__.3.10.lib.pylint.testutils.unittest_linter",
        "peekOfCode": "class UnittestLinter(PyLinter):\n    \"\"\"A fake linter class to capture checker messages.\"\"\"\n    def __init__(self) -> None:\n        self._messages: list[MessageTest] = []\n        super().__init__()\n    def release_messages(self) -> list[MessageTest]:\n        try:\n            return self._messages\n        finally:\n            self._messages = []",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.unittest_linter",
        "documentation": {}
    },
    {
        "label": "create_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.testutils.utils",
        "description": "__pypackages__.3.10.lib.pylint.testutils.utils",
        "peekOfCode": "def create_files(paths: list[str], chroot: str = \".\") -> None:\n    \"\"\"Creates directories and files found in <path>.\n    :param list paths: list of relative paths to files or directories\n    :param str chroot: the root directory in which paths will be created\n    >>> from os.path import isdir, isfile\n    >>> isdir('/tmp/a')\n    False\n    >>> create_files(['a/b/foo.py', 'a/b/c/', 'a/b/c/d/e.py'], '/tmp')\n    >>> isdir('/tmp/a')\n    True",
        "detail": "__pypackages__.3.10.lib.pylint.testutils.utils",
        "documentation": {}
    },
    {
        "label": "ASTWalker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "description": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "peekOfCode": "class ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):",
        "detail": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "documentation": {}
    },
    {
        "label": "AstCallback",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "description": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "peekOfCode": "AstCallback = Callable[[nodes.NodeNG], None]\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n    def _is_method_enabled(self, method: AstCallback) -> bool:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.ast_walker",
        "documentation": {}
    },
    {
        "label": "print_full_documentation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.docs",
        "description": "__pypackages__.3.10.lib.pylint.utils.docs",
        "peekOfCode": "def print_full_documentation(\n    linter: PyLinter, stream: TextIO = sys.stdout, show_options: bool = True\n) -> None:\n    \"\"\"Output a full documentation in ReST format.\"\"\"\n    print(\n        _get_checkers_documentation(linter, show_options=show_options)[:-3], file=stream\n    )",
        "detail": "__pypackages__.3.10.lib.pylint.utils.docs",
        "documentation": {}
    },
    {
        "label": "FileState",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "description": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "peekOfCode": "class FileState:\n    \"\"\"Hold internal state specific to the currently analyzed file.\"\"\"\n    def __init__(\n        self,\n        modname: str | None = None,\n        msg_store: MessageDefinitionStore | None = None,\n        node: nodes.Module | None = None,\n        *,\n        is_base_filestate: bool = False,\n    ) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "documentation": {}
    },
    {
        "label": "MessageStateDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "description": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "peekOfCode": "MessageStateDict = Dict[str, Dict[int, bool]]\nclass FileState:\n    \"\"\"Hold internal state specific to the currently analyzed file.\"\"\"\n    def __init__(\n        self,\n        modname: str | None = None,\n        msg_store: MessageDefinitionStore | None = None,\n        node: nodes.Module | None = None,\n        *,\n        is_base_filestate: bool = False,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.file_state",
        "documentation": {}
    },
    {
        "label": "BadNames",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class BadNames(TypedDict):\n    \"\"\"TypedDict to store counts of node types with bad names.\"\"\"\n    argument: int\n    attr: int\n    klass: int\n    class_attribute: int\n    class_const: int\n    const: int\n    inlinevar: int\n    function: int",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "CodeTypeCount",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class CodeTypeCount(TypedDict):\n    \"\"\"TypedDict to store counts of lines of code types.\"\"\"\n    code: int\n    comment: int\n    docstring: int\n    empty: int\n    total: int\nclass DuplicatedLines(TypedDict):\n    \"\"\"TypedDict to store counts of lines of duplicated code.\"\"\"\n    nb_duplicated_lines: int",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "DuplicatedLines",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class DuplicatedLines(TypedDict):\n    \"\"\"TypedDict to store counts of lines of duplicated code.\"\"\"\n    nb_duplicated_lines: int\n    percent_duplicated_lines: float\nclass NodeCount(TypedDict):\n    \"\"\"TypedDict to store counts of different types of nodes.\"\"\"\n    function: int\n    klass: int\n    method: int\n    module: int",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "NodeCount",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class NodeCount(TypedDict):\n    \"\"\"TypedDict to store counts of different types of nodes.\"\"\"\n    function: int\n    klass: int\n    method: int\n    module: int\nclass UndocumentedNodes(TypedDict):\n    \"\"\"TypedDict to store counts of undocumented node types.\"\"\"\n    function: int\n    klass: int",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "UndocumentedNodes",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class UndocumentedNodes(TypedDict):\n    \"\"\"TypedDict to store counts of undocumented node types.\"\"\"\n    function: int\n    klass: int\n    method: int\n    module: int\nclass ModuleStats(TypedDict):\n    \"\"\"TypedDict to store counts of types of messages and statements.\"\"\"\n    convention: int\n    error: int",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "ModuleStats",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class ModuleStats(TypedDict):\n    \"\"\"TypedDict to store counts of types of messages and statements.\"\"\"\n    convention: int\n    error: int\n    fatal: int\n    info: int\n    refactor: int\n    statement: int\n    warning: int\n# pylint: disable-next=too-many-instance-attributes",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "LinterStats",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "class LinterStats:\n    \"\"\"Class used to linter stats.\"\"\"\n    def __init__(\n        self,\n        bad_names: BadNames | None = None,\n        by_module: dict[str, ModuleStats] | None = None,\n        by_msg: dict[str, int] | None = None,\n        code_type_count: CodeTypeCount | None = None,\n        dependencies: dict[str, set[str]] | None = None,\n        duplicated_lines: DuplicatedLines | None = None,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "merge_stats",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "description": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "peekOfCode": "def merge_stats(stats: list[LinterStats]) -> LinterStats:\n    \"\"\"Used to merge multiple stats objects into a new one when pylint is run in\n    parallel mode.\n    \"\"\"\n    merged = LinterStats()\n    for stat in stats:\n        merged.bad_names[\"argument\"] += stat.bad_names[\"argument\"]\n        merged.bad_names[\"attr\"] += stat.bad_names[\"attr\"]\n        merged.bad_names[\"klass\"] += stat.bad_names[\"klass\"]\n        merged.bad_names[\"class_attribute\"] += stat.bad_names[\"class_attribute\"]",
        "detail": "__pypackages__.3.10.lib.pylint.utils.linterstats",
        "documentation": {}
    },
    {
        "label": "PragmaRepresenter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "class PragmaRepresenter(NamedTuple):\n    action: str\n    messages: list[str]\nATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "PragmaParserError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "class PragmaParserError(Exception):\n    \"\"\"A class for exceptions thrown by pragma_parser module.\"\"\"\n    def __init__(self, message: str, token: str) -> None:\n        \"\"\":args message: explain the reason why the exception has been thrown\n        :args token: token concerned by the exception.\n        \"\"\"\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\nclass UnRecognizedOptionError(PragmaParserError):",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "UnRecognizedOptionError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "class UnRecognizedOptionError(PragmaParserError):\n    \"\"\"Thrown in case the of a valid but unrecognized option.\"\"\"\nclass InvalidPragmaError(PragmaParserError):\n    \"\"\"Thrown in case the pragma is invalid.\"\"\"\ndef parse_pragma(pylint_pragma: str) -> Generator[PragmaRepresenter, None, None]:\n    action: str | None = None\n    messages: list[str] = []\n    assignment_required = False\n    previous_token = \"\"\n    for mo in re.finditer(TOK_REGEX, pylint_pragma):",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "InvalidPragmaError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "class InvalidPragmaError(PragmaParserError):\n    \"\"\"Thrown in case the pragma is invalid.\"\"\"\ndef parse_pragma(pylint_pragma: str) -> Generator[PragmaRepresenter, None, None]:\n    action: str | None = None\n    messages: list[str] = []\n    assignment_required = False\n    previous_token = \"\"\n    for mo in re.finditer(TOK_REGEX, pylint_pragma):\n        kind = mo.lastgroup\n        value = mo.group()",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "emit_pragma_representer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "def emit_pragma_representer(action: str, messages: list[str]) -> PragmaRepresenter:\n    if not messages and action in MESSAGE_KEYWORDS:\n        raise InvalidPragmaError(\n            \"The keyword is not followed by message identifier\", action\n        )\n    return PragmaRepresenter(action, messages)\nclass PragmaParserError(Exception):\n    \"\"\"A class for exceptions thrown by pragma_parser module.\"\"\"\n    def __init__(self, message: str, token: str) -> None:\n        \"\"\":args message: explain the reason why the exception has been thrown",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "parse_pragma",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "def parse_pragma(pylint_pragma: str) -> Generator[PragmaRepresenter, None, None]:\n    action: str | None = None\n    messages: list[str] = []\n    assignment_required = False\n    previous_token = \"\"\n    for mo in re.finditer(TOK_REGEX, pylint_pragma):\n        kind = mo.lastgroup\n        value = mo.group()\n        if kind == \"ASSIGN\":\n            if not assignment_required:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "OPTION_RGX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "OPTION_RGX = r\"\"\"\n    (?:^\\s*\\#.*|\\s*|               # Comment line, or whitespaces,\n       \\s*\\#.*(?=\\#.*?\\bpylint:))  # or a beginning of an inline comment\n                                   # followed by \"pylint:\" pragma\n    (\\#                            # Beginning of comment\n    .*?                            # Anything (as little as possible)\n    \\bpylint:                      # pylint word and column\n    \\s*                            # Any number of whitespaces\n    ([^;#\\n]+))                    # Anything except semicolon or hash or\n                                   # newline (it is the second matched group)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "OPTION_PO",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "OPTION_PO = re.compile(OPTION_RGX, re.VERBOSE)\nclass PragmaRepresenter(NamedTuple):\n    action: str\n    messages: list[str]\nATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "ATOMIC_KEYWORDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "ATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,\n# 'disable' string should not be matched instead of 'disable-all'\nALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "MESSAGE_KEYWORDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "MESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,\n# 'disable' string should not be matched instead of 'disable-all'\nALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)\n)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "ALL_KEYWORDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "ALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)\n)\nTOKEN_SPECIFICATION = [\n    (\"KEYWORD\", rf\"\\b({ALL_KEYWORDS:s})\\b\"),\n    (\"MESSAGE_STRING\", r\"[0-9A-Za-z\\-\\_]{2,}\"),  # Identifiers\n    (\"ASSIGN\", r\"=\"),  # Assignment operator\n    (\"MESSAGE_NUMBER\", r\"[CREIWF]{1}\\d*\"),\n]\nTOK_REGEX = \"|\".join(",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "TOKEN_SPECIFICATION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "TOKEN_SPECIFICATION = [\n    (\"KEYWORD\", rf\"\\b({ALL_KEYWORDS:s})\\b\"),\n    (\"MESSAGE_STRING\", r\"[0-9A-Za-z\\-\\_]{2,}\"),  # Identifiers\n    (\"ASSIGN\", r\"=\"),  # Assignment operator\n    (\"MESSAGE_NUMBER\", r\"[CREIWF]{1}\\d*\"),\n]\nTOK_REGEX = \"|\".join(\n    f\"(?P<{token_name:s}>{token_rgx:s})\"\n    for token_name, token_rgx in TOKEN_SPECIFICATION\n)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "TOK_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "description": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "peekOfCode": "TOK_REGEX = \"|\".join(\n    f\"(?P<{token_name:s}>{token_rgx:s})\"\n    for token_name, token_rgx in TOKEN_SPECIFICATION\n)\ndef emit_pragma_representer(action: str, messages: list[str]) -> PragmaRepresenter:\n    if not messages and action in MESSAGE_KEYWORDS:\n        raise InvalidPragmaError(\n            \"The keyword is not followed by message identifier\", action\n        )\n    return PragmaRepresenter(action, messages)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.pragma_parser",
        "documentation": {}
    },
    {
        "label": "IsortDriver",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "class IsortDriver:\n    \"\"\"A wrapper around isort API that changed between versions 4 and 5.\"\"\"\n    def __init__(self, config: argparse.Namespace) -> None:\n        if HAS_ISORT_5:\n            self.isort5_config = isort.settings.Config(\n                # There is no typo here. EXTRA_standard_library is\n                # what most users want. The option has been named\n                # KNOWN_standard_library for ages in pylint, and we\n                # don't want to break compatibility.\n                extra_standard_library=config.known_standard_library,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def normalize_text(\n    text: str, line_len: int = DEFAULT_LINE_LENGTH, indent: str = \"\"\n) -> str:\n    \"\"\"Wrap the text on the given line length.\"\"\"\n    return \"\\n\".join(\n        textwrap.wrap(\n            text, width=line_len, initial_indent=indent, subsequent_indent=indent\n        )\n    )\nCMPS = [\"=\", \"-\", \"+\"]",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "cmp",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def cmp(a: int | float, b: int | float) -> int:\n    return (a > b) - (a < b)\ndef diff_string(old: int | float, new: int | float) -> str:\n    \"\"\"Given an old and new int value, return a string representing the\n    difference.\n    \"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"\n    return diff_str\ndef get_module_and_frameid(node: nodes.NodeNG) -> tuple[str, str]:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "diff_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def diff_string(old: int | float, new: int | float) -> str:\n    \"\"\"Given an old and new int value, return a string representing the\n    difference.\n    \"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"\n    return diff_str\ndef get_module_and_frameid(node: nodes.NodeNG) -> tuple[str, str]:\n    \"\"\"Return the module name and the frame id in the module.\"\"\"\n    frame = node.frame(future=True)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_module_and_frameid",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_module_and_frameid(node: nodes.NodeNG) -> tuple[str, str]:\n    \"\"\"Return the module name and the frame id in the module.\"\"\"\n    frame = node.frame(future=True)\n    module, obj = \"\", []\n    while frame:\n        if isinstance(frame, Module):\n            module = frame.name\n        else:\n            obj.append(getattr(frame, \"name\", \"<lambda>\"))\n        try:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_rst_title",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_rst_title(title: str, character: str) -> str:\n    \"\"\"Permit to get a title formatted as ReStructuredText test (underlined with a\n    chosen character).\n    \"\"\"\n    return f\"{title}\\n{character * len(title)}\\n\"\ndef get_rst_section(\n    section: str | None,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> str:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_rst_section",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_rst_section(\n    section: str | None,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> str:\n    \"\"\"Format an option's section using as a ReStructuredText formatted output.\"\"\"\n    result = \"\"\n    if section:\n        result += get_rst_title(section, \"'\")\n    if doc:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "decoding_stream",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "tokenize_module",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "register_plugins",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker, option: GLOBAL_OPTION_BOOL, default: bool | None = ...\n) -> bool:\n    ...\n@overload\ndef get_global_option(\n    checker: BaseChecker, option: GLOBAL_OPTION_INT, default: int | None = ...\n) -> int:\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker, option: GLOBAL_OPTION_INT, default: int | None = ...\n) -> int:\n    ...\n@overload\ndef get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_LIST,\n    default: list[str] | None = ...,\n) -> list[str]:",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_LIST,\n    default: list[str] | None = ...,\n) -> list[str]:\n    ...\n@overload\ndef get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_PATTERN,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_PATTERN,\n    default: Pattern[str] | None = ...,\n) -> Pattern[str]:\n    ...\n@overload\ndef get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_PATTERN_LIST,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_PATTERN_LIST,\n    default: list[Pattern[str]] | None = ...,\n) -> list[Pattern[str]]:\n    ...\n@overload\ndef get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_TUPLE_INT,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_TUPLE_INT,\n    default: tuple[int, ...] | None = ...,\n) -> tuple[int, ...]:\n    ...\ndef get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_NAMES,\n    default: T_GlobalOptionReturnTypes | None = None,  # pylint: disable=unused-argument",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_global_option",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def get_global_option(\n    checker: BaseChecker,\n    option: GLOBAL_OPTION_NAMES,\n    default: T_GlobalOptionReturnTypes | None = None,  # pylint: disable=unused-argument\n) -> T_GlobalOptionReturnTypes | None | Any:\n    \"\"\"DEPRECATED: Retrieve an option defined by the given *checker* or\n    by all known option providers.\n    It will look in the list of all options providers\n    until the given *option* will be found.\n    If the option wasn't found, the *default* value will be returned.",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_section",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "def format_section(\n    stream: TextIO,\n    section: str,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> None:\n    \"\"\"Format an option's section using the INI format.\"\"\"\n    warnings.warn(\n        \"format_section has been deprecated. It will be removed in pylint 3.0.\",\n        DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LINE_LENGTH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "DEFAULT_LINE_LENGTH = 79\n# These are types used to overload get_global_option() and refer to the options type\nGLOBAL_OPTION_BOOL = Literal[\n    \"suggestion-mode\",\n    \"analyse-fallback-blocks\",\n    \"allow-global-unused-variables\",\n]\nGLOBAL_OPTION_INT = Literal[\"max-line-length\", \"docstring-min-length\"]\nGLOBAL_OPTION_LIST = Literal[\"ignored-modules\"]\nGLOBAL_OPTION_PATTERN = Literal[",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_BOOL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_BOOL = Literal[\n    \"suggestion-mode\",\n    \"analyse-fallback-blocks\",\n    \"allow-global-unused-variables\",\n]\nGLOBAL_OPTION_INT = Literal[\"max-line-length\", \"docstring-min-length\"]\nGLOBAL_OPTION_LIST = Literal[\"ignored-modules\"]\nGLOBAL_OPTION_PATTERN = Literal[\n    \"no-docstring-rgx\",\n    \"dummy-variables-rgx\",",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_INT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_INT = Literal[\"max-line-length\", \"docstring-min-length\"]\nGLOBAL_OPTION_LIST = Literal[\"ignored-modules\"]\nGLOBAL_OPTION_PATTERN = Literal[\n    \"no-docstring-rgx\",\n    \"dummy-variables-rgx\",\n    \"ignored-argument-names\",\n    \"mixin-class-rgx\",\n]\nGLOBAL_OPTION_PATTERN_LIST = Literal[\"exclude-too-few-public-methods\", \"ignore-paths\"]\nGLOBAL_OPTION_TUPLE_INT = Literal[\"py-version\"]",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_LIST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_LIST = Literal[\"ignored-modules\"]\nGLOBAL_OPTION_PATTERN = Literal[\n    \"no-docstring-rgx\",\n    \"dummy-variables-rgx\",\n    \"ignored-argument-names\",\n    \"mixin-class-rgx\",\n]\nGLOBAL_OPTION_PATTERN_LIST = Literal[\"exclude-too-few-public-methods\", \"ignore-paths\"]\nGLOBAL_OPTION_TUPLE_INT = Literal[\"py-version\"]\nGLOBAL_OPTION_NAMES = Union[",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_PATTERN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_PATTERN = Literal[\n    \"no-docstring-rgx\",\n    \"dummy-variables-rgx\",\n    \"ignored-argument-names\",\n    \"mixin-class-rgx\",\n]\nGLOBAL_OPTION_PATTERN_LIST = Literal[\"exclude-too-few-public-methods\", \"ignore-paths\"]\nGLOBAL_OPTION_TUPLE_INT = Literal[\"py-version\"]\nGLOBAL_OPTION_NAMES = Union[\n    GLOBAL_OPTION_BOOL,",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_PATTERN_LIST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_PATTERN_LIST = Literal[\"exclude-too-few-public-methods\", \"ignore-paths\"]\nGLOBAL_OPTION_TUPLE_INT = Literal[\"py-version\"]\nGLOBAL_OPTION_NAMES = Union[\n    GLOBAL_OPTION_BOOL,\n    GLOBAL_OPTION_INT,\n    GLOBAL_OPTION_LIST,\n    GLOBAL_OPTION_PATTERN,\n    GLOBAL_OPTION_PATTERN_LIST,\n    GLOBAL_OPTION_TUPLE_INT,\n]",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_TUPLE_INT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_TUPLE_INT = Literal[\"py-version\"]\nGLOBAL_OPTION_NAMES = Union[\n    GLOBAL_OPTION_BOOL,\n    GLOBAL_OPTION_INT,\n    GLOBAL_OPTION_LIST,\n    GLOBAL_OPTION_PATTERN,\n    GLOBAL_OPTION_PATTERN_LIST,\n    GLOBAL_OPTION_TUPLE_INT,\n]\nT_GlobalOptionReturnTypes = TypeVar(",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "GLOBAL_OPTION_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "GLOBAL_OPTION_NAMES = Union[\n    GLOBAL_OPTION_BOOL,\n    GLOBAL_OPTION_INT,\n    GLOBAL_OPTION_LIST,\n    GLOBAL_OPTION_PATTERN,\n    GLOBAL_OPTION_PATTERN_LIST,\n    GLOBAL_OPTION_TUPLE_INT,\n]\nT_GlobalOptionReturnTypes = TypeVar(\n    \"T_GlobalOptionReturnTypes\",",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "T_GlobalOptionReturnTypes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "T_GlobalOptionReturnTypes = TypeVar(\n    \"T_GlobalOptionReturnTypes\",\n    bool,\n    int,\n    List[str],\n    Pattern[str],\n    List[Pattern[str]],\n    Tuple[int, ...],\n)\ndef normalize_text(",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "CMPS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.utils.utils",
        "description": "__pypackages__.3.10.lib.pylint.utils.utils",
        "peekOfCode": "CMPS = [\"=\", \"-\", \"+\"]\n# py3k has no more cmp builtin\ndef cmp(a: int | float, b: int | float) -> int:\n    return (a > b) - (a < b)\ndef diff_string(old: int | float, new: int | float) -> str:\n    \"\"\"Given an old and new int value, return a string representing the\n    difference.\n    \"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"",
        "detail": "__pypackages__.3.10.lib.pylint.utils.utils",
        "documentation": {}
    },
    {
        "label": "WarningScope",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "class WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY38_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "PY38_PLUS = sys.version_info[:2] >= (3, 8)\nPY39_PLUS = sys.version_info[:2] >= (3, 9)\nIS_PYPY = platform.python_implementation() == \"PyPy\"\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY39_PLUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "PY39_PLUS = sys.version_info[:2] >= (3, 9)\nIS_PYPY = platform.python_implementation() == \"PyPy\"\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "IS_PYPY",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "IS_PYPY = platform.python_implementation() == \"PyPy\"\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "PY_EXTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "PY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_CONFIDENCE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "MSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "_MSG_ORDER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_SCOPE_CONFIG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "MSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_STATE_SCOPE_MODULE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "MSG_STATE_SCOPE_MODULE = 1\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "_SCOPE_EXEMPT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "_SCOPE_EXEMPT = \"FR\"\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "MSG_TYPES_STATUS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "MSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\nUSER_HOME = os.path.expanduser(\"~\")\n# TODO: 3.0: Remove in 3.0 with all the surrounding code\nOLD_DEFAULT_PYLINT_HOME = \".pylint.d\"\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\nDEFAULT_IGNORE_LIST = (\"CVS\",)",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "MAIN_CHECKER_NAME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "MAIN_CHECKER_NAME = \"main\"\nUSER_HOME = os.path.expanduser(\"~\")\n# TODO: 3.0: Remove in 3.0 with all the surrounding code\nOLD_DEFAULT_PYLINT_HOME = \".pylint.d\"\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\nDEFAULT_IGNORE_LIST = (\"CVS\",)\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "USER_HOME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "USER_HOME = os.path.expanduser(\"~\")\n# TODO: 3.0: Remove in 3.0 with all the surrounding code\nOLD_DEFAULT_PYLINT_HOME = \".pylint.d\"\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\nDEFAULT_IGNORE_LIST = (\"CVS\",)\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "OLD_DEFAULT_PYLINT_HOME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "OLD_DEFAULT_PYLINT_HOME = \".pylint.d\"\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\nDEFAULT_IGNORE_LIST = (\"CVS\",)\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\nHUMAN_READABLE_TYPES = {",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PYLINT_HOME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "DEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\nDEFAULT_IGNORE_LIST = (\"CVS\",)\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_IGNORE_LIST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "DEFAULT_IGNORE_LIST = (\"CVS\",)\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "full_version",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "full_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "HUMAN_READABLE_TYPES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "HUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "INCOMPATIBLE_WITH_USELESS_SUPPRESSION",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "INCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset(\n    [\n        \"R0401\",  # cyclic-import\n        \"W0402\",  # deprecated-module\n        \"W1505\",  # deprecated-method\n        \"W1511\",  # deprecated-argument\n        \"W1512\",  # deprecated-class\n        \"W1513\",  # deprecated-decorator\n        \"R0801\",  # duplicate-code\n    ]",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "PYLINT_HOME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "PYLINT_HOME = _get_pylint_home()\nTYPING_NORETURN = frozenset(\n    (\n        \"typing.NoReturn\",\n        \"typing_extensions.NoReturn\",\n    )\n)\nTYPING_NEVER = frozenset(\n    (\n        \"typing.Never\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "TYPING_NORETURN",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "TYPING_NORETURN = frozenset(\n    (\n        \"typing.NoReturn\",\n        \"typing_extensions.NoReturn\",\n    )\n)\nTYPING_NEVER = frozenset(\n    (\n        \"typing.Never\",\n        \"typing_extensions.Never\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "TYPING_NEVER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "TYPING_NEVER = frozenset(\n    (\n        \"typing.Never\",\n        \"typing_extensions.Never\",\n    )\n)\nDUNDER_METHODS: dict[tuple[int, int], dict[str, str]] = {\n    (0, 0): {\n        \"__init__\": \"Instantiate class directly\",\n        \"__del__\": \"Use del keyword\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "EXTRA_DUNDER_METHODS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "EXTRA_DUNDER_METHODS = [\n    \"__new__\",\n    \"__subclasses__\",\n    \"__init_subclass__\",\n    \"__set_name__\",\n    \"__class_getitem__\",\n    \"__missing__\",\n    \"__exit__\",\n    \"__await__\",\n    \"__aexit__\",",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "DUNDER_PROPERTIES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.constants",
        "description": "__pypackages__.3.10.lib.pylint.constants",
        "peekOfCode": "DUNDER_PROPERTIES = [\n    \"__class__\",\n    \"__dict__\",\n    \"__doc__\",\n    \"__format__\",\n    \"__module__\",\n    \"__sizeof__\",\n    \"__subclasshook__\",\n    \"__weakref__\",\n]",
        "detail": "__pypackages__.3.10.lib.pylint.constants",
        "documentation": {}
    },
    {
        "label": "lint",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.epylint",
        "description": "__pypackages__.3.10.lib.pylint.epylint",
        "peekOfCode": "def lint(filename: str, options: Sequence[str] = ()) -> int:\n    \"\"\"Pylint the given file.\n    When run from Emacs we will be in the directory of a file, and passed its\n    filename.  If this file is part of a package and is trying to import other\n    modules from within its own package or another package rooted in a directory\n    below it, pylint will classify it as a failed import.\n    To get around this, we traverse down the directory tree to find the root of\n    the package this module is in.  We then invoke pylint from this directory.\n    Finally, we must correct the filenames in the output generated by pylint so\n    Emacs doesn't become confused (it will expect just the original filename,",
        "detail": "__pypackages__.3.10.lib.pylint.epylint",
        "documentation": {}
    },
    {
        "label": "py_run",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.epylint",
        "description": "__pypackages__.3.10.lib.pylint.epylint",
        "peekOfCode": "def py_run(\n    command_options: str = ...,\n    return_std: Literal[False] = ...,\n    stdout: TextIO | int | None = ...,\n    stderr: TextIO | int | None = ...,\n) -> None:\n    ...\n@overload\ndef py_run(\n    command_options: str,",
        "detail": "__pypackages__.3.10.lib.pylint.epylint",
        "documentation": {}
    },
    {
        "label": "py_run",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.epylint",
        "description": "__pypackages__.3.10.lib.pylint.epylint",
        "peekOfCode": "def py_run(\n    command_options: str,\n    return_std: Literal[True],\n    stdout: TextIO | int | None = ...,\n    stderr: TextIO | int | None = ...,\n) -> tuple[StringIO, StringIO]:\n    ...\ndef py_run(\n    command_options: str = \"\",\n    return_std: bool = False,",
        "detail": "__pypackages__.3.10.lib.pylint.epylint",
        "documentation": {}
    },
    {
        "label": "py_run",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.epylint",
        "description": "__pypackages__.3.10.lib.pylint.epylint",
        "peekOfCode": "def py_run(\n    command_options: str = \"\",\n    return_std: bool = False,\n    stdout: TextIO | int | None = None,\n    stderr: TextIO | int | None = None,\n) -> tuple[StringIO, StringIO] | None:\n    \"\"\"Run pylint from python.\n    ``command_options`` is a string containing ``pylint`` command line options;\n    ``return_std`` (boolean) indicates return of created standard output\n    and error (see below);",
        "detail": "__pypackages__.3.10.lib.pylint.epylint",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.epylint",
        "description": "__pypackages__.3.10.lib.pylint.epylint",
        "peekOfCode": "def Run(argv: Sequence[str] | None = None) -> NoReturn:\n    warnings.warn(\n        \"'epylint' will be removed in pylint 3.0, use https://github.com/emacsorphanage/pylint instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if not argv and len(sys.argv) == 1:\n        print(f\"Usage: {sys.argv[0]} <filename> [options]\")\n        sys.exit(1)\n    argv = argv or sys.argv[1:]",
        "detail": "__pypackages__.3.10.lib.pylint.epylint",
        "documentation": {}
    },
    {
        "label": "InvalidMessageError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class InvalidMessageError(Exception):\n    \"\"\"Raised when a message creation, registration or addition is rejected.\"\"\"\nclass UnknownMessageError(Exception):\n    \"\"\"Raised when an unregistered message id is encountered.\"\"\"\nclass DeletedMessageError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was deleted from pylint is\n    encountered.\n    \"\"\"\n    def __init__(self, msgid_or_symbol: str, removal_explanation: str):\n        super().__init__(",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "UnknownMessageError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class UnknownMessageError(Exception):\n    \"\"\"Raised when an unregistered message id is encountered.\"\"\"\nclass DeletedMessageError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was deleted from pylint is\n    encountered.\n    \"\"\"\n    def __init__(self, msgid_or_symbol: str, removal_explanation: str):\n        super().__init__(\n            f\"'{msgid_or_symbol}' was removed from pylint, see {removal_explanation}.\"\n        )",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "DeletedMessageError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class DeletedMessageError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was deleted from pylint is\n    encountered.\n    \"\"\"\n    def __init__(self, msgid_or_symbol: str, removal_explanation: str):\n        super().__init__(\n            f\"'{msgid_or_symbol}' was removed from pylint, see {removal_explanation}.\"\n        )\nclass MessageBecameExtensionError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was moved to an optional",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "MessageBecameExtensionError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class MessageBecameExtensionError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was moved to an optional\n    extension is encountered.\n    \"\"\"\n    def __init__(self, msgid_or_symbol: str, moved_explanation: str):\n        super().__init__(\n            f\"'{msgid_or_symbol}' was moved to an optional extension, see {moved_explanation}.\"\n        )\nclass EmptyReportError(Exception):\n    \"\"\"Raised when a report is empty and so should not be displayed.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyReportError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class EmptyReportError(Exception):\n    \"\"\"Raised when a report is empty and so should not be displayed.\"\"\"\nclass InvalidReporterError(Exception):\n    \"\"\"Raised when selected reporter is invalid (e.g. not found).\"\"\"\nclass InvalidArgsError(ValueError):\n    \"\"\"Raised when passed arguments are invalid, e.g., have the wrong length.\"\"\"\nclass NoLineSuppliedError(Exception):\n    \"\"\"Raised when trying to disable a message on a next line without supplying a line\n    number.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidReporterError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class InvalidReporterError(Exception):\n    \"\"\"Raised when selected reporter is invalid (e.g. not found).\"\"\"\nclass InvalidArgsError(ValueError):\n    \"\"\"Raised when passed arguments are invalid, e.g., have the wrong length.\"\"\"\nclass NoLineSuppliedError(Exception):\n    \"\"\"Raised when trying to disable a message on a next line without supplying a line\n    number.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidArgsError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class InvalidArgsError(ValueError):\n    \"\"\"Raised when passed arguments are invalid, e.g., have the wrong length.\"\"\"\nclass NoLineSuppliedError(Exception):\n    \"\"\"Raised when trying to disable a message on a next line without supplying a line\n    number.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "NoLineSuppliedError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.exceptions",
        "description": "__pypackages__.3.10.lib.pylint.exceptions",
        "peekOfCode": "class NoLineSuppliedError(Exception):\n    \"\"\"Raised when trying to disable a message on a next line without supplying a line\n    number.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.exceptions",
        "documentation": {}
    },
    {
        "label": "DotBackend",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.graph",
        "description": "__pypackages__.3.10.lib.pylint.graph",
        "peekOfCode": "class DotBackend:\n    \"\"\"Dot File back-end.\"\"\"\n    def __init__(\n        self,\n        graphname: str,\n        rankdir: str | None = None,\n        size: Any = None,\n        ratio: Any = None,\n        charset: str = \"utf-8\",\n        renderer: str = \"dot\",",
        "detail": "__pypackages__.3.10.lib.pylint.graph",
        "documentation": {}
    },
    {
        "label": "target_info_from_filename",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.graph",
        "description": "__pypackages__.3.10.lib.pylint.graph",
        "peekOfCode": "def target_info_from_filename(filename: str) -> tuple[str, str, str]:\n    \"\"\"Transforms /some/path/foo.png into ('/some/path', 'foo.png', 'png').\"\"\"\n    basename = os.path.basename(filename)\n    storedir = os.path.dirname(os.path.abspath(filename))\n    target = os.path.splitext(filename)[-1][1:]\n    return storedir, basename, target\nclass DotBackend:\n    \"\"\"Dot File back-end.\"\"\"\n    def __init__(\n        self,",
        "detail": "__pypackages__.3.10.lib.pylint.graph",
        "documentation": {}
    },
    {
        "label": "normalize_node_id",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.graph",
        "description": "__pypackages__.3.10.lib.pylint.graph",
        "peekOfCode": "def normalize_node_id(nid: str) -> str:\n    \"\"\"Returns a suitable DOT node id for `nid`.\"\"\"\n    return f'\"{nid}\"'\ndef get_cycles(\n    graph_dict: dict[str, set[str]], vertices: list[str] | None = None\n) -> Sequence[list[str]]:\n    \"\"\"Return a list of detected cycles based on an ordered graph (i.e. keys are\n    vertices and values are lists of destination vertices representing edges).\n    \"\"\"\n    if not graph_dict:",
        "detail": "__pypackages__.3.10.lib.pylint.graph",
        "documentation": {}
    },
    {
        "label": "get_cycles",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.graph",
        "description": "__pypackages__.3.10.lib.pylint.graph",
        "peekOfCode": "def get_cycles(\n    graph_dict: dict[str, set[str]], vertices: list[str] | None = None\n) -> Sequence[list[str]]:\n    \"\"\"Return a list of detected cycles based on an ordered graph (i.e. keys are\n    vertices and values are lists of destination vertices representing edges).\n    \"\"\"\n    if not graph_dict:\n        return ()\n    result: list[list[str]] = []\n    if vertices is None:",
        "detail": "__pypackages__.3.10.lib.pylint.graph",
        "documentation": {}
    },
    {
        "label": "Confidence",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class Confidence(NamedTuple):\n    name: str\n    description: str\n# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "Interface",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(\n            \"Interface and all of its subclasses have been deprecated \"\n            \"and will be removed in pylint 3.0.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    @classmethod",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "IChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class IChecker(Interface):\n    \"\"\"Base interface, to be used only for sub interfaces definition.\"\"\"\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e. set of modules).\"\"\"\nclass IRawChecker(IChecker):\n    \"\"\"Interface for checker which need to parse the raw file.\"\"\"\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "IRawChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class IRawChecker(IChecker):\n    \"\"\"Interface for checker which need to parse the raw file.\"\"\"\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n        The module's content is accessible via ``astroid.stream``\n        \"\"\"\nclass ITokenChecker(IChecker):\n    \"\"\"Interface for checkers that need access to the token list.\"\"\"\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Process a module.",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "ITokenChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class ITokenChecker(IChecker):\n    \"\"\"Interface for checkers that need access to the token list.\"\"\"\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Process a module.\n        Tokens is a list of all source code tokens in the file.\n        \"\"\"\nclass IAstroidChecker(IChecker):\n    \"\"\"Interface for checker which prefers receive events according to\n    statement type.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "IAstroidChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class IAstroidChecker(IChecker):\n    \"\"\"Interface for checker which prefers receive events according to\n    statement type.\n    \"\"\"\nclass IReporter(Interface):\n    \"\"\"Reporter collect messages and display results encapsulated in a layout.\"\"\"\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Handle the given message object.\"\"\"\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Display results encapsulated in the layout tree.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "IReporter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "class IReporter(Interface):\n    \"\"\"Reporter collect messages and display results encapsulated in a layout.\"\"\"\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Handle the given message object.\"\"\"\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Display results encapsulated in the layout tree.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "implements",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "def implements(\n    obj: BaseChecker,\n    interface: type[Interface] | tuple[type[Interface], ...],\n) -> bool:\n    \"\"\"Does the given object (maybe an instance or class) implement the interface.\"\"\"\n    # TODO: 3.0: Remove deprecated function\n    warnings.warn(\n        \"implements has been deprecated in favour of using basic \"\n        \"inheritance patterns without using __implements__.\",\n        DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "__all__ = (\n    \"IRawChecker\",\n    \"IAstroidChecker\",\n    \"ITokenChecker\",\n    \"IReporter\",\n    \"IChecker\",\n    \"HIGH\",\n    \"CONTROL_FLOW\",\n    \"INFERENCE\",\n    \"INFERENCE_FAILURE\",",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "HIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "CONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "INFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nclass Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "INFERENCE_FAILURE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "INFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nclass Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "UNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nclass Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(\n            \"Interface and all of its subclasses have been deprecated \"\n            \"and will be removed in pylint 3.0.\",\n            DeprecationWarning,",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "CONFIDENCE_LEVELS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "CONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nclass Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(\n            \"Interface and all of its subclasses have been deprecated \"\n            \"and will be removed in pylint 3.0.\",\n            DeprecationWarning,\n            stacklevel=2,",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "CONFIDENCE_LEVEL_NAMES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.interfaces",
        "description": "__pypackages__.3.10.lib.pylint.interfaces",
        "peekOfCode": "CONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nclass Interface:\n    \"\"\"Base class for interfaces.\"\"\"\n    def __init__(self) -> None:\n        warnings.warn(\n            \"Interface and all of its subclasses have been deprecated \"\n            \"and will be removed in pylint 3.0.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )",
        "detail": "__pypackages__.3.10.lib.pylint.interfaces",
        "documentation": {}
    },
    {
        "label": "FileItem",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class FileItem(NamedTuple):\n    \"\"\"Represents data about a file handled by pylint.\n    Each file item has:\n    - name: full name of the module\n    - filepath: path of the file\n    - modname: module name\n    \"\"\"\n    name: str\n    filepath: str\n    modpath: str",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "ModuleDescriptionDict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class ModuleDescriptionDict(TypedDict):\n    \"\"\"Represents data about a checked module.\"\"\"\n    path: str\n    name: str\n    isarg: bool\n    basepath: str\n    basename: str\nclass ErrorDescriptionDict(TypedDict):\n    \"\"\"Represents data about errors collected during checking of a module.\"\"\"\n    key: Literal[\"fatal\"]",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "ErrorDescriptionDict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class ErrorDescriptionDict(TypedDict):\n    \"\"\"Represents data about errors collected during checking of a module.\"\"\"\n    key: Literal[\"fatal\"]\n    mod: str\n    ex: ImportError | SyntaxError\nclass MessageLocationTuple(NamedTuple):\n    \"\"\"Tuple with information about the location of a to-be-displayed message.\"\"\"\n    abspath: str\n    path: str\n    module: str",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageLocationTuple",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class MessageLocationTuple(NamedTuple):\n    \"\"\"Tuple with information about the location of a to-be-displayed message.\"\"\"\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None = None\n    end_column: int | None = None",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "ManagedMessage",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class ManagedMessage(NamedTuple):\n    \"\"\"Tuple with information about a managed message of the linter.\"\"\"\n    name: str | None\n    msgid: str\n    symbol: str\n    line: int | None\n    is_disabled: bool\nMessageTypesFullName = Literal[\n    \"convention\", \"error\", \"fatal\", \"info\", \"refactor\", \"statement\", \"warning\"\n]",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "ExtraMessageOptions",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class ExtraMessageOptions(TypedDict, total=False):\n    \"\"\"All allowed keys in the extra options for message definitions.\"\"\"\n    scope: str\n    old_names: list[tuple[str, str]]\n    maxversion: tuple[int, int]\n    minversion: tuple[int, int]\n    shared: bool\n    default_enabled: bool\nMessageDefinitionTuple = Union[\n    Tuple[str, str, str],",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "GetProjectCallable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "class GetProjectCallable(Protocol):\n    def __call__(self, module: str, name: str | None = \"No Name\") -> Project:\n        ...  # pragma: no cover",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageTypesFullName",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "MessageTypesFullName = Literal[\n    \"convention\", \"error\", \"fatal\", \"info\", \"refactor\", \"statement\", \"warning\"\n]\n\"\"\"All possible message categories.\"\"\"\nOptionDict = Dict[\n    str,\n    Union[\n        None,\n        str,\n        bool,",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "OptionDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "OptionDict = Dict[\n    str,\n    Union[\n        None,\n        str,\n        bool,\n        int,\n        Pattern[str],\n        Iterable[Union[str, int, Pattern[str]]],\n        Type[\"_CallbackAction\"],",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "Options",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "Options = Tuple[Tuple[str, OptionDict], ...]\nReportsCallable = Callable[[\"Section\", \"LinterStats\", Optional[\"LinterStats\"]], None]\n\"\"\"Callable to create a report.\"\"\"\nclass ExtraMessageOptions(TypedDict, total=False):\n    \"\"\"All allowed keys in the extra options for message definitions.\"\"\"\n    scope: str\n    old_names: list[tuple[str, str]]\n    maxversion: tuple[int, int]\n    minversion: tuple[int, int]\n    shared: bool",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "ReportsCallable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "ReportsCallable = Callable[[\"Section\", \"LinterStats\", Optional[\"LinterStats\"]], None]\n\"\"\"Callable to create a report.\"\"\"\nclass ExtraMessageOptions(TypedDict, total=False):\n    \"\"\"All allowed keys in the extra options for message definitions.\"\"\"\n    scope: str\n    old_names: list[tuple[str, str]]\n    maxversion: tuple[int, int]\n    minversion: tuple[int, int]\n    shared: bool\n    default_enabled: bool",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "MessageDefinitionTuple",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "MessageDefinitionTuple = Union[\n    Tuple[str, str, str],\n    Tuple[str, str, str, ExtraMessageOptions],\n]\nDirectoryNamespaceDict = Dict[Path, Tuple[argparse.Namespace, \"DirectoryNamespaceDict\"]]\nclass GetProjectCallable(Protocol):\n    def __call__(self, module: str, name: str | None = \"No Name\") -> Project:\n        ...  # pragma: no cover",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "DirectoryNamespaceDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pylint.typing",
        "description": "__pypackages__.3.10.lib.pylint.typing",
        "peekOfCode": "DirectoryNamespaceDict = Dict[Path, Tuple[argparse.Namespace, \"DirectoryNamespaceDict\"]]\nclass GetProjectCallable(Protocol):\n    def __call__(self, module: str, name: str | None = \"No Name\") -> Project:\n        ...  # pragma: no cover",
        "detail": "__pypackages__.3.10.lib.pylint.typing",
        "documentation": {}
    },
    {
        "label": "TOMLDecodeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\ndef load(__fp: BinaryIO, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = __fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Flags",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "NestedDict",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "Output",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags\ndef skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def load(__fp: BinaryIO, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = __fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        ) from None\n    return loads(s, parse_float=parse_float)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "loads",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def loads(__s: str, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = __s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    parse_float = make_safe_parse_float(parse_float)\n    # Parse one statement at a time",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_chars",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos\ndef skip_until(\n    src: str,\n    pos: Pos,",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_until",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: frozenset[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )\n    return pos",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "skip_comments_and_array_ws",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos\ndef create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "create_dict_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "create_list_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "key_value_rule",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def key_value_rule(\n    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat\n) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))\n    for cont_key in relative_path_cont_keys:\n        # Check that dotted key syntax does not redefine an existing table\n        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key_value_pair",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_key_value_pair(\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: str | None = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_key_part",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_one_line_basic_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)\ndef parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_array",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_inline_table",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str_escape",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_basic_str_escape(\n    src: str, pos: Pos, *, multiline: bool = False\n) -> tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str_escape_multiline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)\ndef parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_hex_char",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)\ndef parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_literal_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )\n    return pos + 1, src[start_pos:pos]  # Skip ending apostrophe\ndef parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_multiline_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_basic_str",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "parse_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def parse_value(  # noqa: C901\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Any]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    # IMPORTANT: order conditions based on speed of checking and likelihood\n    # Basic strings\n    if char == '\"':",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "suffixed_err",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "is_unicode_scalar_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)\ndef make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "make_safe_parse_float",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "def make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.\n    if parse_float is float:  # type: ignore[comparison-overlap]\n        return float",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ASCII_CTRL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))\n# Neither of these sets include quotation mark or backslash. They are\n# currently handled as separate cases in the parser functions.\nILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_BASIC_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_MULTILINE_BASIC_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_LITERAL_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_MULTILINE_LITERAL_STR_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "ILLEGAL_COMMENT_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "ILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "TOML_WS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "TOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "TOML_WS_AND_NEWLINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "TOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "BARE_KEY_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "BARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "KEY_INITIAL_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "KEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "HEXDIGIT_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "HEXDIGIT_CHARS = frozenset(string.hexdigits)\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "BASIC_STR_ESCAPE_REPLACEMENTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._parser",
        "description": "__pypackages__.3.10.lib.tomli._parser",
        "peekOfCode": "BASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }",
        "detail": "__pypackages__.3.10.lib.tomli._parser",
        "documentation": {}
    },
    {
        "label": "match_to_datetime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "def match_to_datetime(match: re.Match) -> datetime | date:\n    \"\"\"Convert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.\n    Raises ValueError if the match does not correspond to a valid date\n    or datetime.\n    \"\"\"\n    (\n        year_str,\n        month_str,\n        day_str,\n        hour_str,",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "cached_tz",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "def cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:\n    sign = 1 if sign_str == \"+\" else -1\n    return timezone(\n        timedelta(\n            hours=sign * int(hour_str),\n            minutes=sign * int(minute_str),\n        )\n    )\ndef match_to_localtime(match: re.Match) -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "match_to_localtime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "def match_to_localtime(match: re.Match) -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    return time(int(hour_str), int(minute_str), int(sec_str), micros)\ndef match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "match_to_number",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "def match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "_TIME_RE_STR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "_TIME_RE_STR = r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\\.([0-9]{1,6})[0-9]*)?\"\nRE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_NUMBER",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "RE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct\n)",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_LOCALTIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "RE_LOCALTIME = re.compile(_TIME_RE_STR)\nRE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [Tt ]\n    {_TIME_RE_STR}\n    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset\n)?\n\"\"\",",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "RE_DATETIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._re",
        "description": "__pypackages__.3.10.lib.tomli._re",
        "peekOfCode": "RE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [Tt ]\n    {_TIME_RE_STR}\n    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset\n)?\n\"\"\",\n    flags=re.VERBOSE,",
        "detail": "__pypackages__.3.10.lib.tomli._re",
        "documentation": {}
    },
    {
        "label": "ParseFloat",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._types",
        "description": "__pypackages__.3.10.lib.tomli._types",
        "peekOfCode": "ParseFloat = Callable[[str], Any]\nKey = Tuple[str, ...]\nPos = int",
        "detail": "__pypackages__.3.10.lib.tomli._types",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._types",
        "description": "__pypackages__.3.10.lib.tomli._types",
        "peekOfCode": "Key = Tuple[str, ...]\nPos = int",
        "detail": "__pypackages__.3.10.lib.tomli._types",
        "documentation": {}
    },
    {
        "label": "Pos",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomli._types",
        "description": "__pypackages__.3.10.lib.tomli._types",
        "peekOfCode": "Pos = int",
        "detail": "__pypackages__.3.10.lib.tomli._types",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit._compat",
        "description": "__pypackages__.3.10.lib.tomlkit._compat",
        "peekOfCode": "def decode(string: Any, encodings: Optional[List[str]] = None):\n    if not isinstance(string, bytes):\n        return string\n    encodings = encodings or [\"utf-8\", \"latin1\", \"ascii\"]\n    for encoding in encodings:\n        with contextlib.suppress(UnicodeEncodeError, UnicodeDecodeError):\n            return string.decode(encoding)\n    return string.decode(encodings[0], errors=\"ignore\")",
        "detail": "__pypackages__.3.10.lib.tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "PY38",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._compat",
        "description": "__pypackages__.3.10.lib.tomlkit._compat",
        "peekOfCode": "PY38 = sys.version_info >= (3, 8)\ndef decode(string: Any, encodings: Optional[List[str]] = None):\n    if not isinstance(string, bytes):\n        return string\n    encodings = encodings or [\"utf-8\", \"latin1\", \"ascii\"]\n    for encoding in encodings:\n        with contextlib.suppress(UnicodeEncodeError, UnicodeDecodeError):\n            return string.decode(encoding)\n    return string.decode(encodings[0], errors=\"ignore\")",
        "detail": "__pypackages__.3.10.lib.tomlkit._compat",
        "documentation": {}
    },
    {
        "label": "parse_rfc3339",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "def parse_rfc3339(string: str) -> Union[datetime, date, time]:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n        hour = int(m.group(4))\n        minute = int(m.group(5))\n        second = int(m.group(6))\n        microsecond = 0",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "escape_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "def escape_string(s: str, escape_sequences: Collection[str] = _basic_escapes) -> str:\n    s = decode(s)\n    res = []\n    start = 0\n    def flush(inc=1):\n        if start != i:\n            res.append(s[start:i])\n        return i + inc\n    i = 0\n    while i < len(s):",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "merge_dicts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "def merge_dicts(d1: dict, d2: dict) -> dict:\n    for k, v in d2.items():\n        if k in d1 and isinstance(d1[k], dict) and isinstance(v, Mapping):\n            merge_dicts(d1[k], v)\n        else:\n            d1[k] = d2[k]",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "RFC_3339_LOOSE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "RFC_3339_LOOSE = re.compile(\n    \"^\"\n    r\"(([0-9]+)-(\\d{2})-(\\d{2}))?\"  # Date\n    \"(\"\n    \"([Tt ])?\"  # Separator\n    r\"(\\d{2}):(\\d{2}):(\\d{2})(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \")?\"\n    \"$\"\n)",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "RFC_3339_DATETIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "RFC_3339_DATETIME = re.compile(\n    \"^\"\n    \"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\"  # Date\n    \"[Tt ]\"  # Separator\n    r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \"$\"\n)\nRFC_3339_DATE = re.compile(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$\")\nRFC_3339_TIME = re.compile(",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "RFC_3339_DATE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "RFC_3339_DATE = re.compile(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$\")\nRFC_3339_TIME = re.compile(\n    r\"^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?$\"\n)\n_utc = timezone(timedelta(), \"UTC\")\ndef parse_rfc3339(string: str) -> Union[datetime, date, time]:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "RFC_3339_TIME",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "RFC_3339_TIME = re.compile(\n    r\"^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?$\"\n)\n_utc = timezone(timedelta(), \"UTC\")\ndef parse_rfc3339(string: str) -> Union[datetime, date, time]:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "_utc",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "_utc = timezone(timedelta(), \"UTC\")\ndef parse_rfc3339(string: str) -> Union[datetime, date, time]:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n        hour = int(m.group(4))\n        minute = int(m.group(5))\n        second = int(m.group(6))",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "CONTROL_CHARS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "CONTROL_CHARS = frozenset(chr(c) for c in range(0x20)) | {chr(0x7F)}\n_escaped = {\n    \"b\": \"\\b\",\n    \"t\": \"\\t\",\n    \"n\": \"\\n\",\n    \"f\": \"\\f\",\n    \"r\": \"\\r\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n}",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "_escaped",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "_escaped = {\n    \"b\": \"\\b\",\n    \"t\": \"\\t\",\n    \"n\": \"\\n\",\n    \"f\": \"\\f\",\n    \"r\": \"\\r\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n}\n_compact_escapes = {",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "_compact_escapes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "_compact_escapes = {\n    **{v: f\"\\\\{k}\" for k, v in _escaped.items()},\n    '\"\"\"': '\"\"\\\\\"',\n}\n_basic_escapes = CONTROL_CHARS | {'\"', \"\\\\\"}\ndef _unicode_escape(seq: str) -> str:\n    return \"\".join(f\"\\\\u{ord(c):04x}\" for c in seq)\ndef escape_string(s: str, escape_sequences: Collection[str] = _basic_escapes) -> str:\n    s = decode(s)\n    res = []",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "_basic_escapes",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit._utils",
        "description": "__pypackages__.3.10.lib.tomlkit._utils",
        "peekOfCode": "_basic_escapes = CONTROL_CHARS | {'\"', \"\\\\\"}\ndef _unicode_escape(seq: str) -> str:\n    return \"\".join(f\"\\\\u{ord(c):04x}\" for c in seq)\ndef escape_string(s: str, escape_sequences: Collection[str] = _basic_escapes) -> str:\n    s = decode(s)\n    res = []\n    start = 0\n    def flush(inc=1):\n        if start != i:\n            res.append(s[start:i])",
        "detail": "__pypackages__.3.10.lib.tomlkit._utils",
        "documentation": {}
    },
    {
        "label": "loads",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def loads(string: Union[str, bytes]) -> TOMLDocument:\n    \"\"\"\n    Parses a string into a TOMLDocument.\n    Alias for parse().\n    \"\"\"\n    return parse(string)\ndef dumps(data: Mapping, sort_keys: bool = False) -> str:\n    \"\"\"\n    Dumps a TOMLDocument into a string.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "dumps",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def dumps(data: Mapping, sort_keys: bool = False) -> str:\n    \"\"\"\n    Dumps a TOMLDocument into a string.\n    \"\"\"\n    if not isinstance(data, Container) and isinstance(data, Mapping):\n        data = item(dict(data), _sort_keys=sort_keys)\n    try:\n        # data should be a `Container` (and therefore implement `as_string`)\n        # for all type safe invocations of this function\n        return data.as_string()  # type: ignore[attr-defined]",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def load(fp: IO) -> TOMLDocument:\n    \"\"\"\n    Load toml document from a file-like object.\n    \"\"\"\n    return parse(fp.read())\ndef dump(data: Mapping, fp: IO[str], *, sort_keys: bool = False) -> None:\n    \"\"\"\n    Dump a TOMLDocument into a writable file stream.\n    :param data: a dict-like object to dump\n    :param sort_keys: if true, sort the keys in alphabetic order",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def dump(data: Mapping, fp: IO[str], *, sort_keys: bool = False) -> None:\n    \"\"\"\n    Dump a TOMLDocument into a writable file stream.\n    :param data: a dict-like object to dump\n    :param sort_keys: if true, sort the keys in alphabetic order\n    \"\"\"\n    fp.write(dumps(data, sort_keys=sort_keys))\ndef parse(string: Union[str, bytes]) -> TOMLDocument:\n    \"\"\"\n    Parses a string or bytes into a TOMLDocument.",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def parse(string: Union[str, bytes]) -> TOMLDocument:\n    \"\"\"\n    Parses a string or bytes into a TOMLDocument.\n    \"\"\"\n    return Parser(string).parse()\ndef document() -> TOMLDocument:\n    \"\"\"\n    Returns a new TOMLDocument instance.\n    \"\"\"\n    return TOMLDocument()",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "document",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def document() -> TOMLDocument:\n    \"\"\"\n    Returns a new TOMLDocument instance.\n    \"\"\"\n    return TOMLDocument()\n# Items\ndef integer(raw: Union[str, int]) -> Integer:\n    \"\"\"Create an integer item from a number or string.\"\"\"\n    return item(int(raw))\ndef float_(raw: Union[str, float]) -> Float:",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "integer",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def integer(raw: Union[str, int]) -> Integer:\n    \"\"\"Create an integer item from a number or string.\"\"\"\n    return item(int(raw))\ndef float_(raw: Union[str, float]) -> Float:\n    \"\"\"Create an float item from a number or string.\"\"\"\n    return item(float(raw))\ndef boolean(raw: str) -> Bool:\n    \"\"\"Turn `true` or `false` into a boolean item.\"\"\"\n    return item(raw == \"true\")\ndef string(",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "float_",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def float_(raw: Union[str, float]) -> Float:\n    \"\"\"Create an float item from a number or string.\"\"\"\n    return item(float(raw))\ndef boolean(raw: str) -> Bool:\n    \"\"\"Turn `true` or `false` into a boolean item.\"\"\"\n    return item(raw == \"true\")\ndef string(\n    raw: str,\n    *,\n    literal: bool = False,",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "boolean",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def boolean(raw: str) -> Bool:\n    \"\"\"Turn `true` or `false` into a boolean item.\"\"\"\n    return item(raw == \"true\")\ndef string(\n    raw: str,\n    *,\n    literal: bool = False,\n    multiline: bool = False,\n    escape: bool = True,\n) -> String:",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def string(\n    raw: str,\n    *,\n    literal: bool = False,\n    multiline: bool = False,\n    escape: bool = True,\n) -> String:\n    \"\"\"Create a string item.\n    By default, this function will create *single line basic* strings, but\n    boolean flags (e.g. ``literal=True`` and/or ``multiline=True``)",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "date",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def date(raw: str) -> Date:\n    \"\"\"Create a TOML date.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.date):\n        raise ValueError(\"date() only accepts date strings.\")\n    return item(value)\ndef time(raw: str) -> Time:\n    \"\"\"Create a TOML time.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.time):",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def time(raw: str) -> Time:\n    \"\"\"Create a TOML time.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.time):\n        raise ValueError(\"time() only accepts time strings.\")\n    return item(value)\ndef datetime(raw: str) -> DateTime:\n    \"\"\"Create a TOML datetime.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.datetime):",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def datetime(raw: str) -> DateTime:\n    \"\"\"Create a TOML datetime.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.datetime):\n        raise ValueError(\"datetime() only accepts datetime strings.\")\n    return item(value)\ndef array(raw: str = None) -> Array:\n    \"\"\"Create an array item for its string representation.\n    :Example:\n    >>> array(\"[1, 2, 3]\")  # Create from a string",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def array(raw: str = None) -> Array:\n    \"\"\"Create an array item for its string representation.\n    :Example:\n    >>> array(\"[1, 2, 3]\")  # Create from a string\n    [1, 2, 3]\n    >>> a = array()\n    >>> a.extend([1, 2, 3])  # Create from a list\n    >>> a\n    [1, 2, 3]\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "table",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def table(is_super_table: Optional[bool] = None) -> Table:\n    \"\"\"Create an empty table.\n    :param is_super_table: if true, the table is a super table\n    :Example:\n    >>> doc = document()\n    >>> foo = table(True)\n    >>> bar = table()\n    >>> bar.update({'x': 1})\n    >>> foo.append('bar', bar)\n    >>> doc.append('foo', foo)",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "inline_table",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def inline_table() -> InlineTable:\n    \"\"\"Create an inline table.\n    :Example:\n    >>> table = inline_table()\n    >>> table.update({'x': 1, 'y': 2})\n    >>> print(table.as_string())\n    {x = 1, y = 2}\n    \"\"\"\n    return InlineTable(Container(), Trivia(), new=True)\ndef aot() -> AoT:",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "aot",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def aot() -> AoT:\n    \"\"\"Create an array of table.\n    :Example:\n    >>> doc = document()\n    >>> aot = aot()\n    >>> aot.append(item({'x': 1}))\n    >>> doc.append('foo', aot)\n    >>> print(doc.as_string())\n    [[foo]]\n    x = 1",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def key(k: Union[str, Iterable[str]]) -> Key:\n    \"\"\"Create a key from a string. When a list of string is given,\n    it will create a dotted key.\n    :Example:\n    >>> doc = document()\n    >>> doc.append(key('foo'), 1)\n    >>> doc.append(key(['bar', 'baz']), 2)\n    >>> print(doc.as_string())\n    foo = 1\n    bar.baz = 2",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def value(raw: str) -> _Item:\n    \"\"\"Parse a simple value from a string.\n    :Example:\n    >>> value(\"1\")\n    1\n    >>> value(\"true\")\n    True\n    >>> value(\"[1, 2, 3]\")\n    [1, 2, 3]\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "key_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def key_value(src: str) -> Tuple[Key, _Item]:\n    \"\"\"Parse a key-value pair from a string.\n    :Example:\n    >>> key_value(\"foo = 1\")\n    (Key('foo'), 1)\n    \"\"\"\n    return Parser(src)._parse_key_value()\ndef ws(src: str) -> Whitespace:\n    \"\"\"Create a whitespace from a string.\"\"\"\n    return Whitespace(src, fixed=True)",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "ws",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def ws(src: str) -> Whitespace:\n    \"\"\"Create a whitespace from a string.\"\"\"\n    return Whitespace(src, fixed=True)\ndef nl() -> Whitespace:\n    \"\"\"Create a newline item.\"\"\"\n    return ws(\"\\n\")\ndef comment(string: str) -> Comment:\n    \"\"\"Create a comment item.\"\"\"\n    return Comment(Trivia(comment_ws=\"  \", comment=\"# \" + string))",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "nl",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def nl() -> Whitespace:\n    \"\"\"Create a newline item.\"\"\"\n    return ws(\"\\n\")\ndef comment(string: str) -> Comment:\n    \"\"\"Create a comment item.\"\"\"\n    return Comment(Trivia(comment_ws=\"  \", comment=\"# \" + string))",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.api",
        "description": "__pypackages__.3.10.lib.tomlkit.api",
        "peekOfCode": "def comment(string: str) -> Comment:\n    \"\"\"Create a comment item.\"\"\"\n    return Comment(Trivia(comment_ws=\"  \", comment=\"# \" + string))",
        "detail": "__pypackages__.3.10.lib.tomlkit.api",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.container",
        "description": "__pypackages__.3.10.lib.tomlkit.container",
        "peekOfCode": "class Container(_CustomDict):\n    \"\"\"\n    A container for items within a TOMLDocument.\n    This class implements the `dict` interface with copy/deepcopy protocol.\n    \"\"\"\n    def __init__(self, parsed: bool = False) -> None:\n        self._map: Dict[Key, int] = {}\n        self._body: List[Tuple[Optional[Key], Item]] = []\n        self._parsed = parsed\n        self._table_keys = []",
        "detail": "__pypackages__.3.10.lib.tomlkit.container",
        "documentation": {}
    },
    {
        "label": "OutOfOrderTableProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.container",
        "description": "__pypackages__.3.10.lib.tomlkit.container",
        "peekOfCode": "class OutOfOrderTableProxy(_CustomDict):\n    def __init__(self, container: Container, indices: Tuple[int]) -> None:\n        self._container = container\n        self._internal_container = Container(True)\n        self._tables = []\n        self._tables_map = {}\n        for i in indices:\n            _, item = self._container._body[i]\n            if isinstance(item, Table):\n                self._tables.append(item)",
        "detail": "__pypackages__.3.10.lib.tomlkit.container",
        "documentation": {}
    },
    {
        "label": "ends_with_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.container",
        "description": "__pypackages__.3.10.lib.tomlkit.container",
        "peekOfCode": "def ends_with_whitespace(it: Any) -> bool:\n    \"\"\"Returns ``True`` if the given item ``it`` is a ``Table`` or ``AoT`` object\n    ending with a ``Whitespace``.\n    \"\"\"\n    return (\n        isinstance(it, Table) and isinstance(it.value._previous_item(), Whitespace)\n    ) or (isinstance(it, AoT) and len(it) > 0 and isinstance(it[-1], Whitespace))",
        "detail": "__pypackages__.3.10.lib.tomlkit.container",
        "documentation": {}
    },
    {
        "label": "_NOT_SET",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.container",
        "description": "__pypackages__.3.10.lib.tomlkit.container",
        "peekOfCode": "_NOT_SET = object()\nclass Container(_CustomDict):\n    \"\"\"\n    A container for items within a TOMLDocument.\n    This class implements the `dict` interface with copy/deepcopy protocol.\n    \"\"\"\n    def __init__(self, parsed: bool = False) -> None:\n        self._map: Dict[Key, int] = {}\n        self._body: List[Tuple[Optional[Key], Item]] = []\n        self._parsed = parsed",
        "detail": "__pypackages__.3.10.lib.tomlkit.container",
        "documentation": {}
    },
    {
        "label": "TOMLKitError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class TOMLKitError(Exception):\n    pass\nclass ParseError(ValueError, TOMLKitError):\n    \"\"\"\n    This error occurs when the parser encounters a syntax error\n    in the TOML being parsed. The error references the line and\n    location within the line where the error was encountered.\n    \"\"\"\n    def __init__(self, line: int, col: int, message: Optional[str] = None) -> None:\n        self._line = line",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class ParseError(ValueError, TOMLKitError):\n    \"\"\"\n    This error occurs when the parser encounters a syntax error\n    in the TOML being parsed. The error references the line and\n    location within the line where the error was encountered.\n    \"\"\"\n    def __init__(self, line: int, col: int, message: Optional[str] = None) -> None:\n        self._line = line\n        self._col = col\n        if message is None:",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "MixedArrayTypesError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class MixedArrayTypesError(ParseError):\n    \"\"\"\n    An array was found that had two or more element types.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Mixed types found in array\"\n        super().__init__(line, col, message=message)\nclass InvalidNumberError(ParseError):\n    \"\"\"\n    A numeric field was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidNumberError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidNumberError(ParseError):\n    \"\"\"\n    A numeric field was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number\"\n        super().__init__(line, col, message=message)\nclass InvalidDateTimeError(ParseError):\n    \"\"\"\n    A datetime field was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidDateTimeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidDateTimeError(ParseError):\n    \"\"\"\n    A datetime field was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid datetime\"\n        super().__init__(line, col, message=message)\nclass InvalidDateError(ParseError):\n    \"\"\"\n    A date field was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidDateError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidDateError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid date\"\n        super().__init__(line, col, message=message)\nclass InvalidTimeError(ParseError):\n    \"\"\"\n    A date field was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidTimeError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidTimeError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid time\"\n        super().__init__(line, col, message=message)\nclass InvalidNumberOrDateError(ParseError):\n    \"\"\"\n    A numeric or date field was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidNumberOrDateError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidNumberOrDateError(ParseError):\n    \"\"\"\n    A numeric or date field was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number or date format\"\n        super().__init__(line, col, message=message)\nclass InvalidUnicodeValueError(ParseError):\n    \"\"\"\n    A unicode code was improperly specified.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidUnicodeValueError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidUnicodeValueError(ParseError):\n    \"\"\"\n    A unicode code was improperly specified.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid unicode value\"\n        super().__init__(line, col, message=message)\nclass UnexpectedCharError(ParseError):\n    \"\"\"\n    An unexpected character was found during parsing.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedCharError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class UnexpectedCharError(ParseError):\n    \"\"\"\n    An unexpected character was found during parsing.\n    \"\"\"\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Unexpected character: {repr(char)}\"\n        super().__init__(line, col, message=message)\nclass EmptyKeyError(ParseError):\n    \"\"\"\n    An empty key was found during parsing.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyKeyError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class EmptyKeyError(ParseError):\n    \"\"\"\n    An empty key was found during parsing.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty key\"\n        super().__init__(line, col, message=message)\nclass EmptyTableNameError(ParseError):\n    \"\"\"\n    An empty table name was found during parsing.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyTableNameError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class EmptyTableNameError(ParseError):\n    \"\"\"\n    An empty table name was found during parsing.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty table name\"\n        super().__init__(line, col, message=message)\nclass InvalidCharInStringError(ParseError):\n    \"\"\"\n    The string being parsed contains an invalid character.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidCharInStringError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidCharInStringError(ParseError):\n    \"\"\"\n    The string being parsed contains an invalid character.\n    \"\"\"\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Invalid character {repr(char)} in string\"\n        super().__init__(line, col, message=message)\nclass UnexpectedEofError(ParseError):\n    \"\"\"\n    The TOML being parsed ended before the end of a statement.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedEofError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class UnexpectedEofError(ParseError):\n    \"\"\"\n    The TOML being parsed ended before the end of a statement.\n    \"\"\"\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Unexpected end of file\"\n        super().__init__(line, col, message=message)\nclass InternalParserError(ParseError):\n    \"\"\"\n    An error that indicates a bug in the parser.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InternalParserError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InternalParserError(ParseError):\n    \"\"\"\n    An error that indicates a bug in the parser.\n    \"\"\"\n    def __init__(self, line: int, col: int, message: Optional[str] = None) -> None:\n        msg = \"Internal parser error\"\n        if message:\n            msg += f\" ({message})\"\n        super().__init__(line, col, message=msg)\nclass NonExistentKey(KeyError, TOMLKitError):",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "NonExistentKey",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class NonExistentKey(KeyError, TOMLKitError):\n    \"\"\"\n    A non-existent key was used.\n    \"\"\"\n    def __init__(self, key):\n        message = f'Key \"{key}\" does not exist.'\n        super().__init__(message)\nclass KeyAlreadyPresent(TOMLKitError):\n    \"\"\"\n    An already present key was used.",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "KeyAlreadyPresent",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class KeyAlreadyPresent(TOMLKitError):\n    \"\"\"\n    An already present key was used.\n    \"\"\"\n    def __init__(self, key):\n        key = getattr(key, \"key\", key)\n        message = f'Key \"{key}\" already exists.'\n        super().__init__(message)\nclass InvalidControlChar(ParseError):\n    def __init__(self, line: int, col: int, char: int, type: str) -> None:",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidControlChar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidControlChar(ParseError):\n    def __init__(self, line: int, col: int, char: int, type: str) -> None:\n        display_code = \"\\\\u00\"\n        if char < 16:\n            display_code += \"0\"\n        display_code += hex(char)[2:]\n        message = (\n            \"Control characters (codes less than 0x1f and 0x7f)\"\n            f\" are not allowed in {type}, \"\n            f\"use {display_code} instead\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidStringError",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "description": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "peekOfCode": "class InvalidStringError(ValueError, TOMLKitError):\n    def __init__(self, value: str, invalid_sequences: Collection[str], delimiter: str):\n        repr_ = repr(value)[1:-1]\n        super().__init__(\n            f\"Invalid string: {delimiter}{repr_}{delimiter}. \"\n            f\"The character sequences {invalid_sequences} are invalid.\"\n        )",
        "detail": "__pypackages__.3.10.lib.tomlkit.exceptions",
        "documentation": {}
    },
    {
        "label": "StringType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class StringType(Enum):\n    # Single Line Basic\n    SLB = '\"'\n    # Multi Line Basic\n    MLB = '\"\"\"'\n    # Single Line Literal\n    SLL = \"'\"\n    # Multi Line Literal\n    MLL = \"'''\"\n    @classmethod",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "BoolType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class BoolType(Enum):\n    TRUE = \"true\"\n    FALSE = \"false\"\n    def __bool__(self):\n        return {BoolType.TRUE: True, BoolType.FALSE: False}[self]\n    def __iter__(self):\n        return iter(self.value)\n    def __len__(self):\n        return len(self.value)\nclass Trivia:",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Trivia",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Trivia:\n    \"\"\"\n    Trivia information (aka metadata).\n    \"\"\"\n    def __init__(\n        self,\n        indent: str = None,\n        comment_ws: str = None,\n        comment: str = None,\n        trail: str = None,",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "KeyType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class KeyType(Enum):\n    \"\"\"\n    The type of a Key.\n    Keys can be bare (unquoted), or quoted using basic (\"), or literal (')\n    quotes following the same escaping rules as single-line StringType.\n    \"\"\"\n    Bare = \"\"\n    Basic = '\"'\n    Literal = \"'\"\nclass Key(abc.ABC):",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Key(abc.ABC):\n    \"\"\"Base class for a key\"\"\"\n    sep: str\n    _original: str\n    _keys: List[\"SingleKey\"]\n    _dotted: bool\n    key: str\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        pass",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "SingleKey",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class SingleKey(Key):\n    \"\"\"A single key\"\"\"\n    def __init__(\n        self,\n        k: str,\n        t: Optional[KeyType] = None,\n        sep: Optional[str] = None,\n        original: Optional[str] = None,\n    ) -> None:\n        if t is None:",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "DottedKey",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class DottedKey(Key):\n    def __init__(\n        self,\n        keys: Iterable[Key],\n        sep: Optional[str] = None,\n        original: Optional[str] = None,\n    ) -> None:\n        self._keys = list(keys)\n        if original is None:\n            original = \".\".join(k.as_string() for k in self._keys)",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Item:\n    \"\"\"\n    An item within a TOML document.\n    \"\"\"\n    def __init__(self, trivia: Trivia) -> None:\n        self._trivia = trivia\n    @property\n    def trivia(self) -> Trivia:\n        \"\"\"The trivia element associated with this item\"\"\"\n        return self._trivia",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Whitespace",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Whitespace(Item):\n    \"\"\"\n    A whitespace literal.\n    \"\"\"\n    def __init__(self, s: str, fixed: bool = False) -> None:\n        self._s = s\n        self._fixed = fixed\n    @property\n    def s(self) -> str:\n        return self._s",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Comment",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Comment(Item):\n    \"\"\"\n    A comment literal.\n    \"\"\"\n    @property\n    def discriminant(self) -> int:\n        return 1\n    def as_string(self) -> str:\n        return (\n            f\"{self._trivia.indent}{decode(self._trivia.comment)}{self._trivia.trail}\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Integer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Integer(int, Item):\n    \"\"\"\n    An integer literal.\n    \"\"\"\n    def __new__(cls, value: int, trivia: Trivia, raw: str) -> \"Integer\":\n        return super().__new__(cls, value)\n    def __init__(self, _: int, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._raw = raw\n        self._sign = False",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Float",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Float(float, Item):\n    \"\"\"\n    A float literal.\n    \"\"\"\n    def __new__(cls, value: float, trivia: Trivia, raw: str) -> Integer:\n        return super().__new__(cls, value)\n    def __init__(self, _: float, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._raw = raw\n        self._sign = False",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Bool",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Bool(Item):\n    \"\"\"\n    A boolean literal.\n    \"\"\"\n    def __init__(self, t: int, trivia: Trivia) -> None:\n        super().__init__(trivia)\n        self._value = bool(t)\n    def unwrap(self) -> bool:\n        return bool(self)\n    @property",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class DateTime(Item, datetime):\n    \"\"\"\n    A datetime literal.\n    \"\"\"\n    def __new__(\n        cls,\n        year: int,\n        month: int,\n        day: int,\n        hour: int,",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Date",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Date(Item, date):\n    \"\"\"\n    A date literal.\n    \"\"\"\n    def __new__(cls, year: int, month: int, day: int, *_: Any) -> date:\n        return date.__new__(cls, year, month, day)\n    def __init__(\n        self, year: int, month: int, day: int, trivia: Trivia, raw: str\n    ) -> None:\n        super().__init__(trivia)",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Time",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Time(Item, time):\n    \"\"\"\n    A time literal.\n    \"\"\"\n    def __new__(\n        cls,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "_ArrayItemGroup",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class _ArrayItemGroup:\n    __slots__ = (\"value\", \"indent\", \"comma\", \"comment\")\n    def __init__(\n        self,\n        value: Optional[Item] = None,\n        indent: Optional[Whitespace] = None,\n        comma: Optional[Whitespace] = None,\n        comment: Optional[Comment] = None,\n    ) -> None:\n        self.value = value",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Array",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Array(Item, _CustomList):\n    \"\"\"\n    An array literal\n    \"\"\"\n    def __init__(\n        self, value: List[Item], trivia: Trivia, multiline: bool = False\n    ) -> None:\n        super().__init__(trivia)\n        list.__init__(\n            self,",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "AbstractTable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class AbstractTable(Item, _CustomDict):\n    \"\"\"Common behaviour of both :class:`Table` and :class:`InlineTable`\"\"\"\n    def __init__(self, value: \"container.Container\", trivia: Trivia):\n        Item.__init__(self, trivia)\n        self._value = value\n        for k, v in self._value.body:\n            if k is not None:\n                dict.__setitem__(self, k.key, v)\n    def unwrap(self) -> Dict[str, Any]:\n        unwrapped = {}",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Table(AbstractTable):\n    \"\"\"\n    A table literal.\n    \"\"\"\n    def __init__(\n        self,\n        value: \"container.Container\",\n        trivia: Trivia,\n        is_aot_element: bool,\n        is_super_table: Optional[bool] = None,",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "InlineTable",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class InlineTable(AbstractTable):\n    \"\"\"\n    An inline table literal.\n    \"\"\"\n    def __init__(\n        self, value: \"container.Container\", trivia: Trivia, new: bool = False\n    ) -> None:\n        super().__init__(value, trivia)\n        self._new = new\n    @property",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "String",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class String(str, Item):\n    \"\"\"\n    A string literal.\n    \"\"\"\n    def __new__(cls, t, value, original, trivia):\n        return super().__new__(cls, value)\n    def __init__(self, t: StringType, _: str, original: str, trivia: Trivia) -> None:\n        super().__init__(trivia)\n        self._t = t\n        self._original = original",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "AoT",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class AoT(Item, _CustomList):\n    \"\"\"\n    An array of table literal\n    \"\"\"\n    def __init__(\n        self, body: List[Table], name: Optional[str] = None, parsed: bool = False\n    ) -> None:\n        self.name = name\n        self._body: List[Table] = []\n        self._parsed = parsed",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Null",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "class Null(Item):\n    \"\"\"\n    A null item.\n    \"\"\"\n    def __init__(self) -> None:\n        pass\n    def unwrap(self) -> None:\n        return None\n    @property\n    def discriminant(self) -> int:",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: bool, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Bool\":\n    ...\n@overload\ndef item(\n    value: int, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Integer\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: int, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Integer\":\n    ...\n@overload\ndef item(\n    value: float, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Float\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: float, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Float\":\n    ...\n@overload\ndef item(\n    value: str, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"String\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: str, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"String\":\n    ...\n@overload\ndef item(\n    value: datetime, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"DateTime\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: datetime, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"DateTime\":\n    ...\n@overload\ndef item(\n    value: date, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Date\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: date, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Date\":\n    ...\n@overload\ndef item(\n    value: time, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Time\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: time, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Time\":\n    ...\n@overload\ndef item(\n    value: Sequence[dict], _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"AoT\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: Sequence[dict], _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"AoT\":\n    ...\n@overload\ndef item(\n    value: Sequence, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Array\":\n    ...\n@overload",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: Sequence, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Array\":\n    ...\n@overload\ndef item(value: dict, _parent: \"Array\" = ..., _sort_keys: bool = ...) -> \"InlineTable\":\n    ...\n@overload\ndef item(\n    value: dict, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(value: dict, _parent: \"Array\" = ..., _sort_keys: bool = ...) -> \"InlineTable\":\n    ...\n@overload\ndef item(\n    value: dict, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Table\":\n    ...\n@overload\ndef item(\n    value: ItemT, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: dict, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Table\":\n    ...\n@overload\ndef item(\n    value: ItemT, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> ItemT:\n    ...\ndef item(",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: ItemT, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> ItemT:\n    ...\ndef item(\n    value: Any, _parent: Optional[\"Item\"] = None, _sort_keys: bool = False\n) -> \"Item\":\n    \"\"\"Create a TOML item from a Python object.\n    :Example:\n    >>> item(42)",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "def item(\n    value: Any, _parent: Optional[\"Item\"] = None, _sort_keys: bool = False\n) -> \"Item\":\n    \"\"\"Create a TOML item from a Python object.\n    :Example:\n    >>> item(42)\n    42\n    >>> item([1, 2, 3])\n    [1, 2, 3]\n    >>> item({'a': 1, 'b': 2})",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "ItemT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "ItemT = TypeVar(\"ItemT\", bound=\"Item\")\n@overload\ndef item(\n    value: bool, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Bool\":\n    ...\n@overload\ndef item(\n    value: int, _parent: Optional[\"Item\"] = ..., _sort_keys: bool = ...\n) -> \"Integer\":",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "AT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.items",
        "description": "__pypackages__.3.10.lib.tomlkit.items",
        "peekOfCode": "AT = TypeVar(\"AT\", bound=\"AbstractTable\")\nclass AbstractTable(Item, _CustomDict):\n    \"\"\"Common behaviour of both :class:`Table` and :class:`InlineTable`\"\"\"\n    def __init__(self, value: \"container.Container\", trivia: Trivia):\n        Item.__init__(self, trivia)\n        self._value = value\n        for k, v in self._value.body:\n            if k is not None:\n                dict.__setitem__(self, k.key, v)\n    def unwrap(self) -> Dict[str, Any]:",
        "detail": "__pypackages__.3.10.lib.tomlkit.items",
        "documentation": {}
    },
    {
        "label": "Parser",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "class Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:\n        # Input to parse\n        self._src = Source(decode(string))\n        self._aot_stack: List[Key] = []\n    @property\n    def _state(self):",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "CTRL_I",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "CTRL_I = 0x09  # Tab\nCTRL_J = 0x0A  # Line feed\nCTRL_M = 0x0D  # Carriage return\nCTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "CTRL_J",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "CTRL_J = 0x0A  # Line feed\nCTRL_M = 0x0D  # Carriage return\nCTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:\n        # Input to parse",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "CTRL_M",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "CTRL_M = 0x0D  # Carriage return\nCTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:\n        # Input to parse\n        self._src = Source(decode(string))",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "CTRL_CHAR_LIMIT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "CTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:\n        # Input to parse\n        self._src = Source(decode(string))\n        self._aot_stack: List[Key] = []",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "CHR_DEL",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.tomlkit.parser",
        "description": "__pypackages__.3.10.lib.tomlkit.parser",
        "peekOfCode": "CHR_DEL = 0x7F\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n    def __init__(self, string: str) -> None:\n        # Input to parse\n        self._src = Source(decode(string))\n        self._aot_stack: List[Key] = []\n    @property",
        "detail": "__pypackages__.3.10.lib.tomlkit.parser",
        "documentation": {}
    },
    {
        "label": "_State",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.source",
        "description": "__pypackages__.3.10.lib.tomlkit.source",
        "peekOfCode": "class _State:\n    def __init__(\n        self,\n        source: \"Source\",\n        save_marker: Optional[bool] = False,\n        restore: Optional[bool] = False,\n    ) -> None:\n        self._source = source\n        self._save_marker = save_marker\n        self.restore = restore",
        "detail": "__pypackages__.3.10.lib.tomlkit.source",
        "documentation": {}
    },
    {
        "label": "_StateHandler",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.source",
        "description": "__pypackages__.3.10.lib.tomlkit.source",
        "peekOfCode": "class _StateHandler:\n    \"\"\"\n    State preserver for the Parser.\n    \"\"\"\n    def __init__(self, source: \"Source\") -> None:\n        self._source = source\n        self._states = []\n    def __call__(self, *args, **kwargs):\n        return _State(self._source, *args, **kwargs)\n    def __enter__(self) -> None:",
        "detail": "__pypackages__.3.10.lib.tomlkit.source",
        "documentation": {}
    },
    {
        "label": "Source",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.source",
        "description": "__pypackages__.3.10.lib.tomlkit.source",
        "peekOfCode": "class Source(str):\n    EOF = TOMLChar(\"\\0\")\n    def __init__(self, _: str) -> None:\n        super().__init__()\n        # Collection of TOMLChars\n        self._chars = iter([(i, TOMLChar(c)) for i, c in enumerate(self)])\n        self._idx = 0\n        self._marker = 0\n        self._current = TOMLChar(\"\")\n        self._state = _StateHandler(self)",
        "detail": "__pypackages__.3.10.lib.tomlkit.source",
        "documentation": {}
    },
    {
        "label": "TOMLChar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.toml_char",
        "description": "__pypackages__.3.10.lib.tomlkit.toml_char",
        "peekOfCode": "class TOMLChar(str):\n    def __init__(self, c):\n        super().__init__()\n        if len(self) > 1:\n            raise ValueError(\"A TOML character must be of length 1\")\n    BARE = string.ascii_letters + string.digits + \"-_\"\n    KV = \"= \\t\"\n    NUMBER = string.digits + \"+-_.e\"\n    SPACES = \" \\t\"\n    NL = \"\\n\\r\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.toml_char",
        "documentation": {}
    },
    {
        "label": "TOMLDocument",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.toml_document",
        "description": "__pypackages__.3.10.lib.tomlkit.toml_document",
        "peekOfCode": "class TOMLDocument(Container):\n    \"\"\"\n    A TOML document.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.toml_document",
        "documentation": {}
    },
    {
        "label": "TOMLFile",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.tomlkit.toml_file",
        "description": "__pypackages__.3.10.lib.tomlkit.toml_file",
        "peekOfCode": "class TOMLFile:\n    \"\"\"\n    Represents a TOML file.\n    :param path: path to the TOML file\n    \"\"\"\n    def __init__(self, path: _StrPath) -> None:\n        self._path = path\n        self._linesep = os.linesep\n    def read(self) -> TOMLDocument:\n        \"\"\"Read the file content as a :class:`tomlkit.toml_document.TOMLDocument`.\"\"\"",
        "detail": "__pypackages__.3.10.lib.tomlkit.toml_file",
        "documentation": {}
    },
    {
        "label": "_AdapterFunctionCode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class _AdapterFunctionCode(CallableObjectProxy):\n    def __init__(self, wrapped_code, adapter_code):\n        super(_AdapterFunctionCode, self).__init__(wrapped_code)\n        self._self_adapter_code = adapter_code\n    @property\n    def co_argcount(self):\n        return self._self_adapter_code.co_argcount\n    @property\n    def co_code(self):\n        return self._self_adapter_code.co_code",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "_AdapterFunctionSurrogate",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class _AdapterFunctionSurrogate(CallableObjectProxy):\n    def __init__(self, wrapped, adapter):\n        super(_AdapterFunctionSurrogate, self).__init__(wrapped)\n        self._self_adapter = adapter\n    @property\n    def __code__(self):\n        return _AdapterFunctionCode(self.__wrapped__.__code__,\n                self._self_adapter.__code__)\n    @property\n    def __defaults__(self):",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "_BoundAdapterWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class _BoundAdapterWrapper(BoundFunctionWrapper):\n    @property\n    def __func__(self):\n        return _AdapterFunctionSurrogate(self.__wrapped__.__func__,\n                self._self_parent._self_adapter)\n    @property\n    def __signature__(self):\n        if 'signature' not in globals():\n            return self.__wrapped__.__signature__\n        else:",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "AdapterWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class AdapterWrapper(FunctionWrapper):\n    __bound_function_wrapper__ = _BoundAdapterWrapper\n    def __init__(self, *args, **kwargs):\n        adapter = kwargs.pop('adapter')\n        super(AdapterWrapper, self).__init__(*args, **kwargs)\n        self._self_surrogate = _AdapterFunctionSurrogate(\n                self.__wrapped__, adapter)\n        self._self_adapter = adapter\n    @property\n    def __code__(self):",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "AdapterFactory",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class AdapterFactory(object):\n    def __call__(self, wrapped):\n        raise NotImplementedError()\nclass DelegatedAdapterFactory(AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\nadapter_factory = DelegatedAdapterFactory",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "DelegatedAdapterFactory",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "class DelegatedAdapterFactory(AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\nadapter_factory = DelegatedAdapterFactory\n# Decorator for creating other decorators. This decorator and the\n# wrappers which they use are designed to properly preserve any name\n# attributes, function signatures etc, in addition to the wrappers",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "decorator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "def decorator(wrapper=None, enabled=None, adapter=None, proxy=FunctionWrapper):\n    # The decorator should be supplied with a single positional argument\n    # which is the wrapper function to be used to implement the\n    # decorator. This may be preceded by a step whereby the keyword\n    # arguments are supplied to customise the behaviour of the\n    # decorator. The 'adapter' argument is used to optionally denote a\n    # separate function which is notionally used by an adapter\n    # decorator. In that case parts of the function '__code__' and\n    # '__defaults__' attributes are used from the adapter function\n    # rather than those of the wrapped function. This allows for the",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "synchronized",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "def synchronized(wrapped):\n    # Determine if being passed an object which is a synchronization\n    # primitive. We can't check by type for Lock, RLock, Semaphore etc,\n    # as the means of creating them isn't the type. Therefore use the\n    # existence of acquire() and release() methods. This is more\n    # extensible anyway as it allows custom synchronization mechanisms.\n    if hasattr(wrapped, 'acquire') and hasattr(wrapped, 'release'):\n        # We remember what the original lock is and then return a new\n        # decorator which accesses and locks it. When returning the new\n        # decorator we wrap it with an object proxy so we can override",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nif PY2:\n    string_types = basestring,\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "adapter_factory",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "adapter_factory = DelegatedAdapterFactory\n# Decorator for creating other decorators. This decorator and the\n# wrappers which they use are designed to properly preserve any name\n# attributes, function signatures etc, in addition to the wrappers\n# themselves acting like a transparent proxy for the original wrapped\n# function so the wrapper is effectively indistinguishable from the\n# original wrapped function.\ndef decorator(wrapper=None, enabled=None, adapter=None, proxy=FunctionWrapper):\n    # The decorator should be supplied with a single positional argument\n    # which is the wrapper function to be used to implement the",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "synchronized._synchronized_meta_lock",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.decorators",
        "description": "__pypackages__.3.10.lib.wrapt.decorators",
        "peekOfCode": "synchronized._synchronized_meta_lock = Lock()",
        "detail": "__pypackages__.3.10.lib.wrapt.decorators",
        "documentation": {}
    },
    {
        "label": "_ImportHookLoader",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "class _ImportHookLoader:\n    def load_module(self, fullname):\n        module = sys.modules[fullname]\n        notify_module_loaded(module)\n        return module\nclass _ImportHookChainedLoader:\n    def __init__(self, loader):\n        self.loader = loader\n        if hasattr(loader, \"load_module\"):\n          self.load_module = self._load_module",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "_ImportHookChainedLoader",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "class _ImportHookChainedLoader:\n    def __init__(self, loader):\n        self.loader = loader\n        if hasattr(loader, \"load_module\"):\n          self.load_module = self._load_module\n        if hasattr(loader, \"create_module\"):\n          self.create_module = self._create_module\n        if hasattr(loader, \"exec_module\"):\n          self.exec_module = self._exec_module\n    def _load_module(self, fullname):",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "ImportHookFinder",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "class ImportHookFinder:\n    def __init__(self):\n        self.in_progress = {}\n    @synchronized(_post_import_hooks_lock)\n    def find_module(self, fullname, path=None):\n        # If the module being imported is not one we have registered\n        # post import hooks for, we can return immediately. We will\n        # take no further part in the importing of this module.\n        if not fullname in _post_import_hooks:\n            return None",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "register_post_import_hook",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "def register_post_import_hook(hook, name):\n    # Create a deferred import hook if hook is a string name rather than\n    # a callable function.\n    if isinstance(hook, string_types):\n        hook = _create_import_hook_from_string(hook)\n    # Automatically install the import hook finder if it has not already\n    # been installed.\n    global _post_import_hooks_init\n    if not _post_import_hooks_init:\n        _post_import_hooks_init = True",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "discover_post_import_hooks",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "def discover_post_import_hooks(group):\n    try:\n        import pkg_resources\n    except ImportError:\n        return\n    for entrypoint in pkg_resources.iter_entry_points(group=group):\n        callback = _create_import_hook_from_entrypoint(entrypoint)\n        register_post_import_hook(callback, entrypoint.name)\n# Indicate that a module has been loaded. Any post import hooks which\n# were registered against the target module will be invoked. If an",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "notify_module_loaded",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "def notify_module_loaded(module):\n    name = getattr(module, '__name__', None)\n    hooks = _post_import_hooks.get(name, None)\n    if hooks:\n        _post_import_hooks[name] = []\n        for hook in hooks:\n            hook(module)\n# A custom module import finder. This intercepts attempts to import\n# modules and watches out for attempts to import target modules of\n# interest. When a module of interest is imported, then any post import",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "when_imported",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "def when_imported(name):\n    def register(hook):\n        register_post_import_hook(hook, name)\n        return hook\n    return register",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nif PY2:\n    string_types = basestring,\n    find_spec = None\nelse:\n    string_types = str,\n    from importlib.util import find_spec\nfrom .decorators import synchronized\n# The dictionary registering any post import hooks to be triggered once\n# the target module has been imported. Once a module has been imported",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "_post_import_hooks",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "_post_import_hooks = {}\n_post_import_hooks_init = False\n_post_import_hooks_lock = threading.RLock()\n# Register a new post import hook for the target module name. This\n# differs from the PEP-369 implementation in that it also allows the\n# hook function to be specified as a string consisting of the name of\n# the callback in the form 'module:function'. This will result in a\n# proxy callback being registered which will defer loading of the\n# specified module containing the callback function until required.\ndef _create_import_hook_from_string(name):",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "_post_import_hooks_init",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "_post_import_hooks_init = False\n_post_import_hooks_lock = threading.RLock()\n# Register a new post import hook for the target module name. This\n# differs from the PEP-369 implementation in that it also allows the\n# hook function to be specified as a string consisting of the name of\n# the callback in the form 'module:function'. This will result in a\n# proxy callback being registered which will defer loading of the\n# specified module containing the callback function until required.\ndef _create_import_hook_from_string(name):\n    def import_hook(module):",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "_post_import_hooks_lock",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.importer",
        "description": "__pypackages__.3.10.lib.wrapt.importer",
        "peekOfCode": "_post_import_hooks_lock = threading.RLock()\n# Register a new post import hook for the target module name. This\n# differs from the PEP-369 implementation in that it also allows the\n# hook function to be specified as a string consisting of the name of\n# the callback in the form 'module:function'. This will result in a\n# proxy callback being registered which will defer loading of the\n# specified module containing the callback function until required.\ndef _create_import_hook_from_string(name):\n    def import_hook(module):\n        module_name, function = name.split(':')",
        "detail": "__pypackages__.3.10.lib.wrapt.importer",
        "documentation": {}
    },
    {
        "label": "_ObjectProxyMethods",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class _ObjectProxyMethods(object):\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself\n    # via a meta class. In that way the properties will always take\n    # precedence.\n    @property",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "_ObjectProxyMetaType",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class _ObjectProxyMetaType(type):\n    def __new__(cls, name, bases, dictionary):\n        # Copy our special properties into the class so that they\n        # always take precedence over attributes of the same name added\n        # during construction of a derived class. This is to save\n        # duplicating the implementation for them in all derived classes.\n        dictionary.update(vars(_ObjectProxyMethods))\n        return type.__new__(cls, name, bases, dictionary)\nclass ObjectProxy(with_metaclass(_ObjectProxyMetaType)):\n    __slots__ = '__wrapped__'",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "ObjectProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class ObjectProxy(with_metaclass(_ObjectProxyMetaType)):\n    __slots__ = '__wrapped__'\n    def __init__(self, wrapped):\n        object.__setattr__(self, '__wrapped__', wrapped)\n        # Python 3.2+ has the __qualname__ attribute, but it does not\n        # allow it to be overridden using a property and it must instead\n        # be an actual string object instead.\n        try:\n            object.__setattr__(self, '__qualname__', wrapped.__qualname__)\n        except AttributeError:",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "CallableObjectProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class CallableObjectProxy(ObjectProxy):\n    def __call__(self, *args, **kwargs):\n        return self.__wrapped__(*args, **kwargs)\nclass PartialCallableObjectProxy(ObjectProxy):\n    def __init__(self, *args, **kwargs):\n        if len(args) < 1:\n            raise TypeError('partial type takes at least one argument')\n        wrapped, args = args[0], args[1:]\n        if not callable(wrapped):\n            raise TypeError('the first argument must be callable')",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "PartialCallableObjectProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class PartialCallableObjectProxy(ObjectProxy):\n    def __init__(self, *args, **kwargs):\n        if len(args) < 1:\n            raise TypeError('partial type takes at least one argument')\n        wrapped, args = args[0], args[1:]\n        if not callable(wrapped):\n            raise TypeError('the first argument must be callable')\n        super(PartialCallableObjectProxy, self).__init__(wrapped)\n        self._self_args = args\n        self._self_kwargs = kwargs",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "_FunctionWrapperBase",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class _FunctionWrapperBase(ObjectProxy):\n    __slots__ = ('_self_instance', '_self_wrapper', '_self_enabled',\n            '_self_binding', '_self_parent')\n    def __init__(self, wrapped, instance, wrapper, enabled=None,\n            binding='function', parent=None):\n        super(_FunctionWrapperBase, self).__init__(wrapped)\n        object.__setattr__(self, '_self_instance', instance)\n        object.__setattr__(self, '_self_wrapper', wrapper)\n        object.__setattr__(self, '_self_enabled', enabled)\n        object.__setattr__(self, '_self_binding', binding)",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "BoundFunctionWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class BoundFunctionWrapper(_FunctionWrapperBase):\n    def __call__(self, *args, **kwargs):\n        # If enabled has been specified, then evaluate it at this point\n        # and if the wrapper is not to be executed, then simply return\n        # the bound function rather than a bound wrapper for the bound\n        # function. When evaluating enabled, if it is callable we call\n        # it, otherwise we evaluate it as a boolean.\n        if self._self_enabled is not None:\n            if callable(self._self_enabled):\n                if not self._self_enabled():",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "FunctionWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class FunctionWrapper(_FunctionWrapperBase):\n    __bound_function_wrapper__ = BoundFunctionWrapper\n    def __init__(self, wrapped, wrapper, enabled=None):\n        # What it is we are wrapping here could be anything. We need to\n        # try and detect specific cases though. In particular, we need\n        # to detect when we are given something that is a method of a\n        # class. Further, we need to know when it is likely an instance\n        # method, as opposed to a class or static method. This can\n        # become problematic though as there isn't strictly a fool proof\n        # method of knowing.",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "AttributeWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class AttributeWrapper(object):\n    def __init__(self, attribute, factory, args, kwargs):\n        self.attribute = attribute\n        self.factory = factory\n        self.args = args\n        self.kwargs = kwargs\n    def __get__(self, instance, owner):\n        value = instance.__dict__[self.attribute]\n        return self.factory(value, *self.args, **self.kwargs)\n    def __set__(self, instance, value):",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "WeakFunctionProxy",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "class WeakFunctionProxy(ObjectProxy):\n    __slots__ = ('_self_expired', '_self_instance')\n    def __init__(self, wrapped, callback=None):\n        # We need to determine if the wrapped function is actually a\n        # bound method. In the case of a bound method, we need to keep a\n        # reference to the original unbound function and the instance.\n        # This is necessary because if we hold a reference to the bound\n        # function, it will be the only reference and given it is a\n        # temporary object, it will almost immediately expire and\n        # the weakref callback triggered. So what is done is that we",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "with_metaclass",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})\nclass _ObjectProxyMethods(object):\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "resolve_path",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def resolve_path(module, name):\n    if isinstance(module, string_types):\n        __import__(module)\n        module = sys.modules[module]\n    parent = module\n    path = name.split('.')\n    attribute = path[0]\n    # We can't just always use getattr() because in doing\n    # that on a class it will cause binding to occur which\n    # will complicate things later and cause some things not",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "apply_patch",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def apply_patch(parent, attribute, replacement):\n    setattr(parent, attribute, replacement)\ndef wrap_object(module, name, factory, args=(), kwargs={}):\n    (parent, attribute, original) = resolve_path(module, name)\n    wrapper = factory(original, *args, **kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n# Function for applying a proxy object to an attribute of a class\n# instance. The wrapper works by defining an attribute of the same name\n# on the class which is a descriptor and which intercepts access to the",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "wrap_object",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def wrap_object(module, name, factory, args=(), kwargs={}):\n    (parent, attribute, original) = resolve_path(module, name)\n    wrapper = factory(original, *args, **kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n# Function for applying a proxy object to an attribute of a class\n# instance. The wrapper works by defining an attribute of the same name\n# on the class which is a descriptor and which intercepts access to the\n# instance attribute. Note that this cannot be used on attributes which\n# are themselves defined by a property object.",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "wrap_object_attribute",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def wrap_object_attribute(module, name, factory, args=(), kwargs={}):\n    path, attribute = name.rsplit('.', 1)\n    parent = resolve_path(module, path)[2]\n    wrapper = AttributeWrapper(attribute, factory, args, kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n# Functions for creating a simple decorator using a FunctionWrapper,\n# plus short cut functions for applying wrappers to functions. These are\n# for use when doing monkey patching. For a more featured way of\n# creating decorators see the decorator decorator instead.",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "function_wrapper",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def function_wrapper(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        target_wrapped = args[0]\n        if instance is None:\n            target_wrapper = wrapper\n        elif inspect.isclass(instance):\n            target_wrapper = wrapper.__get__(None, instance)\n        else:\n            target_wrapper = wrapper.__get__(instance, type(instance))\n        return FunctionWrapper(target_wrapped, target_wrapper)",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "wrap_function_wrapper",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def wrap_function_wrapper(module, name, wrapper):\n    return wrap_object(module, name, FunctionWrapper, (wrapper,))\ndef patch_function_wrapper(module, name):\n    def _wrapper(wrapper):\n        return wrap_object(module, name, FunctionWrapper, (wrapper,))\n    return _wrapper\ndef transient_function_wrapper(module, name):\n    def _decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            target_wrapped = args[0]",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "patch_function_wrapper",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def patch_function_wrapper(module, name):\n    def _wrapper(wrapper):\n        return wrap_object(module, name, FunctionWrapper, (wrapper,))\n    return _wrapper\ndef transient_function_wrapper(module, name):\n    def _decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            target_wrapped = args[0]\n            if instance is None:\n                target_wrapper = wrapper",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "transient_function_wrapper",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "def transient_function_wrapper(module, name):\n    def _decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            target_wrapped = args[0]\n            if instance is None:\n                target_wrapper = wrapper\n            elif inspect.isclass(instance):\n                target_wrapper = wrapper.__get__(None, instance)\n            else:\n                target_wrapper = wrapper.__get__(instance, type(instance))",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.wrapt.wrappers",
        "description": "__pypackages__.3.10.lib.wrapt.wrappers",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})\nclass _ObjectProxyMethods(object):\n    # We use properties to override the values of __module__ and",
        "detail": "__pypackages__.3.10.lib.wrapt.wrappers",
        "documentation": {}
    },
    {
        "label": "documentatio",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class documentation for more information.\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\nimport argparse\nimport codecs\nimport collections\nimport copy",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "FixPEP8",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class FixPEP8(object):\n    \"\"\"Fix invalid code.\n    Fixer methods are prefixed \"fix_\". The _fix_source() method looks for these\n    automatically.\n    The fixer method can take either one or two arguments (in addition to\n    self). The first argument is \"result\", which is the error information from\n    pycodestyle. The second argument, \"logical\", is required only for\n    logical-line fixes.\n    The fixer method can return the list of modified lines or None. An empty\n    list would mean that no changes were made. None would mean that only the",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "ReformattedLines",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class ReformattedLines(object):\n    \"\"\"The reflowed lines of atoms.\n    Each part of the line is represented as an \"atom.\" They can be moved\n    around when need be to get the optimal formatting.\n    \"\"\"\n    ###########################################################################\n    # Private Classes\n    class _Indent(object):\n        \"\"\"Represent an indentation in the atom stream.\"\"\"\n        def __init__(self, indent_amt):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "Atom",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class Atom(object):\n    \"\"\"The smallest unbreakable unit that can be reflowed.\"\"\"\n    def __init__(self, atom):\n        self._atom = atom\n    def __repr__(self):\n        return self._atom.token_string\n    def __len__(self):\n        return self.size\n    def reflow(\n        self, reflowed_lines, continued_indent, extent,",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class Container(object):\n    \"\"\"Base class for all container types.\"\"\"\n    def __init__(self, items):\n        self._items = items\n    def __repr__(self):\n        string = ''\n        last_was_keyword = False\n        for item in self._items:\n            if item.is_comma:\n                string += ', '",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class Tuple(Container):\n    \"\"\"A high-level representation of a tuple.\"\"\"\n    @property\n    def open_bracket(self):\n        return '('\n    @property\n    def close_bracket(self):\n        return ')'\nclass List(Container):\n    \"\"\"A high-level representation of a list.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class List(Container):\n    \"\"\"A high-level representation of a list.\"\"\"\n    @property\n    def open_bracket(self):\n        return '['\n    @property\n    def close_bracket(self):\n        return ']'\nclass DictOrSet(Container):\n    \"\"\"A high-level representation of a dictionary or set.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "DictOrSet",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class DictOrSet(Container):\n    \"\"\"A high-level representation of a dictionary or set.\"\"\"\n    @property\n    def open_bracket(self):\n        return '{'\n    @property\n    def close_bracket(self):\n        return '}'\nclass ListComprehension(Container):\n    \"\"\"A high-level representation of a list comprehension.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "ListComprehension",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class ListComprehension(Container):\n    \"\"\"A high-level representation of a list comprehension.\"\"\"\n    @property\n    def size(self):\n        length = 0\n        for item in self._items:\n            if isinstance(item, IfExpression):\n                break\n            length += item.size\n        return length",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "IfExpression",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class IfExpression(Container):\n    \"\"\"A high-level representation of an if-expression.\"\"\"\ndef _parse_container(tokens, index, for_or_if=None):\n    \"\"\"Parse a high-level container, such as a list, tuple, etc.\"\"\"\n    # Store the opening bracket.\n    items = [Atom(Token(*tokens[index]))]\n    index += 1\n    num_tokens = len(tokens)\n    while index < num_tokens:\n        tok = Token(*tokens[index])",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "Reindenter",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class Reindenter(object):\n    \"\"\"Reindents badly-indented code to uniformly use four-space indentation.\n    Released to the public domain, by Tim Peters, 03 October 2000.\n    \"\"\"\n    def __init__(self, input_text, leave_tabs=False):\n        sio = io.StringIO(input_text)\n        source_lines = sio.readlines()\n        self.string_content_line_numbers = multiline_string_lines(input_text)\n        # File lines, rstripped & tab-expanded. Dummy at start is so\n        # that we can use tokenize's 1-based line numbering easily.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "LineEndingWrapper",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class LineEndingWrapper(object):\n    r\"\"\"Replace line endings to work with sys.stdout.\n    It seems that sys.stdout expects only '\\n' as the line ending, no matter\n    the platform. Otherwise, we get repeated line endings.\n    \"\"\"\n    def __init__(self, output):\n        self.__output = output\n    def write(self, s):\n        self.__output.write(s.replace('\\r\\n', '\\n').replace('\\r', '\\n'))\n    def flush(self):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "CachedTokenizer",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "class CachedTokenizer(object):\n    \"\"\"A one-element cache around tokenize.generate_tokens().\n    Original code written by Ned Batchelder, in coverage.py.\n    \"\"\"\n    def __init__(self):\n        self.last_text = None\n        self.last_tokens = None\n    def generate_tokens(self, text):\n        \"\"\"A stand-in for tokenize.generate_tokens().\"\"\"\n        if text != self.last_text:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "open_with_encoding",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def open_with_encoding(filename, mode='r', encoding=None, limit_byte_check=-1):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    if not encoding:\n        encoding = detect_encoding(filename, limit_byte_check=limit_byte_check)\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')  # Preserve line endings\ndef detect_encoding(filename, limit_byte_check=-1):\n    \"\"\"Return file encoding.\"\"\"\n    try:\n        with open(filename, 'rb') as input_file:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def detect_encoding(filename, limit_byte_check=-1):\n    \"\"\"Return file encoding.\"\"\"\n    try:\n        with open(filename, 'rb') as input_file:\n            from lib2to3.pgen2 import tokenize as lib2to3_tokenize\n            encoding = lib2to3_tokenize.detect_encoding(input_file.readline)[0]\n        with open_with_encoding(filename, encoding=encoding) as test_file:\n            test_file.read(limit_byte_check)\n        return encoding\n    except (LookupError, SyntaxError, UnicodeDecodeError):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "readlines_from_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def readlines_from_file(filename):\n    \"\"\"Return contents of file.\"\"\"\n    with open_with_encoding(filename) as input_file:\n        return input_file.readlines()\ndef extended_blank_lines(logical_line,\n                         blank_lines,\n                         blank_before,\n                         indent_level,\n                         previous_logical):\n    \"\"\"Check for missing blank lines after class declaration.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "extended_blank_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def extended_blank_lines(logical_line,\n                         blank_lines,\n                         blank_before,\n                         indent_level,\n                         previous_logical):\n    \"\"\"Check for missing blank lines after class declaration.\"\"\"\n    if previous_logical.startswith('def '):\n        if blank_lines and pycodestyle.DOCSTRING_REGEX.match(logical_line):\n            yield (0, 'E303 too many blank lines ({})'.format(blank_lines))\n    elif pycodestyle.DOCSTRING_REGEX.match(previous_logical):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "continued_indentation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def continued_indentation(logical_line, tokens, indent_level, hang_closing,\n                          indent_char, noqa):\n    \"\"\"Override pycodestyle's function to provide indentation information.\"\"\"\n    first_row = tokens[0][2][0]\n    nrows = 1 + tokens[-1][2][0] - first_row\n    if noqa or nrows == 1:\n        return\n    # indent_next tells us whether the next block is indented. Assuming\n    # that it is indented by 4 spaces, then we should not allow 4-space\n    # indents on the final continuation line. In turn, some other",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_module_imports_on_top_of_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_module_imports_on_top_of_file(source, import_line_index):\n    \"\"\"return import or from keyword position\n    example:\n      > 0: import sys\n        1: import os\n        2:\n        3: def function():\n    \"\"\"\n    def is_string_literal(line):\n        if line[0] in 'uUbB':",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_index_offset_contents",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_index_offset_contents(result, source):\n    \"\"\"Return (line_index, column_offset, line_contents).\"\"\"\n    line_index = result['line'] - 1\n    return (line_index,\n            result['column'] - 1,\n            source[line_index])\ndef get_fixed_long_line(target, previous_line, original,\n                        indent_word='    ', max_line_length=79,\n                        aggressive=False, experimental=False, verbose=False):\n    \"\"\"Break up long line and return result.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_fixed_long_line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_fixed_long_line(target, previous_line, original,\n                        indent_word='    ', max_line_length=79,\n                        aggressive=False, experimental=False, verbose=False):\n    \"\"\"Break up long line and return result.\n    Do this by generating multiple reformatted candidates and then\n    ranking the candidates to heuristically select the best option.\n    \"\"\"\n    indent = _get_indentation(target)\n    source = target[len(indent):]\n    assert source.lstrip() == source",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "longest_line_length",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def longest_line_length(code):\n    \"\"\"Return length of longest line.\"\"\"\n    if len(code) == 0:\n        return 0\n    return max(len(line) for line in code.splitlines())\ndef join_logical_line(logical_line):\n    \"\"\"Return single line based on logical line input.\"\"\"\n    indentation = _get_indentation(logical_line)\n    return indentation + untokenize_without_newlines(\n        generate_tokens(logical_line.lstrip())) + '\\n'",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "join_logical_line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def join_logical_line(logical_line):\n    \"\"\"Return single line based on logical line input.\"\"\"\n    indentation = _get_indentation(logical_line)\n    return indentation + untokenize_without_newlines(\n        generate_tokens(logical_line.lstrip())) + '\\n'\ndef untokenize_without_newlines(tokens):\n    \"\"\"Return source code based on tokens.\"\"\"\n    text = ''\n    last_row = 0\n    last_column = -1",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "untokenize_without_newlines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def untokenize_without_newlines(tokens):\n    \"\"\"Return source code based on tokens.\"\"\"\n    text = ''\n    last_row = 0\n    last_column = -1\n    for t in tokens:\n        token_string = t[1]\n        (start_row, start_column) = t[2]\n        (end_row, end_column) = t[3]\n        if start_row > last_row:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_item",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_item(items, index, default=None):\n    if 0 <= index < len(items):\n        return items[index]\n    return default\ndef reindent(source, indent_size, leave_tabs=False):\n    \"\"\"Reindent all lines.\"\"\"\n    reindenter = Reindenter(source, leave_tabs)\n    return reindenter.run(indent_size)\ndef code_almost_equal(a, b):\n    \"\"\"Return True if code is similar.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "reindent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def reindent(source, indent_size, leave_tabs=False):\n    \"\"\"Reindent all lines.\"\"\"\n    reindenter = Reindenter(source, leave_tabs)\n    return reindenter.run(indent_size)\ndef code_almost_equal(a, b):\n    \"\"\"Return True if code is similar.\n    Ignore whitespace when comparing specific line.\n    \"\"\"\n    split_a = split_and_strip_non_empty_lines(a)\n    split_b = split_and_strip_non_empty_lines(b)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "code_almost_equal",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def code_almost_equal(a, b):\n    \"\"\"Return True if code is similar.\n    Ignore whitespace when comparing specific line.\n    \"\"\"\n    split_a = split_and_strip_non_empty_lines(a)\n    split_b = split_and_strip_non_empty_lines(b)\n    if len(split_a) != len(split_b):\n        return False\n    for (index, _) in enumerate(split_a):\n        if ''.join(split_a[index].split()) != ''.join(split_b[index].split()):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "split_and_strip_non_empty_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def split_and_strip_non_empty_lines(text):\n    \"\"\"Return lines split by newline.\n    Ignore empty lines.\n    \"\"\"\n    return [line.strip() for line in text.splitlines() if line.strip()]\ndef refactor(source, fixer_names, ignore=None, filename=''):\n    \"\"\"Return refactored code using lib2to3.\n    Skip if ignore string is produced in the refactored code.\n    \"\"\"\n    not_found_end_of_file_newline = source and source.rstrip(\"\\r\\n\") == source",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "refactor",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def refactor(source, fixer_names, ignore=None, filename=''):\n    \"\"\"Return refactored code using lib2to3.\n    Skip if ignore string is produced in the refactored code.\n    \"\"\"\n    not_found_end_of_file_newline = source and source.rstrip(\"\\r\\n\") == source\n    if not_found_end_of_file_newline:\n        input_source = source + \"\\n\"\n    else:\n        input_source = source\n    from lib2to3 import pgen2",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "code_to_2to3",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def code_to_2to3(select, ignore, where='', verbose=False):\n    fixes = set()\n    for code, fix in CODE_TO_2TO3.items():\n        if code_match(code, select=select, ignore=ignore):\n            if verbose:\n                print('--->  Applying {} fix for {}'.format(where,\n                                                            code.upper()),\n                      file=sys.stderr)\n            fixes |= set(fix)\n    return fixes",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_2to3",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_2to3(source,\n             aggressive=True, select=None, ignore=None, filename='',\n             where='global', verbose=False):\n    \"\"\"Fix various deprecated code (via lib2to3).\"\"\"\n    if not aggressive:\n        return source\n    select = select or []\n    ignore = ignore or []\n    return refactor(source,\n                    code_to_2to3(select=select,",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "find_newline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def find_newline(source):\n    \"\"\"Return type of newline used in source.\n    Input is a list of lines.\n    \"\"\"\n    assert not isinstance(source, str)\n    counter = collections.defaultdict(int)\n    for line in source:\n        if line.endswith(CRLF):\n            counter[CRLF] += 1\n        elif line.endswith(CR):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_diff_text",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_diff_text(old, new, filename):\n    \"\"\"Return text of unified diff between old and new.\"\"\"\n    newline = '\\n'\n    diff = difflib.unified_diff(\n        old, new,\n        'original/' + filename,\n        'fixed/' + filename,\n        lineterm=newline)\n    text = ''\n    for line in diff:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "shorten_line",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def shorten_line(tokens, source, indentation, indent_word, max_line_length,\n                 aggressive=False, experimental=False, previous_line=''):\n    \"\"\"Separate line at OPERATOR.\n    Multiple candidates will be yielded.\n    \"\"\"\n    for candidate in _shorten_line(tokens=tokens,\n                                   source=source,\n                                   indentation=indentation,\n                                   indent_word=indent_word,\n                                   aggressive=aggressive,",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "token_offsets",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def token_offsets(tokens):\n    \"\"\"Yield tokens and offsets.\"\"\"\n    end_offset = 0\n    previous_end_row = 0\n    previous_end_column = 0\n    for t in tokens:\n        token_type = t[0]\n        token_string = t[1]\n        (start_row, start_column) = t[2]\n        (end_row, end_column) = t[3]",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "normalize_multiline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def normalize_multiline(line):\n    \"\"\"Normalize multiline-related code that will cause syntax error.\n    This is for purposes of checking syntax.\n    \"\"\"\n    if line.startswith('def ') and line.rstrip().endswith(':'):\n        return line + ' pass'\n    elif line.startswith('return '):\n        return 'def _(): ' + line\n    elif line.startswith('@'):\n        return line + 'def _(): pass'",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_whitespace(line, offset, replacement):\n    \"\"\"Replace whitespace at offset and return fixed line.\"\"\"\n    # Replace escaped newlines too\n    left = line[:offset].rstrip('\\n\\r \\t\\\\')\n    right = line[offset:].lstrip('\\n\\r \\t\\\\')\n    if right.startswith('#'):\n        return line\n    return left + replacement + right\ndef _execute_pep8(pep8_options, source):\n    \"\"\"Execute pycodestyle via python method calls.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "refactor_with_2to3",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def refactor_with_2to3(source_text, fixer_names, filename=''):\n    \"\"\"Use lib2to3 to refactor the source.\n    Return the refactored source code.\n    \"\"\"\n    from lib2to3.refactor import RefactoringTool\n    fixers = ['lib2to3.fixes.fix_' + name for name in fixer_names]\n    tool = RefactoringTool(fixer_names=fixers, explicit=fixers)\n    from lib2to3.pgen2 import tokenize as lib2to3_tokenize\n    try:\n        # The name parameter is necessary particularly for the \"import\" fixer.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "check_syntax",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def check_syntax(code):\n    \"\"\"Return True if syntax is okay.\"\"\"\n    try:\n        return compile(code, '<string>', 'exec', dont_inherit=True)\n    except (SyntaxError, TypeError, ValueError):\n        return False\ndef find_with_line_numbers(pattern, contents):\n    \"\"\"A wrapper around 're.finditer' to find line numbers.\n    Returns a list of line numbers where pattern was found in contents.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "find_with_line_numbers",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def find_with_line_numbers(pattern, contents):\n    \"\"\"A wrapper around 're.finditer' to find line numbers.\n    Returns a list of line numbers where pattern was found in contents.\n    \"\"\"\n    matches = list(re.finditer(pattern, contents))\n    if not matches:\n        return []\n    end = matches[-1].start()\n    # -1 so a failed `rfind` maps to the first line.\n    newline_offsets = {",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_disabled_ranges",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_disabled_ranges(source):\n    \"\"\"Returns a list of tuples representing the disabled ranges.\n    If disabled and no re-enable will disable for rest of file.\n    \"\"\"\n    enable_line_nums = find_with_line_numbers(ENABLE_REGEX, source)\n    disable_line_nums = find_with_line_numbers(DISABLE_REGEX, source)\n    total_lines = len(re.findall(\"\\n\", source)) + 1\n    enable_commands = {}\n    for num in enable_line_nums:\n        enable_commands[num] = True",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "filter_disabled_results",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def filter_disabled_results(result, disabled_ranges):\n    \"\"\"Filter out reports based on tuple of disabled ranges.\n    \"\"\"\n    line = result['line']\n    for disabled_range in disabled_ranges:\n        if disabled_range[0] <= line <= disabled_range[1]:\n            return False\n    return True\ndef filter_results(source, results, aggressive):\n    \"\"\"Filter out spurious reports from pycodestyle.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "filter_results",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def filter_results(source, results, aggressive):\n    \"\"\"Filter out spurious reports from pycodestyle.\n    If aggressive is True, we allow possibly unsafe fixes (E711, E712).\n    \"\"\"\n    non_docstring_string_line_numbers = multiline_string_lines(\n        source, include_docstrings=False)\n    all_string_line_numbers = multiline_string_lines(\n        source, include_docstrings=True)\n    commented_out_code_line_numbers = commented_out_code_lines(source)\n    # Filter out the disabled ranges",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "multiline_string_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def multiline_string_lines(source, include_docstrings=False):\n    \"\"\"Return line numbers that are within multiline strings.\n    The line numbers are indexed at 1.\n    Docstrings are ignored.\n    \"\"\"\n    line_numbers = set()\n    previous_token_type = ''\n    try:\n        for t in generate_tokens(source):\n            token_type = t[0]",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "commented_out_code_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def commented_out_code_lines(source):\n    \"\"\"Return line numbers of comments that are likely code.\n    Commented-out code is bad practice, but modifying it just adds even\n    more clutter.\n    \"\"\"\n    line_numbers = []\n    try:\n        for t in generate_tokens(source):\n            token_type = t[0]\n            token_string = t[1]",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "shorten_comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def shorten_comment(line, max_line_length, last_comment=False):\n    \"\"\"Return trimmed or split long comment line.\n    If there are no comments immediately following it, do a text wrap.\n    Doing this wrapping on all comments in general would lead to jagged\n    comment text.\n    \"\"\"\n    assert len(line) > max_line_length\n    line = line.rstrip()\n    # PEP 8 recommends 72 characters for comment text.\n    indentation = _get_indentation(line) + '# '",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "normalize_line_endings",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def normalize_line_endings(lines, newline):\n    \"\"\"Return fixed line endings.\n    All lines will be modified to use the most common line ending.\n    \"\"\"\n    line = [line.rstrip('\\n\\r') + newline for line in lines]\n    if line and lines[-1] == lines[-1].rstrip('\\n\\r'):\n        line[-1] = line[-1].rstrip('\\n\\r')\n    return line\ndef mutual_startswith(a, b):\n    return b.startswith(a) or a.startswith(b)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "mutual_startswith",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def mutual_startswith(a, b):\n    return b.startswith(a) or a.startswith(b)\ndef code_match(code, select, ignore):\n    if ignore:\n        assert not isinstance(ignore, str)\n        for ignored_code in [c.strip() for c in ignore]:\n            if mutual_startswith(code.lower(), ignored_code.lower()):\n                return False\n    if select:\n        assert not isinstance(select, str)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "code_match",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def code_match(code, select, ignore):\n    if ignore:\n        assert not isinstance(ignore, str)\n        for ignored_code in [c.strip() for c in ignore]:\n            if mutual_startswith(code.lower(), ignored_code.lower()):\n                return False\n    if select:\n        assert not isinstance(select, str)\n        for selected_code in [c.strip() for c in select]:\n            if mutual_startswith(code.lower(), selected_code.lower()):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_code",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_code(source, options=None, encoding=None, apply_config=False):\n    \"\"\"Return fixed source code.\n    \"encoding\" will be used to decode \"source\" if it is a byte string.\n    \"\"\"\n    options = _get_options(options, apply_config)\n    if not isinstance(source, str):\n        source = source.decode(encoding or get_encoding())\n    sio = io.StringIO(source)\n    return fix_lines(sio.readlines(), options=options)\ndef _get_options(raw_options, apply_config):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_lines(source_lines, options, filename=''):\n    \"\"\"Return fixed source code.\"\"\"\n    # Transform everything to line feed. Then change them back to original\n    # before returning fixed source code.\n    original_newline = find_newline(source_lines)\n    tmp_source = ''.join(normalize_line_endings(source_lines, '\\n'))\n    # Keep a history to break out of cycles.\n    previous_hashes = set()\n    if options.line_range:\n        # Disable \"apply_local_fixes()\" for now due to issue #175.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_file(filename, options=None, output=None, apply_config=False):\n    if not options:\n        options = parse_args([filename], apply_config=apply_config)\n    original_source = readlines_from_file(filename)\n    fixed_source = original_source\n    if options.in_place or options.diff or output:\n        encoding = detect_encoding(filename)\n    if output:\n        output = LineEndingWrapper(wrap_output(output, encoding=encoding))\n    fixed_source = fix_lines(fixed_source, options, filename=filename)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "global_fixes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def global_fixes():\n    \"\"\"Yield multiple (code, function) tuples.\"\"\"\n    for function in list(globals().values()):\n        if inspect.isfunction(function):\n            arguments = _get_parameters(function)\n            if arguments[:1] != ['source']:\n                continue\n            code = extract_code_from_function(function)\n            if code:\n                yield (code, function)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "apply_global_fixes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def apply_global_fixes(source, options, where='global', filename='',\n                       codes=None):\n    \"\"\"Run global fixes on source code.\n    These are fixes that only need be done once (unlike those in\n    FixPEP8, which are dependent on pycodestyle).\n    \"\"\"\n    if codes is None:\n        codes = []\n    if any(code_match(code, select=options.select, ignore=options.ignore)\n           for code in ['E101', 'E111']):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "extract_code_from_function",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def extract_code_from_function(function):\n    \"\"\"Return code handled by function.\"\"\"\n    if not function.__name__.startswith('fix_'):\n        return None\n    code = re.sub('^fix_', '', function.__name__)\n    if not code:\n        return None\n    try:\n        int(code[1:])\n    except ValueError:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def create_parser():\n    \"\"\"Return command-line parser.\"\"\"\n    parser = argparse.ArgumentParser(description=docstring_summary(__doc__),\n                                     prog='autopep8')\n    parser.add_argument('--version', action='version',\n                        version='%(prog)s {} ({})'.format(\n                            __version__, _get_package_version()))\n    parser.add_argument('-v', '--verbose', action='count',\n                        default=0,\n                        help='print verbose messages; '",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def parse_args(arguments, apply_config=False):\n    \"\"\"Parse command-line options.\"\"\"\n    parser = create_parser()\n    args = parser.parse_args(arguments)\n    if not args.files and not args.list_fixes:\n        parser.exit(EXIT_CODE_ARGPARSE_ERROR, 'incorrect number of arguments')\n    args.files = [decode_filename(name) for name in args.files]\n    if apply_config:\n        parser = read_config(args, parser)\n        # prioritize settings when exist pyproject.toml's tool.autopep8 section",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "read_config",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def read_config(args, parser):\n    \"\"\"Read both user configuration and local configuration.\"\"\"\n    config = SafeConfigParser()\n    try:\n        if args.verbose and os.path.exists(args.global_config):\n            print(\"read config path: {}\".format(args.global_config))\n        config.read(args.global_config)\n        if not args.ignore_local_config:\n            parent = tail = args.files and os.path.abspath(\n                os.path.commonprefix(args.files))",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "read_pyproject_toml",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def read_pyproject_toml(args, parser):\n    \"\"\"Read pyproject.toml and load configuration.\"\"\"\n    if sys.version_info >= (3, 11):\n        import tomllib\n    else:\n        import tomli as tomllib\n    config = None\n    if os.path.exists(args.global_config):\n        with open(args.global_config, \"rb\") as fp:\n            config = tomllib.load(fp)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "decode_filename",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def decode_filename(filename):\n    \"\"\"Return Unicode filename.\"\"\"\n    if isinstance(filename, str):\n        return filename\n    return filename.decode(sys.getfilesystemencoding())\ndef supported_fixes():\n    \"\"\"Yield pep8 error codes that autopep8 fixes.\n    Each item we yield is a tuple of the code followed by its\n    description.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "supported_fixes",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def supported_fixes():\n    \"\"\"Yield pep8 error codes that autopep8 fixes.\n    Each item we yield is a tuple of the code followed by its\n    description.\n    \"\"\"\n    yield ('E101', docstring_summary(reindent.__doc__))\n    instance = FixPEP8(filename=None, options=None, contents='')\n    for attribute in dir(instance):\n        code = re.match('fix_([ew][0-9][0-9][0-9])', attribute)\n        if code:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "docstring_summary",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def docstring_summary(docstring):\n    \"\"\"Return summary of docstring.\"\"\"\n    return docstring.split('\\n')[0] if docstring else ''\ndef line_shortening_rank(candidate, indent_word, max_line_length,\n                         experimental=False):\n    \"\"\"Return rank of candidate.\n    This is for sorting candidates.\n    \"\"\"\n    if not candidate.strip():\n        return 0",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "line_shortening_rank",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def line_shortening_rank(candidate, indent_word, max_line_length,\n                         experimental=False):\n    \"\"\"Return rank of candidate.\n    This is for sorting candidates.\n    \"\"\"\n    if not candidate.strip():\n        return 0\n    rank = 0\n    lines = candidate.rstrip().split('\\n')\n    offset = 0",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "standard_deviation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def standard_deviation(numbers):\n    \"\"\"Return standard deviation.\"\"\"\n    numbers = list(numbers)\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    return (sum((n - mean) ** 2 for n in numbers) /\n            len(numbers)) ** .5\ndef has_arithmetic_operator(line):\n    \"\"\"Return True if line contains any arithmetic operators.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "has_arithmetic_operator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def has_arithmetic_operator(line):\n    \"\"\"Return True if line contains any arithmetic operators.\"\"\"\n    for operator in pycodestyle.ARITHMETIC_OP:\n        if operator in line:\n            return True\n    return False\ndef count_unbalanced_brackets(line):\n    \"\"\"Return number of unmatched open/close brackets.\"\"\"\n    count = 0\n    for opening, closing in ['()', '[]', '{}']:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "count_unbalanced_brackets",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def count_unbalanced_brackets(line):\n    \"\"\"Return number of unmatched open/close brackets.\"\"\"\n    count = 0\n    for opening, closing in ['()', '[]', '{}']:\n        count += abs(line.count(opening) - line.count(closing))\n    return count\ndef split_at_offsets(line, offsets):\n    \"\"\"Split line at offsets.\n    Return list of strings.\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "split_at_offsets",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def split_at_offsets(line, offsets):\n    \"\"\"Split line at offsets.\n    Return list of strings.\n    \"\"\"\n    result = []\n    previous_offset = 0\n    current_offset = 0\n    for current_offset in sorted(offsets):\n        if current_offset < len(line) and previous_offset != current_offset:\n            result.append(line[previous_offset:current_offset].strip())",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "match_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def match_file(filename, exclude):\n    \"\"\"Return True if file is okay for modifying/recursing.\"\"\"\n    base_name = os.path.basename(filename)\n    if base_name.startswith('.'):\n        return False\n    for pattern in exclude:\n        if fnmatch.fnmatch(base_name, pattern):\n            return False\n        if fnmatch.fnmatch(filename, pattern):\n            return False",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "find_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def find_files(filenames, recursive, exclude):\n    \"\"\"Yield filenames.\"\"\"\n    while filenames:\n        name = filenames.pop(0)\n        if recursive and os.path.isdir(name):\n            for root, directories, children in os.walk(name):\n                filenames += [os.path.join(root, f) for f in children\n                              if match_file(os.path.join(root, f),\n                                            exclude)]\n                directories[:] = [d for d in directories",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "fix_multiple_files",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def fix_multiple_files(filenames, options, output=None):\n    \"\"\"Fix list of files.\n    Optionally fix files recursively.\n    \"\"\"\n    results = []\n    filenames = find_files(filenames, options.recursive, options.exclude)\n    if options.jobs > 1:\n        import multiprocessing\n        pool = multiprocessing.Pool(options.jobs)\n        rets = []",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "is_python_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def is_python_file(filename):\n    \"\"\"Return True if filename is Python file.\"\"\"\n    if filename.endswith('.py'):\n        return True\n    try:\n        with open_with_encoding(\n                filename,\n                limit_byte_check=MAX_PYTHON_FILE_DETECTION_BYTES) as f:\n            text = f.read(MAX_PYTHON_FILE_DETECTION_BYTES)\n            if not text:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "is_probably_part_of_multiline",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def is_probably_part_of_multiline(line):\n    \"\"\"Return True if line is likely part of a multiline string.\n    When multiline strings are involved, pep8 reports the error as being\n    at the start of the multiline string, which doesn't work for us.\n    \"\"\"\n    return (\n        '\"\"\"' in line or\n        \"'''\" in line or\n        line.rstrip().endswith('\\\\')\n    )",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "wrap_output",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def wrap_output(output, encoding):\n    \"\"\"Return output with specified encoding.\"\"\"\n    return codecs.getwriter(encoding)(output.buffer\n                                      if hasattr(output, 'buffer')\n                                      else output)\ndef get_encoding():\n    \"\"\"Return preferred encoding.\"\"\"\n    return locale.getpreferredencoding() or sys.getdefaultencoding()\ndef main(argv=None, apply_config=True):\n    \"\"\"Command-line entry.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "get_encoding",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def get_encoding():\n    \"\"\"Return preferred encoding.\"\"\"\n    return locale.getpreferredencoding() or sys.getdefaultencoding()\ndef main(argv=None, apply_config=True):\n    \"\"\"Command-line entry.\"\"\"\n    if argv is None:\n        argv = sys.argv\n    try:\n        # Exit on broken pipe.\n        signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "def main(argv=None, apply_config=True):\n    \"\"\"Command-line entry.\"\"\"\n    if argv is None:\n        argv = sys.argv\n    try:\n        # Exit on broken pipe.\n        signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n    except AttributeError:  # pragma: no cover\n        # SIGPIPE is not available on Windows.\n        pass",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "__version__ = '2.0.1'\nCR = '\\r'\nLF = '\\n'\nCRLF = '\\r\\n'\nPYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\\bpython[23]?\\b\\s*$')\nLAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "CR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "CR = '\\r'\nLF = '\\n'\nCRLF = '\\r\\n'\nPYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\\bpython[23]?\\b\\s*$')\nLAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "LF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "LF = '\\n'\nCRLF = '\\r\\n'\nPYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\\bpython[23]?\\b\\s*$')\nLAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "CRLF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "CRLF = '\\r\\n'\nPYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\\bpython[23]?\\b\\s*$')\nLAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "PYTHON_SHEBANG_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "PYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\\bpython[23]?\\b\\s*$')\nLAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "LAMBDA_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "LAMBDA_REGEX = re.compile(r'([\\w.]+)\\s=\\slambda\\s*([)(=\\w,\\s.]*):')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "COMPARE_NEGATIVE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "COMPARE_NEGATIVE_REGEX = re.compile(r'\\b(not)\\s+([^][)(}{]+?)\\s+(in|is)\\s')\nCOMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "COMPARE_NEGATIVE_REGEX_THROUGH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "COMPARE_NEGATIVE_REGEX_THROUGH = re.compile(r'\\b(not\\s+in|is\\s+not)\\s')\nBARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "BARE_EXCEPT_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "BARE_EXCEPT_REGEX = re.compile(r'except\\s*:')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "STARTSWITH_DEF_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "STARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\s.*\\):')\nDOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "DOCSTRING_START_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "DOCSTRING_START_REGEX = re.compile(r'^u?r?(?P<kind>[\"\\']{3})')\nENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "ENABLE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "ENABLE_REGEX = re.compile(r'# *(fmt|autopep8): *on')\nDISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "DISABLE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "DISABLE_REGEX = re.compile(r'# *(fmt|autopep8): *off')\nEXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "EXIT_CODE_OK",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "EXIT_CODE_OK = 0\nEXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),\n    frozenset(['%', '(', '[', '{']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "EXIT_CODE_ERROR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "EXIT_CODE_ERROR = 1\nEXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),\n    frozenset(['%', '(', '[', '{']),\n    frozenset([',', '(', '[', '{', '%', '+', '-', '*', '/', '//']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "EXIT_CODE_EXISTS_DIFF",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "EXIT_CODE_EXISTS_DIFF = 2\nEXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),\n    frozenset(['%', '(', '[', '{']),\n    frozenset([',', '(', '[', '{', '%', '+', '-', '*', '/', '//']),\n    frozenset(['%', '+', '-', '*', '/', '//']),",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "EXIT_CODE_ARGPARSE_ERROR",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "EXIT_CODE_ARGPARSE_ERROR = 99\n# For generating line shortening candidates.\nSHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),\n    frozenset(['%', '(', '[', '{']),\n    frozenset([',', '(', '[', '{', '%', '+', '-', '*', '/', '//']),\n    frozenset(['%', '+', '-', '*', '/', '//']),\n])",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "SHORTEN_OPERATOR_GROUPS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "SHORTEN_OPERATOR_GROUPS = frozenset([\n    frozenset([',']),\n    frozenset(['%']),\n    frozenset([',', '(', '[', '{']),\n    frozenset(['%', '(', '[', '{']),\n    frozenset([',', '(', '[', '{', '%', '+', '-', '*', '/', '//']),\n    frozenset(['%', '+', '-', '*', '/', '//']),\n])\nDEFAULT_IGNORE = 'E226,E24,W50,W690'    # TODO: use pycodestyle.DEFAULT_IGNORE\nDEFAULT_INDENT_SIZE = 4",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "DEFAULT_IGNORE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "DEFAULT_IGNORE = 'E226,E24,W50,W690'    # TODO: use pycodestyle.DEFAULT_IGNORE\nDEFAULT_INDENT_SIZE = 4\n# these fixes conflict with each other, if the `--ignore` setting causes both\n# to be enabled, disable both of them\nCONFLICTING_CODES = ('W503', 'W504')\n# W602 is handled separately due to the need to avoid \"with_traceback\".\nCODE_TO_2TO3 = {\n    'E231': ['ws_comma'],\n    'E721': ['idioms'],\n    'W690': ['apply',",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INDENT_SIZE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "DEFAULT_INDENT_SIZE = 4\n# these fixes conflict with each other, if the `--ignore` setting causes both\n# to be enabled, disable both of them\nCONFLICTING_CODES = ('W503', 'W504')\n# W602 is handled separately due to the need to avoid \"with_traceback\".\nCODE_TO_2TO3 = {\n    'E231': ['ws_comma'],\n    'E721': ['idioms'],\n    'W690': ['apply',\n             'except',",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "CONFLICTING_CODES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "CONFLICTING_CODES = ('W503', 'W504')\n# W602 is handled separately due to the need to avoid \"with_traceback\".\nCODE_TO_2TO3 = {\n    'E231': ['ws_comma'],\n    'E721': ['idioms'],\n    'W690': ['apply',\n             'except',\n             'exitfunc',\n             'numliterals',\n             'operator',",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "CODE_TO_2TO3",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "CODE_TO_2TO3 = {\n    'E231': ['ws_comma'],\n    'E721': ['idioms'],\n    'W690': ['apply',\n             'except',\n             'exitfunc',\n             'numliterals',\n             'operator',\n             'paren',\n             'reduce',",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "PROJECT_CONFIG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "PROJECT_CONFIG = ('setup.cfg', 'tox.ini', '.pep8', '.flake8')\nMAX_PYTHON_FILE_DETECTION_BYTES = 1024\ndef open_with_encoding(filename, mode='r', encoding=None, limit_byte_check=-1):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    if not encoding:\n        encoding = detect_encoding(filename, limit_byte_check=limit_byte_check)\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')  # Preserve line endings\ndef detect_encoding(filename, limit_byte_check=-1):\n    \"\"\"Return file encoding.\"\"\"",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "MAX_PYTHON_FILE_DETECTION_BYTES",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "MAX_PYTHON_FILE_DETECTION_BYTES = 1024\ndef open_with_encoding(filename, mode='r', encoding=None, limit_byte_check=-1):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    if not encoding:\n        encoding = detect_encoding(filename, limit_byte_check=limit_byte_check)\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')  # Preserve line endings\ndef detect_encoding(filename, limit_byte_check=-1):\n    \"\"\"Return file encoding.\"\"\"\n    try:",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "Token = collections.namedtuple('Token', ['token_type', 'token_string',\n                                         'spos', 'epos', 'line'])\nclass ReformattedLines(object):\n    \"\"\"The reflowed lines of atoms.\n    Each part of the line is represented as an \"atom.\" They can be moved\n    around when need be to get the optimal formatting.\n    \"\"\"\n    ###########################################################################\n    # Private Classes\n    class _Indent(object):",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "_cached_tokenizer",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "_cached_tokenizer = CachedTokenizer()\ngenerate_tokens = _cached_tokenizer.generate_tokens\nif __name__ == '__main__':\n    sys.exit(main())",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "generate_tokens",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.autopep8",
        "description": "__pypackages__.3.10.lib.autopep8",
        "peekOfCode": "generate_tokens = _cached_tokenizer.generate_tokens\nif __name__ == '__main__':\n    sys.exit(main())",
        "detail": "__pypackages__.3.10.lib.autopep8",
        "documentation": {}
    },
    {
        "label": "ASTVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "class ASTVisitor(object):\n    \"\"\"Performs a depth-first walk of the AST.\"\"\"\n    def __init__(self):\n        self.node = None\n        self._cache = {}\n    def default(self, node, *args):\n        for child in iter_child_nodes(node):\n            self.dispatch(child, *args)\n    def dispatch(self, node, *args):\n        self.node = node",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "PathNode",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "class PathNode(object):\n    def __init__(self, name, look=\"circle\"):\n        self.name = name\n        self.look = look\n    def to_dot(self):\n        print('node [shape=%s,label=\"%s\"] %d;' % (\n            self.look, self.name, self.dot_id()))\n    def dot_id(self):\n        return id(self)\nclass PathGraph(object):",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "PathGraph",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "class PathGraph(object):\n    def __init__(self, name, entity, lineno, column=0):\n        self.name = name\n        self.entity = entity\n        self.lineno = lineno\n        self.column = column\n        self.nodes = defaultdict(list)\n    def connect(self, n1, n2):\n        self.nodes[n1].append(n2)\n        # Ensure that the destination node is always counted.",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "PathGraphingAstVisitor",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "class PathGraphingAstVisitor(ASTVisitor):\n    \"\"\" A visitor for a parsed Abstract Syntax Tree which finds executable\n        statements.\n    \"\"\"\n    def __init__(self):\n        super(PathGraphingAstVisitor, self).__init__()\n        self.classname = \"\"\n        self.graphs = {}\n        self.reset()\n    def reset(self):",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "McCabeChecker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "class McCabeChecker(object):\n    \"\"\"McCabe cyclomatic complexity checker.\"\"\"\n    name = 'mccabe'\n    version = __version__\n    _code = 'C901'\n    _error_tmpl = \"C901 %r is too complex (%d)\"\n    max_complexity = -1\n    def __init__(self, tree, filename):\n        self.tree = tree\n    @classmethod",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "get_code_complexity",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "def get_code_complexity(code, threshold=7, filename='stdin'):\n    try:\n        tree = compile(code, filename, \"exec\", ast.PyCF_ONLY_AST)\n    except SyntaxError:\n        e = sys.exc_info()[1]\n        sys.stderr.write(\"Unable to parse %s: %s\\n\" % (filename, e))\n        return 0\n    complx = []\n    McCabeChecker.max_complexity = threshold\n    for lineno, offset, text, check in McCabeChecker(tree, filename).run():",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "get_module_complexity",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "def get_module_complexity(module_path, threshold=7):\n    \"\"\"Returns the complexity of a module\"\"\"\n    code = _read(module_path)\n    return get_code_complexity(code, threshold, filename=module_path)\ndef _read(filename):\n    if (2, 5) < sys.version_info < (3, 0):\n        with open(filename, 'rU') as f:\n            return f.read()\n    elif (3, 0) <= sys.version_info < (4, 0):\n        \"\"\"Read the source code.\"\"\"",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "def main(argv=None):\n    if argv is None:\n        argv = sys.argv[1:]\n    opar = optparse.OptionParser()\n    opar.add_option(\"-d\", \"--dot\", dest=\"dot\",\n                    help=\"output a graphviz dot file\", action=\"store_true\")\n    opar.add_option(\"-m\", \"--min\", dest=\"threshold\",\n                    help=\"minimum complexity for output\", type=\"int\",\n                    default=1)\n    options, args = opar.parse_args(argv)",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.mccabe",
        "description": "__pypackages__.3.10.lib.mccabe",
        "peekOfCode": "__version__ = '0.7.0'\nclass ASTVisitor(object):\n    \"\"\"Performs a depth-first walk of the AST.\"\"\"\n    def __init__(self):\n        self.node = None\n        self._cache = {}\n    def default(self, node, *args):\n        for child in iter_child_nodes(node):\n            self.dispatch(child, *args)\n    def dispatch(self, node, *args):",
        "detail": "__pypackages__.3.10.lib.mccabe",
        "documentation": {}
    },
    {
        "label": "sys.modules[\"py.error\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.py",
        "description": "__pypackages__.3.10.lib.py",
        "peekOfCode": "sys.modules[\"py.error\"] = error\nsys.modules[\"py.path\"] = path",
        "detail": "__pypackages__.3.10.lib.py",
        "documentation": {}
    },
    {
        "label": "sys.modules[\"py.path\"]",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.py",
        "description": "__pypackages__.3.10.lib.py",
        "peekOfCode": "sys.modules[\"py.path\"] = path",
        "detail": "__pypackages__.3.10.lib.py",
        "documentation": {}
    },
    {
        "label": "Checker",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class Checker:\n    \"\"\"Load a Python source file, tokenize it, check coding style.\"\"\"\n    def __init__(self, filename=None, lines=None,\n                 options=None, report=None, **kwargs):\n        if options is None:\n            options = StyleGuide(kwargs).options\n        else:\n            assert not kwargs\n        self._io_error = None\n        self._physical_checks = options.physical_checks",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "BaseReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class BaseReport:\n    \"\"\"Collect the results of the checks.\"\"\"\n    print_filename = False\n    def __init__(self, options):\n        self._benchmark_keys = options.benchmark_keys\n        self._ignore_code = options.ignore_code\n        # Results\n        self.elapsed = 0\n        self.total_errors = 0\n        self.counters = dict.fromkeys(self._benchmark_keys, 0)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "FileReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class FileReport(BaseReport):\n    \"\"\"Collect the results of the checks and print the filenames.\"\"\"\n    print_filename = True\nclass StandardReport(BaseReport):\n    \"\"\"Collect and print the results of the checks.\"\"\"\n    def __init__(self, options):\n        super().__init__(options)\n        self._fmt = REPORT_FORMAT.get(options.format.lower(),\n                                      options.format)\n        self._repeat = options.repeat",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "StandardReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class StandardReport(BaseReport):\n    \"\"\"Collect and print the results of the checks.\"\"\"\n    def __init__(self, options):\n        super().__init__(options)\n        self._fmt = REPORT_FORMAT.get(options.format.lower(),\n                                      options.format)\n        self._repeat = options.repeat\n        self._show_source = options.show_source\n        self._show_pep8 = options.show_pep8\n    def init_file(self, filename, lines, expected, line_offset):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "DiffReport",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class DiffReport(StandardReport):\n    \"\"\"Collect and print the results for the changed lines only.\"\"\"\n    def __init__(self, options):\n        super().__init__(options)\n        self._selected = options.selected_lines\n    def error(self, line_number, offset, text, check):\n        if line_number not in self._selected[self.filename]:\n            return\n        return super().error(line_number, offset, text, check)\nclass StyleGuide:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "StyleGuide",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "class StyleGuide:\n    \"\"\"Initialize a PEP-8 instance with few options.\"\"\"\n    def __init__(self, *args, **kwargs):\n        # build options from the command line\n        self.checker_class = kwargs.pop('checker_class', Checker)\n        parse_argv = kwargs.pop('parse_argv', False)\n        config_file = kwargs.pop('config_file', False)\n        parser = kwargs.pop('parser', None)\n        # build options from dict\n        options_dict = dict(*args, **kwargs)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "register_check",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def register_check(check, codes=None):\n    \"\"\"Register a new check object.\"\"\"\n    def _add_check(check, kind, codes, args):\n        if check in _checks[kind]:\n            _checks[kind][check][0].extend(codes or [])\n        else:\n            _checks[kind][check] = (codes or [''], args)\n    if inspect.isfunction(check):\n        args = _get_parameters(check)\n        if args and args[0] in ('physical_line', 'logical_line'):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "tabs_or_spaces",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def tabs_or_spaces(physical_line, indent_char):\n    r\"\"\"Never mix tabs and spaces.\n    The most popular way of indenting Python is with spaces only.  The\n    second-most popular way is with tabs only.  Code indented with a\n    mixture of tabs and spaces should be converted to using spaces\n    exclusively.  When invoking the Python command line interpreter with\n    the -t option, it issues warnings about code that illegally mixes\n    tabs and spaces.  When using -tt these warnings become errors.\n    These options are highly recommended!\n    Okay: if a == 0:\\n    a = 1\\n    b = 1",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "tabs_obsolete",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def tabs_obsolete(physical_line):\n    r\"\"\"On new projects, spaces-only are strongly recommended over tabs.\n    Okay: if True:\\n    return\n    W191: if True:\\n\\treturn\n    \"\"\"\n    indent = INDENT_REGEX.match(physical_line).group(1)\n    if '\\t' in indent:\n        return indent.index('\\t'), \"W191 indentation contains tabs\"\n@register_check\ndef trailing_whitespace(physical_line):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "trailing_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def trailing_whitespace(physical_line):\n    r\"\"\"Trailing whitespace is superfluous.\n    The warning returned varies on whether the line itself is blank,\n    for easier filtering for those who want to indent their blank lines.\n    Okay: spam(1)\\n#\n    W291: spam(1) \\n#\n    W293: class Foo(object):\\n    \\n    bang = 12\n    \"\"\"\n    physical_line = physical_line.rstrip('\\n')    # chr(10), newline\n    physical_line = physical_line.rstrip('\\r')    # chr(13), carriage return",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "trailing_blank_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def trailing_blank_lines(physical_line, lines, line_number, total_lines):\n    r\"\"\"Trailing blank lines are superfluous.\n    Okay: spam(1)\n    W391: spam(1)\\n\n    However the last line should end with a new line (warning W292).\n    \"\"\"\n    if line_number == total_lines:\n        stripped_last_line = physical_line.rstrip('\\r\\n')\n        if physical_line and not stripped_last_line:\n            return 0, \"W391 blank line at end of file\"",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "maximum_line_length",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def maximum_line_length(physical_line, max_line_length, multiline,\n                        line_number, noqa):\n    r\"\"\"Limit all lines to a maximum of 79 characters.\n    There are still many devices around that are limited to 80 character\n    lines; plus, limiting windows to 80 characters makes it possible to\n    have several windows side-by-side.  The default wrapping on such\n    devices looks ugly.  Therefore, please limit all lines to a maximum\n    of 79 characters. For flowing long blocks of text (docstrings or\n    comments), limiting the length to 72 characters is recommended.\n    Reports error E501.",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "blank_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def blank_lines(logical_line, blank_lines, indent_level, line_number,\n                blank_before, previous_logical,\n                previous_unindented_logical_line, previous_indent_level,\n                lines):\n    r\"\"\"Separate top-level function and class definitions with two blank\n    lines.\n    Method definitions inside a class are separated by a single blank\n    line.\n    Extra blank lines may be used (sparingly) to separate groups of\n    related functions.  Blank lines may be omitted between a bunch of",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "extraneous_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def extraneous_whitespace(logical_line):\n    r\"\"\"Avoid extraneous whitespace.\n    Avoid extraneous whitespace in these situations:\n    - Immediately inside parentheses, brackets or braces.\n    - Immediately before a comma, semicolon, or colon.\n    Okay: spam(ham[1], {eggs: 2})\n    E201: spam( ham[1], {eggs: 2})\n    E201: spam(ham[ 1], {eggs: 2})\n    E201: spam(ham[1], { eggs: 2})\n    E202: spam(ham[1], {eggs: 2} )",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_around_keywords",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_around_keywords(logical_line):\n    r\"\"\"Avoid extraneous whitespace around keywords.\n    Okay: True and False\n    E271: True and  False\n    E272: True  and False\n    E273: True and\\tFalse\n    E274: True\\tand False\n    \"\"\"\n    for match in KEYWORD_REGEX.finditer(logical_line):\n        before, after = match.groups()",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "missing_whitespace_after_keyword",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def missing_whitespace_after_keyword(logical_line, tokens):\n    r\"\"\"Keywords should be followed by whitespace.\n    Okay: from foo import (bar, baz)\n    E275: from foo import(bar, baz)\n    E275: from importable.module import(bar, baz)\n    E275: if(foo): bar\n    \"\"\"\n    for tok0, tok1 in zip(tokens, tokens[1:]):\n        # This must exclude the True/False/None singletons, which can\n        # appear e.g. as \"if x is None:\", and async/await, which were",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "missing_whitespace",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def missing_whitespace(logical_line):\n    r\"\"\"Each comma, semicolon or colon should be followed by whitespace.\n    Okay: [a, b]\n    Okay: (3,)\n    Okay: a[3,] = 1\n    Okay: a[1:4]\n    Okay: a[:4]\n    Okay: a[1:]\n    Okay: a[1:4:2]\n    E231: ['a','b']",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "indentation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def indentation(logical_line, previous_logical, indent_char,\n                indent_level, previous_indent_level,\n                indent_size):\n    r\"\"\"Use indent_size (PEP8 says 4) spaces per indentation level.\n    For really old code that you don't want to mess up, you can continue\n    to use 8-space tabs.\n    Okay: a = 1\n    Okay: if a == 0:\\n    a = 1\n    E111:   a = 1\n    E114:   # a = 1",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "continued_indentation",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def continued_indentation(logical_line, tokens, indent_level, hang_closing,\n                          indent_char, indent_size, noqa, verbose):\n    r\"\"\"Continuation lines indentation.\n    Continuation lines should align wrapped elements either vertically\n    using Python's implicit line joining inside parentheses, brackets\n    and braces, or using a hanging indent.\n    When using a hanging indent these considerations should be applied:\n    - there should be no arguments on the first line, and\n    - further indentation should be used to clearly distinguish itself\n      as a continuation line.",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_before_parameters",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_before_parameters(logical_line, tokens):\n    r\"\"\"Avoid extraneous whitespace.\n    Avoid extraneous whitespace in the following situations:\n    - before the open parenthesis that starts the argument list of a\n      function call.\n    - before the open parenthesis that starts an indexing or slicing.\n    Okay: spam(1)\n    E211: spam (1)\n    Okay: dict['key'] = list[index]\n    E211: dict ['key'] = list[index]",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_around_operator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_around_operator(logical_line):\n    r\"\"\"Avoid extraneous whitespace around an operator.\n    Okay: a = 12 + 3\n    E221: a = 4  + 5\n    E222: a = 4 +  5\n    E223: a = 4\\t+ 5\n    E224: a = 4 +\\t5\n    \"\"\"\n    for match in OPERATOR_REGEX.finditer(logical_line):\n        before, after = match.groups()",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "missing_whitespace_around_operator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def missing_whitespace_around_operator(logical_line, tokens):\n    r\"\"\"Surround operators with a single space on either side.\n    - Always surround these binary operators with a single space on\n      either side: assignment (=), augmented assignment (+=, -= etc.),\n      comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),\n      Booleans (and, or, not).\n    - If operators with different priorities are used, consider adding\n      whitespace around the operators with the lowest priorities.\n    Okay: i = i + 1\n    Okay: submitted += 1",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_around_comma",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_around_comma(logical_line):\n    r\"\"\"Avoid extraneous whitespace after a comma or a colon.\n    Note: these checks are disabled by default\n    Okay: a = (1, 2)\n    E241: a = (1,  2)\n    E242: a = (1,\\t2)\n    \"\"\"\n    line = logical_line\n    for m in WHITESPACE_AFTER_COMMA_REGEX.finditer(line):\n        found = m.start() + 1",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_around_named_parameter_equals",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_around_named_parameter_equals(logical_line, tokens):\n    r\"\"\"Don't use spaces around the '=' sign in function arguments.\n    Don't use spaces around the '=' sign when used to indicate a\n    keyword argument or a default parameter value, except when\n    using a type annotation.\n    Okay: def complex(real, imag=0.0):\n    Okay: return magic(r=real, i=imag)\n    Okay: boolean(a == b)\n    Okay: boolean(a != b)\n    Okay: boolean(a <= b)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "whitespace_before_comment",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def whitespace_before_comment(logical_line, tokens):\n    \"\"\"Separate inline comments by at least two spaces.\n    An inline comment is a comment on the same line as a statement.\n    Inline comments should be separated by at least two spaces from the\n    statement. They should start with a # and a single space.\n    Each line of a block comment starts with a # and one or multiple\n    spaces as there can be indented text inside the comment.\n    Okay: x = x + 1  # Increment x\n    Okay: x = x + 1    # Increment x\n    Okay: # Block comments:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "imports_on_separate_lines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def imports_on_separate_lines(logical_line):\n    r\"\"\"Place imports on separate lines.\n    Okay: import os\\nimport sys\n    E401: import sys, os\n    Okay: from subprocess import Popen, PIPE\n    Okay: from myclas import MyClass\n    Okay: from foo.bar.yourclass import YourClass\n    Okay: import myclass\n    Okay: import foo.bar.yourclass\n    \"\"\"",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "module_imports_on_top_of_file",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def module_imports_on_top_of_file(\n        logical_line, indent_level, checker_state, noqa):\n    r\"\"\"Place imports at the top of the file.\n    Always put imports at the top of the file, just after any module\n    comments and docstrings, and before module globals and constants.\n    Okay: import os\n    Okay: # this is a comment\\nimport os\n    Okay: '''this is a module docstring'''\\nimport os\n    Okay: r'''this is a module docstring'''\\nimport os\n    Okay:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "compound_statements",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def compound_statements(logical_line):\n    r\"\"\"Compound statements (on the same line) are generally\n    discouraged.\n    While sometimes it's okay to put an if/for/while with a small body\n    on the same line, never do this for multi-clause statements.\n    Also avoid folding such long lines!\n    Always use a def statement instead of an assignment statement that\n    binds a lambda expression directly to a name.\n    Okay: if foo == 'blah':\\n    do_blah_thing()\n    Okay: do_one()",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "explicit_line_join",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def explicit_line_join(logical_line, tokens):\n    r\"\"\"Avoid explicit line join between brackets.\n    The preferred way of wrapping long lines is by using Python's\n    implied line continuation inside parentheses, brackets and braces.\n    Long lines can be broken over multiple lines by wrapping expressions\n    in parentheses.  These should be used in preference to using a\n    backslash for line continuation.\n    E502: aaa = [123, \\\\n       123]\n    E502: aaa = (\"bbb \" \\\\n       \"ccc\")\n    Okay: aaa = [123,\\n       123]",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "break_before_binary_operator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def break_before_binary_operator(logical_line, tokens):\n    r\"\"\"\n    Avoid breaks before binary operators.\n    The preferred place to break around a binary operator is after the\n    operator, not before it.\n    W503: (width == 0\\n + height == 0)\n    W503: (width == 0\\n and height == 0)\n    W503: var = (1\\n       & ~2)\n    W503: var = (1\\n       / -2)\n    W503: var = (1\\n       + -1\\n       + -2)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "break_after_binary_operator",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def break_after_binary_operator(logical_line, tokens):\n    r\"\"\"\n    Avoid breaks after binary operators.\n    The preferred place to break around a binary operator is before the\n    operator, not after it.\n    W504: (width == 0 +\\n height == 0)\n    W504: (width == 0 and\\n height == 0)\n    W504: var = (1 &\\n       ~2)\n    Okay: foo(\\n    -x)\n    Okay: foo(x\\n    [])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "comparison_to_singleton",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def comparison_to_singleton(logical_line, noqa):\n    r\"\"\"Comparison to singletons should use \"is\" or \"is not\".\n    Comparisons to singletons like None should always be done\n    with \"is\" or \"is not\", never the equality operators.\n    Okay: if arg is not None:\n    E711: if arg != None:\n    E711: if None == arg:\n    E712: if arg == True:\n    E712: if False == arg:\n    Also, beware of writing if x when you really mean if x is not None",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "comparison_negative",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def comparison_negative(logical_line):\n    r\"\"\"Negative comparison should be done using \"not in\" and \"is not\".\n    Okay: if x not in y:\\n    pass\n    Okay: assert (X in Y or X is Z)\n    Okay: if not (X in Y):\\n    pass\n    Okay: zz = x is not y\n    E713: Z = not X in Y\n    E713: if not X.B in Y:\\n    pass\n    E714: if not X is Y:\\n    pass\n    E714: Z = not X.B is Y",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "comparison_type",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def comparison_type(logical_line, noqa):\n    r\"\"\"Object type comparisons should always use isinstance().\n    Do not compare types directly.\n    Okay: if isinstance(obj, int):\n    E721: if type(obj) is type(1):\n    When checking if an object is a string, keep in mind that it might\n    be a unicode string too! In Python 2.3, str and unicode have a\n    common base class, basestring, so you can do:\n    Okay: if isinstance(obj, basestring):\n    Okay: if type(a1) is type(b1):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "bare_except",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def bare_except(logical_line, noqa):\n    r\"\"\"When catching exceptions, mention specific exceptions when\n    possible.\n    Okay: except Exception:\n    Okay: except BaseException:\n    E722: except:\n    \"\"\"\n    if noqa:\n        return\n    match = BLANK_EXCEPT_REGEX.match(logical_line)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "ambiguous_identifier",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def ambiguous_identifier(logical_line, tokens):\n    r\"\"\"Never use the characters 'l', 'O', or 'I' as variable names.\n    In some fonts, these characters are indistinguishable from the\n    numerals one and zero. When tempted to use 'l', use 'L' instead.\n    Okay: L = 0\n    Okay: o = 123\n    Okay: i = 42\n    E741: l = 0\n    E741: O = 123\n    E741: I = 42",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "python_3000_invalid_escape_sequence",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def python_3000_invalid_escape_sequence(logical_line, tokens, noqa):\n    r\"\"\"Invalid escape sequences are deprecated in Python 3.6.\n    Okay: regex = r'\\.png$'\n    W605: regex = '\\.png$'\n    \"\"\"\n    if noqa:\n        return\n    # https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n    valid = [\n        '\\n',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "python_3000_async_await_keywords",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def python_3000_async_await_keywords(logical_line, tokens):\n    \"\"\"'async' and 'await' are reserved keywords starting at Python 3.7.\n    W606: async = 42\n    W606: await = 42\n    Okay: async def read(db):\\n    data = await db.fetch('SELECT ...')\n    \"\"\"\n    # The Python tokenize library before Python 3.5 recognizes\n    # async/await as a NAME token. Therefore, use a state machine to\n    # look for the possible async/await constructs as defined by the\n    # Python grammar:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "maximum_doc_length",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def maximum_doc_length(logical_line, max_doc_length, noqa, tokens):\n    r\"\"\"Limit all doc lines to a maximum of 72 characters.\n    For flowing long blocks of text (docstrings or comments), limiting\n    the length to 72 characters is recommended.\n    Reports warning W505\n    \"\"\"\n    if max_doc_length is None or noqa:\n        return\n    prev_token = None\n    skip_lines = set()",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "readlines",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def readlines(filename):\n    \"\"\"Read the source code.\"\"\"\n    try:\n        with tokenize.open(filename) as f:\n            return f.readlines()\n    except (LookupError, SyntaxError, UnicodeError):\n        # Fall back if file encoding is improperly declared\n        with open(filename, encoding='latin-1') as f:\n            return f.readlines()\ndef stdin_get_value():",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "stdin_get_value",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def stdin_get_value():\n    \"\"\"Read the value from stdin.\"\"\"\n    return io.TextIOWrapper(sys.stdin.buffer, errors='ignore').read()\nnoqa = lru_cache(512)(re.compile(r'# no(?:qa|pep8)\\b', re.I).search)\ndef expand_indent(line):\n    r\"\"\"Return the amount of indentation.\n    Tabs are expanded to the next multiple of 8.\n    >>> expand_indent('    ')\n    4\n    >>> expand_indent('\\t')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "expand_indent",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def expand_indent(line):\n    r\"\"\"Return the amount of indentation.\n    Tabs are expanded to the next multiple of 8.\n    >>> expand_indent('    ')\n    4\n    >>> expand_indent('\\t')\n    8\n    >>> expand_indent('       \\t')\n    8\n    >>> expand_indent('        \\t')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "mute_string",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def mute_string(text):\n    \"\"\"Replace contents with 'xxx' to prevent syntax matching.\n    >>> mute_string('\"abc\"')\n    '\"xxx\"'\n    >>> mute_string(\"'''abc'''\")\n    \"'''xxx'''\"\n    >>> mute_string(\"r'abc'\")\n    \"r'xxx'\"\n    \"\"\"\n    # String modifiers (e.g. u or r)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "parse_udiff",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def parse_udiff(diff, patterns=None, parent='.'):\n    \"\"\"Return a dictionary of matching lines.\"\"\"\n    # For each file of the diff, the entry key is the filename,\n    # and the value is a set of row numbers to consider.\n    rv = {}\n    path = nrows = None\n    for line in diff.splitlines():\n        if nrows:\n            if line[:1] != '-':\n                nrows -= 1",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "normalize_paths",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def normalize_paths(value, parent=os.curdir):\n    \"\"\"Parse a comma-separated list of paths.\n    Return a list of absolute paths.\n    \"\"\"\n    if not value:\n        return []\n    if isinstance(value, list):\n        return value\n    paths = []\n    for path in value.split(','):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "filename_match",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def filename_match(filename, patterns, default=True):\n    \"\"\"Check if patterns contains a pattern that matches filename.\n    If patterns is unspecified, this always returns True.\n    \"\"\"\n    if not patterns:\n        return default\n    return any(fnmatch(filename, pattern) for pattern in patterns)\ndef update_counts(s, counts):\n    r\"\"\"Adds one to the counts of each appearance of characters in s,\n        for characters in counts\"\"\"",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "update_counts",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def update_counts(s, counts):\n    r\"\"\"Adds one to the counts of each appearance of characters in s,\n        for characters in counts\"\"\"\n    for char in s:\n        if char in counts:\n            counts[char] += 1\ndef _is_eol_token(token):\n    return token[0] in NEWLINE or token[4][token[3][1]:].lstrip() == '\\\\\\n'\n########################################################################\n# Framework to run all checks",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "get_parser",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def get_parser(prog='pycodestyle', version=__version__):\n    \"\"\"Create the parser for the program.\"\"\"\n    parser = OptionParser(prog=prog, version=version,\n                          usage=\"%prog [options] input ...\")\n    parser.config_options = [\n        'exclude', 'filename', 'select', 'ignore', 'max-line-length',\n        'max-doc-length', 'indent-size', 'hang-closing', 'count', 'format',\n        'quiet', 'show-pep8', 'show-source', 'statistics', 'verbose']\n    parser.add_option('-v', '--verbose', default=0, action='count',\n                      help=\"print status messages, or debug with -vv\")",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "read_config",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def read_config(options, args, arglist, parser):\n    \"\"\"Read and parse configurations.\n    If a config file is specified on the command line with the\n    \"--config\" option, then only it is used for configuration.\n    Otherwise, the user configuration (~/.config/pycodestyle) and any\n    local configurations in the current directory or above will be\n    merged together (in that order) using the read method of\n    ConfigParser.\n    \"\"\"\n    config = configparser.RawConfigParser()",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "process_options",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "def process_options(arglist=None, parse_argv=False, config_file=None,\n                    parser=None, verbose=None):\n    \"\"\"Process options passed either via arglist or command line args.\n    Passing in the ``config_file`` parameter allows other tools, such as\n    flake8 to specify their own options to be processed in pycodestyle.\n    \"\"\"\n    if not parser:\n        parser = get_parser()\n    if not parser.has_option('--config'):\n        group = parser.add_option_group(\"Configuration\", description=(",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "__version__ = '2.10.0'\nDEFAULT_EXCLUDE = '.svn,CVS,.bzr,.hg,.git,__pycache__,.tox'\nDEFAULT_IGNORE = 'E121,E123,E126,E226,E24,E704,W503,W504'\ntry:\n    if sys.platform == 'win32':\n        USER_CONFIG = os.path.expanduser(r'~\\.pycodestyle')\n    else:\n        USER_CONFIG = os.path.join(\n            os.getenv('XDG_CONFIG_HOME') or os.path.expanduser('~/.config'),\n            'pycodestyle'",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "DEFAULT_EXCLUDE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "DEFAULT_EXCLUDE = '.svn,CVS,.bzr,.hg,.git,__pycache__,.tox'\nDEFAULT_IGNORE = 'E121,E123,E126,E226,E24,E704,W503,W504'\ntry:\n    if sys.platform == 'win32':\n        USER_CONFIG = os.path.expanduser(r'~\\.pycodestyle')\n    else:\n        USER_CONFIG = os.path.join(\n            os.getenv('XDG_CONFIG_HOME') or os.path.expanduser('~/.config'),\n            'pycodestyle'\n        )",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "DEFAULT_IGNORE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "DEFAULT_IGNORE = 'E121,E123,E126,E226,E24,E704,W503,W504'\ntry:\n    if sys.platform == 'win32':\n        USER_CONFIG = os.path.expanduser(r'~\\.pycodestyle')\n    else:\n        USER_CONFIG = os.path.join(\n            os.getenv('XDG_CONFIG_HOME') or os.path.expanduser('~/.config'),\n            'pycodestyle'\n        )\nexcept ImportError:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "PROJECT_CONFIG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "PROJECT_CONFIG = ('setup.cfg', 'tox.ini')\nTESTSUITE_PATH = os.path.join(os.path.dirname(__file__), 'testsuite')\nMAX_LINE_LENGTH = 79\n# Number of blank lines between various code parts.\nBLANK_LINES_CONFIG = {\n    # Top level class and function.\n    'top_level': 2,\n    # Methods and nested class and function.\n    'method': 1,\n}",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "TESTSUITE_PATH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "TESTSUITE_PATH = os.path.join(os.path.dirname(__file__), 'testsuite')\nMAX_LINE_LENGTH = 79\n# Number of blank lines between various code parts.\nBLANK_LINES_CONFIG = {\n    # Top level class and function.\n    'top_level': 2,\n    # Methods and nested class and function.\n    'method': 1,\n}\nMAX_DOC_LENGTH = 72",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "MAX_LINE_LENGTH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "MAX_LINE_LENGTH = 79\n# Number of blank lines between various code parts.\nBLANK_LINES_CONFIG = {\n    # Top level class and function.\n    'top_level': 2,\n    # Methods and nested class and function.\n    'method': 1,\n}\nMAX_DOC_LENGTH = 72\nINDENT_SIZE = 4",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "BLANK_LINES_CONFIG",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "BLANK_LINES_CONFIG = {\n    # Top level class and function.\n    'top_level': 2,\n    # Methods and nested class and function.\n    'method': 1,\n}\nMAX_DOC_LENGTH = 72\nINDENT_SIZE = 4\nREPORT_FORMAT = {\n    'default': '%(path)s:%(row)d:%(col)d: %(code)s %(text)s',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "MAX_DOC_LENGTH",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "MAX_DOC_LENGTH = 72\nINDENT_SIZE = 4\nREPORT_FORMAT = {\n    'default': '%(path)s:%(row)d:%(col)d: %(code)s %(text)s',\n    'pylint': '%(path)s:%(row)d: [%(code)s] %(text)s',\n}\nPyCF_ONLY_AST = 1024\nSINGLETONS = frozenset(['False', 'None', 'True'])\nKEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "INDENT_SIZE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "INDENT_SIZE = 4\nREPORT_FORMAT = {\n    'default': '%(path)s:%(row)d:%(col)d: %(code)s %(text)s',\n    'pylint': '%(path)s:%(row)d: [%(code)s] %(text)s',\n}\nPyCF_ONLY_AST = 1024\nSINGLETONS = frozenset(['False', 'None', 'True'])\nKEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "REPORT_FORMAT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "REPORT_FORMAT = {\n    'default': '%(path)s:%(row)d:%(col)d: %(code)s %(text)s',\n    'pylint': '%(path)s:%(row)d: [%(code)s] %(text)s',\n}\nPyCF_ONLY_AST = 1024\nSINGLETONS = frozenset(['False', 'None', 'True'])\nKEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "PyCF_ONLY_AST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "PyCF_ONLY_AST = 1024\nSINGLETONS = frozenset(['False', 'None', 'True'])\nKEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "SINGLETONS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "SINGLETONS = frozenset(['False', 'None', 'True'])\nKEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "KEYWORDS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "KEYWORDS = frozenset(keyword.kwlist + ['print', 'async']) - SINGLETONS\nUNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "UNARY_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "UNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])\nARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)\nWHITESPACE = frozenset(' \\t\\xa0')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "ARITHMETIC_OP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "ARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-', '@'])\nWS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)\nWHITESPACE = frozenset(' \\t\\xa0')\nNEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "WS_OPTIONAL_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "WS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])\nASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)\nWHITESPACE = frozenset(' \\t\\xa0')\nNEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])\nSKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "ASSIGNMENT_EXPRESSION_OP",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "ASSIGNMENT_EXPRESSION_OP = [':='] if sys.version_info >= (3, 8) else []\nWS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)\nWHITESPACE = frozenset(' \\t\\xa0')\nNEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])\nSKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])\n# ERRORTOKEN is triggered by backticks in Python 3",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "WS_NEEDED_OPERATORS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "WS_NEEDED_OPERATORS = frozenset([\n    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',\n    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '=',\n    'and', 'in', 'is', 'or', '->'] +\n    ASSIGNMENT_EXPRESSION_OP)\nWHITESPACE = frozenset(' \\t\\xa0')\nNEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])\nSKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])\n# ERRORTOKEN is triggered by backticks in Python 3\nSKIP_COMMENTS = SKIP_TOKENS.union([tokenize.COMMENT, tokenize.ERRORTOKEN])",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "WHITESPACE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "WHITESPACE = frozenset(' \\t\\xa0')\nNEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])\nSKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])\n# ERRORTOKEN is triggered by backticks in Python 3\nSKIP_COMMENTS = SKIP_TOKENS.union([tokenize.COMMENT, tokenize.ERRORTOKEN])\nBENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']\nINDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "NEWLINE",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "NEWLINE = frozenset([tokenize.NL, tokenize.NEWLINE])\nSKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])\n# ERRORTOKEN is triggered by backticks in Python 3\nSKIP_COMMENTS = SKIP_TOKENS.union([tokenize.COMMENT, tokenize.ERRORTOKEN])\nBENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']\nINDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "SKIP_TOKENS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "SKIP_TOKENS = NEWLINE.union([tokenize.INDENT, tokenize.DEDENT])\n# ERRORTOKEN is triggered by backticks in Python 3\nSKIP_COMMENTS = SKIP_TOKENS.union([tokenize.COMMENT, tokenize.ERRORTOKEN])\nBENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']\nINDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "SKIP_COMMENTS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "SKIP_COMMENTS = SKIP_TOKENS.union([tokenize.COMMENT, tokenize.ERRORTOKEN])\nBENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']\nINDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "BENCHMARK_KEYS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "BENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']\nINDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "INDENT_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "INDENT_REGEX = re.compile(r'([ \\t]*)')\nERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "ERRORCODE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "ERRORCODE_REGEX = re.compile(r'\\b[A-Z]\\d{3}\\b')\nDOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "DOCSTRING_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "DOCSTRING_REGEX = re.compile(r'u?r?[\"\\']')\nEXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "EXTRANEOUS_WHITESPACE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "EXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[\\[({][ \\t]|[ \\t][\\]}),;:](?!=)')\nWHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "WHITESPACE_AFTER_COMMA_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "WHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\\s*(?:  |\\t)')\nCOMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "COMPARE_SINGLETON_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "COMPARE_SINGLETON_REGEX = re.compile(r'(\\bNone|\\bFalse|\\bTrue)?\\s*([=!]=)'\n                                     r'\\s*(?(1)|(None|False|True))\\b')\nCOMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "COMPARE_NEGATIVE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "COMPARE_NEGATIVE_REGEX = re.compile(r'\\b(?<!is\\s)(not)\\s+[^][)(}{ ]+\\s+'\n                                    r'(in|is)\\s')\nCOMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "COMPARE_TYPE_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "COMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\\s+not)?)\\s+type(?:s.\\w+Type'\n                                r'|\\s*\\(\\s*([^)]*[^ )])\\s*\\))')\nKEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "KEYWORD_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "KEYWORD_REGEX = re.compile(r'(\\s*)\\b(?:%s)\\b(\\s*)' % r'|'.join(KEYWORDS))\nOPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "OPERATOR_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "OPERATOR_REGEX = re.compile(r'(?:[^,\\s])(\\s*)(?:[-+*/|!<=>%&^]+|:=)(\\s*)')\nLAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "LAMBDA_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "LAMBDA_REGEX = re.compile(r'\\blambda\\b')\nHUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',\n        'try', 'except', 'finally',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "HUNK_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "HUNK_REGEX = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,(\\d+))? @@.*$')\nSTARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',\n        'try', 'except', 'finally',\n        'with', 'async with',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "STARTSWITH_DEF_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "STARTSWITH_DEF_REGEX = re.compile(r'^(async\\s+def|def)\\b')\nSTARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',\n        'try', 'except', 'finally',\n        'with', 'async with',\n        'class',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "STARTSWITH_TOP_LEVEL_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "STARTSWITH_TOP_LEVEL_REGEX = re.compile(r'^(async\\s+def\\s+|def\\s+|class\\s+|@)')\nSTARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',\n        'try', 'except', 'finally',\n        'with', 'async with',\n        'class',\n        'while',",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "STARTSWITH_INDENT_STATEMENT_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "STARTSWITH_INDENT_STATEMENT_REGEX = re.compile(\n    r'^\\s*({})\\b'.format('|'.join(s.replace(' ', r'\\s+') for s in (\n        'def', 'async def',\n        'for', 'async for',\n        'if', 'elif', 'else',\n        'try', 'except', 'finally',\n        'with', 'async with',\n        'class',\n        'while',\n    )))",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "DUNDER_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "DUNDER_REGEX = re.compile(r\"^__([^\\s]+)__(?::\\s*[a-zA-Z.0-9_\\[\\]\\\"]+)? = \")\nBLANK_EXCEPT_REGEX = re.compile(r\"except\\s*:\")\n_checks = {'physical_line': {}, 'logical_line': {}, 'tree': {}}\ndef _get_parameters(function):\n    return [parameter.name\n            for parameter\n            in inspect.signature(function).parameters.values()\n            if parameter.kind == parameter.POSITIONAL_OR_KEYWORD]\ndef register_check(check, codes=None):\n    \"\"\"Register a new check object.\"\"\"",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "BLANK_EXCEPT_REGEX",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "BLANK_EXCEPT_REGEX = re.compile(r\"except\\s*:\")\n_checks = {'physical_line': {}, 'logical_line': {}, 'tree': {}}\ndef _get_parameters(function):\n    return [parameter.name\n            for parameter\n            in inspect.signature(function).parameters.values()\n            if parameter.kind == parameter.POSITIONAL_OR_KEYWORD]\ndef register_check(check, codes=None):\n    \"\"\"Register a new check object.\"\"\"\n    def _add_check(check, kind, codes, args):",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "_checks",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "_checks = {'physical_line': {}, 'logical_line': {}, 'tree': {}}\ndef _get_parameters(function):\n    return [parameter.name\n            for parameter\n            in inspect.signature(function).parameters.values()\n            if parameter.kind == parameter.POSITIONAL_OR_KEYWORD]\ndef register_check(check, codes=None):\n    \"\"\"Register a new check object.\"\"\"\n    def _add_check(check, kind, codes, args):\n        if check in _checks[kind]:",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "_SYMBOLIC_OPS",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "_SYMBOLIC_OPS = frozenset(\"()[]{},:.;@=%~\") | frozenset((\"...\",))\ndef _is_binary_operator(token_type, text):\n    return (\n        token_type == tokenize.OP or\n        text in {'and', 'or'}\n    ) and (\n        text not in _SYMBOLIC_OPS\n    )\ndef _break_around_binary_operators(tokens):\n    \"\"\"Private function to reduce duplication.",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "noqa",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.pycodestyle",
        "description": "__pypackages__.3.10.lib.pycodestyle",
        "peekOfCode": "noqa = lru_cache(512)(re.compile(r'# no(?:qa|pep8)\\b', re.I).search)\ndef expand_indent(line):\n    r\"\"\"Return the amount of indentation.\n    Tabs are expanded to the next multiple of 8.\n    >>> expand_indent('    ')\n    4\n    >>> expand_indent('\\t')\n    8\n    >>> expand_indent('       \\t')\n    8",
        "detail": "__pypackages__.3.10.lib.pycodestyle",
        "documentation": {}
    },
    {
        "label": "_DefaultMixin",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "class _DefaultMixin:\n    \"\"\"Mixin for TypeVarLike defaults.\"\"\"\n    __slots__ = ()\n    def __init__(self, default):\n        if isinstance(default, (tuple, list)):\n            self.__default__ = tuple((typing._type_check(d, \"Default must be a type\")\n                                      for d in default))\n        elif default != _marker:\n            self.__default__ = typing._type_check(default, \"Default must be a type\")\n        else:",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "class TypeVar(typing.TypeVar, _DefaultMixin, _root=True):\n    \"\"\"Type variable.\"\"\"\n    __module__ = 'typing'\n    def __init__(self, name, *constraints, bound=None,\n                 covariant=False, contravariant=False,\n                 default=_marker, infer_variance=False):\n        super().__init__(name, *constraints, bound=bound, covariant=covariant,\n                         contravariant=contravariant)\n        _DefaultMixin.__init__(self, default)\n        self.__infer_variance__ = infer_variance",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_SpecialForm",
        "kind": 6,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "class _SpecialForm(typing._Final, _root=True):\n    __slots__ = ('_name', '__doc__', '_getitem')\n    def __init__(self, getitem):\n        self._getitem = getitem\n        self._name = getitem.__name__\n        self.__doc__ = getitem.__doc__\n    def __getattr__(self, item):\n        if item in {'__name__', '__qualname__'}:\n            return self._name\n        raise AttributeError(item)",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IntVar",
        "kind": 2,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "def IntVar(name):\n    return typing.TypeVar(name)\n# 3.8+:\nif hasattr(typing, 'Literal'):\n    Literal = typing.Literal\n# 3.7:\nelse:\n    class _LiteralForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return 'typing_extensions.' + self._name",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "__all__ = [\n    # Super-special typing primitives.\n    'Any',\n    'ClassVar',\n    'Concatenate',\n    'Final',\n    'LiteralString',\n    'ParamSpec',\n    'ParamSpecArgs',\n    'ParamSpecKwargs',",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "PEP_560",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "PEP_560 = True\nGenericMeta = type\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\n_marker = object()\ndef _check_generic(cls, parameters, elen=_marker):\n    \"\"\"Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    \"\"\"\n    if not elen:",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "GenericMeta = type\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\n_marker = object()\ndef _check_generic(cls, parameters, elen=_marker):\n    \"\"\"Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    \"\"\"\n    if not elen:\n        raise TypeError(f\"{cls} is not a generic class\")",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_marker",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "_marker = object()\ndef _check_generic(cls, parameters, elen=_marker):\n    \"\"\"Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    \"\"\"\n    if not elen:\n        raise TypeError(f\"{cls} is not a generic class\")\n    if elen is _marker:\n        if not hasattr(cls, \"__parameters__\") or not cls.__parameters__:\n            raise TypeError(f\"{cls} is not a generic class\")",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "NoReturn = typing.NoReturn\n# Some unconstrained type variables.  These are used by the container types.\n# (These are not for export.)\nT = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "T = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "KT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "VT",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "VT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_contra",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)\n        def __repr__(self):",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "ClassVar = typing.ClassVar\n# On older versions of typing there is an internal class named \"Final\".\n# 3.8+\nif hasattr(typing, 'Final') and sys.version_info[:2] >= (3, 7):\n    Final = typing.Final\n# 3.7\nelse:\n    class _FinalForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return 'typing_extensions.' + self._name",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_overload_dummy",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "_overload_dummy = typing._overload_dummy  # noqa\nif hasattr(typing, \"get_overloads\"):  # 3.11+\n    overload = typing.overload\n    get_overloads = typing.get_overloads\n    clear_overloads = typing.clear_overloads\nelse:\n    # {module: {qualname: {firstlineno: func}}}\n    _overload_registry = collections.defaultdict(\n        functools.partial(collections.defaultdict, dict)\n    )",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Type = typing.Type\n# Various ABCs mimicking those in collections.abc.\n# A few are simply re-exported for completeness.\nAwaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Awaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Coroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "AsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "AsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2\nelse:",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Deque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2\nelse:\n    OrderedDict = typing._alias(collections.OrderedDict, (KT, VT))",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "ContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2\nelse:\n    OrderedDict = typing._alias(collections.OrderedDict, (KT, VT))\nCounter = typing.Counter",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncContextManager",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "AsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2\nelse:\n    OrderedDict = typing._alias(collections.OrderedDict, (KT, VT))\nCounter = typing.Counter\nChainMap = typing.ChainMap",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "DefaultDict = typing.DefaultDict\n# 3.7.2+\nif hasattr(typing, 'OrderedDict'):\n    OrderedDict = typing.OrderedDict\n# 3.7.0-3.7.2\nelse:\n    OrderedDict = typing._alias(collections.OrderedDict, (KT, VT))\nCounter = typing.Counter\nChainMap = typing.ChainMap\nAsyncGenerator = typing.AsyncGenerator",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Counter = typing.Counter\nChainMap = typing.ChainMap\nAsyncGenerator = typing.AsyncGenerator\nNewType = typing.NewType\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "ChainMap = typing.ChainMap\nAsyncGenerator = typing.AsyncGenerator\nNewType = typing.NewType\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "AsyncGenerator = typing.AsyncGenerator\nNewType = typing.NewType\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):\n    attrs = set()",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "NewType",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "NewType = typing.NewType\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "Text = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in ('Protocol', 'Generic'):",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "TYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in ('Protocol', 'Generic'):\n            continue",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PROTO_WHITELIST",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "_PROTO_WHITELIST = ['Callable', 'Awaitable',\n                    'Iterable', 'Iterator', 'AsyncIterable', 'AsyncIterator',\n                    'Hashable', 'Sized', 'Container', 'Collection', 'Reversible',\n                    'ContextManager', 'AsyncContextManager']\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in ('Protocol', 'Generic'):\n            continue\n        annotations = getattr(base, '__annotations__', {})",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "runtime",
        "kind": 5,
        "importPath": "__pypackages__.3.10.lib.typing_extensions",
        "description": "__pypackages__.3.10.lib.typing_extensions",
        "peekOfCode": "runtime = runtime_checkable\n# 3.8+\nif hasattr(typing, 'SupportsIndex'):\n    SupportsIndex = typing.SupportsIndex\n# 3.7\nelse:\n    @runtime_checkable\n    class SupportsIndex(Protocol):\n        __slots__ = ()\n        @abc.abstractmethod",
        "detail": "__pypackages__.3.10.lib.typing_extensions",
        "documentation": {}
    },
    {
        "label": "InvalidUuidException",
        "kind": 6,
        "importPath": "src.__seedwork.domain.exceptions",
        "description": "src.__seedwork.domain.exceptions",
        "peekOfCode": "class InvalidUuidException(Exception):\n    def __init__(self, error = 'ID must be a valid UUID') -> None:\n        super().__init__(error)",
        "detail": "src.__seedwork.domain.exceptions",
        "documentation": {}
    },
    {
        "label": "ValueObject",
        "kind": 6,
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "peekOfCode": "class ValueObject(ABC):\n    def __str__(self) -> str:\n        fields_name = [f.name for f in fields(self)]\n        return str(getattr(self, fields_name[0])) \\\n                   if len(fields_name) == 1 \\\n                   else json.dumps({field_name: getattr(self, field_name) for field_name in fields_name})\n@dataclass(frozen=True)\nclass UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())",
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "UniqueEntityId",
        "kind": 6,
        "importPath": "src.__seedwork.domain.value_objects",
        "description": "src.__seedwork.domain.value_objects",
        "peekOfCode": "class UniqueEntityId(ValueObject):\n    id: str = field(\n        default_factory=lambda: str(uuid.uuid4())\n                    )\n    def __post_init__(self):\n        id_value = str(self.id) if isinstance(self.id, uuid.UUID) else self.id\n        object.__setattr__(self, 'id', id_value)\n        self.__validate()\n    def __validate(self):\n        try:",
        "detail": "src.__seedwork.domain.value_objects",
        "documentation": {}
    },
    {
        "label": "Entity",
        "kind": 6,
        "importPath": "src.__seedwork.entities.entities",
        "description": "src.__seedwork.entities.entities",
        "peekOfCode": "class Entity(ABC):\n    unique_entity_id: UniqueEntityId = field(default_factory=lambda: UniqueEntityId())\n    @property\n    def id(self):\n        return str(self.unique_entity_id)\n    def to_dict(self):\n        entity_dict = asdict(self)\n        entity_dict.pop('unique_entity_id')\n        entity_dict['id'] = self.id\n        return entity_dict",
        "detail": "src.__seedwork.entities.entities",
        "documentation": {}
    },
    {
        "label": "StubEntity",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "description": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "peekOfCode": "class StubEntity(Entity):\n    prop1: str\n    prop2: str\nclass TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "documentation": {}
    },
    {
        "label": "TestEntityUnit",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "description": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "peekOfCode": "class TestEntityUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Entity))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(Entity(), ABC)\n    def test_set_unique_entity_id_and_props(self):\n        entity = StubEntity(prop1='some id', prop2='some prop')\n        self.assertEqual(entity.prop1, 'some id')\n        self.assertEqual(entity.prop2, 'some prop')\n        self.assertIsInstance(entity.unique_entity_id, UniqueEntityId)",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_entities",
        "documentation": {}
    },
    {
        "label": "StubOneProp",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "description": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "peekOfCode": "class StubOneProp(ValueObject):\n    prop: str\n@dataclass(frozen=True)\nclass StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "documentation": {}
    },
    {
        "label": "StubTwoProp",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "description": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "peekOfCode": "class StubTwoProp(ValueObject):\n    prop1: str\n    prop2: str\nclass TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "documentation": {}
    },
    {
        "label": "TestValueObjectUnit",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "description": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "peekOfCode": "class TestValueObjectUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_if_is_a_abstract_class(self):\n        self.assertIsInstance(ValueObject(), ABC)\n    def test_init_prop(self):\n        value_object = StubOneProp(prop='some value')\n        self.assertEqual(value_object.prop, 'some value')\n        value_object2 = StubTwoProp(prop1='some value', prop2='some value 2')\n        self.assertEqual(value_object2.prop1, 'some value')",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "documentation": {}
    },
    {
        "label": "TestUniqueEntityIdUnit",
        "kind": 6,
        "importPath": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "description": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "peekOfCode": "class TestUniqueEntityIdUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(UniqueEntityId))\n    def test_throw_exception_when_uuid_is_invalid(self):\n        with patch.object(\n            UniqueEntityId,\n            '_UniqueEntityId__validate',\n            autospec=True,\n            side_effect=UniqueEntityId._UniqueEntityId__validate\n        ) as mock_validate:",
        "detail": "src.__seedwork.tests.unit.domain.test_unit_value_object",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": "src.category.domain.entities",
        "description": "src.category.domain.entities",
        "peekOfCode": "class Category(Entity):\n    name: str\n    description: Optional[str] = None\n    is_active: Optional[bool] = True\n    created_at: Optional[datetime] = field(default_factory=lambda: datetime.now())\n    # Piramide de testes\n    # - Unidade\n    # - Integração\n    # - e2e",
        "detail": "src.category.domain.entities",
        "documentation": {}
    },
    {
        "label": "TestCategoryUnit",
        "kind": 6,
        "importPath": "src.category.tests.unit.domain.test_unit_entities",
        "description": "src.category.tests.unit.domain.test_unit_entities",
        "peekOfCode": "class TestCategoryUnit(unittest.TestCase):\n    def test_if_is_a_dataclass(self):\n        self.assertTrue(is_dataclass(Category))\n    def test_constructor(self):\n        category = Category(name='Movie')\n        self.assertEqual(category.name, 'Movie')\n        self.assertEqual(category.description, None)\n        self.assertEqual(category.is_active, True)\n        self.assertIsInstance(category.created_at, datetime)\n        created_at = datetime.now()",
        "detail": "src.category.tests.unit.domain.test_unit_entities",
        "documentation": {}
    }
]